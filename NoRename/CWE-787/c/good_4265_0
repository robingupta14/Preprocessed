







__FBSDID("$FreeBSD: head/lib/libarchive/archive_string.c 201095 2009-12-28 02:33:22Z kientzle $");

struct archive_string_conv {
 struct archive_string_conv *next;
 char *from_charset;
 char *to_charset;
 unsigned from_cp;
 unsigned to_cp;

 int same;
 int flag;

 struct archive_string utftmp;
 int (*converter[2])(struct archive_string *, const void *, size_t,
     struct archive_string_conv *);
 int nconverter;
};

static const char utf8_replacement_char[] = {0xef, 0xbf, 0xbd};

static struct archive_string_conv *find_sconv_object(struct archive *,
 const char *, const char *);
static void add_sconv_object(struct archive *, struct archive_string_conv *);
static struct archive_string_conv *create_sconv_object(const char *,
 const char *, unsigned, int);
static void free_sconv_object(struct archive_string_conv *);
static struct archive_string_conv *get_sconv_object(struct archive *,
 const char *, const char *, int);
static unsigned make_codepage_from_charset(const char *);
static unsigned get_current_codepage(void);
static unsigned get_current_oemcp(void);
static size_t mbsnbytes(const void *, size_t);
static size_t utf16nbytes(const void *, size_t);

static int best_effort_strncat_from_utf16be(struct archive_string *,
    const void *, size_t, struct archive_string_conv *);
static int best_effort_strncat_from_utf16le(struct archive_string *,
    const void *, size_t, struct archive_string_conv *);
static int best_effort_strncat_to_utf16be(struct archive_string *,
    const void *, size_t, struct archive_string_conv *);
static int best_effort_strncat_to_utf16le(struct archive_string *,
    const void *, size_t, struct archive_string_conv *);




static int best_effort_strncat_in_locale(struct archive_string *,
    const void *, size_t, struct archive_string_conv *);
static int _utf8_to_unicode(uint32_t *, const char *, size_t);
static int utf8_to_unicode(uint32_t *, const char *, size_t);
static inline uint32_t combine_surrogate_pair(uint32_t, uint32_t);
static int cesu8_to_unicode(uint32_t *, const char *, size_t);
static size_t unicode_to_utf8(char *, size_t, uint32_t);
static int utf16_to_unicode(uint32_t *, const char *, size_t, int);
static size_t unicode_to_utf16be(char *, size_t, uint32_t);
static size_t unicode_to_utf16le(char *, size_t, uint32_t);
static int strncat_from_utf8_libarchive2(struct archive_string *,
    const void *, size_t, struct archive_string_conv *);
static int strncat_from_utf8_to_utf8(struct archive_string *, const void *,
    size_t, struct archive_string_conv *);
static int archive_string_normalize_C(struct archive_string *, const void *,
    size_t, struct archive_string_conv *);
static int archive_string_normalize_D(struct archive_string *, const void *,
    size_t, struct archive_string_conv *);
static int archive_string_append_unicode(struct archive_string *,
    const void *, size_t, struct archive_string_conv *);

static struct archive_string *
archive_string_append(struct archive_string *as, const char *p, size_t s)
{
 if (archive_string_ensure(as, as->length + s + 1) == NULL)
  return (NULL);
 if (s)
  memmove(as->s + as->length, p, s);
 as->length += s;
 as->s[as->length] = 0;
 return (as);
}

static struct archive_wstring *
archive_wstring_append(struct archive_wstring *as, const wchar_t *p, size_t s)
{
 if (archive_wstring_ensure(as, as->length + s + 1) == NULL)
  return (NULL);
 if (s)
  (wchar_t *)memmove((as->s + as->length), (p), (s) * sizeof(wchar_t));
 as->length += s;
 as->s[as->length] = 0;
 return (as);
}

struct archive_string *
archive_array_append(struct archive_string *as, const char *p, size_t s)
{
 return archive_string_append(as, p, s);
}

void
archive_string_concat(struct archive_string *dest, struct archive_string *src)
{
 if (archive_string_append(dest, src->s, src->length) == NULL)
  __archive_errx(1, "Out of memory");
}

void
archive_wstring_concat(struct archive_wstring *dest,
    struct archive_wstring *src)
{
 if (archive_wstring_append(dest, src->s, src->length) == NULL)
  __archive_errx(1, "Out of memory");
}

void
archive_string_free(struct archive_string *as)
{
 as->length = 0;
 as->buffer_length = 0;
 free(as->s);
 as->s = NULL;
}

void
archive_wstring_free(struct archive_wstring *as)
{
 as->length = 0;
 as->buffer_length = 0;
 free(as->s);
 as->s = NULL;
}

struct archive_wstring *
archive_wstring_ensure(struct archive_wstring *as, size_t s)
{
 return (struct archive_wstring *)
  archive_string_ensure((struct archive_string *)as,
     s * sizeof(wchar_t));
}


struct archive_string *
archive_string_ensure(struct archive_string *as, size_t s)
{
 char *p;
 size_t new_length;


 if (as->s && (s <= as->buffer_length))
  return (as);

 if (as->buffer_length < 32)

  new_length = 32;
 else if (as->buffer_length < 8192)

  new_length = as->buffer_length + as->buffer_length;
 else {

  new_length = as->buffer_length + as->buffer_length / 4;

  if (new_length < as->buffer_length) {

   archive_string_free(as);
   errno = ENOMEM;
   return (NULL);
  }
 }





 if (new_length < s)
  new_length = s;

 p = (char *)realloc(as->s, new_length);
 if (p == NULL) {

  archive_string_free(as);
  errno = ENOMEM;
  return (NULL);
 }

 as->s = p;
 as->buffer_length = new_length;
 return (as);
}

struct archive_string *
archive_strncat(struct archive_string *as, const void *_p, size_t n)
{
 size_t s;
 const char *p, *pp;

 p = (const char *)_p;


 s = 0;
 pp = p;
 while (s < n && *pp) {
  pp++;
  s++;
 }
 if ((as = archive_string_append(as, p, s)) == NULL)
  __archive_errx(1, "Out of memory");
 return (as);
}

struct archive_wstring *
archive_wstrncat(struct archive_wstring *as, const wchar_t *p, size_t n)
{
 size_t s;
 const wchar_t *pp;


 s = 0;
 pp = p;
 while (s < n && *pp) {
  pp++;
  s++;
 }
 if ((as = archive_wstring_append(as, p, s)) == NULL)
  __archive_errx(1, "Out of memory");
 return (as);
}

struct archive_string *
archive_strcat(struct archive_string *as, const void *p)
{






 return archive_strncat(as, p, 0x1000000);
}

struct archive_wstring *
archive_wstrcat(struct archive_wstring *as, const wchar_t *p)
{

 return archive_wstrncat(as, p, 0x1000000);
}

struct archive_string *
archive_strappend_char(struct archive_string *as, char c)
{
 if ((as = archive_string_append(as, &c, 1)) == NULL)
  __archive_errx(1, "Out of memory");
 return (as);
}

struct archive_wstring *
archive_wstrappend_wchar(struct archive_wstring *as, wchar_t c)
{
 if ((as = archive_wstring_append(as, &c, 1)) == NULL)
  __archive_errx(1, "Out of memory");
 return (as);
}

static const char *
default_iconv_charset(const char *charset) {
 if (charset != NULL && charset[0] != '\0')
  return charset;






 return "";

}

int
archive_wstring_append_from_mbs(struct archive_wstring *dest,
    const char *p, size_t len)
{
 size_t r;
 int ret_val = 0;





 size_t mbs_length = len;
 const char *mbs = p;
 wchar_t *wcs;

 if (NULL == archive_wstring_ensure(dest, dest->length + len + 1))
  return -1;
 wcs = dest->s + dest->length;





 while (*mbs && mbs_length > 0) {

  r = mbtowc(wcs, mbs, mbs_length);

  if (r == (size_t)-1 || r == (size_t)-2) {
   ret_val = -1;
   break;
  }
  if (r == 0 || r > mbs_length)
   break;
  wcs++;

  mbs += r;
  mbs_length -= r;
 }
 dest->length = wcs - dest->s;
 dest->s[dest->length] = L'\0';
 return (ret_val);
}

int
archive_string_append_from_wcs(struct archive_string *as,
    const wchar_t *w, size_t len)
{
 (void)as;
 (void)w;
 (void)len;
 errno = ENOSYS;
 return -1;
}

static struct archive_string_conv *
find_sconv_object(struct archive *a, const char *fc, const char *tc)
{
 struct archive_string_conv *sc;

 if (a == NULL)
  return (NULL);

 for (sc = a->sconv; sc != NULL; sc = sc->next) {
  if (strcmp(sc->from_charset, fc) == 0 &&
      strcmp(sc->to_charset, tc) == 0)
   break;
 }
 return (sc);
}




static void
add_sconv_object(struct archive *a, struct archive_string_conv *sc)
{
 struct archive_string_conv **psc;


 psc = &(a->sconv);
 while (*psc != NULL)
  psc = &((*psc)->next);
 *psc = sc;
}

static void
add_converter(struct archive_string_conv *sc, int (*converter)
    (struct archive_string *, const void *, size_t,
     struct archive_string_conv *))
{
 if (sc == NULL || sc->nconverter >= 2)
  __archive_errx(1, "Programming error");
 sc->converter[sc->nconverter++] = converter;
}

static void
setup_converter(struct archive_string_conv *sc)
{


 sc->nconverter = 0;





 if (sc->flag & 16) {
  add_converter(sc, strncat_from_utf8_libarchive2);
  return;
 }




 if (sc->flag & 5120) {




  if (sc->flag & 512) {
   add_converter(sc, archive_string_append_unicode);
   return;
  }

  if (sc->flag & 4) {
   if (sc->flag & 1024)
    add_converter(sc,
     best_effort_strncat_to_utf16be);
   else
    add_converter(sc,
     best_effort_strncat_to_utf16le);
  } else

   sc->nconverter = 0;
  return;
 }




 if (sc->flag & 10240) {



  if (sc->flag & 128)
   add_converter(sc,archive_string_normalize_D);
  else if (sc->flag & 64)
   add_converter(sc, archive_string_normalize_C);

  if (sc->flag & 256) {




   if (!(sc->flag &
       192))
    add_converter(sc,
        archive_string_append_unicode);
   return;
  }

  if ((sc->flag & 2052)
      == 2052)
   add_converter(sc, best_effort_strncat_from_utf16be);
  else if ((sc->flag & 8196)
      == 8196)
   add_converter(sc, best_effort_strncat_from_utf16le);
  else

   sc->nconverter = 0;
  return;
 }

 if (sc->flag & 512) {



  if (sc->flag & 128)
   add_converter(sc,archive_string_normalize_D);
  else if (sc->flag & 64)
   add_converter(sc, archive_string_normalize_C);







  if (sc->flag & 256) {




   if (!(sc->flag &
       192))
    add_converter(sc, strncat_from_utf8_to_utf8);
   return;
  }
 }

 if ((sc->flag & 4) || sc->same)
  add_converter(sc, best_effort_strncat_in_locale);
 else

  sc->nconverter = 0;
}





static const char *
canonical_charset_name(const char *charset)
{
 char cs[16];
 char *p;
 const char *s;

 if (charset == NULL || charset[0] == '\0'
     || strlen(charset) > 15)
  return (charset);


 p = cs;
 s = charset;
 while (*s) {
  char c = *s++;
  if (c >= 'a' && c <= 'z')
   c -= 'a' - 'A';
  *p++ = c;
 }
 *p++ = '\0';

 if (strcmp(cs, "UTF-8") == 0 ||
     strcmp(cs, "UTF8") == 0)
  return ("UTF-8");
 if (strcmp(cs, "UTF-16BE") == 0 ||
     strcmp(cs, "UTF16BE") == 0)
  return ("UTF-16BE");
 if (strcmp(cs, "UTF-16LE") == 0 ||
     strcmp(cs, "UTF16LE") == 0)
  return ("UTF-16LE");
 if (strcmp(cs, "CP932") == 0)
  return ("CP932");
 return (charset);
}




static struct archive_string_conv *
create_sconv_object(const char *fc, const char *tc,
    unsigned current_codepage, int flag)
{
 struct archive_string_conv *sc;

 sc = calloc(1, sizeof(*sc));
 if (sc == NULL)
  return (NULL);
 sc->next = NULL;
 sc->from_charset = strdup(fc);
 if (sc->from_charset == NULL) {
  free(sc);
  return (NULL);
 }
 sc->to_charset = strdup(tc);
 if (sc->to_charset == NULL) {
  free(sc->from_charset);
  free(sc);
  return (NULL);
 }
 archive_string_init(&sc->utftmp);

 if (flag & 1) {




  sc->from_cp = current_codepage;
  sc->to_cp = make_codepage_from_charset(tc);




 } else if (flag & 2) {




  sc->to_cp = current_codepage;
  sc->from_cp = make_codepage_from_charset(fc);




 }




 if (strcmp(fc, tc) == 0 ||
     (sc->from_cp != (unsigned)-1 && sc->from_cp == sc->to_cp))
  sc->same = 1;
 else
  sc->same = 0;




 if (strcmp(tc, "UTF-8") == 0)
  flag |= 256;
 else if (strcmp(tc, "UTF-16BE") == 0)
  flag |= 1024;
 else if (strcmp(tc, "UTF-16LE") == 0)
  flag |= 4096;
 if (strcmp(fc, "UTF-8") == 0)
  flag |= 512;
 else if (strcmp(fc, "UTF-16BE") == 0)
  flag |= 2048;
 else if (strcmp(fc, "UTF-16LE") == 0)
  flag |= 8192;

 if ((flag & 2) &&
     (flag & 10752)) {





   flag |= 64;
 }

 sc->flag = flag;




 setup_converter(sc);

 return (sc);
}




static void
free_sconv_object(struct archive_string_conv *sc)
{
 free(sc->from_charset);
 free(sc->to_charset);
 archive_string_free(&sc->utftmp);






 free(sc);
}

static unsigned
get_current_codepage(void)
{
 return -1;
}
static unsigned
make_codepage_from_charset(const char *charset)
{
 (void)charset;
 return -1;
}
static unsigned
get_current_oemcp(void)
{
 return -1;
}






static struct archive_string_conv *
get_sconv_object(struct archive *a, const char *fc, const char *tc, int flag)
{
 struct archive_string_conv *sc;
 unsigned current_codepage;


 sc = find_sconv_object(a, fc, tc);
 if (sc != NULL)
  return (sc);

 if (a == NULL)
  current_codepage = get_current_codepage();
 else
  current_codepage = a->current_codepage;

 sc = create_sconv_object(canonical_charset_name(fc),
     canonical_charset_name(tc), current_codepage, flag);
 if (sc == NULL) {
  if (a != NULL)
   archive_set_error(a, ENOMEM,
       "Could not allocate memory for "
       "a string conversion object");
  return (NULL);
 }





 if (sc->nconverter == 0) {
  if (a != NULL) {





   archive_set_error(a, ARCHIVE_ERRNO_MISC,
       "A character-set conversion not fully supported "
       "on this platform");

  }

  free_sconv_object(sc);
  return (NULL);
 }




 if (a != NULL)
  add_sconv_object(a, sc);
 return (sc);
}

static const char *
get_current_charset(struct archive *a)
{
 const char *cur_charset;

 if (a == NULL)
  cur_charset = default_iconv_charset("");
 else {
  cur_charset = default_iconv_charset(a->current_code);
  if (a->current_code == NULL) {
   a->current_code = strdup(cur_charset);
   a->current_codepage = get_current_codepage();
   a->current_oemcp = get_current_oemcp();
  }
 }
 return (cur_charset);
}

struct archive_string_conv *
archive_string_conversion_to_charset(struct archive *a, const char *charset,
    int best_effort)
{
 int flag = 1;

 if (best_effort)
  flag |= 4;
 return (get_sconv_object(a, get_current_charset(a), charset, flag));
}

struct archive_string_conv *
archive_string_conversion_from_charset(struct archive *a, const char *charset,
    int best_effort)
{
 int flag = 2;

 if (best_effort)
  flag |= 4;
 return (get_sconv_object(a, charset, get_current_charset(a), flag));
}

struct archive_string_conv *
archive_string_default_conversion_for_read(struct archive *a)
{
 (void)a;
 return (NULL);
}

struct archive_string_conv *
archive_string_default_conversion_for_write(struct archive *a)
{
 (void)a;
 return (NULL);
}





void
archive_string_conversion_free(struct archive *a)
{
 struct archive_string_conv *sc;
 struct archive_string_conv *sc_next;

 for (sc = a->sconv; sc != NULL; sc = sc_next) {
  sc_next = sc->next;
  free_sconv_object(sc);
 }
 a->sconv = NULL;
 free(a->current_code);
 a->current_code = NULL;
}




const char *
archive_string_conversion_charset_name(struct archive_string_conv *sc)
{
 if (sc->flag & 1)
  return (sc->to_charset);
 else
  return (sc->from_charset);
}




void
archive_string_conversion_set_opt(struct archive_string_conv *sc, int opt)
{
 switch (opt) {






 case SCONV_SET_OPT_UTF8_LIBARCHIVE2X:

  if ((sc->flag & 16) == 0) {
   sc->flag |= 16;

   setup_converter(sc);
  }

  break;
 case SCONV_SET_OPT_NORMALIZATION_C:
  if ((sc->flag & 64) == 0) {
   sc->flag |= 64;
   sc->flag &= ~128;

   setup_converter(sc);
  }
  break;
 case SCONV_SET_OPT_NORMALIZATION_D:

  if ((sc->flag & 128) == 0) {
   sc->flag |= 128;
   sc->flag &= ~64;

   setup_converter(sc);
  }
  break;
 default:
  break;
 }
}

static size_t
mbsnbytes(const void *_p, size_t n)
{
 size_t s;
 const char *p, *pp;

 if (_p == NULL)
  return 0;
 p = (const char *)_p;


 s = 0;
 pp = p;
 while (s < n && *pp) {
  pp++;
  s++;
 }
 return (s);
}

static size_t
utf16nbytes(const void *_p, size_t n)
{
 size_t s;
 const char *p, *pp;

 if (_p == NULL)
  return 0;
 p = (const char *)_p;


 s = 0;
 pp = p;
 n >>= 1;
 while (s < n && (pp[0] || pp[1])) {
  pp += 2;
  s++;
 }
 return (s<<1);
}

int
archive_strncpy_l(struct archive_string *as, const void *_p, size_t n,
    struct archive_string_conv *sc)
{
 as->length = 0;
 return (archive_strncat_l(as, _p, n, sc));
}

int
archive_strncat_l(struct archive_string *as, const void *_p, size_t n,
    struct archive_string_conv *sc)
{
 const void *s;
 size_t length = 0;
 int i, r = 0, r2;

 if (_p != NULL && n > 0) {
  if (sc != NULL && (sc->flag & 10240))
   length = utf16nbytes(_p, n);
  else
   length = mbsnbytes(_p, n);
 }



 if (length == 0) {
  int tn = 1;
  if (sc != NULL && (sc->flag & 5120))
   tn = 2;
  if (archive_string_ensure(as, as->length + tn) == NULL)
   return -1;
  as->s[as->length] = 0;
  if (tn == 2)
   as->s[as->length+1] = 0;
  return 0;
 }




 if (sc == NULL) {
  if (archive_string_append(as, _p, length) == NULL)
   return -1;
  return 0;
 }

 s = _p;
 i = 0;
 if (sc->nconverter > 1) {
  sc->utftmp.length = 0;
  r2 = sc->converter[0](&(sc->utftmp), s, length, sc);
  if (r2 != 0 && errno == ENOMEM)
   return (r2);
  if (r > r2)
   r = r2;
  s = sc->utftmp.s;
  length = sc->utftmp.length;
  ++i;
 }
 r2 = sc->converter[i](as, s, length, sc);
 if (r > r2)
  r = r2;
 return (r);
}

static int
invalid_mbs(const void *_p, size_t n, struct archive_string_conv *sc)
{
 const char *p = (const char *)_p;
 size_t r;







 mbtowc(NULL, NULL, 0);

 while (n) {
  wchar_t wc;




  r = mbtowc(&wc, p, n);

  if (r == (size_t)-1 || r == (size_t)-2)
   return -1;
  if (r == 0)
   break;
  p += r;
  n -= r;
 }
 (void)sc;
 return 0;
}

static int
best_effort_strncat_in_locale(struct archive_string *as, const void *_p,
    size_t length, struct archive_string_conv *sc)
{
 size_t remaining;
 const uint8_t *itp;
 int return_value = 0;





 if (sc->same) {
  if (archive_string_append(as, _p, length) == NULL)
   return -1;
  return (invalid_mbs(_p, length, sc));
 }

 remaining = length;
 itp = (const uint8_t *)_p;
 while (*itp && remaining > 0) {
  if (*itp > 127) {

   if (sc->flag & 256) {
    if (archive_string_append(as, utf8_replacement_char, sizeof(utf8_replacement_char)) == NULL) {
     __archive_errx(1, "Out of memory");
    }
   } else {
    archive_strappend_char(as, '?');
   }
   return_value = -1;
  } else {
   archive_strappend_char(as, *itp);
  }
  ++itp;
 }
 return (return_value);
}

static int
_utf8_to_unicode(uint32_t *pwc, const char *s, size_t n)
{
 static const char utf8_count[256] = {
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
   4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 int ch, i;
 int cnt;
 uint32_t wc;


 if (n == 0)
  return 0;



 ch = (unsigned char)*s;
 if (ch == 0)
  return 0;
 cnt = utf8_count[ch];


 if ((int)n < cnt) {
  cnt = (int)n;
  for (i = 1; i < cnt; i++) {
   if ((s[i] & 0xc0) != 0x80) {
    cnt = i;
    break;
   }
  }
  goto invalid_sequence;
 }


 switch (cnt) {
 case 1:
  *pwc = ch & 0x7f;
  return (cnt);
 case 2:
  if ((s[1] & 0xc0) != 0x80) {
   cnt = 1;
   goto invalid_sequence;
  }
  *pwc = ((ch & 0x1f) << 6) | (s[1] & 0x3f);
  return (cnt);
 case 3:
  if ((s[1] & 0xc0) != 0x80) {
   cnt = 1;
   goto invalid_sequence;
  }
  if ((s[2] & 0xc0) != 0x80) {
   cnt = 2;
   goto invalid_sequence;
  }
  wc = ((ch & 0x0f) << 12)
      | ((s[1] & 0x3f) << 6)
      | (s[2] & 0x3f);
  if (wc < 0x800)
   goto invalid_sequence;
  break;
 case 4:
  if ((s[1] & 0xc0) != 0x80) {
   cnt = 1;
   goto invalid_sequence;
  }
  if ((s[2] & 0xc0) != 0x80) {
   cnt = 2;
   goto invalid_sequence;
  }
  if ((s[3] & 0xc0) != 0x80) {
   cnt = 3;
   goto invalid_sequence;
  }
  wc = ((ch & 0x07) << 18)
      | ((s[1] & 0x3f) << 12)
      | ((s[2] & 0x3f) << 6)
      | (s[3] & 0x3f);
  if (wc < 0x10000)
   goto invalid_sequence;
  break;
 default:
  if (ch == 0xc0 || ch == 0xc1)
   cnt = 2;
  else if (ch >= 0xf5 && ch <= 0xf7)
   cnt = 4;
  else if (ch >= 0xf8 && ch <= 0xfb)
   cnt = 5;
  else if (ch == 0xfc || ch == 0xfd)
   cnt = 6;
  else
   cnt = 1;
  if ((int)n < cnt)
   cnt = (int)n;
  for (i = 1; i < cnt; i++) {
   if ((s[i] & 0xc0) != 0x80) {
    cnt = i;
    break;
   }
  }
  goto invalid_sequence;
 }



 if (wc > 0x10FFFF)
  goto invalid_sequence;

 *pwc = wc;
 return (cnt);
invalid_sequence:
 *pwc = 0xFFFD;
 return (cnt * -1);
}

static int
utf8_to_unicode(uint32_t *pwc, const char *s, size_t n)
{
 int cnt;

 cnt = _utf8_to_unicode(pwc, s, n);

 if (cnt == 3 && ((*pwc) >= 0xD800 && (*pwc) <= 0xDFFF))
  return -3;
 return (cnt);
}

static inline uint32_t
combine_surrogate_pair(uint32_t uc, uint32_t uc2)
{
 uc -= 0xD800;
 uc *= 0x400;
 uc += uc2 - 0xDC00;
 uc += 0x10000;
 return (uc);
}

static int
cesu8_to_unicode(uint32_t *pwc, const char *s, size_t n)
{
 uint32_t wc = 0;
 int cnt;

 cnt = _utf8_to_unicode(&wc, s, n);
 if (cnt == 3 && ((wc) >= 0xD800 && (wc) <= 0xDBFF)) {
  uint32_t wc2 = 0;
  if (n - 3 < 3) {

   goto invalid_sequence;
  }
  cnt = _utf8_to_unicode(&wc2, s+3, n-3);
  if (cnt != 3 || !((wc2) >= 0xDC00 && (wc2) <= 0xDFFF)) {

   goto invalid_sequence;
  }
  wc = combine_surrogate_pair(wc, wc2);
  cnt = 6;
 } else if (cnt == 3 && ((wc) >= 0xDC00 && (wc) <= 0xDFFF)) {

  goto invalid_sequence;
 }
 *pwc = wc;
 return (cnt);
invalid_sequence:
 *pwc = 0xFFFD;
 if (cnt > 0)
  cnt *= -1;
 return (cnt);
}







static size_t
unicode_to_utf8(char *p, size_t remaining, uint32_t uc)
{
 char *_p = p;


 if (uc > 0x10FFFF)
  uc = 0xFFFD;

 if (uc <= 0x7f) {
  if (remaining == 0)
   return 0;
  *p++ = (char)uc;
 } else if (uc <= 0x7ff) {
  if (remaining < 2)
   return 0;
  *p++ = 0xc0 | ((uc >> 6) & 0x1f);
  *p++ = 0x80 | (uc & 0x3f);
 } else if (uc <= 0xffff) {
  if (remaining < 3)
   return 0;
  *p++ = 0xe0 | ((uc >> 12) & 0x0f);
  *p++ = 0x80 | ((uc >> 6) & 0x3f);
  *p++ = 0x80 | (uc & 0x3f);
 } else {
  if (remaining < 4)
   return 0;
  *p++ = 0xf0 | ((uc >> 18) & 0x07);
  *p++ = 0x80 | ((uc >> 12) & 0x3f);
  *p++ = 0x80 | ((uc >> 6) & 0x3f);
  *p++ = 0x80 | (uc & 0x3f);
 }
 return (p - _p);
}

static int
utf16be_to_unicode(uint32_t *pwc, const char *s, size_t n)
{
 return (utf16_to_unicode(pwc, s, n, 1));
}

static int
utf16le_to_unicode(uint32_t *pwc, const char *s, size_t n)
{
 return (utf16_to_unicode(pwc, s, n, 0));
}

static int
utf16_to_unicode(uint32_t *pwc, const char *s, size_t n, int be)
{
 const char *utf16 = s;
 unsigned uc;

 if (n == 0)
  return 0;
 if (n == 1) {

  *pwc = 0xFFFD;
  return -1;
 }

 if (be)
  uc = archive_be16dec(utf16);
 else
  uc = archive_le16dec(utf16);
 utf16 += 2;


 if (((uc) >= 0xD800 && (uc) <= 0xDBFF)) {
  unsigned uc2;

  if (n >= 4) {
   if (be)
    uc2 = archive_be16dec(utf16);
   else
    uc2 = archive_le16dec(utf16);
  } else
   uc2 = 0;
  if (((uc2) >= 0xDC00 && (uc2) <= 0xDFFF)) {
   uc = combine_surrogate_pair(uc, uc2);
   utf16 += 2;
  } else {


   *pwc = 0xFFFD;
   return -2;
  }
 }

 if (((uc) >= 0xD800 && (uc) <= 0xDFFF) || uc > 0x10FFFF) {


  *pwc = 0xFFFD;
  return (((int)(utf16 - s)) * -1);
 }
 *pwc = uc;
 return ((int)(utf16 - s));
}

static size_t
unicode_to_utf16be(char *p, size_t remaining, uint32_t uc)
{
 char *utf16 = p;

 if (uc > 0xffff) {


  if (remaining < 4)
   return 0;
  uc -= 0x10000;
  archive_be16enc(utf16, ((uc >> 10) & 0x3ff) + 0xD800);
  archive_be16enc(utf16+2, (uc & 0x3ff) + 0xDC00);
  return 4;
 } else {
  if (remaining < 2)
   return 0;
  archive_be16enc(utf16, uc);
  return 2;
 }
}

static size_t
unicode_to_utf16le(char *p, size_t remaining, uint32_t uc)
{
 char *utf16 = p;

 if (uc > 0xffff) {


  if (remaining < 4)
   return 0;
  uc -= 0x10000;
  archive_le16enc(utf16, ((uc >> 10) & 0x3ff) + 0xD800);
  archive_le16enc(utf16+2, (uc & 0x3ff) + 0xDC00);
  return 4;
 } else {
  if (remaining < 2)
   return 0;
  archive_le16enc(utf16, uc);
  return 2;
 }
}





static int
strncat_from_utf8_to_utf8(struct archive_string *as, const void *_p,
    size_t len, struct archive_string_conv *sc)
{
 const char *s;
 char *p, *endp;
 int n, ret = 0;

 (void)sc;

 if (archive_string_ensure(as, as->length + len + 1) == NULL)
  return -1;

 s = (const char *)_p;
 p = as->s + as->length;
 endp = as->s + as->buffer_length -1;
 do {
  uint32_t uc;
  const char *ss = s;
  size_t w;




  while ((n = utf8_to_unicode(&uc, s, len)) > 0) {
   s += n;
   len -= n;
  }
  if (ss < s) {
   if (p + (s - ss) > endp) {
    as->length = p - as->s;
    if (archive_string_ensure(as,
        as->buffer_length + len + 1) == NULL)
     return -1;
    p = as->s + as->length;
    endp = as->s + as->buffer_length -1;
   }

   memcpy(p, ss, s - ss);
   p += s - ss;
  }




  if (n < 0) {
   if (n == -3 && ((uc) >= 0xD800 && (uc) <= 0xDFFF)) {

    n = cesu8_to_unicode(&uc, s, len);
   }
   if (n < 0) {
    ret = -1;
    n *= -1;
   }


   while ((w = unicode_to_utf8(p, endp - p, uc)) == 0) {
    as->length = p - as->s;
    if (archive_string_ensure(as,
        as->buffer_length + len + 1) == NULL)
     return -1;
    p = as->s + as->length;
    endp = as->s + as->buffer_length -1;
   }
   p += w;
   s += n;
   len -= n;
  }
 } while (n > 0);
 as->length = p - as->s;
 as->s[as->length] = '\0';
 return (ret);
}

static int
archive_string_append_unicode(struct archive_string *as, const void *_p,
    size_t len, struct archive_string_conv *sc)
{
 const char *s;
 char *p, *endp;
 uint32_t uc;
 size_t w;
 int n, ret = 0, ts, tm;
 int (*parse)(uint32_t *, const char *, size_t);
 size_t (*unparse)(char *, size_t, uint32_t);

 if (sc->flag & 1024) {
  unparse = unicode_to_utf16be;
  ts = 2;
 } else if (sc->flag & 4096) {
  unparse = unicode_to_utf16le;
  ts = 2;
 } else if (sc->flag & 256) {
  unparse = unicode_to_utf8;
  ts = 1;
 } else {




  if (sc->flag & 2048) {
   unparse = unicode_to_utf16be;
   ts = 2;
  } else if (sc->flag & 8192) {
   unparse = unicode_to_utf16le;
   ts = 2;
  } else {
   unparse = unicode_to_utf8;
   ts = 1;
  }
 }

 if (sc->flag & 2048) {
  parse = utf16be_to_unicode;
  tm = 1;
 } else if (sc->flag & 8192) {
  parse = utf16le_to_unicode;
  tm = 1;
 } else {
  parse = cesu8_to_unicode;
  tm = ts;
 }

 if (archive_string_ensure(as, as->length + len * tm + ts) == NULL)
  return -1;

 s = (const char *)_p;
 p = as->s + as->length;
 endp = as->s + as->buffer_length - ts;
 while ((n = parse(&uc, s, len)) != 0) {
  if (n < 0) {

   n *= -1;
   ret = -1;
  }
  s += n;
  len -= n;
  while ((w = unparse(p, endp - p, uc)) == 0) {


   as->length = p - as->s;
   if (archive_string_ensure(as,
       as->buffer_length + len * tm + ts) == NULL)
    return -1;
   p = as->s + as->length;
   endp = as->s + as->buffer_length - ts;
  }
  p += w;
 }
 as->length = p - as->s;
 as->s[as->length] = '\0';
 if (ts == 2)
  as->s[as->length+1] = '\0';
 return (ret);
}

static uint32_t
get_nfc(uint32_t uc, uint32_t uc2)
{
 int t, b;

 t = 0;
 b = sizeof(u_composition_table)/sizeof(u_composition_table[0]) -1;
 while (b >= t) {
  int m = (t + b) / 2;
  if (u_composition_table[m].cp1 < uc)
   t = m + 1;
  else if (u_composition_table[m].cp1 > uc)
   b = m - 1;
  else if (u_composition_table[m].cp2 < uc2)
   t = m + 1;
  else if (u_composition_table[m].cp2 > uc2)
   b = m - 1;
  else
   return (u_composition_table[m].nfc);
 }
 return 0;
}

static int
archive_string_normalize_C(struct archive_string *as, const void *_p,
    size_t len, struct archive_string_conv *sc)
{
 const char *s = (const char *)_p;
 char *p, *endp;
 uint32_t uc, uc2;
 size_t w;
 int always_replace, n, n2, ret = 0, spair, ts, tm;
 int (*parse)(uint32_t *, const char *, size_t);
 size_t (*unparse)(char *, size_t, uint32_t);

 always_replace = 1;
 ts = 1;
 if (sc->flag & 1024) {
  unparse = unicode_to_utf16be;
  ts = 2;
  if (sc->flag & 2048)
   always_replace = 0;
 } else if (sc->flag & 4096) {
  unparse = unicode_to_utf16le;
  ts = 2;
  if (sc->flag & 8192)
   always_replace = 0;
 } else if (sc->flag & 256) {
  unparse = unicode_to_utf8;
  if (sc->flag & 512)
   always_replace = 0;
 } else {




  always_replace = 0;
  if (sc->flag & 2048) {
   unparse = unicode_to_utf16be;
   ts = 2;
  } else if (sc->flag & 8192) {
   unparse = unicode_to_utf16le;
   ts = 2;
  } else {
   unparse = unicode_to_utf8;
  }
 }

 if (sc->flag & 2048) {
  parse = utf16be_to_unicode;
  tm = 1;
  spair = 4;
 } else if (sc->flag & 8192) {
  parse = utf16le_to_unicode;
  tm = 1;
  spair = 4;
 } else {
  parse = cesu8_to_unicode;
  tm = ts;
  spair = 6;
 }

 if (archive_string_ensure(as, as->length + len * tm + ts) == NULL)
  return -1;

 p = as->s + as->length;
 endp = as->s + as->buffer_length - ts;
 while ((n = parse(&uc, s, len)) != 0) {
  const char *ucptr, *uc2ptr;

  if (n < 0) {

   do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0;
   s += n*-1;
   len -= n*-1;
   ret = -1;
   continue;
  } else if (n == spair || always_replace)


   ucptr = NULL;
  else
   ucptr = s;
  s += n;
  len -= n;


  while ((n2 = parse(&uc2, s, len)) > 0) {
   uint32_t ucx[10];
   int ccx[10];
   int cl, cx, i, nx, ucx_size;
   int LIndex,SIndex;
   uint32_t nfc;

   if (n2 == spair || always_replace)


    uc2ptr = NULL;
   else
    uc2ptr = s;
   s += n2;
   len -= n2;





   if (!IS_DECOMPOSABLE_BLOCK(uc2)) {
    do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
    do { uc = uc2; ucptr = uc2ptr; n = n2; } while 0;
    continue;
   }

   if (0 <= (LIndex = uc - 0x1100) &&
       LIndex < 19) {




    int VIndex = uc2 - 0x1161;
    if (0 <= VIndex && VIndex < 21) {

     do { uc = 0xAC00 + (LIndex * 21 + VIndex) * 28; ucptr = NULL; } while 0;


    } else {
     do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
     do { uc = uc2; ucptr = uc2ptr; n = n2; } while 0;
    }
    continue;
   } else if (0 <= (SIndex = uc - 0xAC00) &&
       SIndex < 11172 && (SIndex % 28) == 0) {




    int TIndex = uc2 - 0x11A7;
    if (0 < TIndex && TIndex < 28) {

     do { uc = uc + TIndex; ucptr = NULL; } while 0;
    } else {
     do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
     do { uc = uc2; ucptr = uc2ptr; n = n2; } while 0;
    }
    continue;
   } else if ((nfc = get_nfc(uc, uc2)) != 0) {


    do { uc = nfc; ucptr = NULL; } while 0;
    continue;
   } else if ((cl = CCC(uc2)) == 0) {


    do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
    do { uc = uc2; ucptr = uc2ptr; n = n2; } while 0;
    continue;
   }




   cx = 0;
   ucx[0] = uc2;
   ccx[0] = cl;
   do { int _i; for (_i = 1; _i < 10 ; _i++) { nx = parse(&ucx[_i], s, len); if (nx <= 0) break; cx = CCC(ucx[_i]); if (cl >= cx && cl != 228 && cx != 228) break; s += nx; len -= nx; cl = cx; ccx[_i] = cx; } if (_i >= 10) { ret = -1; ucx_size = 10; } else ucx_size = _i; } while 0;




   i = 1;
   while (i < ucx_size) {
    int j;

    if ((nfc = get_nfc(uc, ucx[i])) == 0) {
     i++;
     continue;
    }




    do { uc = nfc; ucptr = NULL; } while 0;





    for (j = i; j+1 < ucx_size; j++) {
     ucx[j] = ucx[j+1];
     ccx[j] = ccx[j+1];
    }
    ucx_size --;





    if (ucx_size > 0 && i == ucx_size &&
        nx > 0 && cx == cl) {
     cl = ccx[ucx_size-1];
     do { int _i; for (_i = ucx_size; _i < 10 ; _i++) { nx = parse(&ucx[_i], s, len); if (nx <= 0) break; cx = CCC(ucx[_i]); if (cl >= cx && cl != 228 && cx != 228) break; s += nx; len -= nx; cl = cx; ccx[_i] = cx; } if (_i >= 10) { ret = -1; ucx_size = 10; } else ucx_size = _i; } while 0;
    }





    i = 0;
   }





   do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
   for (i = 0; i < ucx_size; i++)
    do { while ((w = unparse(p, (endp) - (p), ucx[i])) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0;




   if (nx > 0 && cx == cl && len > 0) {
    while ((nx = parse(&ucx[0], s, len))
        > 0) {
     cx = CCC(ucx[0]);
     if (cl > cx)
      break;
     s += nx;
     len -= nx;
     cl = cx;
     do { while ((w = unparse(p, (endp) - (p), ucx[0])) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0;
    }
   }
   break;
  }
  if (n2 < 0) {
   do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;

   do { while ((w = unparse(p, (endp) - (p), uc2)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0;
   s += n2*-1;
   len -= n2*-1;
   ret = -1;
   continue;
  } else if (n2 == 0) {
   do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
   break;
  }
 }
 as->length = p - as->s;
 as->s[as->length] = '\0';
 if (ts == 2)
  as->s[as->length+1] = '\0';
 return (ret);
}

static int
get_nfd(uint32_t *cp1, uint32_t *cp2, uint32_t uc)
{
 int t, b;




 if ((uc >= 0x2000 && uc <= 0x2FFF) ||
     (uc >= 0xF900 && uc <= 0xFAFF) ||
     (uc >= 0x2F800 && uc <= 0x2FAFF))
  return 0;

 if (uc == 0x1109A || uc == 0x1109C || uc == 0x110AB)
  return 0;

 t = 0;
 b = sizeof(u_decomposition_table)/sizeof(u_decomposition_table[0]) -1;
 while (b >= t) {
  int m = (t + b) / 2;
  if (u_decomposition_table[m].nfc < uc)
   t = m + 1;
  else if (u_decomposition_table[m].nfc > uc)
   b = m - 1;
  else {
   *cp1 = u_decomposition_table[m].cp1;
   *cp2 = u_decomposition_table[m].cp2;
   return 1;
  }
 }
 return 0;
}

static int
archive_string_normalize_D(struct archive_string *as, const void *_p,
    size_t len, struct archive_string_conv *sc)
{
 const char *s = (const char *)_p;
 char *p, *endp;
 uint32_t uc, uc2;
 size_t w;
 int always_replace, n, n2, ret = 0, spair, ts, tm;
 int (*parse)(uint32_t *, const char *, size_t);
 size_t (*unparse)(char *, size_t, uint32_t);

 always_replace = 1;
 ts = 1;
 if (sc->flag & 1024) {
  unparse = unicode_to_utf16be;
  ts = 2;
  if (sc->flag & 2048)
   always_replace = 0;
 } else if (sc->flag & 4096) {
  unparse = unicode_to_utf16le;
  ts = 2;
  if (sc->flag & 8192)
   always_replace = 0;
 } else if (sc->flag & 256) {
  unparse = unicode_to_utf8;
  if (sc->flag & 512)
   always_replace = 0;
 } else {




  always_replace = 0;
  if (sc->flag & 2048) {
   unparse = unicode_to_utf16be;
   ts = 2;
  } else if (sc->flag & 8192) {
   unparse = unicode_to_utf16le;
   ts = 2;
  } else {
   unparse = unicode_to_utf8;
  }
 }

 if (sc->flag & 2048) {
  parse = utf16be_to_unicode;
  tm = 1;
  spair = 4;
 } else if (sc->flag & 8192) {
  parse = utf16le_to_unicode;
  tm = 1;
  spair = 4;
 } else {
  parse = cesu8_to_unicode;
  tm = ts;
  spair = 6;
 }

 if (archive_string_ensure(as, as->length + len * tm + ts) == NULL)
  return -1;

 p = as->s + as->length;
 endp = as->s + as->buffer_length - ts;
 while ((n = parse(&uc, s, len)) != 0) {
  const char *ucptr;
  uint32_t cp1, cp2;
  int SIndex;
  struct {
   uint32_t uc;
   int ccc;
  } fdc[10];
  int fdi, fdj;
  int ccc;

check_first_code:
  if (n < 0) {

   do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0;
   s += n*-1;
   len -= n*-1;
   ret = -1;
   continue;
  } else if (n == spair || always_replace)


   ucptr = NULL;
  else
   ucptr = s;
  s += n;
  len -= n;


  if ((SIndex = uc - 0xAC00) >= 0 && SIndex < 11172) {
   int L = 0x1100 + SIndex / 588;
   int V = 0x1161 + (SIndex % 588) / 28;
   int T = 0x11A7 + SIndex % 28;

   do { uc = L; ucptr = NULL; } while 0;
   do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
   do { uc = V; ucptr = NULL; } while 0;
   do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
   if (T != 0x11A7) {
    do { uc = T; ucptr = NULL; } while 0;
    do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
   }
   continue;
  }
  if (IS_DECOMPOSABLE_BLOCK(uc) && CCC(uc) != 0) {
   do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
   continue;
  }

  fdi = 0;
  while (get_nfd(&cp1, &cp2, uc) && fdi < 10) {
   int k;

   for (k = fdi; k > 0; k--)
    fdc[k] = fdc[k-1];
   fdc[0].ccc = CCC(cp2);
   fdc[0].uc = cp2;
   fdi++;
   do { uc = cp1; ucptr = NULL; } while 0;
  }


  while ((n2 = parse(&uc2, s, len)) > 0 &&
      (ccc = CCC(uc2)) != 0 && fdi < 10) {
   int j, k;

   s += n2;
   len -= n2;
   for (j = 0; j < fdi; j++) {
    if (fdc[j].ccc > ccc)
     break;
   }
   if (j < fdi) {
    for (k = fdi; k > j; k--)
     fdc[k] = fdc[k-1];
    fdc[j].ccc = ccc;
    fdc[j].uc = uc2;
   } else {
    fdc[fdi].ccc = ccc;
    fdc[fdi].uc = uc2;
   }
   fdi++;
  }

  do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
  for (fdj = 0; fdj < fdi; fdj++) {
   do { uc = fdc[fdj].uc; ucptr = NULL; } while 0;
   do { if (ucptr) { if (p + n > endp) do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; switch (n) { case 4: *p++ = *ucptr++; case 3: *p++ = *ucptr++; case 2: *p++ = *ucptr++; case 1: *p++ = *ucptr; break; } ucptr = NULL; } else { do { while ((w = unparse(p, (endp) - (p), uc)) == 0) { do { as->length = p - as->s; if (archive_string_ensure(as, as->buffer_length + len * tm + ts) == NULL) return -1; p = as->s + as->length; endp = as->s + as->buffer_length - ts; } while 0; } p += w; } while 0; } } while 0;
  }

  if (n2 == 0)
   break;
  do { uc = uc2; ucptr = NULL; } while 0;
  n = n2;
  goto check_first_code;
 }
 as->length = p - as->s;
 as->s[as->length] = '\0';
 if (ts == 2)
  as->s[as->length+1] = '\0';
 return (ret);
}

static int
strncat_from_utf8_libarchive2(struct archive_string *as,
    const void *_p, size_t len, struct archive_string_conv *sc)
{
 const char *s;
 int n;
 char *p;
 char *end;
 uint32_t unicode;






 wctomb(NULL, L'\0');

 (void)sc;





 if (archive_string_ensure(as, as->length + len + 1) == NULL)
  return -1;

 s = (const char *)_p;
 p = as->s + as->length;
 end = as->s + as->buffer_length - MB_CUR_MAX -1;
 while ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {
  wchar_t wc;

  if (p >= end) {
   as->length = p - as->s;

   if (archive_string_ensure(as,
       as->length + ((len * 2)>((size_t)MB_CUR_MAX)?(len * 2):((size_t)MB_CUR_MAX)) + 1) == NULL)

    return -1;
   p = as->s + as->length;
   end = as->s + as->buffer_length - MB_CUR_MAX -1;
  }





  if (n < 0) {
   n *= -1;
   wc = L'?';
  } else
   wc = (wchar_t)unicode;

  s += n;
  len -= n;






  n = (int)wctomb(p, wc);

  if (n == -1)
   return -1;
  p += n;
 }
 as->length = p - as->s;
 as->s[as->length] = '\0';
 return 0;
}

static int
best_effort_strncat_from_utf16(struct archive_string *as, const void *_p,
    size_t bytes, struct archive_string_conv *sc, int be)
{
 const char *utf16 = (const char *)_p;
 char *mbs;
 uint32_t uc;
 int n, ret;

 (void)sc;





 ret = 0;
 if (archive_string_ensure(as, as->length + bytes +1) == NULL)
  return -1;
 mbs = as->s + as->length;

 while ((n = utf16_to_unicode(&uc, utf16, bytes, be)) != 0) {
  if (n < 0) {
   n *= -1;
   ret = -1;
  }
  bytes -= n;
  utf16 += n;

  if (uc > 127) {

   *mbs++ = '?';
   ret = -1;
  } else
   *mbs++ = (char)uc;
 }
 as->length = mbs - as->s;
 as->s[as->length] = '\0';
 return (ret);
}

static int
best_effort_strncat_from_utf16be(struct archive_string *as, const void *_p,
    size_t bytes, struct archive_string_conv *sc)
{
 return (best_effort_strncat_from_utf16(as, _p, bytes, sc, 1));
}

static int
best_effort_strncat_from_utf16le(struct archive_string *as, const void *_p,
    size_t bytes, struct archive_string_conv *sc)
{
 return (best_effort_strncat_from_utf16(as, _p, bytes, sc, 0));
}





static int
best_effort_strncat_to_utf16(struct archive_string *as16, const void *_p,
    size_t length, struct archive_string_conv *sc, int bigendian)
{
 const char *s = (const char *)_p;
 char *utf16;
 size_t remaining;
 int ret;

 (void)sc;





 ret = 0;
 remaining = length;

 if (archive_string_ensure(as16,
     as16->length + (length + 1) * 2) == NULL)
  return -1;

 utf16 = as16->s + as16->length;
 while (remaining--) {
  unsigned c = *s++;
  if (c > 127) {

   c = 0xFFFD;
   ret = -1;
  }
  if (bigendian)
   archive_be16enc(utf16, c);
  else
   archive_le16enc(utf16, c);
  utf16 += 2;
 }
 as16->length = utf16 - as16->s;
 as16->s[as16->length] = 0;
 as16->s[as16->length+1] = 0;
 return (ret);
}

static int
best_effort_strncat_to_utf16be(struct archive_string *as16, const void *_p,
    size_t length, struct archive_string_conv *sc)
{
 return (best_effort_strncat_to_utf16(as16, _p, length, sc, 1));
}

static int
best_effort_strncat_to_utf16le(struct archive_string *as16, const void *_p,
    size_t length, struct archive_string_conv *sc)
{
 return (best_effort_strncat_to_utf16(as16, _p, length, sc, 0));
}






void
archive_mstring_clean(struct archive_mstring *aes)
{
 archive_wstring_free(&(aes->aes_wcs));
 archive_string_free(&(aes->aes_mbs));
 archive_string_free(&(aes->aes_utf8));
 archive_string_free(&(aes->aes_mbs_in_locale));
 aes->aes_set = 0;
}

void
archive_mstring_copy(struct archive_mstring *dest, struct archive_mstring *src)
{
 dest->aes_set = src->aes_set;
 archive_string_copy(&(dest->aes_mbs), &(src->aes_mbs));
 archive_string_copy(&(dest->aes_utf8), &(src->aes_utf8));
 archive_wstring_copy(&(dest->aes_wcs), &(src->aes_wcs));
}

int
archive_mstring_get_utf8(struct archive *a, struct archive_mstring *aes,
  const char **p)
{
 struct archive_string_conv *sc;
 int r;


 if (aes->aes_set & AES_SET_UTF8) {
  *p = aes->aes_utf8.s;
  return 0;
 }

 *p = NULL;
 if (aes->aes_set & AES_SET_MBS) {
  sc = archive_string_conversion_to_charset(a, "UTF-8", 1);
  if (sc == NULL)
   return -1;
  r = archive_strncpy_l(&(aes->aes_utf8), aes->aes_mbs.s,
      aes->aes_mbs.length, sc);
  if (a == NULL)
   free_sconv_object(sc);
  if (r == 0) {
   aes->aes_set |= AES_SET_UTF8;
   *p = aes->aes_utf8.s;
   return 0;
  } else
   return -1;
 }
 return 0;
}

int
archive_mstring_get_mbs(struct archive *a, struct archive_mstring *aes,
    const char **p)
{
 int r, ret = 0;

 (void)a;

 if (aes->aes_set & AES_SET_MBS) {
  *p = aes->aes_mbs.s;
  return (ret);
 }

 *p = NULL;

 if (aes->aes_set & AES_SET_WCS) {
  archive_string_empty(&(aes->aes_mbs));
  r = archive_string_append_from_wcs(&(aes->aes_mbs),
      aes->aes_wcs.s, aes->aes_wcs.length);
  *p = aes->aes_mbs.s;
  if (r == 0) {
   aes->aes_set |= AES_SET_MBS;
   return (ret);
  } else
   ret = -1;
 }





 return (ret);
}

int
archive_mstring_get_wcs(struct archive *a, struct archive_mstring *aes,
    const wchar_t **wp)
{
 int r, ret = 0;

 (void)a;

 if (aes->aes_set & AES_SET_WCS) {
  *wp = aes->aes_wcs.s;
  return (ret);
 }

 *wp = NULL;

 if (aes->aes_set & AES_SET_MBS) {
  archive_wstring_empty(&(aes->aes_wcs));
  r = archive_wstring_append_from_mbs(&(aes->aes_wcs),
      aes->aes_mbs.s, aes->aes_mbs.length);
  if (r == 0) {
   aes->aes_set |= AES_SET_WCS;
   *wp = aes->aes_wcs.s;
  } else
   ret = -1;
 }
 return (ret);
}

int
archive_mstring_get_mbs_l(struct archive_mstring *aes,
    const char **p, size_t *length, struct archive_string_conv *sc)
{
 int r, ret = 0;

 if ((aes->aes_set & AES_SET_MBS) == 0 &&
     (aes->aes_set & AES_SET_WCS) != 0) {
  archive_string_empty(&(aes->aes_mbs));
  r = archive_string_append_from_wcs(&(aes->aes_mbs),
      aes->aes_wcs.s, aes->aes_wcs.length);
  if (r == 0)
   aes->aes_set |= AES_SET_MBS;
  else if (errno == ENOMEM)
   return -1;
  else
   ret = -1;
 }


 if (aes->aes_set & AES_SET_MBS) {
  if (sc == NULL) {

   *p = aes->aes_mbs.s;
   if (length != NULL)
    *length = aes->aes_mbs.length;
   return 0;
  }
  ret = archive_strncpy_l(&(aes->aes_mbs_in_locale),
      aes->aes_mbs.s, aes->aes_mbs.length, sc);
  *p = aes->aes_mbs_in_locale.s;
  if (length != NULL)
   *length = aes->aes_mbs_in_locale.length;
 } else {
  *p = NULL;
  if (length != NULL)
   *length = 0;
 }
 return (ret);
}

int
archive_mstring_copy_mbs(struct archive_mstring *aes, const char *mbs)
{
 if (mbs == NULL) {
  aes->aes_set = 0;
  return 0;
 }
 return (archive_mstring_copy_mbs_len(aes, mbs, strlen(mbs)));
}

int
archive_mstring_copy_mbs_len(struct archive_mstring *aes, const char *mbs,
    size_t len)
{
 if (mbs == NULL) {
  aes->aes_set = 0;
  return 0;
 }
 aes->aes_set = AES_SET_MBS;
 archive_strncpy(&(aes->aes_mbs), mbs, len);
 archive_string_empty(&(aes->aes_utf8));
 archive_wstring_empty(&(aes->aes_wcs));
 return 0;
}

int
archive_mstring_copy_wcs(struct archive_mstring *aes, const wchar_t *wcs)
{
 return archive_mstring_copy_wcs_len(aes, wcs,
    wcs == NULL ? 0 : wcslen(wcs));
}

int
archive_mstring_copy_utf8(struct archive_mstring *aes, const char *utf8)
{
  if (utf8 == NULL) {
    aes->aes_set = 0;
    return 0;
  }
  aes->aes_set = AES_SET_UTF8;
  archive_string_empty(&(aes->aes_mbs));
  archive_string_empty(&(aes->aes_wcs));
  archive_strncpy(&(aes->aes_utf8), utf8, strlen(utf8));
  return (int)strlen(utf8);
}

int
archive_mstring_copy_wcs_len(struct archive_mstring *aes, const wchar_t *wcs,
    size_t len)
{
 if (wcs == NULL) {
  aes->aes_set = 0;
  return 0;
 }
 aes->aes_set = AES_SET_WCS;
 archive_string_empty(&(aes->aes_mbs));
 archive_string_empty(&(aes->aes_utf8));
 archive_wstrncpy(&(aes->aes_wcs), wcs, len);
 return 0;
}

int
archive_mstring_copy_mbs_len_l(struct archive_mstring *aes,
    const char *mbs, size_t len, struct archive_string_conv *sc)
{
 int r;

 if (mbs == NULL) {
  aes->aes_set = 0;
  return 0;
 }
 archive_string_empty(&(aes->aes_mbs));
 archive_wstring_empty(&(aes->aes_wcs));
 archive_string_empty(&(aes->aes_utf8));

 r = archive_strncpy_l(&(aes->aes_mbs), mbs, len, sc);
 if (r == 0)
  aes->aes_set = AES_SET_MBS;
 else
  aes->aes_set = 0;

 return (r);
}

int
archive_mstring_update_utf8(struct archive *a, struct archive_mstring *aes,
    const char *utf8)
{
 struct archive_string_conv *sc;
 int r;

 if (utf8 == NULL) {
  aes->aes_set = 0;
  return 0;
 }


 archive_strcpy(&(aes->aes_utf8), utf8);


 archive_string_empty(&(aes->aes_mbs));
 archive_wstring_empty(&(aes->aes_wcs));

 aes->aes_set = AES_SET_UTF8;


 sc = archive_string_conversion_from_charset(a, "UTF-8", 1);
 if (sc == NULL)
  return -1;
 r = archive_strcpy_l(&(aes->aes_mbs), utf8, sc);
 if (a == NULL)
  free_sconv_object(sc);
 if (r != 0)
  return -1;
 aes->aes_set = AES_SET_UTF8 | AES_SET_MBS;


 if (archive_wstring_append_from_mbs(&(aes->aes_wcs), aes->aes_mbs.s,
     aes->aes_mbs.length))
  return -1;
 aes->aes_set = AES_SET_UTF8 | AES_SET_WCS | AES_SET_MBS;


 return 0;
}
