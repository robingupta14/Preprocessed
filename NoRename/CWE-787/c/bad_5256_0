







static int le_gd, le_gd_font;

int overflow2(int a, int b);

static void php_image_filter_negate(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_grayscale(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_brightness(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_contrast(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_colorize(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_edgedetect(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_emboss(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_gaussian_blur(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_selective_blur(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_mean_removal(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_smooth(INTERNAL_FUNCTION_PARAMETERS);
static void php_image_filter_pixelate(INTERNAL_FUNCTION_PARAMETERS);


static gdImagePtr _php_image_create_from_string (zval **Data, char *tn, gdImagePtr (*ioctx_func_p)() TSRMLS_DC);
static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)());
static void _php_image_output(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)());
static int _php_image_type(char data[8]);
static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type);
static void _php_image_bw_convert(gdImagePtr im_org, gdIOCtx *out, int threshold);


ZEND_BEGIN_ARG_INFO(arginfo_gd_info, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageloadfont, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetstyle, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, styles)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatetruecolor, 0)
 ZEND_ARG_INFO(0, x_size)
 ZEND_ARG_INFO(0, y_size)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageistruecolor, 0)
 ZEND_ARG_INFO(0, im)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagetruecolortopalette, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, ditherFlag)
 ZEND_ARG_INFO(0, colorsWanted)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagepalettetotruecolor, 0)
 ZEND_ARG_INFO(0, im)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolormatch, 0)
 ZEND_ARG_INFO(0, im1)
 ZEND_ARG_INFO(0, im2)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetthickness, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, thickness)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilledellipse, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, cx)
 ZEND_ARG_INFO(0, cy)
 ZEND_ARG_INFO(0, w)
 ZEND_ARG_INFO(0, h)
 ZEND_ARG_INFO(0, color)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilledarc, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, cx)
 ZEND_ARG_INFO(0, cy)
 ZEND_ARG_INFO(0, w)
 ZEND_ARG_INFO(0, h)
 ZEND_ARG_INFO(0, s)
 ZEND_ARG_INFO(0, e)
 ZEND_ARG_INFO(0, col)
 ZEND_ARG_INFO(0, style)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagealphablending, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, blend)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesavealpha, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, save)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagelayereffect, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, effect)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorallocatealpha, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, alpha)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorresolvealpha, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, alpha)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorclosestalpha, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, alpha)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorexactalpha, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, alpha)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopyresampled, 0)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, dst_w)
 ZEND_ARG_INFO(0, dst_h)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagerotate, 0, 0, 3)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, angle)
 ZEND_ARG_INFO(0, bgdcolor)
 ZEND_ARG_INFO(0, ignoretransparent)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesettile, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, tile)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetbrush, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, brush)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreate, 0)
 ZEND_ARG_INFO(0, x_size)
 ZEND_ARG_INFO(0, y_size)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagetypes, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromstring, 0)
 ZEND_ARG_INFO(0, image)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgif, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromxbm, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()







ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromwbmp, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgd, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgd2, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgd2part, 0)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, srcX)
 ZEND_ARG_INFO(0, srcY)
 ZEND_ARG_INFO(0, width)
 ZEND_ARG_INFO(0, height)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagexbm, 0, 0, 2)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, foreground)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegif, 0, 0, 1)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagewbmp, 0, 0, 1)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, foreground)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegd, 0, 0, 1)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegd2, 0, 0, 1)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, chunk_size)
 ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagedestroy, 0)
 ZEND_ARG_INFO(0, im)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorallocate, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagepalettecopy, 0)
 ZEND_ARG_INFO(0, dst)
 ZEND_ARG_INFO(0, src)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorat, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, x)
 ZEND_ARG_INFO(0, y)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorclosest, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorclosesthwb, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolordeallocate, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorresolve, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorexact, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagecolorset, 0, 0, 5)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, color)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, alpha)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorsforindex, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagegammacorrect, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, inputgamma)
 ZEND_ARG_INFO(0, outputgamma)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetpixel, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, x)
 ZEND_ARG_INFO(0, y)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageline, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, x1)
 ZEND_ARG_INFO(0, y1)
 ZEND_ARG_INFO(0, x2)
 ZEND_ARG_INFO(0, y2)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagedashedline, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, x1)
 ZEND_ARG_INFO(0, y1)
 ZEND_ARG_INFO(0, x2)
 ZEND_ARG_INFO(0, y2)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagerectangle, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, x1)
 ZEND_ARG_INFO(0, y1)
 ZEND_ARG_INFO(0, x2)
 ZEND_ARG_INFO(0, y2)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilledrectangle, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, x1)
 ZEND_ARG_INFO(0, y1)
 ZEND_ARG_INFO(0, x2)
 ZEND_ARG_INFO(0, y2)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagearc, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, cx)
 ZEND_ARG_INFO(0, cy)
 ZEND_ARG_INFO(0, w)
 ZEND_ARG_INFO(0, h)
 ZEND_ARG_INFO(0, s)
 ZEND_ARG_INFO(0, e)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageellipse, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, cx)
 ZEND_ARG_INFO(0, cy)
 ZEND_ARG_INFO(0, w)
 ZEND_ARG_INFO(0, h)
 ZEND_ARG_INFO(0, color)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilltoborder, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, x)
 ZEND_ARG_INFO(0, y)
 ZEND_ARG_INFO(0, border)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefill, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, x)
 ZEND_ARG_INFO(0, y)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorstotal, 0)
 ZEND_ARG_INFO(0, im)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagecolortransparent, 0, 0, 1)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imageinterlace, 0, 0, 1)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, interlace)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagepolygon, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, points)
 ZEND_ARG_INFO(0, num_pos)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilledpolygon, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, points)
 ZEND_ARG_INFO(0, num_pos)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefontwidth, 0)
 ZEND_ARG_INFO(0, font)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefontheight, 0)
 ZEND_ARG_INFO(0, font)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagechar, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, font)
 ZEND_ARG_INFO(0, x)
 ZEND_ARG_INFO(0, y)
 ZEND_ARG_INFO(0, c)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecharup, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, font)
 ZEND_ARG_INFO(0, x)
 ZEND_ARG_INFO(0, y)
 ZEND_ARG_INFO(0, c)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagestring, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, font)
 ZEND_ARG_INFO(0, x)
 ZEND_ARG_INFO(0, y)
 ZEND_ARG_INFO(0, str)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagestringup, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, font)
 ZEND_ARG_INFO(0, x)
 ZEND_ARG_INFO(0, y)
 ZEND_ARG_INFO(0, str)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopy, 0)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopymerge, 0)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
 ZEND_ARG_INFO(0, pct)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopymergegray, 0)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
 ZEND_ARG_INFO(0, pct)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopyresized, 0)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, dst_w)
 ZEND_ARG_INFO(0, dst_h)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesx, 0)
 ZEND_ARG_INFO(0, im)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesy, 0)
 ZEND_ARG_INFO(0, im)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_image2wbmp, 0, 0, 1)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, threshold)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagefilter, 0, 0, 2)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, filtertype)
 ZEND_ARG_INFO(0, arg1)
 ZEND_ARG_INFO(0, arg2)
 ZEND_ARG_INFO(0, arg3)
 ZEND_ARG_INFO(0, arg4)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageconvolution, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, matrix3x3)
 ZEND_ARG_INFO(0, div)
 ZEND_ARG_INFO(0, offset)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageflip, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, mode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecrop, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, rect)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagecropauto, 0, 0, 1)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, mode)
 ZEND_ARG_INFO(0, threshold)
 ZEND_ARG_INFO(0, color)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagescale, 0, 0, 2)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, new_width)
 ZEND_ARG_INFO(0, new_height)
 ZEND_ARG_INFO(0, mode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imageaffine, 0, 0, 2)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, affine)
 ZEND_ARG_INFO(0, clip)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imageaffinematrixget, 0, 0, 1)
 ZEND_ARG_INFO(0, type)
 ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageaffinematrixconcat, 0)
 ZEND_ARG_INFO(0, m1)
 ZEND_ARG_INFO(0, m2)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetinterpolation, 0)
 ZEND_ARG_INFO(0, im)
 ZEND_ARG_INFO(0, method)
ZEND_END_ARG_INFO()





const zend_function_entry gd_functions[] = {
 PHP_FE(gd_info, arginfo_gd_info)
 PHP_FE(imagearc, arginfo_imagearc)
 PHP_FE(imageellipse, arginfo_imageellipse)
 PHP_FE(imagechar, arginfo_imagechar)
 PHP_FE(imagecharup, arginfo_imagecharup)
 PHP_FE(imagecolorat, arginfo_imagecolorat)
 PHP_FE(imagecolorallocate, arginfo_imagecolorallocate)
 PHP_FE(imagepalettecopy, arginfo_imagepalettecopy)
 PHP_FE(imagecreatefromstring, arginfo_imagecreatefromstring)
 PHP_FE(imagecolorclosest, arginfo_imagecolorclosest)
 PHP_FE(imagecolorclosesthwb, arginfo_imagecolorclosesthwb)
 PHP_FE(imagecolordeallocate, arginfo_imagecolordeallocate)
 PHP_FE(imagecolorresolve, arginfo_imagecolorresolve)
 PHP_FE(imagecolorexact, arginfo_imagecolorexact)
 PHP_FE(imagecolorset, arginfo_imagecolorset)
 PHP_FE(imagecolortransparent, arginfo_imagecolortransparent)
 PHP_FE(imagecolorstotal, arginfo_imagecolorstotal)
 PHP_FE(imagecolorsforindex, arginfo_imagecolorsforindex)
 PHP_FE(imagecopy, arginfo_imagecopy)
 PHP_FE(imagecopymerge, arginfo_imagecopymerge)
 PHP_FE(imagecopymergegray, arginfo_imagecopymergegray)
 PHP_FE(imagecopyresized, arginfo_imagecopyresized)
 PHP_FE(imagecreate, arginfo_imagecreate)
 PHP_FE(imagecreatetruecolor, arginfo_imagecreatetruecolor)
 PHP_FE(imageistruecolor, arginfo_imageistruecolor)
 PHP_FE(imagetruecolortopalette, arginfo_imagetruecolortopalette)
 PHP_FE(imagepalettetotruecolor, arginfo_imagepalettetotruecolor)
 PHP_FE(imagesetthickness, arginfo_imagesetthickness)
 PHP_FE(imagefilledarc, arginfo_imagefilledarc)
 PHP_FE(imagefilledellipse, arginfo_imagefilledellipse)
 PHP_FE(imagealphablending, arginfo_imagealphablending)
 PHP_FE(imagesavealpha, arginfo_imagesavealpha)
 PHP_FE(imagecolorallocatealpha, arginfo_imagecolorallocatealpha)
 PHP_FE(imagecolorresolvealpha, arginfo_imagecolorresolvealpha)
 PHP_FE(imagecolorclosestalpha, arginfo_imagecolorclosestalpha)
 PHP_FE(imagecolorexactalpha, arginfo_imagecolorexactalpha)
 PHP_FE(imagecopyresampled, arginfo_imagecopyresampled)






 PHP_FE(imagerotate, arginfo_imagerotate)
 PHP_FE(imageflip, arginfo_imageflip)




 PHP_FE(imagecrop, arginfo_imagecrop)
 PHP_FE(imagecropauto, arginfo_imagecropauto)
 PHP_FE(imagescale, arginfo_imagescale)
 PHP_FE(imageaffine, arginfo_imageaffine)
 PHP_FE(imageaffinematrixconcat, arginfo_imageaffinematrixconcat)
 PHP_FE(imageaffinematrixget, arginfo_imageaffinematrixget)
 PHP_FE(imagesetinterpolation, arginfo_imagesetinterpolation)
 PHP_FE(imagesettile, arginfo_imagesettile)
 PHP_FE(imagesetbrush, arginfo_imagesetbrush)
 PHP_FE(imagesetstyle, arginfo_imagesetstyle)







 PHP_FE(imagecreatefromgif, arginfo_imagecreatefromgif)



 PHP_FE(imagecreatefromwbmp, arginfo_imagecreatefromwbmp)
 PHP_FE(imagecreatefromxbm, arginfo_imagecreatefromxbm)



 PHP_FE(imagecreatefromgd, arginfo_imagecreatefromgd)
 PHP_FE(imagecreatefromgd2, arginfo_imagecreatefromgd2)
 PHP_FE(imagecreatefromgd2part, arginfo_imagecreatefromgd2part)






 PHP_FE(imagegif, arginfo_imagegif)



 PHP_FE(imagewbmp, arginfo_imagewbmp)
 PHP_FE(imagegd, arginfo_imagegd)
 PHP_FE(imagegd2, arginfo_imagegd2)

 PHP_FE(imagedestroy, arginfo_imagedestroy)
 PHP_FE(imagegammacorrect, arginfo_imagegammacorrect)
 PHP_FE(imagefill, arginfo_imagefill)
 PHP_FE(imagefilledpolygon, arginfo_imagefilledpolygon)
 PHP_FE(imagefilledrectangle, arginfo_imagefilledrectangle)
 PHP_FE(imagefilltoborder, arginfo_imagefilltoborder)
 PHP_FE(imagefontwidth, arginfo_imagefontwidth)
 PHP_FE(imagefontheight, arginfo_imagefontheight)
 PHP_FE(imageinterlace, arginfo_imageinterlace)
 PHP_FE(imageline, arginfo_imageline)
 PHP_FE(imageloadfont, arginfo_imageloadfont)
 PHP_FE(imagepolygon, arginfo_imagepolygon)
 PHP_FE(imagerectangle, arginfo_imagerectangle)
 PHP_FE(imagesetpixel, arginfo_imagesetpixel)
 PHP_FE(imagestring, arginfo_imagestring)
 PHP_FE(imagestringup, arginfo_imagestringup)
 PHP_FE(imagesx, arginfo_imagesx)
 PHP_FE(imagesy, arginfo_imagesy)
 PHP_FE(imagedashedline, arginfo_imagedashedline)

 PHP_FE(imagetypes, arginfo_imagetypes)







 PHP_FE(image2wbmp, arginfo_image2wbmp)
 PHP_FE(imagelayereffect, arginfo_imagelayereffect)
 PHP_FE(imagexbm, arginfo_imagexbm)

 PHP_FE(imagecolormatch, arginfo_imagecolormatch)


 PHP_FE(imagefilter, arginfo_imagefilter)
 PHP_FE(imageconvolution, arginfo_imageconvolution)

 PHP_FE_END
};


zend_module_entry gd_module_entry = {
 STANDARD_MODULE_HEADER,
 "gd",
 gd_functions,
 PHP_MINIT(gd),



 NULL,

 NULL,



 NULL,

 PHP_MINFO(gd),
 NO_VERSION_YET,
 STANDARD_MODULE_PROPERTIES
};






PHP_INI_BEGIN()
 PHP_INI_ENTRY("gd.jpeg_ignore_warning", "0", PHP_INI_ALL, NULL)
PHP_INI_END()




static void php_free_gd_image(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
 gdImageDestroy((gdImagePtr) rsrc->ptr);
}




static void php_free_gd_font(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
 gdFontPtr fp = (gdFontPtr) rsrc->ptr;

 if (fp->data) {
  efree(fp->data);
 }

 efree(fp);
}





void php_gd_error_method(int type, const char *format, va_list args)
{
 TSRMLS_FETCH();

 switch (type) {
  case GD_DEBUG:
  case GD_INFO:
  case GD_NOTICE:
   type = E_NOTICE;
   break;
  case GD_WARNING:
   type = E_WARNING;
   break;
  default:
   type = E_ERROR;
 }
 php_verror(NULL, "", type, format, args TSRMLS_CC);
}

PHP_MINIT_FUNCTION(gd)
{
 le_gd = zend_register_list_destructors_ex(php_free_gd_image, NULL, "gd", module_number);
 le_gd_font = zend_register_list_destructors_ex(php_free_gd_font, NULL, "gd font", module_number);

 gdSetErrorMethod(php_gd_error_method);

 REGISTER_INI_ENTRIES();

 REGISTER_LONG_CONSTANT("IMG_GIF", 1, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_JPG", 2, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_JPEG", 2, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_PNG", 4, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_WBMP", 8, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_XPM", 16, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_WEBP", 32, CONST_CS | CONST_PERSISTENT);


 REGISTER_LONG_CONSTANT("IMG_COLOR_TILED", gdTiled, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_COLOR_STYLED", gdStyled, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_COLOR_BRUSHED", gdBrushed, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_COLOR_STYLEDBRUSHED", gdStyledBrushed, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_COLOR_TRANSPARENT", gdTransparent, CONST_CS | CONST_PERSISTENT);


 REGISTER_LONG_CONSTANT("IMG_ARC_ROUNDED", gdArc, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_ARC_PIE", gdPie, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_ARC_CHORD", gdChord, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_ARC_NOFILL", gdNoFill, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_ARC_EDGED", gdEdged, CONST_CS | CONST_PERSISTENT);


 REGISTER_LONG_CONSTANT("IMG_GD2_RAW", GD2_FMT_RAW, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_GD2_COMPRESSED", GD2_FMT_COMPRESSED, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FLIP_HORIZONTAL", GD_FLIP_HORINZONTAL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FLIP_VERTICAL", GD_FLIP_VERTICAL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FLIP_BOTH", GD_FLIP_BOTH, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_EFFECT_REPLACE", gdEffectReplace, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_EFFECT_ALPHABLEND", gdEffectAlphaBlend, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_EFFECT_NORMAL", gdEffectNormal, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_EFFECT_OVERLAY", gdEffectOverlay, CONST_CS | CONST_PERSISTENT);

 REGISTER_LONG_CONSTANT("IMG_CROP_DEFAULT", GD_CROP_DEFAULT, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_TRANSPARENT", GD_CROP_TRANSPARENT, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_BLACK", GD_CROP_BLACK, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_WHITE", GD_CROP_WHITE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_SIDES", GD_CROP_SIDES, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_THRESHOLD", GD_CROP_THRESHOLD, CONST_CS | CONST_PERSISTENT);


 REGISTER_LONG_CONSTANT("IMG_BELL", GD_BELL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BESSEL", GD_BESSEL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BILINEAR_FIXED", GD_BILINEAR_FIXED, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BICUBIC", GD_BICUBIC, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BICUBIC_FIXED", GD_BICUBIC_FIXED, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BLACKMAN", GD_BLACKMAN, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BOX", GD_BOX, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BSPLINE", GD_BSPLINE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CATMULLROM", GD_CATMULLROM, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_GAUSSIAN", GD_GAUSSIAN, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_GENERALIZED_CUBIC", GD_GENERALIZED_CUBIC, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_HERMITE", GD_HERMITE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_HAMMING", GD_HAMMING, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_HANNING", GD_HANNING, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_MITCHELL", GD_MITCHELL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_POWER", GD_POWER, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_QUADRATIC", GD_QUADRATIC, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_SINC", GD_SINC, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_NEAREST_NEIGHBOUR", GD_NEAREST_NEIGHBOUR, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_WEIGHTED4", GD_WEIGHTED4, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_TRIANGLE", GD_TRIANGLE, CONST_CS | CONST_PERSISTENT);

 REGISTER_LONG_CONSTANT("IMG_AFFINE_TRANSLATE", GD_AFFINE_TRANSLATE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_AFFINE_SCALE", GD_AFFINE_SCALE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_AFFINE_ROTATE", GD_AFFINE_ROTATE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_AFFINE_SHEAR_HORIZONTAL", GD_AFFINE_SHEAR_HORIZONTAL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_AFFINE_SHEAR_VERTICAL", GD_AFFINE_SHEAR_VERTICAL, CONST_CS | CONST_PERSISTENT);




 REGISTER_LONG_CONSTANT("GD_BUNDLED", 0, CONST_CS | CONST_PERSISTENT);



 REGISTER_LONG_CONSTANT("IMG_FILTER_NEGATE", 0, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_GRAYSCALE", 1, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_BRIGHTNESS", 2, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_CONTRAST", 3, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_COLORIZE", 4, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_EDGEDETECT", 5, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_GAUSSIAN_BLUR", 7, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_SELECTIVE_BLUR", 8, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_EMBOSS", 6, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_MEAN_REMOVAL", 9, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_SMOOTH", 10, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_PIXELATE", 11, CONST_CS | CONST_PERSISTENT);

 return SUCCESS;
}

PHP_MINFO_FUNCTION(gd)
{
 php_info_print_table_start();
 php_info_print_table_row(2, "GD Support", "enabled");






 php_info_print_table_row(2, "GD headers Version", GD_VERSION_STRING);

 php_info_print_table_row(2, "GIF Read Support", "enabled");
 php_info_print_table_row(2, "GIF Create Support", "enabled");

 php_info_print_table_row(2, "WBMP Support", "enabled");

 php_info_print_table_row(2, "XBM Support", "enabled");






 php_info_print_table_end();
 DISPLAY_INI_ENTRIES();
}




PHP_FUNCTION(gd_info)
{
 if (zend_parse_parameters_none() == FAILURE) {
  RETURN_FALSE;
 }

 array_init(return_value);

 add_assoc_string(return_value, "GD Version", GD_VERSION_STRING, 1);

 add_assoc_bool(return_value, "FreeType Support", 0);





 add_assoc_bool(return_value, "T1Lib Support", 0);

 add_assoc_bool(return_value, "GIF Read Support", 1);
 add_assoc_bool(return_value, "GIF Create Support", 1);



 add_assoc_bool(return_value, "JPEG Support", 0);




 add_assoc_bool(return_value, "PNG Support", 0);

 add_assoc_bool(return_value, "WBMP Support", 1);



 add_assoc_bool(return_value, "XPM Support", 0);

 add_assoc_bool(return_value, "XBM Support", 1);



 add_assoc_bool(return_value, "WebP Support", 0);




 add_assoc_bool(return_value, "JIS-mapped Japanese Font Support", 0);

}



PHP_GD_API int phpi_get_le_gd(void)
{
 return le_gd;
}






PHP_FUNCTION(imageloadfont)
{
 char *file;
 int file_name, hdr_size = sizeof(gdFont) - sizeof(char *);
 int ind, body_size, n = 0, b, i, body_size_check;
 gdFontPtr font;
 php_stream *stream;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "p", &file, &file_name) == FAILURE) {
  return;
 }

 stream = php_stream_open_wrapper(file, "rb", IGNORE_PATH | IGNORE_URL_WIN | REPORT_ERRORS, NULL);
 if (stream == NULL) {
  RETURN_FALSE;
 }

 font = (gdFontPtr) emalloc(sizeof(gdFont));
 b = 0;
 while (b < hdr_size && (n = php_stream_read(stream, (char*)&font[b], hdr_size - b))) {
  b += n;
 }

 if (!n) {
  efree(font);
  if (php_stream_eof(stream)) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "End of file while reading header");
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading header");
  }
  php_stream_close(stream);
  RETURN_FALSE;
 }
 i = php_stream_tell(stream);
 php_stream_seek(stream, 0, SEEK_END);
 body_size_check = php_stream_tell(stream) - hdr_size;
 php_stream_seek(stream, i, SEEK_SET);

 body_size = font->w * font->h * font->nchars;
 if (body_size != body_size_check) {
  font->w = (((font->w & 0xff000000) >> 24) | ((font->w & 0x00ff0000) >> 8) | ((font->w & 0x0000ff00) << 8) | ((font->w & 0x000000ff) << 24));
  font->h = (((font->h & 0xff000000) >> 24) | ((font->h & 0x00ff0000) >> 8) | ((font->h & 0x0000ff00) << 8) | ((font->h & 0x000000ff) << 24));
  font->nchars = (((font->nchars & 0xff000000) >> 24) | ((font->nchars & 0x00ff0000) >> 8) | ((font->nchars & 0x0000ff00) << 8) | ((font->nchars & 0x000000ff) << 24));
  body_size = font->w * font->h * font->nchars;
 }

 if (overflow2(font->nchars, font->h) || overflow2(font->nchars * font->h, font->w )) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error reading font, invalid font header");
  efree(font);
  php_stream_close(stream);
  RETURN_FALSE;
 }

 if (body_size != body_size_check) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error reading font");
  efree(font);
  php_stream_close(stream);
  RETURN_FALSE;
 }

 font->data = emalloc(body_size);
 b = 0;
 while (b < body_size && (n = php_stream_read(stream, &font->data[b], body_size - b))) {
  b += n;
 }

 if (!n) {
  efree(font->data);
  efree(font);
  if (php_stream_eof(stream)) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "End of file while reading body");
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading body");
  }
  php_stream_close(stream);
  RETURN_FALSE;
 }
 php_stream_close(stream);





 ind = 5 + zend_list_insert(font, le_gd_font TSRMLS_CC);

 RETURN_LONG(ind);
}




PHP_FUNCTION(imagesetstyle)
{
 zval *IM, *styles;
 gdImagePtr im;
 int * stylearr;
 int index;
 HashPosition pos;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ra", &IM, &styles) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);


 stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

 zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

 for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos)) {
  zval ** item;

  if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
   break;
  }

  if (Z_TYPE_PP(item) != IS_LONG) {
   zval lval;
   lval = **item;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   stylearr[index++] = Z_LVAL(lval);
  } else {
   stylearr[index++] = Z_LVAL_PP(item);
  }
 }

 gdImageSetStyle(im, stylearr, index);

 efree(stylearr);

 RETURN_TRUE;
}




PHP_FUNCTION(imagecreatetruecolor)
{
 long x_size, y_size;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &x_size, &y_size) == FAILURE) {
  return;
 }

 if (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid image dimensions");
  RETURN_FALSE;
 }

 im = gdImageCreateTrueColor(x_size, y_size);

 if (!im) {
  RETURN_FALSE;
 }

 ZEND_REGISTER_RESOURCE(return_value, im, le_gd);
}




PHP_FUNCTION(imageistruecolor)
{
 zval *IM;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_BOOL(im->trueColor);
}




PHP_FUNCTION(imagetruecolortopalette)
{
 zval *IM;
 zend_bool dither;
 long ncolors;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rbl", &IM, &dither, &ncolors) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (ncolors <= 0) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number of colors has to be greater than zero");
  RETURN_FALSE;
 }
 gdImageTrueColorToPalette(im, dither, ncolors);

 RETURN_TRUE;
}






PHP_FUNCTION(imagepalettetotruecolor)
{
 zval *IM;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (gdImagePaletteToTrueColor(im) == 0) {
  RETURN_FALSE;
 }

 RETURN_TRUE;
}




PHP_FUNCTION(imagecolormatch)
{
 zval *IM1, *IM2;
 gdImagePtr im1, im2;
 int result;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rr", &IM1, &IM2) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im1, gdImagePtr, &IM1, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im2, gdImagePtr, &IM2, -1, "Image", le_gd);

 result = gdImageColorMatch(im1, im2);
 switch (result) {
  case -1:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Image1 must be TrueColor" );
   RETURN_FALSE;
   break;
  case -2:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Image2 must be Palette" );
   RETURN_FALSE;
   break;
  case -3:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Image1 and Image2 must be the same size" );
   RETURN_FALSE;
   break;
  case -4:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Image2 must have at least one color" );
   RETURN_FALSE;
   break;
 }

 RETURN_TRUE;
}




PHP_FUNCTION(imagesetthickness)
{
 zval *IM;
 long thick;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &thick) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 gdImageSetThickness(im, thick);

 RETURN_TRUE;
}




PHP_FUNCTION(imagefilledellipse)
{
 zval *IM;
 long cx, cy, w, h, color;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &cx, &cy, &w, &h, &color) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 gdImageFilledEllipse(im, cx, cy, w, h, color);

 RETURN_TRUE;
}




PHP_FUNCTION(imagefilledarc)
{
 zval *IM;
 long cx, cy, w, h, ST, E, col, style;
 gdImagePtr im;
 int e, st;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllllllll", &IM, &cx, &cy, &w, &h, &ST, &E, &col, &style) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 e = E;
 if (e < 0) {
  e %= 360;
 }

 st = ST;
 if (st < 0) {
  st %= 360;
 }

 gdImageFilledArc(im, cx, cy, w, h, st, e, col, style);

 RETURN_TRUE;
}




PHP_FUNCTION(imagealphablending)
{
 zval *IM;
 zend_bool blend;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rb", &IM, &blend) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageAlphaBlending(im, blend);

 RETURN_TRUE;
}




PHP_FUNCTION(imagesavealpha)
{
 zval *IM;
 zend_bool save;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rb", &IM, &save) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageSaveAlpha(im, save);

 RETURN_TRUE;
}




PHP_FUNCTION(imagelayereffect)
{
 zval *IM;
 long effect;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &effect) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageAlphaBlending(im, effect);

 RETURN_TRUE;
}




PHP_FUNCTION(imagecolorallocatealpha)
{
 zval *IM;
 long red, green, blue, alpha;
 gdImagePtr im;
 int ct = -1;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &red, &green, &blue, &alpha) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 ct = gdImageColorAllocateAlpha(im, red, green, blue, alpha);
 if (ct < 0) {
  RETURN_FALSE;
 }
 RETURN_LONG((long)ct);
}




PHP_FUNCTION(imagecolorresolvealpha)
{
 zval *IM;
 long red, green, blue, alpha;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &red, &green, &blue, &alpha) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorResolveAlpha(im, red, green, blue, alpha));
}




PHP_FUNCTION(imagecolorclosestalpha)
{
 zval *IM;
 long red, green, blue, alpha;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &red, &green, &blue, &alpha) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorClosestAlpha(im, red, green, blue, alpha));
}




PHP_FUNCTION(imagecolorexactalpha)
{
 zval *IM;
 long red, green, blue, alpha;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &red, &green, &blue, &alpha) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorExactAlpha(im, red, green, blue, alpha));
}




PHP_FUNCTION(imagecopyresampled)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY, DW, DH;
 gdImagePtr im_dst, im_src;
 int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrllllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;
 dstH = DH;
 dstW = DW;

 gdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);

 RETURN_TRUE;
}

PHP_FUNCTION(imagerotate)
{
 zval *SIM;
 gdImagePtr im_dst, im_src;
 double degrees;
 long color;
 long ignoretransparent = 0;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rdl|l", &SIM, &degrees, &color, &ignoretransparent) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);

 im_dst = gdImageRotateInterpolated(im_src, (const float)degrees, color);

 if (im_dst != NULL) {
  ZEND_REGISTER_RESOURCE(return_value, im_dst, le_gd);
 } else {
  RETURN_FALSE;
 }
}




PHP_FUNCTION(imagesettile)
{
 zval *IM, *TILE;
 gdImagePtr im, tile;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rr", &IM, &TILE) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, "Image", le_gd);

 gdImageSetTile(im, tile);

 RETURN_TRUE;
}




PHP_FUNCTION(imagesetbrush)
{
 zval *IM, *TILE;
 gdImagePtr im, tile;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rr", &IM, &TILE) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, "Image", le_gd);

 gdImageSetBrush(im, tile);

 RETURN_TRUE;
}




PHP_FUNCTION(imagecreate)
{
 long x_size, y_size;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &x_size, &y_size) == FAILURE) {
  return;
 }

 if (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid image dimensions");
  RETURN_FALSE;
 }

 im = gdImageCreate(x_size, y_size);

 if (!im) {
  RETURN_FALSE;
 }

 ZEND_REGISTER_RESOURCE(return_value, im, le_gd);
}




PHP_FUNCTION(imagetypes)
{
 int ret=0;
 ret = 1;






 ret |= 8;







 if (zend_parse_parameters_none() == FAILURE) {
  return;
 }

 RETURN_LONG(ret);
}





static int _php_ctx_getmbi(gdIOCtx *ctx)
{
 int i, mbi = 0;

 do {
  i = (ctx->getC)(ctx);
  if (i < 0) {
   return -1;
  }
  mbi = (mbi << 7) | (i & 0x7f);
 } while (i & 0x80);

 return mbi;
}




static const char php_sig_gd2[3] = {'g', 'd', '2'};

static int _php_image_type (char data[8])
{


 if (data == NULL) {
  return -1;
 }

 if (!memcmp(data, php_sig_gd2, 3)) {
  return PHP_GDIMG_TYPE_GD2;
 } else if (!memcmp(data, php_sig_jpg, 3)) {
  return PHP_GDIMG_TYPE_JPG;
 } else if (!memcmp(data, php_sig_png, 3)) {
  if (!memcmp(data, php_sig_png, 8)) {
   return PHP_GDIMG_TYPE_PNG;
  }
 } else if (!memcmp(data, php_sig_gif, 3)) {
  return PHP_GDIMG_TYPE_GIF;
 }
 else {
  gdIOCtx *io_ctx;
  io_ctx = gdNewDynamicCtxEx(8, data, 0);
  if (io_ctx) {
   if (_php_ctx_getmbi(io_ctx) == 0 && _php_ctx_getmbi(io_ctx) >= 0) {
    io_ctx->gd_free(io_ctx);
    return PHP_GDIMG_TYPE_WBM;
   } else {
    io_ctx->gd_free(io_ctx);
   }
  }
 }
 return -1;
}




gdImagePtr _php_image_create_from_string(zval **data, char *tn, gdImagePtr (*ioctx_func_p)() TSRMLS_DC)
{
 gdImagePtr im;
 gdIOCtx *io_ctx;

 io_ctx = gdNewDynamicCtxEx(Z_STRLEN_PP(data), Z_STRVAL_PP(data), 0);

 if (!io_ctx) {
  return NULL;
 }

 im = (*ioctx_func_p)(io_ctx);
 if (!im) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Passed data is not in '%s' format", tn);
  io_ctx->gd_free(io_ctx);
  return NULL;
 }

 io_ctx->gd_free(io_ctx);

 return im;
}




PHP_FUNCTION(imagecreatefromstring)
{
 zval **data;
 gdImagePtr im;
 int imtype;
 char sig[8];

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Z", &data) == FAILURE) {
  return;
 }

 convert_to_string_ex(data);
 if (Z_STRLEN_PP(data) < 8) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Empty string or invalid image");
  RETURN_FALSE;
 }

 memcpy(sig, Z_STRVAL_PP(data), 8);

 imtype = _php_image_type(sig);

 switch (imtype) {
  case PHP_GDIMG_TYPE_JPG:



   php_error_docref(NULL TSRMLS_CC, E_WARNING, "No JPEG support in this PHP build");
   RETURN_FALSE;

   break;

  case PHP_GDIMG_TYPE_PNG:



   php_error_docref(NULL TSRMLS_CC, E_WARNING, "No PNG support in this PHP build");
   RETURN_FALSE;

   break;

  case PHP_GDIMG_TYPE_GIF:
   im = _php_image_create_from_string(data, "GIF", gdImageCreateFromGifCtx TSRMLS_CC);
   break;

  case PHP_GDIMG_TYPE_WBM:
   im = _php_image_create_from_string(data, "WBMP", gdImageCreateFromWBMPCtx TSRMLS_CC);
   break;

  case PHP_GDIMG_TYPE_GD2:
   im = _php_image_create_from_string(data, "GD2", gdImageCreateFromGd2Ctx TSRMLS_CC);
   break;

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Data is not in a recognized format");
   RETURN_FALSE;
 }

 if (!im) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Couldn't create GD Image Stream out of Data");
  RETURN_FALSE;
 }

 ZEND_REGISTER_RESOURCE(return_value, im, le_gd);
}




static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())
{
 char *file;
 int file_len;
 long srcx, srcy, width, height;
 gdImagePtr im = NULL;
 php_stream *stream;
 FILE * fp = NULL;
 long ignore_warning;

 if (image_type == PHP_GDIMG_TYPE_GD2PART) {
  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "pllll", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {
   return;
  }
  if (width < 1 || height < 1) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Zero width or height not allowed");
   RETURN_FALSE;
  }
 } else {
  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "p", &file, &file_len) == FAILURE) {
   return;
  }
 }


 stream = php_stream_open_wrapper(file, "rb", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);
 if (stream == NULL) {
  RETURN_FALSE;
 }


 if (php_stream_is(stream, PHP_STREAM_IS_STDIO)) {
  if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {
   goto out_err;
  }
 } else if (ioctx_func_p) {

  gdIOCtx* io_ctx;
  size_t buff_size;
  char *buff;


  buff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);

  if (!buff_size) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING,"Cannot read image data");
   goto out_err;
  }

  io_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);
  if (!io_ctx) {
   pefree(buff, 1);
   php_error_docref(NULL TSRMLS_CC, E_WARNING,"Cannot allocate GD IO context");
   goto out_err;
  }

  if (image_type == PHP_GDIMG_TYPE_GD2PART) {
   im = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);
  } else {
   im = (*ioctx_func_p)(io_ctx);
  }
  io_ctx->gd_free(io_ctx);
  pefree(buff, 1);
 }
 else if (php_stream_can_cast(stream, PHP_STREAM_AS_STDIO)) {

  if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {
   goto out_err;
  }
 }

 if (!im && fp) {
  switch (image_type) {
   case PHP_GDIMG_TYPE_GD2PART:
    im = (*func_p)(fp, srcx, srcy, width, height);
    break;

   default:
    im = (*func_p)(fp);
    break;
  }

  fflush(fp);
 }


 if (im) {
  ZEND_REGISTER_RESOURCE(return_value, im, le_gd);
  php_stream_close(stream);
  return;
 }

 php_error_docref(NULL TSRMLS_CC, E_WARNING, "'%s' is not a valid %s file", file, tn);
out_err:
 php_stream_close(stream);
 RETURN_FALSE;

}




PHP_FUNCTION(imagecreatefromgif)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, "GIF", gdImageCreateFromGif, gdImageCreateFromGifCtx);
}

PHP_FUNCTION(imagecreatefromxbm)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, "XBM", gdImageCreateFromXbm, NULL);
}

PHP_FUNCTION(imagecreatefromwbmp)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, "WBMP", gdImageCreateFromWBMP, gdImageCreateFromWBMPCtx);
}




PHP_FUNCTION(imagecreatefromgd)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, "GD", gdImageCreateFromGd, gdImageCreateFromGdCtx);
}




PHP_FUNCTION(imagecreatefromgd2)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, "GD2", gdImageCreateFromGd2, gdImageCreateFromGd2Ctx);
}




PHP_FUNCTION(imagecreatefromgd2part)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2PART, "GD2", gdImageCreateFromGd2Part, gdImageCreateFromGd2PartCtx);
}




static void _php_image_output(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)())
{
 zval *imgind;
 char *file = NULL;
 long quality = 0, type = 0;
 gdImagePtr im;
 char *fn = NULL;
 FILE *fp;
 int file_len = 0, argc = ZEND_NUM_ARGS();
 int q = -1, i, t = 1;





 if (zend_parse_parameters(argc TSRMLS_CC, "r|pll", &imgind, &file, &file_len, &quality, &type) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &imgind, -1, "Image", le_gd);

 if (argc > 1) {
  fn = file;
  if (argc == 3) {
   q = quality;
  }
  if (argc == 4) {
   t = type;
  }
 }

 if (argc >= 2 && file_len) {
  PHP_GD_CHECK_OPEN_BASEDIR(fn, "Invalid filename");

  fp = VCWD_FOPEN(fn, "wb");
  if (!fp) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' for writing", fn);
   RETURN_FALSE;
  }

  switch (image_type) {
   case PHP_GDIMG_CONVERT_WBM:
    if (q == -1) {
     q = 0;
    } else if (q < 0 || q > 255) {
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid threshold value '%d'. It must be between 0 and 255", q);
     q = 0;
    }
    gdImageWBMP(im, q, fp);
    break;
   case PHP_GDIMG_TYPE_JPG:
    (*func_p)(im, fp, q);
    break;
   case PHP_GDIMG_TYPE_WBM:
    for (i = 0; i < gdImageColorsTotal(im); i++) {
     if (gdImageRed(im, i) == 0) break;
    }
    (*func_p)(im, i, fp);
    break;
   case PHP_GDIMG_TYPE_GD:
    if (im->trueColor){
     gdImageTrueColorToPalette(im,1,256);
    }
    (*func_p)(im, fp);
    break;
   case PHP_GDIMG_TYPE_GD2:
    if (q == -1) {
     q = 128;
    }
    (*func_p)(im, fp, q, t);
    break;
   default:
    if (q == -1) {
     q = 128;
    }
    (*func_p)(im, fp, q, t);
    break;
  }
  fflush(fp);
  fclose(fp);
 } else {
  int b;
  FILE *tmp;
  char buf[4096];
  char *path;

  tmp = php_open_temporary_file(NULL, NULL, &path TSRMLS_CC);
  if (tmp == NULL) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open temporary file");
   RETURN_FALSE;
  }

  switch (image_type) {
   case PHP_GDIMG_CONVERT_WBM:
     if (q == -1) {
       q = 0;
      } else if (q < 0 || q > 255) {
       php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid threshold value '%d'. It must be between 0 and 255", q);
      q = 0;
      }
    gdImageWBMP(im, q, tmp);
    break;
   case PHP_GDIMG_TYPE_JPG:
    (*func_p)(im, tmp, q);
    break;
   case PHP_GDIMG_TYPE_WBM:
    for (i = 0; i < gdImageColorsTotal(im); i++) {
     if (gdImageRed(im, i) == 0) {
      break;
     }
    }
    (*func_p)(im, q, tmp);
    break;
   case PHP_GDIMG_TYPE_GD:
    if (im->trueColor) {
     gdImageTrueColorToPalette(im,1,256);
    }
    (*func_p)(im, tmp);
    break;
   case PHP_GDIMG_TYPE_GD2:
    if (q == -1) {
     q = 128;
    }
    (*func_p)(im, tmp, q, t);
    break;
   default:
    (*func_p)(im, tmp);
    break;
  }

  fseek(tmp, 0, SEEK_SET);







  while ((b = fread(buf, 1, sizeof(buf), tmp)) > 0) {
   php_write(buf, b TSRMLS_CC);
  }

  fclose(tmp);
  VCWD_UNLINK((const char *)path);
  efree(path);
 }
 RETURN_TRUE;
}




PHP_FUNCTION(imagexbm)
{
 _php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, "XBM", gdImageXbmCtx);
}




PHP_FUNCTION(imagegif)
{
 _php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, "GIF", gdImageGifCtx);
}

PHP_FUNCTION(imagewbmp)
{
 _php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, "WBMP", gdImageWBMPCtx);
}




PHP_FUNCTION(imagegd)
{
 _php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, "GD", gdImageGd);
}




PHP_FUNCTION(imagegd2)
{
 _php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, "GD2", gdImageGd2);
}




PHP_FUNCTION(imagedestroy)
{
 zval *IM;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 zend_list_delete(Z_LVAL_P(IM));

 RETURN_TRUE;
}





PHP_FUNCTION(imagecolorallocate)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr im;
 int ct = -1;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 ct = gdImageColorAllocate(im, red, green, blue);
 if (ct < 0) {
  RETURN_FALSE;
 }
 RETURN_LONG(ct);
}




PHP_FUNCTION(imagepalettecopy)
{
 zval *dstim, *srcim;
 gdImagePtr dst, src;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rr", &dstim, &srcim) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(dst, gdImagePtr, &dstim, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(src, gdImagePtr, &srcim, -1, "Image", le_gd);

 gdImagePaletteCopy(dst, src);
}




PHP_FUNCTION(imagecolorat)
{
 zval *IM;
 long x, y;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rll", &IM, &x, &y) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (gdImageTrueColor(im)) {
  if (im->tpixels && gdImageBoundsSafe(im, x, y)) {
   RETURN_LONG(gdImageTrueColorPixel(im, x, y));
  } else {
   php_error_docref(NULL TSRMLS_CC, E_NOTICE, "%ld,%ld is out of bounds", x, y);
   RETURN_FALSE;
  }
 } else {
  if (im->pixels && gdImageBoundsSafe(im, x, y)) {
   RETURN_LONG(im->pixels[y][x]);
  } else {
   php_error_docref(NULL TSRMLS_CC, E_NOTICE, "%ld,%ld is out of bounds", x, y);
   RETURN_FALSE;
  }
 }
}




PHP_FUNCTION(imagecolorclosest)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorClosest(im, red, green, blue));
}




PHP_FUNCTION(imagecolorclosesthwb)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorClosestHWB(im, red, green, blue));
}




PHP_FUNCTION(imagecolordeallocate)
{
 zval *IM;
 long index;
 int col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &index) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);


 if (gdImageTrueColor(im)) {
  RETURN_TRUE;
 }

 col = index;

 if (col >= 0 && col < gdImageColorsTotal(im)) {
  gdImageColorDeallocate(im, col);
  RETURN_TRUE;
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Color index %d out of range", col);
  RETURN_FALSE;
 }
}




PHP_FUNCTION(imagecolorresolve)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorResolve(im, red, green, blue));
}




PHP_FUNCTION(imagecolorexact)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorExact(im, red, green, blue));
}




PHP_FUNCTION(imagecolorset)
{
 zval *IM;
 long color, red, green, blue, alpha = 0;
 int col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll|l", &IM, &color, &red, &green, &blue, &alpha) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 col = color;

 if (col >= 0 && col < gdImageColorsTotal(im)) {
  im->red[col] = red;
  im->green[col] = green;
  im->blue[col] = blue;
  im->alpha[col] = alpha;
 } else {
  RETURN_FALSE;
 }
}




PHP_FUNCTION(imagecolorsforindex)
{
 zval *IM;
 long index;
 int col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &index) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 col = index;

 if ((col >= 0 && gdImageTrueColor(im)) || (!gdImageTrueColor(im) && col >= 0 && col < gdImageColorsTotal(im))) {
  array_init(return_value);

  add_assoc_long(return_value,"red", gdImageRed(im,col));
  add_assoc_long(return_value,"green", gdImageGreen(im,col));
  add_assoc_long(return_value,"blue", gdImageBlue(im,col));
  add_assoc_long(return_value,"alpha", gdImageAlpha(im,col));
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Color index %d out of range", col);
  RETURN_FALSE;
 }
}




PHP_FUNCTION(imagegammacorrect)
{
 zval *IM;
 gdImagePtr im;
 int i;
 double input, output;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rdd", &IM, &input, &output) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (gdImageTrueColor(im)) {
  int x, y, c;

  for (y = 0; y < gdImageSY(im); y++) {
   for (x = 0; x < gdImageSX(im); x++) {
    c = gdImageGetPixel(im, x, y);
    gdImageSetPixel(im, x, y,
     gdTrueColorAlpha(
      (int) ((pow((pow((gdTrueColorGetRed(c) / 255.0), input)), 1.0 / output) * 255) + .5),
      (int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),
      (int) ((pow((pow((gdTrueColorGetBlue(c) / 255.0), input)), 1.0 / output) * 255) + .5),
      gdTrueColorGetAlpha(c)
     )
    );
   }
  }
  RETURN_TRUE;
 }

 for (i = 0; i < gdImageColorsTotal(im); i++) {
  im->red[i] = (int)((pow((pow((im->red[i] / 255.0), input)), 1.0 / output) * 255) + .5);
  im->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);
  im->blue[i] = (int)((pow((pow((im->blue[i] / 255.0), input)), 1.0 / output) * 255) + .5);
 }

 RETURN_TRUE;
}




PHP_FUNCTION(imagesetpixel)
{
 zval *IM;
 long x, y, col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &x, &y, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageSetPixel(im, x, y, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imageline)
{
 zval *IM;
 long x1, y1, x2, y2, col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);






 {
  gdImageLine(im, x1, y1, x2, y2, col);
 }
 RETURN_TRUE;
}




PHP_FUNCTION(imagedashedline)
{
 zval *IM;
 long x1, y1, x2, y2, col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageDashedLine(im, x1, y1, x2, y2, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagerectangle)
{
 zval *IM;
 long x1, y1, x2, y2, col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageRectangle(im, x1, y1, x2, y2, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagefilledrectangle)
{
 zval *IM;
 long x1, y1, x2, y2, col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageFilledRectangle(im, x1, y1, x2, y2, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagearc)
{
 zval *IM;
 long cx, cy, w, h, ST, E, col;
 gdImagePtr im;
 int e, st;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllllll", &IM, &cx, &cy, &w, &h, &ST, &E, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 e = E;
 if (e < 0) {
  e %= 360;
 }

 st = ST;
 if (st < 0) {
  st %= 360;
 }

 gdImageArc(im, cx, cy, w, h, st, e, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imageellipse)
{
 zval *IM;
 long cx, cy, w, h, color;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &cx, &cy, &w, &h, &color) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 gdImageEllipse(im, cx, cy, w, h, color);
 RETURN_TRUE;
}




PHP_FUNCTION(imagefilltoborder)
{
 zval *IM;
 long x, y, border, col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &x, &y, &border, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageFillToBorder(im, x, y, border, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagefill)
{
 zval *IM;
 long x, y, col;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &x, &y, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageFill(im, x, y, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagecolorstotal)
{
 zval *IM;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorsTotal(im));
}




PHP_FUNCTION(imagecolortransparent)
{
 zval *IM;
 long COL = 0;
 gdImagePtr im;
 int argc = ZEND_NUM_ARGS();

 if (zend_parse_parameters(argc TSRMLS_CC, "r|l", &IM, &COL) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (argc > 1) {
  gdImageColorTransparent(im, COL);
 }

 RETURN_LONG(gdImageGetTransparent(im));
}




PHP_FUNCTION(imageinterlace)
{
 zval *IM;
 int argc = ZEND_NUM_ARGS();
 long INT = 0;
 gdImagePtr im;

 if (zend_parse_parameters(argc TSRMLS_CC, "r|l", &IM, &INT) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (argc > 1) {
  gdImageInterlace(im, INT);
 }

 RETURN_LONG(gdImageGetInterlaced(im));
}






static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)
{
 zval *IM, *POINTS;
 long NPOINTS, COL;
 zval **var = NULL;
 gdImagePtr im;
 gdPointPtr points;
 int npoints, col, nelem, i;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rall", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 npoints = NPOINTS;
 col = COL;

 nelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));
 if (nelem < 6) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must have at least 3 points in your array");
  RETURN_FALSE;
 }
 if (npoints <= 0) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must give a positive number of points");
  RETURN_FALSE;
 }
 if (nelem < npoints * 2) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Trying to use %d points in array with only %d points", npoints, nelem/2);
  RETURN_FALSE;
 }

 points = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);

 for (i = 0; i < npoints; i++) {
  if (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {
   if (Z_TYPE_PP(var) != IS_LONG) {
    zval lval;
    lval = **var;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    points[i].x = Z_LVAL(lval);
   } else {
    points[i].x = Z_LVAL_PP(var);
   }
  }
  if (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {
   if (Z_TYPE_PP(var) != IS_LONG) {
    zval lval;
    lval = **var;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    points[i].y = Z_LVAL(lval);
   } else {
    points[i].y = Z_LVAL_PP(var);
   }
  }
 }

 if (filled) {
  gdImageFilledPolygon(im, points, npoints, col);
 } else {
  gdImagePolygon(im, points, npoints, col);
 }

 efree(points);
 RETURN_TRUE;
}




PHP_FUNCTION(imagepolygon)
{
 php_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}




PHP_FUNCTION(imagefilledpolygon)
{
 php_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}




static gdFontPtr php_find_gd_font(int size TSRMLS_DC)
{
 gdFontPtr font;
 int ind_type;

 switch (size) {
  case 1:
    font = gdFontTiny;
    break;
  case 2:
    font = gdFontSmall;
    break;
  case 3:
    font = gdFontMediumBold;
    break;
  case 4:
    font = gdFontLarge;
    break;
  case 5:
    font = gdFontGiant;
    break;
  default:
   font = zend_list_find(size - 5, &ind_type);
    if (!font || ind_type != le_gd_font) {
      if (size < 1) {
        font = gdFontTiny;
      } else {
        font = gdFontGiant;
      }
    }
    break;
 }

 return font;
}






static void php_imagefontsize(INTERNAL_FUNCTION_PARAMETERS, int arg)
{
 long SIZE;
 gdFontPtr font;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &SIZE) == FAILURE) {
  return;
 }

 font = php_find_gd_font(SIZE TSRMLS_CC);
 RETURN_LONG(arg ? font->h : font->w);
}




PHP_FUNCTION(imagefontwidth)
{
 php_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}




PHP_FUNCTION(imagefontheight)
{
 php_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}




static void php_gdimagecharup(gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)
{
 int cx, cy, px, py, fline;
 cx = 0;
 cy = 0;

 if ((c < f->offset) || (c >= (f->offset + f->nchars))) {
  return;
 }

 fline = (c - f->offset) * f->h * f->w;
 for (py = y; (py > (y - f->w)); py--) {
  for (px = x; (px < (x + f->h)); px++) {
   if (f->data[fline + cy * f->w + cx]) {
    gdImageSetPixel(im, px, py, color);
   }
   cy++;
  }
  cy = 0;
  cx++;
 }
}

static void php_imagechar(INTERNAL_FUNCTION_PARAMETERS, int mode)
{
 zval *IM;
 long SIZE, X, Y, COL;
 char *C;
 int C_len;
 gdImagePtr im;
 int ch = 0, col, x, y, size, i, l = 0;
 unsigned char *str = NULL;
 gdFontPtr font;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllsl", &IM, &SIZE, &X, &Y, &C, &C_len, &COL) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 col = COL;

 if (mode < 2) {
  ch = (int)((unsigned char)*C);
 } else {
  str = (unsigned char *) estrndup(C, C_len);
  l = strlen((char *)str);
 }

 y = Y;
 x = X;
 size = SIZE;

 font = php_find_gd_font(size TSRMLS_CC);

 switch (mode) {
  case 0:
   gdImageChar(im, font, x, y, ch, col);
   break;
  case 1:
   php_gdimagecharup(im, font, x, y, ch, col);
   break;
  case 2:
   for (i = 0; (i < l); i++) {
    gdImageChar(im, font, x, y, (int) ((unsigned char) str[i]), col);
    x += font->w;
   }
   break;
  case 3: {
   for (i = 0; (i < l); i++) {

    gdImageCharUp(im, font, x, y, (int) str[i], col);
    y -= font->w;
   }
   break;
  }
 }
 if (str) {
  efree(str);
 }
 RETURN_TRUE;
}




PHP_FUNCTION(imagechar)
{
 php_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}




PHP_FUNCTION(imagecharup)
{
 php_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}




PHP_FUNCTION(imagestring)
{
 php_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);
}




PHP_FUNCTION(imagestringup)
{
 php_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);
}




PHP_FUNCTION(imagecopy)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY;
 gdImagePtr im_dst, im_src;
 int srcH, srcW, srcY, srcX, dstY, dstX;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;

 gdImageCopy(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH);
 RETURN_TRUE;
}




PHP_FUNCTION(imagecopymerge)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY, PCT;
 gdImagePtr im_dst, im_src;
 int srcH, srcW, srcY, srcX, dstY, dstX, pct;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrlllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;
 pct = PCT;

 gdImageCopyMerge(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH, pct);
 RETURN_TRUE;
}




PHP_FUNCTION(imagecopymergegray)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY, PCT;
 gdImagePtr im_dst, im_src;
 int srcH, srcW, srcY, srcX, dstY, dstX, pct;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrlllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;
 pct = PCT;

 gdImageCopyMergeGray(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH, pct);
 RETURN_TRUE;
}




PHP_FUNCTION(imagecopyresized)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY, DW, DH;
 gdImagePtr im_dst, im_src;
 int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrllllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;
 dstH = DH;
 dstW = DW;

 if (dstW <= 0 || dstH <= 0 || srcW <= 0 || srcH <= 0) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid image dimensions");
  RETURN_FALSE;
 }

 gdImageCopyResized(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);
 RETURN_TRUE;
}




PHP_FUNCTION(imagesx)
{
 zval *IM;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageSX(im));
}




PHP_FUNCTION(imagesy)
{
 zval *IM;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageSY(im));
}

PHP_FUNCTION(image2wbmp)
{
 _php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_CONVERT_WBM, "WBMP", _php_image_bw_convert);
}

static void _php_image_bw_convert(gdImagePtr im_org, gdIOCtx *out, int threshold)
{
 gdImagePtr im_dest;
 int white, black;
 int color, color_org, median;
 int dest_height = gdImageSY(im_org);
 int dest_width = gdImageSX(im_org);
 int x, y;
 TSRMLS_FETCH();

 im_dest = gdImageCreate(dest_width, dest_height);
 if (im_dest == NULL) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate temporary buffer");
  return;
 }

 white = gdImageColorAllocate(im_dest, 255, 255, 255);
 if (white == -1) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate the colors for the destination buffer");
  return;
 }

 black = gdImageColorAllocate(im_dest, 0, 0, 0);
 if (black == -1) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate the colors for the destination buffer");
  return;
 }

 if (im_org->trueColor) {
  gdImageTrueColorToPalette(im_org, 1, 256);
 }

 for (y = 0; y < dest_height; y++) {
  for (x = 0; x < dest_width; x++) {
   color_org = gdImageGetPixel(im_org, x, y);
   median = (im_org->red[color_org] + im_org->green[color_org] + im_org->blue[color_org]) / 3;
   if (median < threshold) {
    color = black;
   } else {
    color = white;
   }
   gdImageSetPixel (im_dest, x, y, color);
  }
 }
 gdImageWBMPCtx (im_dest, black, out);

}




static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )
{
 char *f_org, *f_dest;
 int f_org_len, f_dest_len;
 long height, width, threshold;
 gdImagePtr im_org, im_dest, im_tmp;
 char *fn_org = NULL;
 char *fn_dest = NULL;
 FILE *org, *dest;
 int dest_height = -1;
 int dest_width = -1;
 int org_height, org_width;
 int white, black;
 int color, color_org, median;
 int int_threshold;
 int x, y;
 float x_ratio, y_ratio;
    long ignore_warning;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "pplll", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {
  return;
 }

 fn_org = f_org;
 fn_dest = f_dest;
 dest_height = height;
 dest_width = width;
 int_threshold = threshold;


 if (int_threshold < 0 || int_threshold > 8) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid threshold value '%d'", int_threshold);
  RETURN_FALSE;
 }


 PHP_GD_CHECK_OPEN_BASEDIR(fn_org, "Invalid origin filename");


 PHP_GD_CHECK_OPEN_BASEDIR(fn_dest, "Invalid destination filename");


 org = VCWD_FOPEN(fn_org, "rb");
 if (!org) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' for reading", fn_org);
  RETURN_FALSE;
 }


 dest = VCWD_FOPEN(fn_dest, "wb");
 if (!dest) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' for writing", fn_dest);
  RETURN_FALSE;
 }

 switch (image_type) {
  case PHP_GDIMG_TYPE_GIF:
   im_org = gdImageCreateFromGif(org);
   if (im_org == NULL) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' Not a valid GIF file", fn_dest);
    RETURN_FALSE;
   }
   break;

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Format not supported");
   RETURN_FALSE;
   break;
 }

 org_width = gdImageSX (im_org);
 org_height = gdImageSY (im_org);

 x_ratio = (float) org_width / (float) dest_width;
 y_ratio = (float) org_height / (float) dest_height;

 if (x_ratio > 1 && y_ratio > 1) {
  if (y_ratio > x_ratio) {
   x_ratio = y_ratio;
  } else {
   y_ratio = x_ratio;
  }
  dest_width = (int) (org_width / x_ratio);
  dest_height = (int) (org_height / y_ratio);
 } else {
  x_ratio = (float) dest_width / (float) org_width;
  y_ratio = (float) dest_height / (float) org_height;

  if (y_ratio < x_ratio) {
   x_ratio = y_ratio;
  } else {
   y_ratio = x_ratio;
  }
  dest_width = (int) (org_width * x_ratio);
  dest_height = (int) (org_height * y_ratio);
 }

 im_tmp = gdImageCreate (dest_width, dest_height);
 if (im_tmp == NULL ) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate temporary buffer");
  RETURN_FALSE;
 }

 gdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);

 gdImageDestroy(im_org);

 fclose(org);

 im_dest = gdImageCreate(dest_width, dest_height);
 if (im_dest == NULL) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate destination buffer");
  RETURN_FALSE;
 }

 white = gdImageColorAllocate(im_dest, 255, 255, 255);
 if (white == -1) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate the colors for the destination buffer");
  RETURN_FALSE;
 }

 black = gdImageColorAllocate(im_dest, 0, 0, 0);
 if (black == -1) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate the colors for the destination buffer");
  RETURN_FALSE;
 }

 int_threshold = int_threshold * 32;

 for (y = 0; y < dest_height; y++) {
  for (x = 0; x < dest_width; x++) {
   color_org = gdImageGetPixel (im_tmp, x, y);
   median = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;
   if (median < int_threshold) {
    color = black;
   } else {
    color = white;
   }
   gdImageSetPixel (im_dest, x, y, color);
  }
 }

 gdImageDestroy (im_tmp );

 gdImageWBMP(im_dest, black , dest);

 fflush(dest);
 fclose(dest);

 gdImageDestroy(im_dest);

 RETURN_TRUE;
}

static void php_image_filter_negate(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr im_src; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd); if (im_src == NULL) { RETURN_FALSE; }

 if (gdImageNegate(im_src) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_grayscale(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr im_src; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd); if (im_src == NULL) { RETURN_FALSE; }

 if (gdImageGrayScale(im_src) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_brightness(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM;
 gdImagePtr im_src;
 long brightness, tmp;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zll", &SIM, &tmp, &brightness) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);

 if (im_src == NULL) {
  RETURN_FALSE;
 }

 if (gdImageBrightness(im_src, (int)brightness) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_contrast(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM;
 gdImagePtr im_src;
 long contrast, tmp;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rll", &SIM, &tmp, &contrast) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);

 if (im_src == NULL) {
  RETURN_FALSE;
 }

 if (gdImageContrast(im_src, (int)contrast) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_colorize(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM;
 gdImagePtr im_src;
 long r,g,b,tmp;
 long a = 0;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll|l", &SIM, &tmp, &r, &g, &b, &a) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);

 if (im_src == NULL) {
  RETURN_FALSE;
 }

 if (gdImageColor(im_src, (int) r, (int) g, (int) b, (int) a) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_edgedetect(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr im_src; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd); if (im_src == NULL) { RETURN_FALSE; }

 if (gdImageEdgeDetectQuick(im_src) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_emboss(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr im_src; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd); if (im_src == NULL) { RETURN_FALSE; }

 if (gdImageEmboss(im_src) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_gaussian_blur(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr im_src; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd); if (im_src == NULL) { RETURN_FALSE; }

 if (gdImageGaussianBlur(im_src) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_selective_blur(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr im_src; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd); if (im_src == NULL) { RETURN_FALSE; }

 if (gdImageSelectiveBlur(im_src) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_mean_removal(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr im_src; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd); if (im_src == NULL) { RETURN_FALSE; }

 if (gdImageMeanRemoval(im_src) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_smooth(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM;
 long tmp;
 gdImagePtr im_src;
 double weight;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rld", &SIM, &tmp, &weight) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);

 if (im_src == NULL) {
  RETURN_FALSE;
 }

 if (gdImageSmooth(im_src, (float)weight)==1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void php_image_filter_pixelate(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *IM;
 gdImagePtr im;
 long tmp, blocksize;
 zend_bool mode = 0;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rll|b", &IM, &tmp, &blocksize, &mode) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (im == NULL) {
  RETURN_FALSE;
 }

 if (gdImagePixelate(im, (int) blocksize, (const unsigned int) mode)) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}



PHP_FUNCTION(imagefilter)
{
 zval *tmp;

 typedef void (*image_filter)(INTERNAL_FUNCTION_PARAMETERS);
 long filtertype;
 image_filter filters[] =
 {
  php_image_filter_negate ,
  php_image_filter_grayscale,
  php_image_filter_brightness,
  php_image_filter_contrast,
  php_image_filter_colorize,
  php_image_filter_edgedetect,
  php_image_filter_emboss,
  php_image_filter_gaussian_blur,
  php_image_filter_selective_blur,
  php_image_filter_mean_removal,
  php_image_filter_smooth,
  php_image_filter_pixelate
 };

 if (ZEND_NUM_ARGS() < 2 || ZEND_NUM_ARGS() > 6) {
  WRONG_PARAM_COUNT;
 } else if (zend_parse_parameters(2 TSRMLS_CC, "rl", &tmp, &filtertype) == FAILURE) {
  return;
 }

 if (filtertype >= 0 && filtertype <= 11) {
  filters[filtertype](INTERNAL_FUNCTION_PARAM_PASSTHRU);
 }
}




PHP_FUNCTION(imageconvolution)
{
 zval *SIM, *hash_matrix;
 zval **var = NULL, **var2 = NULL;
 gdImagePtr im_src = NULL;
 double div, offset;
 int nelem, i, j, res;
 float matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "radd", &SIM, &hash_matrix, &div, &offset) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, "Image", le_gd);

 nelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));
 if (nelem != 3) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must have 3x3 array");
  RETURN_FALSE;
 }

 for (i=0; i<3; i++) {
  if (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {
   if (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must have 3x3 array");
    RETURN_FALSE;
   }

   for (j=0; j<3; j++) {
    if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {
     if (Z_TYPE_PP(var2) != IS_DOUBLE) {
      zval dval;
      dval = **var2;
      zval_copy_ctor(&dval);
      convert_to_double(&dval);
      matrix[i][j] = (float)Z_DVAL(dval);
     } else {
      matrix[i][j] = (float)Z_DVAL_PP(var2);
     }
    } else {
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must have a 3x3 matrix");
     RETURN_FALSE;
    }
   }
  }
 }
 res = gdImageConvolution(im_src, matrix, (float)div, (float)offset);

 if (res) {
  RETURN_TRUE;
 } else {
  RETURN_FALSE;
 }
}





PHP_FUNCTION(imageflip)
{
 zval *IM;
 long mode;
 gdImagePtr im;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &mode) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 switch (mode) {
  case GD_FLIP_VERTICAL:
   gdImageFlipVertical(im);
   break;

  case GD_FLIP_HORINZONTAL:
   gdImageFlipHorizontal(im);
   break;

  case GD_FLIP_BOTH:
   gdImageFlipBoth(im);
   break;

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown flip mode");
   RETURN_FALSE;
 }

 RETURN_TRUE;
}

PHP_FUNCTION(imagecrop)
{
 zval *IM;
 gdImagePtr im;
 gdImagePtr im_crop;
 gdRect rect;
 zval *z_rect;
 zval **tmp;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ra", &IM, &z_rect) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (zend_hash_find(HASH_OF(z_rect), "x", sizeof("x"), (void **)&tmp) != FAILURE) {
  if (Z_TYPE_PP(tmp) != IS_LONG) {
   zval lval;
   lval = **tmp;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   rect.x = Z_LVAL(lval);
  } else {
   rect.x = Z_LVAL_PP(tmp);
  }
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing x position");
  RETURN_FALSE;
 }

 if (zend_hash_find(HASH_OF(z_rect), "y", sizeof("x"), (void **)&tmp) != FAILURE) {
  if (Z_TYPE_PP(tmp) != IS_LONG) {
   zval lval;
   lval = **tmp;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   rect.y = Z_LVAL(lval);
  } else {
   rect.y = Z_LVAL_PP(tmp);
  }
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing y position");
  RETURN_FALSE;
 }

 if (zend_hash_find(HASH_OF(z_rect), "width", sizeof("width"), (void **)&tmp) != FAILURE) {
  if (Z_TYPE_PP(tmp) != IS_LONG) {
   zval lval;
   lval = **tmp;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   rect.width = Z_LVAL(lval);
  } else {
   rect.width = Z_LVAL_PP(tmp);
  }
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing width");
  RETURN_FALSE;
 }

 if (zend_hash_find(HASH_OF(z_rect), "height", sizeof("height"), (void **)&tmp) != FAILURE) {
  if (Z_TYPE_PP(tmp) != IS_LONG) {
   zval lval;
   lval = **tmp;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   rect.height = Z_LVAL(lval);
  } else {
   rect.height = Z_LVAL_PP(tmp);
  }
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing height");
  RETURN_FALSE;
 }

 im_crop = gdImageCrop(im, &rect);

 if (im_crop == NULL) {
  RETURN_FALSE;
 } else {
  ZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);
 }
}




PHP_FUNCTION(imagecropauto)
{
 zval *IM;
 long mode = -1;
 long color = -1;
 double threshold = 0.5f;
 gdImagePtr im;
 gdImagePtr im_crop;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r|ldl", &IM, &mode, &threshold, &color) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 switch (mode) {
  case -1:
   mode = GD_CROP_DEFAULT;
  case GD_CROP_DEFAULT:
  case GD_CROP_TRANSPARENT:
  case GD_CROP_BLACK:
  case GD_CROP_WHITE:
  case GD_CROP_SIDES:
   im_crop = gdImageCropAuto(im, mode);
   break;

  case GD_CROP_THRESHOLD:
   if (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Color argument missing with threshold mode");
    RETURN_FALSE;
   }
   im_crop = gdImageCropThreshold(im, color, (float) threshold);
   break;

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown crop mode");
   RETURN_FALSE;
 }
 if (im_crop == NULL) {
  RETURN_FALSE;
 } else {
  ZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);
 }
}




PHP_FUNCTION(imagescale)
{
 zval *IM;
 gdImagePtr im;
 gdImagePtr im_scaled = NULL;
 int new_width, new_height;
 long tmp_w, tmp_h=-1, tmp_m = GD_BILINEAR_FIXED;
 gdInterpolationMethod method;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl|ll", &IM, &tmp_w, &tmp_h, &tmp_m) == FAILURE) {
  return;
 }
 method = tmp_m;

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (tmp_h < 0) {

  long src_x, src_y;

  src_x = gdImageSX(im);
  src_y = gdImageSY(im);
  if (src_x) {
   tmp_h = tmp_w * src_y / src_x;
  }
 }

 if (tmp_h <= 0 || tmp_w <= 0) {
  RETURN_FALSE;
 }

 new_width = tmp_w;
 new_height = tmp_h;

 if (gdImageSetInterpolationMethod(im, method)) {
  im_scaled = gdImageScale(im, new_width, new_height);
 }

 if (im_scaled == NULL) {
  RETURN_FALSE;
 } else {
  ZEND_REGISTER_RESOURCE(return_value, im_scaled, le_gd);
 }
}




PHP_FUNCTION(imageaffine)
{
 zval *IM;
 gdImagePtr src;
 gdImagePtr dst;
 gdRect rect;
 gdRectPtr pRect = NULL;
 zval *z_rect = NULL;
 zval *z_affine;
 zval **tmp;
 double affine[6];
 int i, nelems;
 zval **zval_affine_elem = NULL;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ra|a", &IM, &z_affine, &z_rect) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(src, gdImagePtr, &IM, -1, "Image", le_gd);

 if ((nelems = zend_hash_num_elements(Z_ARRVAL_P(z_affine))) != 6) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Affine array must have six elements");
  RETURN_FALSE;
 }

 for (i = 0; i < nelems; i++) {
  if (zend_hash_index_find(Z_ARRVAL_P(z_affine), i, (void **) &zval_affine_elem) == SUCCESS) {
   switch (Z_TYPE_PP(zval_affine_elem)) {
    case IS_LONG:
     affine[i] = Z_LVAL_PP(zval_affine_elem);
     break;
    case IS_DOUBLE:
     affine[i] = Z_DVAL_PP(zval_affine_elem);
     break;
    case IS_STRING:
     {
      zval dval;
      dval = **zval_affine_elem;
      zval_copy_ctor(&dval);
      convert_to_double(&dval);
      affine[i] = Z_DVAL(dval);
     }
     break;
    default:
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type for element %i", i);
     RETURN_FALSE;
   }
  }
 }

 if (z_rect != NULL) {
  if (zend_hash_find(HASH_OF(z_rect), "x", sizeof("x"), (void **)&tmp) != FAILURE) {
   if (Z_TYPE_PP(tmp) != IS_LONG) {
    zval lval;
    lval = **tmp;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    rect.x = Z_LVAL(lval);
   } else {
    rect.x = Z_LVAL_PP(tmp);
   }
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing x position");
   RETURN_FALSE;
  }

  if (zend_hash_find(HASH_OF(z_rect), "y", sizeof("x"), (void **)&tmp) != FAILURE) {
   if (Z_TYPE_PP(tmp) != IS_LONG) {
    zval lval;
    lval = **tmp;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    rect.y = Z_LVAL(lval);
   } else {
    rect.y = Z_LVAL_PP(tmp);
   }
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing y position");
   RETURN_FALSE;
  }

  if (zend_hash_find(HASH_OF(z_rect), "width", sizeof("width"), (void **)&tmp) != FAILURE) {
   if (Z_TYPE_PP(tmp) != IS_LONG) {
    zval lval;
    lval = **tmp;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    rect.width = Z_LVAL(lval);
   } else {
    rect.width = Z_LVAL_PP(tmp);
   }
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing width");
   RETURN_FALSE;
  }

  if (zend_hash_find(HASH_OF(z_rect), "height", sizeof("height"), (void **)&tmp) != FAILURE) {
   if (Z_TYPE_PP(tmp) != IS_LONG) {
    zval lval;
    lval = **tmp;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    rect.height = Z_LVAL(lval);
   } else {
    rect.height = Z_LVAL_PP(tmp);
   }
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing height");
   RETURN_FALSE;
  }
  pRect = &rect;
 } else {
  rect.x = -1;
  rect.y = -1;
  rect.width = gdImageSX(src);
  rect.height = gdImageSY(src);
  pRect = NULL;
 }

 if (gdTransformAffineGetImage(&dst, src, pRect, affine) != GD_TRUE) {
  RETURN_FALSE;
 }

 if (dst == NULL) {
  RETURN_FALSE;
 } else {
  ZEND_REGISTER_RESOURCE(return_value, dst, le_gd);
 }
}




PHP_FUNCTION(imageaffinematrixget)
{
 double affine[6];
 long type;
 zval *options = NULL;
 zval **tmp;
 int res = GD_FALSE, i;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|z", &type, &options) == FAILURE) {
  return;
 }

 switch((gdAffineStandardMatrix)type) {
  case GD_AFFINE_TRANSLATE:
  case GD_AFFINE_SCALE: {
   double x, y;
   if (!options || Z_TYPE_P(options) != IS_ARRAY) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Array expected as options");
    RETURN_FALSE;
   }
   if (zend_hash_find(HASH_OF(options), "x", sizeof("x"), (void **)&tmp) != FAILURE) {
    if (Z_TYPE_PP(tmp) != IS_DOUBLE) {
     zval dval;
     dval = **tmp;
     zval_copy_ctor(&dval);
     convert_to_double(&dval);
     x = Z_DVAL(dval);
    } else {
     x = Z_DVAL_PP(tmp);
    }
   } else {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing x position");
    RETURN_FALSE;
   }

   if (zend_hash_find(HASH_OF(options), "y", sizeof("y"), (void **)&tmp) != FAILURE) {
    if (Z_TYPE_PP(tmp) != IS_DOUBLE) {
     zval dval;
     dval = **tmp;
     zval_copy_ctor(&dval);
     convert_to_double(&dval);
     y = Z_DVAL(dval);
    } else {
     y = Z_DVAL_PP(tmp);
    }
   } else {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing y position");
    RETURN_FALSE;
   }

   if (type == GD_AFFINE_TRANSLATE) {
    res = gdAffineTranslate(affine, x, y);
   } else {
    res = gdAffineScale(affine, x, y);
   }
   break;
  }

  case GD_AFFINE_ROTATE:
  case GD_AFFINE_SHEAR_HORIZONTAL:
  case GD_AFFINE_SHEAR_VERTICAL: {
   double angle;

   if (!options) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number is expected as option");
    RETURN_FALSE;
   }
   if(Z_TYPE_P(options) != IS_DOUBLE) {
    zval dval;
    dval = *options;
    zval_copy_ctor(&dval);
    convert_to_double(&dval);
    angle = Z_DVAL(dval);
   } else {
    angle = Z_DVAL_P(options);
   }

   if (type == GD_AFFINE_SHEAR_HORIZONTAL) {
    res = gdAffineShearHorizontal(affine, angle);
   } else if (type == GD_AFFINE_SHEAR_VERTICAL) {
    res = gdAffineShearVertical(affine, angle);
   } else {
    res = gdAffineRotate(affine, angle);
   }
   break;
  }

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type for element %li", type);
   RETURN_FALSE;
 }

 if (res == GD_FALSE) {
  RETURN_FALSE;
 } else {
  array_init(return_value);
  for (i = 0; i < 6; i++) {
   add_index_double(return_value, i, affine[i]);
  }
 }
}




PHP_FUNCTION(imageaffinematrixconcat)
{
 double m1[6];
 double m2[6];
 double mr[6];

 zval **tmp;
 zval *z_m1;
 zval *z_m2;
 int i, nelems;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "aa", &z_m1, &z_m2) == FAILURE) {
  return;
 }

 if (((nelems = zend_hash_num_elements(Z_ARRVAL_P(z_m1))) != 6) || (nelems = zend_hash_num_elements(Z_ARRVAL_P(z_m2))) != 6) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Affine arrays must have six elements");
  RETURN_FALSE;
 }

 for (i = 0; i < 6; i++) {
  if (zend_hash_index_find(Z_ARRVAL_P(z_m1), i, (void **) &tmp) == SUCCESS) {
   switch (Z_TYPE_PP(tmp)) {
    case IS_LONG:
     m1[i] = Z_LVAL_PP(tmp);
     break;
    case IS_DOUBLE:
     m1[i] = Z_DVAL_PP(tmp);
     break;
    case IS_STRING:
     {
      zval dval;
      dval = **tmp;
      zval_copy_ctor(&dval);
      convert_to_double(&dval);
      m1[i] = Z_DVAL(dval);
     }
     break;
    default:
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type for element %i", i);
     RETURN_FALSE;
   }
  }
  if (zend_hash_index_find(Z_ARRVAL_P(z_m2), i, (void **) &tmp) == SUCCESS) {
   switch (Z_TYPE_PP(tmp)) {
    case IS_LONG:
     m2[i] = Z_LVAL_PP(tmp);
     break;
    case IS_DOUBLE:
     m2[i] = Z_DVAL_PP(tmp);
     break;
    case IS_STRING:
     {
      zval dval;
      dval = **tmp;
      zval_copy_ctor(&dval);
      convert_to_double(&dval);
      m2[i] = Z_DVAL(dval);
     }
     break;
    default:
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type for element %i", i);
     RETURN_FALSE;
   }
  }
 }

 if (gdAffineConcat (mr, m1, m2) != GD_TRUE) {
  RETURN_FALSE;
 }

 array_init(return_value);
 for (i = 0; i < 6; i++) {
  add_index_double(return_value, i, mr[i]);
 }
}



PHP_FUNCTION(imagesetinterpolation)
{
 zval *IM;
 gdImagePtr im;
 long method = GD_BILINEAR_FIXED;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r|l", &IM, &method) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, "Image", le_gd);

 if (method == -1) {
   method = GD_BILINEAR_FIXED;
 }
 RETURN_BOOL(gdImageSetInterpolationMethod(im, (gdInterpolationMethod) method));
}
