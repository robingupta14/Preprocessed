







static int iw_imgtype_alpha_channel_index(int t)
{
 switch(t) {
 case IW_IMGTYPE_RGBA:
  return 3;
 case IW_IMGTYPE_GRAYA:
  return 1;
 }
 return 0;
}

static IW_INLINE iw_tmpsample srgb_to_linear_sample(iw_tmpsample v_srgb)
{
 if(v_srgb<=0.04045) {
  return v_srgb/12.92;
 }
 else {
  return pow( (v_srgb+0.055)/(1.055) , 2.4);
 }
}

static IW_INLINE iw_tmpsample rec709_to_linear_sample(iw_tmpsample v_rec709)
{
 if(v_rec709 < 4.5*0.020) {
  return v_rec709/4.5;
 }
 else {
  return pow( (v_rec709+0.099)/1.099 , 1.0/0.45);
 }
}

static IW_INLINE iw_tmpsample gamma_to_linear_sample(iw_tmpsample v, double gamma)
{
 return pow(v,gamma);
}

static iw_tmpsample x_to_linear_sample(iw_tmpsample v, const struct iw_csdescr *csdescr)
{
 switch(csdescr->cstype) {
 case IW_CSTYPE_SRGB:
  return srgb_to_linear_sample(v);
 case IW_CSTYPE_LINEAR:
  return v;
 case IW_CSTYPE_GAMMA:
  return gamma_to_linear_sample(v,csdescr->gamma);
 case IW_CSTYPE_REC709:
  return rec709_to_linear_sample(v);
 }
 return srgb_to_linear_sample(v);
}


IW_IMPL(double) iw_convert_sample_to_linear(double v, const struct iw_csdescr *csdescr)
{
 return (double)x_to_linear_sample(v,csdescr);
}

static IW_INLINE iw_tmpsample linear_to_srgb_sample(iw_tmpsample v_linear)
{
 if(v_linear <= 0.0031308) {
  return 12.92*v_linear;
 }
 return 1.055*pow(v_linear,1.0/2.4) - 0.055;
}

static IW_INLINE iw_tmpsample linear_to_rec709_sample(iw_tmpsample v_linear)
{



 if(v_linear < 0.020) {
  return 4.5*v_linear;
 }
 return 1.099*pow(v_linear,0.45) - 0.099;
}

static IW_INLINE iw_tmpsample linear_to_gamma_sample(iw_tmpsample v_linear, double gamma)
{
 return pow(v_linear,1.0/gamma);
}

static iw_float32 iw_get_float32(const iw_byte *m)
{
 int k;

 union su_union {
  iw_byte c[4];
  iw_float32 f;
 } volatile su;

 for(k=0;k<4;k++) {
  su.c[k] = m[k];
 }
 return su.f;
}

static void iw_put_float32(iw_byte *m, iw_float32 s)
{
 int k;

 union su_union {
  iw_byte c[4];
  iw_float32 f;
 } volatile su;

 su.f = s;

 for(k=0;k<4;k++) {
  m[k] = su.c[k];
 }
}

static iw_tmpsample get_raw_sample_flt32(struct iw_context *ctx,
    int x, int y, int channel)
{
 size_t z;
 z = y*ctx->img1.bpr + (ctx->img1_numchannels_physical*x + channel)*4;
 return (iw_tmpsample)iw_get_float32(&ctx->img1.pixels[z]);
}

static IW_INLINE unsigned int get_raw_sample_16(struct iw_context *ctx,
    int x, int y, int channel)
{
 size_t z;
 unsigned short tmpui16;
 z = y*ctx->img1.bpr + (ctx->img1_numchannels_physical*x + channel)*2;
 tmpui16 = ( ((unsigned short)(ctx->img1.pixels[z+0])) <<8) | ctx->img1.pixels[z+1];
 return tmpui16;
}

static IW_INLINE unsigned int get_raw_sample_8(struct iw_context *ctx,
    int x, int y, int channel)
{
 unsigned short tmpui8;
 tmpui8 = ctx->img1.pixels[y*ctx->img1.bpr + ctx->img1_numchannels_physical*x + channel];
 return tmpui8;
}


static IW_INLINE unsigned int get_raw_sample_4(struct iw_context *ctx,
    int x, int y)
{
 unsigned short tmpui8;
 tmpui8 = ctx->img1.pixels[y*ctx->img1.bpr + x/2];
 if(x&0x1)
  tmpui8 = tmpui8&0x0f;
 else
  tmpui8 = tmpui8>>4;
 return tmpui8;
}


static IW_INLINE unsigned int get_raw_sample_2(struct iw_context *ctx,
    int x, int y)
{
 unsigned short tmpui8;
 tmpui8 = ctx->img1.pixels[y*ctx->img1.bpr + x/4];
 tmpui8 = ( tmpui8 >> ((3-x%4)*2) ) & 0x03;
 return tmpui8;
}


static IW_INLINE unsigned int get_raw_sample_1(struct iw_context *ctx,
    int x, int y)
{
 unsigned short tmpui8;
 tmpui8 = ctx->img1.pixels[y*ctx->img1.bpr + x/8];
 if(tmpui8 & (1<<(7-x%8))) return 1;
 return 0;
}


static IW_INLINE void translate_coords(struct iw_context *ctx,
 int x, int y, int *prx, int *pry)
{
 if(ctx->img1.orient_transform==0) {

  *prx = ctx->input_start_x+x;
  *pry = ctx->input_start_y+y;
  return;
 }

 switch(ctx->img1.orient_transform) {
 case 1:
  *prx = ctx->img1.width - 1 - (ctx->input_start_x+x);
  *pry = ctx->input_start_y+y;
  break;
 case 2:
  *prx = ctx->input_start_x+x;
  *pry = ctx->img1.height - 1 - (ctx->input_start_y+y);
  break;
 case 3:
  *prx = ctx->img1.width - 1 - (ctx->input_start_x+x);
  *pry = ctx->img1.height - 1 - (ctx->input_start_y+y);
  break;
 case 4:

  *prx = ctx->input_start_y+y;
  *pry = ctx->input_start_x+x;
  break;
 case 5:
  *prx = ctx->input_start_y+y;
  *pry = ctx->img1.width - 1 - (ctx->input_start_x+x);
  break;
 case 6:
  *prx = ctx->img1.height - 1 - (ctx->input_start_y+y);
  *pry = ctx->input_start_x+x;
  break;
 case 7:
  *prx = ctx->img1.height - 1 - (ctx->input_start_y+y);
  *pry = ctx->img1.width - 1 - (ctx->input_start_x+x);
  break;
 default:
  *prx = 0;
  *pry = 0;
  break;
 }
}



static unsigned int get_raw_sample_int(struct iw_context *ctx,
    int x, int y, int channel)
{
 int rx,ry;

 translate_coords(ctx,x,y,&rx,&ry);

 switch(ctx->img1.bit_depth) {
 case 8: return get_raw_sample_8(ctx,rx,ry,channel);
 case 1: return get_raw_sample_1(ctx,rx,ry);
 case 16: return get_raw_sample_16(ctx,rx,ry,channel);
 case 4: return get_raw_sample_4(ctx,rx,ry);
 case 2: return get_raw_sample_2(ctx,rx,ry);
 }
 return 0;
}



static iw_tmpsample get_raw_sample(struct iw_context *ctx,
    int x, int y, int channel)
{
 unsigned int v;

 if(channel>=ctx->img1_numchannels_physical) {

  return 1.0;
 }

 if(ctx->img1.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
  int rx, ry;
  translate_coords(ctx,x,y,&rx,&ry);
  if(ctx->img1.bit_depth!=32) return 0.0;
  return get_raw_sample_flt32(ctx,rx,ry,channel);
 }

 v = get_raw_sample_int(ctx,x,y,channel);
 return ((double)v) / ctx->img1_ci[channel].maxcolorcode_dbl;
}

static iw_tmpsample iw_color_to_grayscale(struct iw_context *ctx,
 iw_tmpsample r, iw_tmpsample g, iw_tmpsample b)
{
 iw_tmpsample v0,v1,v2;

 switch(ctx->grayscale_formula) {
 case IW_GSF_WEIGHTED:
  return ctx->grayscale_weight[0]*r +
   ctx->grayscale_weight[1]*g +
   ctx->grayscale_weight[2]*b;
 case IW_GSF_ORDERBYVALUE:

  if(g<=r) { v0=r; v1=g; }
  else { v0=g; v1=r; }
  if(b<=v1) {
   v2=b;
  }
  else {
   v2=v1;
   if(b<=v0) { v1=b; }
   else { v1=v0; v0=b; }
  }
  return ctx->grayscale_weight[0]*v0 +
   ctx->grayscale_weight[1]*v1 +
   ctx->grayscale_weight[2]*v2;
 }
 return 0.0;
}



static iw_tmpsample cvt_int_sample_to_linear(struct iw_context *ctx,
 unsigned int v, const struct iw_csdescr *csdescr)
{
 iw_tmpsample s;

 if(csdescr->cstype==IW_CSTYPE_LINEAR) {



  return ((double)v) / ctx->input_maxcolorcode;
 }
 else if(ctx->input_color_corr_table) {

  return ctx->input_color_corr_table[v];
 }

 s = ((double)v) / ctx->input_maxcolorcode;
 return x_to_linear_sample(s,csdescr);
}


static iw_tmpsample cvt_int_sample_to_linear_output(struct iw_context *ctx,
 unsigned int v, const struct iw_csdescr *csdescr, double overall_maxcolorcode)
{
 iw_tmpsample s;

 if(csdescr->cstype==IW_CSTYPE_LINEAR) {
  return ((double)v) / overall_maxcolorcode;
 }
 else if(ctx->output_rev_color_corr_table) {
  return ctx->output_rev_color_corr_table[v];
 }

 s = ((double)v) / overall_maxcolorcode;
 return x_to_linear_sample(s,csdescr);
}



static iw_tmpsample get_sample_cvt_to_linear(struct iw_context *ctx,
    int x, int y, int channel, const struct iw_csdescr *csdescr)
{
 unsigned int v1,v2,v3;
 iw_tmpsample r,g,b;
 int ch;

 ch = ctx->intermed_ci[channel].corresponding_input_channel;

 if(ctx->img1_ci[ch].disable_fast_get_sample) {

  if(ctx->intermed_ci[channel].cvt_to_grayscale) {
   r = x_to_linear_sample(get_raw_sample(ctx,x,y,ch+0),csdescr);
   g = x_to_linear_sample(get_raw_sample(ctx,x,y,ch+1),csdescr);
   b = x_to_linear_sample(get_raw_sample(ctx,x,y,ch+2),csdescr);
   return iw_color_to_grayscale(ctx,r,g,b);
  }
  return x_to_linear_sample(get_raw_sample(ctx,x,y,ch),csdescr);
 }




 if(ctx->intermed_ci[channel].cvt_to_grayscale) {
  v1 = get_raw_sample_int(ctx,x,y,ch+0);
  v2 = get_raw_sample_int(ctx,x,y,ch+1);
  v3 = get_raw_sample_int(ctx,x,y,ch+2);
  r = cvt_int_sample_to_linear(ctx,v1,csdescr);
  g = cvt_int_sample_to_linear(ctx,v2,csdescr);
  b = cvt_int_sample_to_linear(ctx,v3,csdescr);
  return iw_color_to_grayscale(ctx,r,g,b);
 }

 v1 = get_raw_sample_int(ctx,x,y,ch);
 return cvt_int_sample_to_linear(ctx,v1,csdescr);
}


static IW_INLINE void put_raw_sample_16(struct iw_context *ctx, double s,
    int x, int y, int channel)
{
 size_t z;
 unsigned short tmpui16;

 tmpui16 = (unsigned short)(0.5+s);
 z = y*ctx->img2.bpr + (ctx->img2_numchannels*x + channel)*2;
 ctx->img2.pixels[z+0] = (iw_byte)(tmpui16>>8);
 ctx->img2.pixels[z+1] = (iw_byte)(tmpui16&0xff);
}


static IW_INLINE void put_raw_sample_8(struct iw_context *ctx, double s,
    int x, int y, int channel)
{
 iw_byte tmpui8;

 tmpui8 = (iw_byte)(0.5+s);
 ctx->img2.pixels[y*ctx->img2.bpr + ctx->img2_numchannels*x + channel] = tmpui8;
}


static void put_raw_sample(struct iw_context *ctx, double s,
    int x, int y, int channel)
{
 switch(ctx->img2.bit_depth) {
 case 8: put_raw_sample_8(ctx,s,x,y,channel); break;
 case 16: put_raw_sample_16(ctx,s,x,y,channel); break;
 }
}


static void put_raw_sample_flt32(struct iw_context *ctx, double s,
    int x, int y, int channel)
{
 size_t pos;
 pos = y*ctx->img2.bpr + (ctx->img2_numchannels*x + channel)*4;
 iw_put_float32(&ctx->img2.pixels[pos], (iw_float32)s);
}

static iw_tmpsample linear_to_x_sample(iw_tmpsample samp_lin, const struct iw_csdescr *csdescr)
{
 if(samp_lin > 0.999999999) {


  return 1.0;
 }

 switch(csdescr->cstype) {
 case IW_CSTYPE_SRGB:
  return linear_to_srgb_sample(samp_lin);
 case IW_CSTYPE_LINEAR:
  return samp_lin;
 case IW_CSTYPE_GAMMA:
  return linear_to_gamma_sample(samp_lin,csdescr->gamma);
 case IW_CSTYPE_REC709:
  return linear_to_rec709_sample(samp_lin);
 }
 return linear_to_srgb_sample(samp_lin);
}


IW_IMPL(double) iw_convert_sample_from_linear(double v, const struct iw_csdescr *csdescr)
{
 return (double)linear_to_x_sample(v,csdescr);
}




static int iw_ordered_dither(int dithersubtype, double fraction, int x, int y)
{
 double threshold;
 static const float pattern[2][64] = {
  {
   0.5/64,48.5/64,12.5/64,60.5/64, 3.5/64,51.5/64,15.5/64,63.5/64,
  32.5/64,16.5/64,44.5/64,28.5/64,35.5/64,19.5/64,47.5/64,31.5/64,
   8.5/64,56.5/64, 4.5/64,52.5/64,11.5/64,59.5/64, 7.5/64,55.5/64,
  40.5/64,24.5/64,36.5/64,20.5/64,43.5/64,27.5/64,39.5/64,23.5/64,
   2.5/64,50.5/64,14.5/64,62.5/64, 1.5/64,49.5/64,13.5/64,61.5/64,
  34.5/64,18.5/64,46.5/64,30.5/64,33.5/64,17.5/64,45.5/64,29.5/64,
  10.5/64,58.5/64, 6.5/64,54.5/64, 9.5/64,57.5/64, 5.5/64,53.5/64,
  42.5/64,26.5/64,38.5/64,22.5/64,41.5/64,25.5/64,37.5/64,21.5/64
  },
  {
   3.5/64, 9.5/64,17.5/64,27.5/64,25.5/64,15.5/64, 7.5/64, 1.5/64,
  11.5/64,29.5/64,37.5/64,45.5/64,43.5/64,35.5/64,23.5/64, 5.5/64,
  19.5/64,39.5/64,51.5/64,57.5/64,55.5/64,49.5/64,33.5/64,13.5/64,
  31.5/64,47.5/64,59.5/64,63.5/64,61.5/64,53.5/64,41.5/64,21.5/64,
  30.5/64,46.5/64,58.5/64,62.5/64,60.5/64,52.5/64,40.5/64,20.5/64,
  18.5/64,38.5/64,50.5/64,56.5/64,54.5/64,48.5/64,32.5/64,12.5/64,
  10.5/64,28.5/64,36.5/64,44.5/64,42.5/64,34.5/64,22.5/64, 4.5/64,
   2.5/64, 8.5/64,16.5/64,26.5/64,24.5/64,14.5/64, 6.5/64, 0.5/64
  }};

 threshold = pattern[dithersubtype][(x%8) + 8*(y%8)];
 return (fraction >= threshold);
}


static int iw_random_dither(struct iw_context *ctx, double fraction, int x, int y,
 int dithersubtype, int channel)
{
 double threshold;

 threshold = ((double)iwpvt_prng_rand(ctx->prng)) / (double)0xffffffff;
 if(fraction>=threshold) return 1;
 return 0;
}

static void iw_errdiff_dither(struct iw_context *ctx,int dithersubtype,
 double err,int x,int y)
{
 int fwd;
 const double *m;





 static const double matrix_list[][12] = {
 { 7.0/16, 0.0,
    0.0 , 3.0/16, 5.0/16, 1.0/16, 0.0,
    0.0 , 0.0, 0.0, 0.0 , 0.0 },
 { 7.0/48, 5.0/48,
    3.0/48, 5.0/48, 7.0/48, 5.0/48, 3.0/48,
    1.0/48, 3.0/48, 5.0/48, 3.0/48, 1.0/48 },
 { 8.0/42, 4.0/42,
    2.0/42, 4.0/42, 8.0/42, 4.0/42, 2.0/42,
    1.0/42, 2.0/42, 4.0/42, 2.0/42, 1.0/42 },
 { 8.0/32, 4.0/32,
    2.0/32, 4.0/32, 8.0/32, 4.0/32, 2.0/32,
    0.0 , 0.0 , 0.0 , 0.0 , 0.0 },
 { 5.0/32, 3.0/32,
    2.0/32, 4.0/32, 5.0/32, 4.0/32, 2.0/32,
       0.0, 2.0/32, 3.0/32, 2.0/32, 0.0 },
 { 4.0/16, 3.0/16,
    1.0/16, 2.0/16, 3.0/16, 2.0/16, 1.0/16,
    0.0 , 0.0 , 0.0 , 0.0 , 0.0 },
 { 2.0/4 , 0.0,
    0.0 , 1.0/4 , 1.0/4 , 0.0 , 0.0,
    0.0 , 0.0 , 0.0 , 0.0 , 0.0 },
 { 1.0/8 , 1.0/8,
    0.0 , 1.0/8 , 1.0/8 , 1.0/8 , 0.0,
    0.0 , 0.0 , 1.0/8 , 0.0 , 0.0 }
 };

 if(dithersubtype<=7)
  m = matrix_list[dithersubtype];
 else
  m = matrix_list[0];

 fwd = (y%2)?-1:1;

 if((x-fwd)>=0 && (x-fwd)<ctx->img2.width) {
  if((x-2*fwd)>=0 && (x-2*fwd)<ctx->img2.width) {
   ctx->dither_errors[1][x-2*fwd] += err*(m[2]);
   ctx->dither_errors[2][x-2*fwd] += err*(m[7]);
  }
  ctx->dither_errors[1][x-fwd] += err*(m[3]);
  ctx->dither_errors[2][x-fwd] += err*(m[8]);
 }

 ctx->dither_errors[1][x] += err*(m[4]);
 ctx->dither_errors[2][x] += err*(m[9]);

 if((x+fwd)>=0 && (x+fwd)<ctx->img2.width) {
  ctx->dither_errors[0][x+fwd] += err*(m[0]);
  ctx->dither_errors[1][x+fwd] += err*(m[5]);
  ctx->dither_errors[2][x+fwd] += err*(m[10]);
  if((x+2*fwd)>=0 && (x+2*fwd)<ctx->img2.width) {
   ctx->dither_errors[0][x+2*fwd] += err*(m[1]);
   ctx->dither_errors[1][x+2*fwd] += err*(m[6]);
   ctx->dither_errors[2][x+2*fwd] += err*(m[11]);
  }
 }
}


static int get_nearest_valid_colors(struct iw_context *ctx, iw_tmpsample samp_lin,
  const struct iw_csdescr *csdescr,
  double *s_lin_floor_1, double *s_lin_ceil_1,
  double *s_cvt_floor_full, double *s_cvt_ceil_full,
  double overall_maxcolorcode, int color_count)
{
 iw_tmpsample samp_cvt;
 double samp_cvt_expanded;
 unsigned int floor_int, ceil_int;


 samp_cvt = linear_to_x_sample(samp_lin,csdescr);

 if(color_count==0) {

  samp_cvt_expanded = samp_cvt * overall_maxcolorcode;
  if(samp_cvt_expanded>overall_maxcolorcode) samp_cvt_expanded=overall_maxcolorcode;
  if(samp_cvt_expanded<0.0) samp_cvt_expanded=0.0;





  *s_cvt_floor_full = floor(samp_cvt_expanded);
  *s_cvt_ceil_full = ceil(samp_cvt_expanded);
 }
 else {

  double posterized_maxcolorcode;




  posterized_maxcolorcode = (double)(color_count-1);

  samp_cvt_expanded = samp_cvt * posterized_maxcolorcode;
  if(samp_cvt_expanded>posterized_maxcolorcode) samp_cvt_expanded=posterized_maxcolorcode;
  if(samp_cvt_expanded<0.0) samp_cvt_expanded=0.0;






  *s_cvt_floor_full = floor(0.5000000001 + floor(samp_cvt_expanded) * (overall_maxcolorcode/posterized_maxcolorcode));
  *s_cvt_ceil_full = floor(0.5000000001 + ceil (samp_cvt_expanded) * (overall_maxcolorcode/posterized_maxcolorcode));
 }

 floor_int = (unsigned int)(*s_cvt_floor_full);
 ceil_int = (unsigned int)(*s_cvt_ceil_full);
 if(floor_int == ceil_int) {
  return 1;
 }


 *s_lin_floor_1 = cvt_int_sample_to_linear_output(ctx,floor_int,csdescr,overall_maxcolorcode);
 *s_lin_ceil_1 = cvt_int_sample_to_linear_output(ctx,ceil_int ,csdescr,overall_maxcolorcode);

 return 0;
}


static void put_sample_convert_from_linear_flt(struct iw_context *ctx, iw_tmpsample samp_lin,
    int x, int y, int channel, const struct iw_csdescr *csdescr)
{
 put_raw_sample_flt32(ctx,(double)samp_lin,x,y,channel);
}

static double get_final_sample_using_nc_tbl(struct iw_context *ctx, iw_tmpsample samp_lin)
{
 unsigned int x;
 unsigned int d;






 x = 127;
 d = 64;

 while1 {
  if(x>254 || ctx->nearest_color_table[x] > samp_lin)
   x -= d;
  else
   x += d;

  if(d==1) {
   if(x>254 || ctx->nearest_color_table[x] > samp_lin)
    return (double)(x);
   else
    return (double)(x+1);
  }

  d = d/2;
 }
}


static void put_sample_convert_from_linear(struct iw_context *ctx, iw_tmpsample samp_lin,
    int x, int y, int channel, const struct iw_csdescr *csdescr)
{
 double s_lin_floor_1, s_lin_ceil_1;
 double s_cvt_floor_full, s_cvt_ceil_full;
 double d_floor, d_ceil;
 int is_exact;
 double s_full;
 int ditherfamily;
 int dd;





 if(samp_lin<0.0) samp_lin=0.0;
 if(samp_lin>1.0) samp_lin=1.0;

 if(ctx->img2_ci[channel].use_nearest_color_table) {
  s_full = get_final_sample_using_nc_tbl(ctx,samp_lin);
  goto okay;
 }

 ditherfamily=ctx->img2_ci[channel].ditherfamily;

 if(ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
  samp_lin += ctx->dither_errors[0][x];


  if(samp_lin>1.0) samp_lin=1.0;
  else if(samp_lin<0.0) samp_lin=0.0;
 }

 is_exact = get_nearest_valid_colors(ctx,samp_lin,csdescr,
  &s_lin_floor_1, &s_lin_ceil_1,
  &s_cvt_floor_full, &s_cvt_ceil_full,
  ctx->img2_ci[channel].maxcolorcode_dbl, ctx->img2_ci[channel].color_count);

 if(is_exact) {
  s_full = s_cvt_floor_full;



  if(ditherfamily==IW_DITHERFAMILY_RANDOM) {
   (void)iwpvt_prng_rand(ctx->prng);
  }
  goto okay;
 }




 d_floor = samp_lin-s_lin_floor_1;
 d_ceil = s_lin_ceil_1-samp_lin;

 if(ditherfamily==IW_DITHERFAMILY_NONE) {

  if(d_ceil<=d_floor) s_full=s_cvt_ceil_full;
  else s_full=s_cvt_floor_full;
 }
 else if(ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
  if(d_ceil<=d_floor) {


   iw_errdiff_dither(ctx,ctx->img2_ci[channel].dithersubtype,-d_ceil,x,y);
   s_full=s_cvt_ceil_full;
  }
  else {
   iw_errdiff_dither(ctx,ctx->img2_ci[channel].dithersubtype,d_floor,x,y);
   s_full=s_cvt_floor_full;
  }
 }
 else if(ditherfamily==IW_DITHERFAMILY_ORDERED) {
  dd=iw_ordered_dither(ctx->img2_ci[channel].dithersubtype, d_floor/(d_floor+d_ceil),x,y);
  s_full = dd ? s_cvt_ceil_full : s_cvt_floor_full;
 }
 else if(ditherfamily==IW_DITHERFAMILY_RANDOM) {
  dd=iw_random_dither(ctx,d_floor/(d_floor+d_ceil),x,y,ctx->img2_ci[channel].dithersubtype,channel);
  s_full = dd ? s_cvt_ceil_full : s_cvt_floor_full;
 }
 else {

  s_full = 0.0;
 }

okay:
 put_raw_sample(ctx,s_full,x,y,channel);
}



static unsigned int calc_sample_convert_from_linear(struct iw_context *ctx, iw_tmpsample samp_lin,
    const struct iw_csdescr *csdescr, double overall_maxcolorcode)
{
 double s_lin_floor_1, s_lin_ceil_1;
 double s_cvt_floor_full, s_cvt_ceil_full;
 double d_floor, d_ceil;
 int is_exact;
 double s_full;

 if(samp_lin<0.0) samp_lin=0.0;
 if(samp_lin>1.0) samp_lin=1.0;

 is_exact = get_nearest_valid_colors(ctx,samp_lin,csdescr,
  &s_lin_floor_1, &s_lin_ceil_1,
  &s_cvt_floor_full, &s_cvt_ceil_full,
  overall_maxcolorcode, 0);

 if(is_exact) {
  s_full = s_cvt_floor_full;
  goto okay;
 }

 d_floor = samp_lin-s_lin_floor_1;
 d_ceil = s_lin_ceil_1-samp_lin;

 if(d_ceil<=d_floor) s_full=s_cvt_ceil_full;
 else s_full=s_cvt_floor_full;

okay:
 return (unsigned int)(0.5+s_full);
}

static void clamp_output_samples(struct iw_context *ctx, iw_tmpsample *out_pix, int num_out_pix)
{
 int i;

 for(i=0;i<num_out_pix;i++) {
  if(out_pix[i]<0.0) out_pix[i]=0.0;
  else if(out_pix[i]>1.0) out_pix[i]=1.0;
 }
}



static int iw_bkgd_has_transparency(struct iw_context *ctx)
{
 if(!ctx->apply_bkgd) return 0;
 if(!(ctx->output_profile&IW_PROFILE_TRANSPARENCY)) return 0;
 if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) return 0;
 if(ctx->bkgd_color_source==IW_BKGD_COLOR_SOURCE_FILE) {
  if(ctx->img1_bkgd_label_inputcs.c[3]<1.0) return 1;
 }
 else if(ctx->bkgd_color_source==IW_BKGD_COLOR_SOURCE_REQ) {
  if(ctx->bkgd_checkerboard) {
   if(ctx->req.bkgd2.c[3]<1.0) return 1;
  }
  if(ctx->req.bkgd.c[3]<1.0) return 1;
 }
 return 0;
}


static int iw_process_cols_to_intermediate(struct iw_context *ctx, int channel,
 const struct iw_csdescr *in_csdescr)
{
 int i,j;
 int retval=0;
 iw_tmpsample tmp_alpha;
 iw_tmpsample *inpix_tofree = NULL;
 iw_tmpsample *outpix_tofree = NULL;
 int is_alpha_channel;
 struct iw_resize_settings *rs = NULL;
 struct iw_channelinfo_intermed *int_ci;

 iw_tmpsample *in_pix;
 iw_tmpsample *out_pix;
 int num_in_pix;
 int num_out_pix;

 int_ci = &ctx->intermed_ci[channel];
 is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);

 num_in_pix = ctx->input_h;
 inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));
 if(!inpix_tofree) goto done;
 in_pix = inpix_tofree;

 num_out_pix = ctx->intermed_canvas_height;
 outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));
 if(!outpix_tofree) goto done;
 out_pix = outpix_tofree;

 rs=&ctx->resize_settings[IW_DIMENSION_V];



 if(!rs->rrctx) {


  rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,
   num_in_pix, num_out_pix);
  if(!rs->rrctx) goto done;
 }

 for(i=0;i<ctx->input_w;i++) {


  for(j=0;j<ctx->input_h;j++) {

   in_pix[j] = get_sample_cvt_to_linear(ctx,i,j,channel,in_csdescr);

   if(int_ci->need_unassoc_alpha_processing) {
    tmp_alpha = get_raw_sample(ctx,i,j,ctx->img1_alpha_channel_index);


    in_pix[j] *= tmp_alpha;
   }
   else if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) {



    tmp_alpha = get_raw_sample(ctx,i,j,ctx->img1_alpha_channel_index);
    in_pix[j] = (tmp_alpha)*(in_pix[j]) +
     (1.0-tmp_alpha)*(int_ci->bkgd_color_lin);
   }
  }




  iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);

  if(ctx->intclamp)
   clamp_output_samples(ctx,out_pix,num_out_pix);


  for(j=0;j<ctx->intermed_canvas_height;j++) {
   if(is_alpha_channel) {
    ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width + i] = (iw_float32)out_pix[j];
   }
   else {
    ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width + i] = (iw_float32)out_pix[j];
   }
  }
 }

 retval=1;

done:
 if(rs && rs->disable_rrctx_cache && rs->rrctx) {


  iwpvt_resize_rows_done(rs->rrctx);
  rs->rrctx = NULL;
 }
 if(inpix_tofree) iw_free(ctx,inpix_tofree);
 if(outpix_tofree) iw_free(ctx,outpix_tofree);
 return retval;
}

static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,
 const struct iw_csdescr *out_csdescr)
{
 int i,j;
 int z;
 int k;
 int retval=0;
 iw_tmpsample tmpsamp;
 iw_tmpsample alphasamp = 0.0;
 iw_tmpsample *inpix_tofree = NULL;
 iw_tmpsample *outpix_tofree = NULL;

 int using_errdiffdither = 0;
 int output_channel;
 int is_alpha_channel;
 int bkgd_has_transparency;
 double tmpbkgdalpha=0.0;
 int alt_bkgd = 0;
 struct iw_resize_settings *rs = NULL;
 int ditherfamily, dithersubtype;
 struct iw_channelinfo_intermed *int_ci;
 struct iw_channelinfo_out *out_ci;

 iw_tmpsample *in_pix = NULL;
 iw_tmpsample *out_pix = NULL;
 int num_in_pix;
 int num_out_pix;
 struct iw_channelinfo_out default_ci_out;

 num_in_pix = ctx->intermed_canvas_width;
 num_out_pix = ctx->img2.width;

 int_ci = &ctx->intermed_ci[intermed_channel];
 output_channel = int_ci->corresponding_output_channel;
 if(output_channel>=0) {
  out_ci = &ctx->img2_ci[output_channel];
 }
 else {





  iw_zeromem(&default_ci_out, sizeof(struct iw_channelinfo_out));
  default_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;
  out_ci = &default_ci_out;
 }

 is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);
 bkgd_has_transparency = iw_bkgd_has_transparency(ctx);

 inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));
 in_pix = inpix_tofree;


 outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));
 if(!outpix_tofree) goto done;
 out_pix = outpix_tofree;


 if(ctx->nearest_color_table && !is_alpha_channel &&
    out_ci->ditherfamily==IW_DITHERFAMILY_NONE &&
    out_ci->color_count==0)
 {
  out_ci->use_nearest_color_table = 1;
 }
 else {
  out_ci->use_nearest_color_table = 0;
 }


 ditherfamily = out_ci->ditherfamily;
 dithersubtype = out_ci->dithersubtype;
 if(ditherfamily==IW_DITHERFAMILY_RANDOM) {


  if(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)
  {
   iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed);
  }
  else {
   iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype);
  }
 }


 if(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
  using_errdiffdither = 1;
  for(i=0;i<ctx->img2.width;i++) {
   for(k=0;k<IW_DITHER_MAXROWS;k++) {
    ctx->dither_errors[k][i] = 0.0;
   }
  }
 }

 rs=&ctx->resize_settings[IW_DIMENSION_H];



 if(!rs->rrctx) {
  rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,
   num_in_pix, num_out_pix);
  if(!rs->rrctx) goto done;
 }

 for(j=0;j<ctx->intermed_canvas_height;j++) {




  if(is_alpha_channel) {
   for(i=0;i<num_in_pix;i++) {
    inpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i];
   }
  }
  else {
   for(i=0;i<num_in_pix;i++) {
    inpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i];
   }
  }


  iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);

  if(ctx->intclamp)
   clamp_output_samples(ctx,out_pix,num_out_pix);


  if(is_alpha_channel && outpix_tofree && ctx->final_alpha32) {
   for(i=0;i<num_out_pix;i++) {
    ctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i];
   }
  }



  if(output_channel == -1) {



   goto here;
  }

  for(z=0;z<ctx->img2.width;z++) {


   if(using_errdiffdither && (j%2))
    i=ctx->img2.width-1-z;
   else
    i=z;

   tmpsamp = out_pix[i];

   if(ctx->bkgd_checkerboard) {
    alt_bkgd = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) !=
     (((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);
   }

   if(bkgd_has_transparency) {
    tmpbkgdalpha = alt_bkgd ? ctx->bkgd2alpha : ctx->bkgd1alpha;
   }

   if(int_ci->need_unassoc_alpha_processing) {

    alphasamp = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i];

    if(alphasamp!=0.0) {
     tmpsamp /= alphasamp;
    }

    if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {

     double bkcolor;
     bkcolor = alt_bkgd ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin;

     if(bkgd_has_transparency) {
      tmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp);
     }
     else {
      tmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp);
     }
    }
   }
   else if(is_alpha_channel && bkgd_has_transparency) {

    tmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp);
   }

   if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)
    put_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);
   else
    put_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);

  }

  if(using_errdiffdither) {



   for(i=0;i<ctx->img2.width;i++) {

    for(k=0;k<IW_DITHER_MAXROWS-1;k++) {
     ctx->dither_errors[k][i] = ctx->dither_errors[k+1][i];
    }

    ctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;
   }
  }

here:
  ;
 }

 retval=1;

done:
 if(rs && rs->disable_rrctx_cache && rs->rrctx) {


  iwpvt_resize_rows_done(rs->rrctx);
  rs->rrctx = NULL;
 }
 if(inpix_tofree) iw_free(ctx,inpix_tofree);
 if(outpix_tofree) iw_free(ctx,outpix_tofree);

 return retval;
}

static int iw_process_one_channel(struct iw_context *ctx, int intermed_channel,
  const struct iw_csdescr *in_csdescr, const struct iw_csdescr *out_csdescr)
{
 if(!iw_process_cols_to_intermediate(ctx,intermed_channel,in_csdescr)) {
  return 0;
 }

 if(!iw_process_rows_intermediate_to_final(ctx,intermed_channel,out_csdescr)) {
  return 0;
 }

 return 1;
}


static void iw_make_x_to_linear_table(struct iw_context *ctx, double **ptable,
 const struct iw_image *img, const struct iw_csdescr *csdescr)
{
 int ncolors;
 int i;
 double *tbl;

 if(csdescr->cstype==IW_CSTYPE_LINEAR) return;

 ncolors = (1 << img->bit_depth);
 if(ncolors>256) return;


 if( ((size_t)img->width)*img->height <= 512 ) return;

 tbl = iw_malloc(ctx,ncolors*sizeof(double));
 if(!tbl) return;

 for(i=0;i<ncolors;i++) {
  tbl[i] = x_to_linear_sample(((double)i)/(ncolors-1), csdescr);
 }

 *ptable = tbl;
}

static void iw_make_nearest_color_table(struct iw_context *ctx, double **ptable,
 const struct iw_image *img, const struct iw_csdescr *csdescr)
{
 int ncolors;
 int nentries;
 int i;
 double *tbl;
 double prev;
 double curr;

 if(ctx->no_gamma) return;
 if(csdescr->cstype==IW_CSTYPE_LINEAR) return;
 if(img->sampletype==IW_SAMPLETYPE_FLOATINGPOINT) return;
 if(img->bit_depth != ctx->img2.bit_depth) return;

 ncolors = (1 << img->bit_depth);
 if(ncolors>256) return;
 nentries = ncolors-1;


 if( ((size_t)img->width)*img->height <= 512 ) return;

 tbl = iw_malloc(ctx,nentries*sizeof(double));
 if(!tbl) return;



 prev = 0.0;
 for(i=0;i<nentries;i++) {




  curr = x_to_linear_sample( ((double)(i+1))/(ncolors-1), csdescr);
  tbl[i] = (prev + curr)/2.0;
  prev = curr;
 }

 *ptable = tbl;
}



static int get_output_bkgd_label_lin(struct iw_context *ctx, struct iw_color *clr)
{
 clr->c[0] = 1.0; clr->c[1] = 0.0; clr->c[2] = 1.0; clr->c[3] = 1.0;

 if(ctx->req.suppress_output_bkgd_label) return 0;

 if(ctx->req.output_bkgd_label_valid) {
  *clr = ctx->req.output_bkgd_label;
  return 1;
 }



 if(ctx->img1_bkgd_label_set) {
  *clr = ctx->img1_bkgd_label_lin;
  return 1;
 }

 return 0;
}

static unsigned int iw_scale_to_int(double s, unsigned int maxcolor)
{
 if(s<=0.0) return 0;
 if(s>=1.0) return maxcolor;
 return (unsigned int)(0.5+s*maxcolor);
}



static void iw_process_bkgd_label(struct iw_context *ctx)
{
 int ret;
 int k;
 struct iw_color clr;
 double maxcolor;
 unsigned int tmpu;

 if(!(ctx->output_profile&IW_PROFILE_PNG_BKGD) &&
  !(ctx->output_profile&IW_PROFILE_RGB8_BKGD) &&
  !(ctx->output_profile&IW_PROFILE_RGB16_BKGD))
 {
  return;
 }

 ret = get_output_bkgd_label_lin(ctx,&clr);
 if(!ret) return;

 if(ctx->to_grayscale) {
  iw_tmpsample g;
  g = iw_color_to_grayscale(ctx, clr.c[0], clr.c[1], clr.c[2]);
  clr.c[0] = clr.c[1] = clr.c[2] = g;
 }

 if(ctx->output_profile&IW_PROFILE_RGB8_BKGD) {
  maxcolor=255.0;
 }
 else if(ctx->output_profile&IW_PROFILE_RGB16_BKGD) {
  maxcolor=65535.0;
 }
 else if(ctx->img2.bit_depth==8) {
  maxcolor=255.0;
 }
 else if(ctx->img2.bit_depth==16) {
  maxcolor=65535.0;
 }
 else {
  return;
 }




 for(k=0;k<3;k++) {
  tmpu = calc_sample_convert_from_linear(ctx, clr.c[k], &ctx->img2cs, maxcolor);
  ctx->img2.bkgdlabel.c[k] = ((double)tmpu)/maxcolor;
 }

 tmpu = iw_scale_to_int(clr.c[3],(unsigned int)maxcolor);
 ctx->img2.bkgdlabel.c[3] = ((double)tmpu)/maxcolor;

 ctx->img2.has_bkgdlabel = 1;
}

static void negate_target_image(struct iw_context *ctx)
{
 int channel;
 struct iw_channelinfo_out *ci;
 int i,j;
 size_t pos;
 iw_float32 s;
 unsigned int n;

 for(channel=0; channel<ctx->img2_numchannels; channel++) {
  ci = &ctx->img2_ci[channel];
  if(ci->channeltype == IW_CHANNELTYPE_ALPHA) continue;

  if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
   for(j=0; j<ctx->img2.height; j++) {
    for(i=0; i<ctx->img2.width; i++) {
     pos = j*ctx->img2.bpr + ctx->img2_numchannels*i*4 + channel*4;
     s = iw_get_float32(&ctx->img2.pixels[pos]);
     iw_put_float32(&ctx->img2.pixels[pos], ((iw_float32)1.0)-s);
    }
   }
  }
  else if(ctx->img2.bit_depth==8) {
   for(j=0; j<ctx->img2.height; j++) {
    for(i=0; i<ctx->img2.width; i++) {
     pos = j*ctx->img2.bpr + ctx->img2_numchannels*i + channel;
     ctx->img2.pixels[pos] = ci->maxcolorcode_int-ctx->img2.pixels[pos];
    }
   }
  }
  else if(ctx->img2.bit_depth==16) {
   for(j=0; j<ctx->img2.height; j++) {
    for(i=0; i<ctx->img2.width; i++) {
     pos = j*ctx->img2.bpr + ctx->img2_numchannels*i*2 + channel*2;
     n = ctx->img2.pixels[pos]*256 + ctx->img2.pixels[pos+1];
     n = ci->maxcolorcode_int - n;
     ctx->img2.pixels[pos] = (n&0xff00)>>8;
     ctx->img2.pixels[pos+1] = n&0x00ff;
    }
   }
  }
 }
}

static int iw_process_internal(struct iw_context *ctx)
{
 int channel;
 int retval=0;
 int i,k;
 int ret;

 struct iw_csdescr csdescr_linear;

 ctx->intermediate32=NULL;
 ctx->intermediate_alpha32=NULL;
 ctx->final_alpha32=NULL;
 ctx->intermed_canvas_width = ctx->input_w;
 ctx->intermed_canvas_height = ctx->img2.height;

 iw_make_linear_csdescr(&csdescr_linear);

 ctx->img2.bpr = iw_calc_bytesperrow(ctx->img2.width,ctx->img2.bit_depth*ctx->img2_numchannels);

 ctx->img2.pixels = iw_malloc_large(ctx, ctx->img2.bpr, ctx->img2.height);
 if(!ctx->img2.pixels) {
  goto done;
 }

 ctx->intermediate32 = (iw_float32*)iw_malloc_large(ctx, ctx->intermed_canvas_width * ctx->intermed_canvas_height, sizeof(iw_float32));
 if(!ctx->intermediate32) {
  goto done;
 }

 if(ctx->uses_errdiffdither) {
  for(k=0;k<IW_DITHER_MAXROWS;k++) {
   ctx->dither_errors[k] = (double*)iw_malloc(ctx, ctx->img2.width * sizeof(double));
   if(!ctx->dither_errors[k]) goto done;
  }
 }

 if(!ctx->disable_output_lookup_tables) {
  iw_make_x_to_linear_table(ctx,&ctx->output_rev_color_corr_table,&ctx->img2,&ctx->img2cs);

  iw_make_nearest_color_table(ctx,&ctx->nearest_color_table,&ctx->img2,&ctx->img2cs);
 }


 if(IW_IMGTYPE_HAS_ALPHA(ctx->intermed_imgtype)) {
  ctx->intermediate_alpha32 = (iw_float32*)iw_malloc_large(ctx, ctx->intermed_canvas_width * ctx->intermed_canvas_height, sizeof(iw_float32));
  if(!ctx->intermediate_alpha32) {
   goto done;
  }
  ctx->final_alpha32 = (iw_float32*)iw_malloc_large(ctx, ctx->img2.width * ctx->img2.height, sizeof(iw_float32));
  if(!ctx->final_alpha32) {
   goto done;
  }

  if(!iw_process_one_channel(ctx,ctx->intermed_alpha_channel_index,&csdescr_linear,&csdescr_linear)) goto done;
 }



 for(channel=0;channel<ctx->intermed_numchannels;channel++) {
  if(ctx->intermed_ci[channel].channeltype!=IW_CHANNELTYPE_ALPHA) {
   if(ctx->no_gamma)
    ret=iw_process_one_channel(ctx,channel,&csdescr_linear,&csdescr_linear);
   else
    ret=iw_process_one_channel(ctx,channel,&ctx->img1cs,&ctx->img2cs);

   if(!ret) goto done;
  }
 }

 iw_process_bkgd_label(ctx);

 if(ctx->req.negate_target) {
  negate_target_image(ctx);
 }

 retval=1;

done:
 if(ctx->intermediate32) { iw_free(ctx,ctx->intermediate32); ctx->intermediate32=NULL; }
 if(ctx->intermediate_alpha32) { iw_free(ctx,ctx->intermediate_alpha32); ctx->intermediate_alpha32=NULL; }
 if(ctx->final_alpha32) { iw_free(ctx,ctx->final_alpha32); ctx->final_alpha32=NULL; }
 for(k=0;k<IW_DITHER_MAXROWS;k++) {
  if(ctx->dither_errors[k]) { iw_free(ctx,ctx->dither_errors[k]); ctx->dither_errors[k]=NULL; }
 }


 for(i=0;i<2;i++) {
  if(ctx->resize_settings[i].rrctx) {
   iwpvt_resize_rows_done(ctx->resize_settings[i].rrctx);
   ctx->resize_settings[i].rrctx = NULL;
  }
 }
 return retval;
}

static int iw_get_channeltype(int imgtype, int channel)
{
 switch(imgtype) {
 case IW_IMGTYPE_GRAY:
  if(channel==0) return IW_CHANNELTYPE_GRAY;
  break;
 case IW_IMGTYPE_GRAYA:
  if(channel==0) return IW_CHANNELTYPE_GRAY;
  if(channel==1) return IW_CHANNELTYPE_ALPHA;
  break;
 case IW_IMGTYPE_RGB:
  if(channel==0) return IW_CHANNELTYPE_RED;
  if(channel==1) return IW_CHANNELTYPE_GREEN;
  if(channel==2) return IW_CHANNELTYPE_BLUE;
  break;
 case IW_IMGTYPE_RGBA:
  if(channel==0) return IW_CHANNELTYPE_RED;
  if(channel==1) return IW_CHANNELTYPE_GREEN;
  if(channel==2) return IW_CHANNELTYPE_BLUE;
  if(channel==3) return IW_CHANNELTYPE_ALPHA;
  break;
 }
 return 0;
}

static void iw_set_input_channeltypes(struct iw_context *ctx)
{
 int i;
 for(i=0;i<ctx->img1_numchannels_logical;i++) {
  ctx->img1_ci[i].channeltype = iw_get_channeltype(ctx->img1_imgtype_logical,i);
 }
}

static void iw_set_intermed_channeltypes(struct iw_context *ctx)
{
 int i;
 for(i=0;i<ctx->intermed_numchannels;i++) {
  ctx->intermed_ci[i].channeltype = iw_get_channeltype(ctx->intermed_imgtype,i);
 }
}

static void iw_set_out_channeltypes(struct iw_context *ctx)
{
 int i;
 for(i=0;i<ctx->img2_numchannels;i++) {
  ctx->img2_ci[i].channeltype = iw_get_channeltype(ctx->img2.imgtype,i);
 }
}



static void decide_output_bit_depth(struct iw_context *ctx)
{
 if(ctx->output_profile&IW_PROFILE_HDRI) {
  ctx->img2.sampletype=IW_SAMPLETYPE_FLOATINGPOINT;
 }
 else {
  ctx->img2.sampletype=IW_SAMPLETYPE_UINT;
 }

 if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {

  ctx->img2.bit_depth=32;
  return;
 }



 if(ctx->req.output_depth>8 && (ctx->output_profile&IW_PROFILE_16BPS)) {
  ctx->img2.bit_depth=16;
 }
 else {
  if(ctx->req.output_depth>8) {

   iw_warning(ctx,"Reducing depth to 8; required by the output format.");
  }
  ctx->img2.bit_depth=8;
 }
}




static void prepare_apply_bkgd(struct iw_context *ctx)
{
 struct iw_color bkgd1;
 struct iw_color bkgd2;
 int i;

 if(!ctx->apply_bkgd) return;


 bkgd1.c[0]=1.0; bkgd1.c[1]=0.0; bkgd1.c[2]=1.0; bkgd1.c[3]=1.0;
 bkgd2.c[0]=0.0; bkgd2.c[1]=0.0; bkgd2.c[2]=0.0; bkgd2.c[3]=1.0;



 if(ctx->bkgd_color_source == IW_BKGD_COLOR_SOURCE_FILE) {
  bkgd1 = ctx->img1_bkgd_label_lin;
  ctx->bkgd_checkerboard = 0;
 }
 else if(ctx->bkgd_color_source == IW_BKGD_COLOR_SOURCE_REQ) {
  bkgd1 = ctx->req.bkgd;
  if(ctx->req.bkgd_checkerboard) {
   bkgd2 = ctx->req.bkgd2;
  }
 }





 if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) {
  ctx->bkgd1alpha = 1.0;
 }
 else {
  ctx->bkgd1alpha = bkgd1.c[3];
  ctx->bkgd2alpha = bkgd2.c[3];
 }

 if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE && (ctx->img2.imgtype==IW_IMGTYPE_RGB ||
  ctx->img2.imgtype==IW_IMGTYPE_RGBA))
 {
  for(i=0;i<3;i++) {
   ctx->img2_ci[i].bkgd1_color_lin = bkgd1.c[i];
  }
  if(ctx->bkgd_checkerboard) {
   for(i=0;i<3;i++) {
    ctx->img2_ci[i].bkgd2_color_lin = bkgd2.c[i];
   }
  }
 }
 else if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE && (ctx->img2.imgtype==IW_IMGTYPE_GRAY ||
  ctx->img2.imgtype==IW_IMGTYPE_GRAYA))
 {
  ctx->img2_ci[0].bkgd1_color_lin = iw_color_to_grayscale(ctx,bkgd1.c[0],bkgd1.c[1],bkgd1.c[2]);
  if(ctx->bkgd_checkerboard) {
   ctx->img2_ci[0].bkgd2_color_lin = iw_color_to_grayscale(ctx,bkgd2.c[0],bkgd2.c[1],bkgd2.c[2]);
  }
 }
 else if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY && ctx->img2.imgtype==IW_IMGTYPE_RGB) {
  for(i=0;i<3;i++) {
   ctx->intermed_ci[i].bkgd_color_lin = bkgd1.c[i];
  }
 }
 else if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY && ctx->img2.imgtype==IW_IMGTYPE_GRAY) {
  ctx->intermed_ci[0].bkgd_color_lin = iw_color_to_grayscale(ctx,bkgd1.c[0],bkgd1.c[1],bkgd1.c[2]);
 }
}

static void iw_restrict_to_range(int r1, int r2, int *pvar)
{
 if(*pvar < r1) *pvar = r1;
 else if(*pvar > r2) *pvar = r2;
}

static void decide_strategy(struct iw_context *ctx, int *ps1, int *ps2)
{
 int s1, s2;


 switch(ctx->img1_imgtype_logical) {
 case IW_IMGTYPE_RGBA:
  if(ctx->to_grayscale) {
   s1=0x042;
   s2=0x122;
  }
  else {
   s1=0x044;
   s2=0x144;
  }
  break;
 case IW_IMGTYPE_RGB:
  if(ctx->to_grayscale) {
   s1=0x031;
   s2=0x111;
  }
  else {
   s1=0x033;
   s2=0x133;
  }
  break;
 case IW_IMGTYPE_GRAYA:
  if(ctx->to_grayscale) {
   s1=0x022;
   s2=0x122;
  }
  else {
   s1=0x024;
   s2=0x144;
  }
  break;
 default:
  if(ctx->to_grayscale) {
   s1=0x011;
   s2=0x111;
  }
  else {
   s1=0x013;
   s2=0x133;
  }
 }

 if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) {

  if(s1==0x044) {
   s1=0x043;
   s2=0x133;
  }
  else if(s1==0x022) {
   s1=0x021;
   s2=0x111;
  }
  else if(s1==0x024) {
   s1=0x023;
   s2=0x133;
  }
  else if(s1==0x042) {
   s1=0x041;
   s2=0x111;
  }
 }

 if(ctx->apply_bkgd && !iw_bkgd_has_transparency(ctx)) {
  if(s2==0x122) {
   s2=0x121;
  }
  else if(s2==0x144) {
   s2=0x143;
  }
 }

 *ps1 = s1;
 *ps2 = s2;
}

static void decide_how_to_apply_bkgd(struct iw_context *ctx)
{
 if(!IW_IMGTYPE_HAS_ALPHA(ctx->img1_imgtype_logical)) {


  ctx->apply_bkgd=0;
  return;
 }



 if(ctx->img1_bkgd_label_set &&
  (ctx->req.use_bkgd_label_from_file || !ctx->req.bkgd_valid))
 {




  ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_FILE;
 }
 else if(ctx->req.bkgd_valid) {

  ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_REQ;



  ctx->bkgd_checkerboard = ctx->req.bkgd_checkerboard;
 }
 else {

  ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_NONE;
 }

 if(ctx->bkgd_checkerboard) {
  if(ctx->bkgd_check_size<1) ctx->bkgd_check_size=1;
 }

 if(ctx->req.bkgd_valid) {

  ctx->apply_bkgd=1;
 }

 if(!(ctx->output_profile&IW_PROFILE_TRANSPARENCY)) {
  if(!ctx->req.bkgd_valid && !ctx->apply_bkgd) {
   iw_warning(ctx,"This image may have transparency, which is incompatible with the output format. A background color will be applied.");
  }
  ctx->apply_bkgd=1;
 }

 if(ctx->resize_settings[IW_DIMENSION_H].use_offset ||
  ctx->resize_settings[IW_DIMENSION_V].use_offset)
 {




  if(!ctx->req.bkgd_valid && !ctx->apply_bkgd) {
   iw_warning(ctx,"This image may have transparency, which is incompatible with a channel offset. A background color will be applied.");
  }
  ctx->apply_bkgd=1;

  if(ctx->bkgd_checkerboard && ctx->req.bkgd_checkerboard) {
   iw_warning(ctx,"Checkerboard backgrounds are not supported when using a channel offset.");
   ctx->bkgd_checkerboard=0;
  }
  ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_EARLY;
  return;
 }

 if(!ctx->apply_bkgd) {

  return;
 }

 if(ctx->bkgd_checkerboard) {

  ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_LATE;
  return;
 }

 ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_LATE;
}

static void iw_set_auto_resizetype(struct iw_context *ctx, int size1, int size2,
 int dimension)
{


 if(size2==size1 && !ctx->resize_settings[dimension].use_offset &&
  !ctx->req.out_true_valid &&
  ctx->resize_settings[dimension].translate==0.0)
 {
  iw_set_resize_alg(ctx, dimension, IW_RESIZETYPE_NULL, 1.0, 0.0, 0.0);
  return;
 }


 iw_set_resize_alg(ctx, dimension, IW_RESIZETYPE_CUBIC, 1.0, 0.0, 0.5);
}

static void init_channel_info(struct iw_context *ctx)
{
 int i;

 ctx->img1_imgtype_logical = ctx->img1.imgtype;

 if(ctx->resize_settings[IW_DIMENSION_H].edge_policy==IW_EDGE_POLICY_TRANSPARENT ||
  ctx->resize_settings[IW_DIMENSION_V].edge_policy==IW_EDGE_POLICY_TRANSPARENT)
 {

  if(ctx->img1.imgtype==IW_IMGTYPE_GRAY) {
   ctx->img1_imgtype_logical = IW_IMGTYPE_GRAYA;
  }
  else if(ctx->img1.imgtype==IW_IMGTYPE_RGB)
   ctx->img1_imgtype_logical = IW_IMGTYPE_RGBA;
 }

 ctx->img1_numchannels_physical = iw_imgtype_num_channels(ctx->img1.imgtype);
 ctx->img1_numchannels_logical = iw_imgtype_num_channels(ctx->img1_imgtype_logical);
 ctx->img1_alpha_channel_index = iw_imgtype_alpha_channel_index(ctx->img1_imgtype_logical);

 iw_set_input_channeltypes(ctx);

 ctx->img2.imgtype = ctx->img1_imgtype_logical;
 ctx->img2_numchannels = ctx->img1_numchannels_logical;
 ctx->intermed_numchannels = ctx->img1_numchannels_logical;

 for(i=0;i<ctx->img1_numchannels_logical;i++) {
  ctx->intermed_ci[i].channeltype = ctx->img1_ci[i].channeltype;
  ctx->intermed_ci[i].corresponding_input_channel = i;
  ctx->img2_ci[i].channeltype = ctx->img1_ci[i].channeltype;
  if(i>=ctx->img1_numchannels_physical) {



   ctx->img1_ci[i].disable_fast_get_sample = 1;
  }
 }
}


static void prepare_grayscale(struct iw_context *ctx)
{
 switch(ctx->grayscale_formula) {
 case IW_GSF_STANDARD:
  ctx->grayscale_formula = IW_GSF_WEIGHTED;
  iw_set_grayscale_weights(ctx,0.212655,0.715158,0.072187);
  break;
 case IW_GSF_COMPATIBLE:
  ctx->grayscale_formula = IW_GSF_WEIGHTED;
  iw_set_grayscale_weights(ctx,0.299,0.587,0.114);
  break;
 }
}



static int iw_prepare_processing(struct iw_context *ctx, int w, int h)
{
 int i,j;
 int output_maxcolorcode_int;
 int strategy1, strategy2;
 int flag;

 if(ctx->output_profile==0) {
  iw_set_error(ctx,"Output profile not set");
  return 0;
 }

 if(!ctx->prng) {


  ctx->prng = iwpvt_prng_create(ctx);
 }

 if(ctx->randomize) {


  ctx->random_seed = iwpvt_util_randomize(ctx->prng);
 }

 if(ctx->req.out_true_valid) {
  ctx->resize_settings[IW_DIMENSION_H].out_true_size = ctx->req.out_true_width;
  ctx->resize_settings[IW_DIMENSION_V].out_true_size = ctx->req.out_true_height;
 }
 else {
  ctx->resize_settings[IW_DIMENSION_H].out_true_size = (double)w;
  ctx->resize_settings[IW_DIMENSION_V].out_true_size = (double)h;
 }

 if(!iw_check_image_dimensions(ctx,ctx->img1.width,ctx->img1.height)) {
  return 0;
 }
 if(!iw_check_image_dimensions(ctx,w,h)) {
  return 0;
 }

 if(ctx->to_grayscale) {
  prepare_grayscale(ctx);
 }

 init_channel_info(ctx);

 ctx->img2.width = w;
 ctx->img2.height = h;


 if(ctx->input_start_x<0) ctx->input_start_x=0;
 if(ctx->input_start_y<0) ctx->input_start_y=0;
 if(ctx->input_start_x>ctx->img1.width-1) ctx->input_start_x=ctx->img1.width-1;
 if(ctx->input_start_y>ctx->img1.height-1) ctx->input_start_x=ctx->img1.height-1;
 if(ctx->input_w<0) ctx->input_w = ctx->img1.width - ctx->input_start_x;
 if(ctx->input_h<0) ctx->input_h = ctx->img1.height - ctx->input_start_y;
 if(ctx->input_w<1) ctx->input_w = 1;
 if(ctx->input_h<1) ctx->input_h = 1;
 if(ctx->input_w>(ctx->img1.width-ctx->input_start_x)) ctx->input_w=ctx->img1.width-ctx->input_start_x;
 if(ctx->input_h>(ctx->img1.height-ctx->input_start_y)) ctx->input_h=ctx->img1.height-ctx->input_start_y;


 if(ctx->req.output_cs_valid) {

  ctx->img2cs = ctx->req.output_cs;

  if(ctx->output_profile&IW_PROFILE_ALWAYSLINEAR) {
   if(ctx->img2cs.cstype!=IW_CSTYPE_LINEAR) {
    iw_warning(ctx,"Forcing output colorspace to linear; required by the output format.");
    iw_make_linear_csdescr(&ctx->img2cs);
   }
  }
 }
 else {

  if(ctx->output_profile&IW_PROFILE_ALWAYSLINEAR) {
   iw_make_linear_csdescr(&ctx->img2cs);
  }
  else {
   iw_make_srgb_csdescr_2(&ctx->img2cs);
  }
 }


 if(ctx->img1.sampletype!=IW_SAMPLETYPE_FLOATINGPOINT) {
  ctx->input_maxcolorcode_int = (1 << ctx->img1.bit_depth)-1;
  ctx->input_maxcolorcode = (double)ctx->input_maxcolorcode_int;

  for(i=0;i<IW_CI_COUNT;i++) {
   if(ctx->img1_ci[i].maxcolorcode_int<=0) {
    ctx->img1_ci[i].maxcolorcode_int = ctx->input_maxcolorcode_int;
   }
   ctx->img1_ci[i].maxcolorcode_dbl = (double)ctx->img1_ci[i].maxcolorcode_int;

   if(ctx->img1_ci[i].maxcolorcode_int != ctx->input_maxcolorcode_int) {


    ctx->support_reduced_input_bitdepths = 1;
   }
  }
 }

 if(ctx->support_reduced_input_bitdepths ||
  ctx->img1.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)
 {
  for(i=0;i<ctx->img1_numchannels_physical;i++) {
   ctx->img1_ci[i].disable_fast_get_sample=1;
  }
 }



 for(i=0;i<2;i++) {
  for(j=0;j<3;j++) {
   if(fabs(ctx->resize_settings[i].channel_offset[j])>0.00001) {
    ctx->resize_settings[i].use_offset=1;
   }
  }
 }

 if(ctx->to_grayscale &&
  (ctx->resize_settings[IW_DIMENSION_H].use_offset ||
  ctx->resize_settings[IW_DIMENSION_V].use_offset) )
 {
  iw_warning(ctx,"Disabling channel offset, due to grayscale output.");
  ctx->resize_settings[IW_DIMENSION_H].use_offset=0;
  ctx->resize_settings[IW_DIMENSION_V].use_offset=0;
 }

 decide_how_to_apply_bkgd(ctx);


 for(i=0;i<2;i++) {
  if(ctx->resize_settings[i].use_offset ||
    (ctx->apply_bkgd &&
     ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY &&
     ctx->resize_settings[i].edge_policy==IW_EDGE_POLICY_TRANSPARENT))
  {






   ctx->resize_settings[i].disable_rrctx_cache=1;
  }
 }

 decide_strategy(ctx,&strategy1,&strategy2);

 switch(strategy1) {
 case 0x044:
  ctx->intermed_imgtype = IW_IMGTYPE_RGBA;
  break;
 case 0x024:
  ctx->intermed_imgtype = IW_IMGTYPE_RGBA;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  ctx->intermed_ci[1].corresponding_input_channel=0;
  ctx->intermed_ci[2].corresponding_input_channel=0;
  ctx->intermed_ci[3].corresponding_input_channel=1;
  break;
 case 0x033:
 case 0x043:
  ctx->intermed_imgtype = IW_IMGTYPE_RGB;
  break;
 case 0x013:
 case 0x023:
  ctx->intermed_imgtype = IW_IMGTYPE_RGB;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  ctx->intermed_ci[1].corresponding_input_channel=0;
  ctx->intermed_ci[2].corresponding_input_channel=0;
  break;
 case 0x042:
  ctx->intermed_imgtype = IW_IMGTYPE_GRAYA;
  ctx->intermed_ci[0].cvt_to_grayscale=1;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  ctx->intermed_ci[1].corresponding_input_channel=3;
  break;
 case 0x022:
  ctx->intermed_imgtype = IW_IMGTYPE_GRAYA;
  break;
 case 0x031:
  ctx->intermed_imgtype = IW_IMGTYPE_GRAY;
  ctx->intermed_ci[0].cvt_to_grayscale=1;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  break;
 case 0x011:
  ctx->intermed_imgtype = IW_IMGTYPE_GRAY;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  break;
 default:
  iw_set_errorf(ctx,"Internal error, unknown strategy %d",strategy1);
  return 0;
 }

 ctx->intermed_numchannels = iw_imgtype_num_channels(ctx->intermed_imgtype);
 ctx->intermed_alpha_channel_index = iw_imgtype_alpha_channel_index(ctx->intermed_imgtype);


 for(i=0;i<ctx->intermed_numchannels;i++) {
  ctx->intermed_ci[i].corresponding_output_channel = i;
 }

 switch(strategy2) {
 case 0x144:
  ctx->img2.imgtype = IW_IMGTYPE_RGBA;
  break;
 case 0x133:
  ctx->img2.imgtype = IW_IMGTYPE_RGB;
  break;
 case 0x143:
  ctx->img2.imgtype = IW_IMGTYPE_RGB;
  ctx->intermed_ci[3].corresponding_output_channel= -1;
  break;
 case 0x122:
  ctx->img2.imgtype = IW_IMGTYPE_GRAYA;
  break;
 case 0x111:
  ctx->img2.imgtype = IW_IMGTYPE_GRAY;
  break;
 case 0x121:
  ctx->img2.imgtype = IW_IMGTYPE_GRAY;
  ctx->intermed_ci[1].corresponding_output_channel= -1;
  break;
 default:
  iw_set_error(ctx,"Internal error");
  return 0;
 }

 ctx->img2_numchannels = iw_imgtype_num_channels(ctx->img2.imgtype);

 iw_set_intermed_channeltypes(ctx);
 iw_set_out_channeltypes(ctx);



 if(IW_IMGTYPE_HAS_ALPHA(ctx->intermed_imgtype)) {
  for(i=0;i<ctx->intermed_numchannels;i++) {
   if(ctx->intermed_ci[i].channeltype!=IW_CHANNELTYPE_ALPHA)
    ctx->intermed_ci[i].need_unassoc_alpha_processing = 1;
  }
 }


 decide_output_bit_depth(ctx);

 if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
  flag=0;
  for(i=0;i<IW_NUM_CHANNELTYPES;i++) {
   if(ctx->req.color_count[i]) flag=1;
  }
  if(flag) {
   iw_warning(ctx,"Posterization is not supported with floating point output.");
  }
 }
 else {
  output_maxcolorcode_int = (1 << ctx->img2.bit_depth)-1;


  for(i=0;i<ctx->img2_numchannels;i++) {
   ctx->img2_ci[i].maxcolorcode_int = output_maxcolorcode_int;
  }


  if((ctx->output_profile&IW_PROFILE_REDUCEDBITDEPTHS)) {
   for(i=0;i<ctx->img2_numchannels;i++) {
    int mccr;
    mccr = ctx->req.output_maxcolorcode[ctx->img2_ci[i].channeltype];
    if(mccr>0) {
     if(mccr>output_maxcolorcode_int) mccr=output_maxcolorcode_int;
     ctx->img2_ci[i].maxcolorcode_int = mccr;
    }
   }
  }


  for(i=0;i<ctx->img2_numchannels;i++) {
   if(ctx->img2_ci[i].maxcolorcode_int != output_maxcolorcode_int) {
    ctx->reduced_output_maxcolor_flag = 1;
    ctx->disable_output_lookup_tables = 1;
   }

   ctx->img2_ci[i].maxcolorcode_dbl = (double)ctx->img2_ci[i].maxcolorcode_int;
  }
 }

 for(i=0;i<ctx->img2_numchannels;i++) {
  ctx->img2_ci[i].color_count = ctx->req.color_count[ctx->img2_ci[i].channeltype];
  if(ctx->img2_ci[i].color_count) {
   iw_restrict_to_range(2,ctx->img2_ci[i].maxcolorcode_int,&ctx->img2_ci[i].color_count);
  }
  if(ctx->img2_ci[i].color_count==1+ctx->img2_ci[i].maxcolorcode_int) {
   ctx->img2_ci[i].color_count = 0;
  }

  ctx->img2_ci[i].ditherfamily = ctx->ditherfamily_by_channeltype[ctx->img2_ci[i].channeltype];
  ctx->img2_ci[i].dithersubtype = ctx->dithersubtype_by_channeltype[ctx->img2_ci[i].channeltype];
 }


 for(i=0;i<ctx->img2_numchannels;i++) {
  if(ctx->img2_ci[i].ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
   ctx->uses_errdiffdither=1;
  }
 }

 if(!ctx->support_reduced_input_bitdepths && ctx->img1.sampletype==IW_SAMPLETYPE_UINT) {
  iw_make_x_to_linear_table(ctx,&ctx->input_color_corr_table,&ctx->img1,&ctx->img1cs);
 }

 if(ctx->img1_bkgd_label_set) {

  for(i=0;i<3;i++) {
   ctx->img1_bkgd_label_lin.c[i] = x_to_linear_sample(ctx->img1_bkgd_label_inputcs.c[i],&ctx->img1cs);
  }
  ctx->img1_bkgd_label_lin.c[3] = ctx->img1_bkgd_label_inputcs.c[3];
 }

 if(ctx->apply_bkgd) {
  prepare_apply_bkgd(ctx);
 }

 if(ctx->req.output_rendering_intent==IW_INTENT_UNKNOWN) {

  ctx->img2.rendering_intent = ctx->img1.rendering_intent;
 }
 else {
  ctx->img2.rendering_intent = ctx->req.output_rendering_intent;
 }

 if(ctx->resize_settings[IW_DIMENSION_H].family==IW_RESIZETYPE_AUTO) {
  iw_set_auto_resizetype(ctx,ctx->input_w,ctx->img2.width,IW_DIMENSION_H);
 }
 if(ctx->resize_settings[IW_DIMENSION_V].family==IW_RESIZETYPE_AUTO) {
  iw_set_auto_resizetype(ctx,ctx->input_h,ctx->img2.height,IW_DIMENSION_V);
 }

 if(IW_IMGTYPE_HAS_ALPHA(ctx->img2.imgtype)) {
  if(!ctx->opt_strip_alpha) {




   ctx->opt_palette = 0;
   ctx->opt_binary_trns = 0;
  }
 }

 return 1;
}

IW_IMPL(int) iw_process_image(struct iw_context *ctx)
{
 int ret;
 int retval = 0;

 if(ctx->use_count>0) {
  iw_set_error(ctx,"Internal: Incorrect attempt to reprocess image");
  goto done;
 }
 ctx->use_count++;

 ret = iw_prepare_processing(ctx,ctx->canvas_width,ctx->canvas_height);
 if(!ret) goto done;

 ret = iw_process_internal(ctx);
 if(!ret) goto done;

 iwpvt_optimize_image(ctx);

 retval = 1;
done:
 return retval;
}
