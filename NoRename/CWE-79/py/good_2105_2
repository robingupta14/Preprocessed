
from bs4 import BeautifulSoup
from django.conf import settings as django_settings
from django.core import exceptions

from django.core.urlresolvers import reverse
from django.contrib.auth.decorators import login_required
from django.http import Http404
from django.http import HttpResponse
from django.http import HttpResponseBadRequest
from django.http import HttpResponseRedirect
from django.http import HttpResponseForbidden
from django.forms import ValidationError, IntegerField, CharField
from django.shortcuts import get_object_or_404
from django.shortcuts import render
from django.template.loader import get_template
from django.views.decorators import csrf
from django.utils import simplejson
from django.utils.html import escape
from django.utils.translation import ugettext as _
from django.utils.translation import string_concat
from askbot.utils.slug import slugify
from askbot import models
from askbot import forms
from askbot import conf
from askbot import const
from askbot import mail
from askbot.conf import settings as askbot_settings
from askbot.utils import category_tree
from askbot.utils import decorators
from askbot.utils import url_utils
from askbot.utils.forms import get_db_object_or_404
from django.template import RequestContext
from askbot.skins.loaders import render_into_skin_as_string
from askbot.skins.loaders import render_text_into_skin
from askbot.askbot.models.tag import get_tags_by_names



@django.views.askbot.utils.decorators.csrf.csrf_exempt
def manage_inbox(request):
    

    response_data = dict()
    try:
        if request.is_ajax():
            if request.method == POST:
                post_data = django.utils.simplejson.loads(request.raw_post_data)
                if request.user.is_authenticated():
                    activity_types = askbot.const.RESPONSE_ACTIVITY_TYPES_FOR_DISPLAY
                    activity_types += (
                        askbot.const.TYPE_ACTIVITY_MENTION,
                        askbot.const.TYPE_ACTIVITY_MARK_OFFENSIVE,
                        askbot.const.TYPE_ACTIVITY_MODERATED_NEW_POST,
                        askbot.const.TYPE_ACTIVITY_MODERATED_POST_EDIT
                    )
                    user = request.user
                    memo_set = askbot.models.ActivityAuditStatus.objects.filter(
                        id__in = post_data[memo_list],
                        activity__activity_type__in = activity_types,
                        user = user
                    )

                    action_type = post_data[action_type]
                    if action_type == delete:
                        memo_set.delete()
                    elif action_type == mark_new:
                        memo_set.update(status = askbot.models.ActivityAuditStatus.STATUS_NEW)
                    elif action_type == mark_seen:
                        memo_set.update(status = askbot.models.ActivityAuditStatus.STATUS_SEEN)
                    elif action_type == remove_flag:
                        for memo in memo_set:
                            activity_type = memo.activity.activity_type
                            if activity_type == askbot.const.TYPE_ACTIVITY_MARK_OFFENSIVE:
                                request.user.flag_post(
                                    post = memo.activity.content_object,
                                    cancel_all = True
                                )
                            elif activity_type in \
                                (
                                    askbot.const.TYPE_ACTIVITY_MODERATED_NEW_POST,
                                    askbot.const.TYPE_ACTIVITY_MODERATED_POST_EDIT
                                ):
                                post_revision = memo.activity.content_object
                                request.user.approve_post_revision(post_revision)
                                memo.delete()

                    
                    
                    
                    
                    
                    elif action_type == delete_post:
                        for memo in memo_set:
                            content_object = memo.activity.content_object
                            if isinstance(content_object, askbot.models.PostRevision):
                                post = content_object.post
                            else:
                                post = content_object
                            request.user.delete_post(post)
                            reject_reason = askbot.models.PostFlagReason.objects.get(
                                                    id = post_data[reject_reason_id]
                                                )
                            template = get_templateemail/rejected_post.html
                            data = {
                                    post: post.html,
                                    reject_reason: reject_reason.details.html
                                   }
                            body_text = template.render(RequestContext(request, data))
                            askbot.mail.send_mail(
                                subject_line = _your post was not accepted,
                                body_text = unicode(body_text),
                                recipient_list = [post.author.email,]
                            )
                            memo.delete()

                    user.update_response_counts()

                    response_data[success] = True
                    data = django.utils.simplejson.dumps(response_data)
                    return HttpResponse(data, mimetype=application/json)
                else:
                    raise django.core.exceptions.PermissionDenied(
                        _Sorry, but anonymous users cannot access the inbox
                    )
            else:
                raise django.core.exceptions.PermissionDeniedmust use POST request
        else:
            
            return HttpResponseRedirect(reverseindex)
    except Exception, e:
        message = unicode(e)
        if message == :
            message = _Oops, apologies - there was some error
        response_data[message] = message
        response_data[success] = False
        data = django.utils.simplejson.dumps(response_data)
        return HttpResponse(data, mimetype=application/json)


def process_vote(user = None, vote_direction = None, post = None):
    
    if user.is_anonymous():
        raise django.core.exceptions.PermissionDenied(_Sorry, anonymous users cannot vote)

    user.assert_can_vote_for_post(post = post, direction = vote_direction)
    vote = user.get_old_vote_for_post(post)
    response_data = {}
    if vote != None:
        user.assert_can_revoke_old_vote(vote)
        score_delta = vote.cancel()
        response_data[count] = post.points+ score_delta
        response_data[status] = 1 

    else:
        
        votes_left = user.get_unused_votes_today()
        if votes_left <= 0:
            raise django.core.exceptions.PermissionDenied(
                            _Sorry you ran out of votes for today
                        )

        votes_left -= 1
        if votes_left <= \
            askbot.conf.settings.VOTES_LEFT_WARNING_THRESHOLD:
            msg = _You have %(votes_left)s votes left for today \
                    % {votes_left: votes_left }
            response_data[message] = msg

        if vote_direction == up:
            vote = user.upvote(post = post)
        else:
            vote = user.downvote(post = post)

        response_data[count] = post.points
        response_data[status] = 0 

    response_data[success] = 1

    return response_data


@django.views.askbot.utils.decorators.csrf.csrf_exempt
def vote(request):
    
    response_data = {'allowed': 1, 'success': 1, 'status': 0, 'count': 0, 'message': ''}

    try:
        if request.is_ajax() and request.method == POST:
            vote_type = request.POST.gettype
        else:
            raise Exception(_Sorry, something is not right here...)

        id = request.POST.getpostId

        if vote_type == 0:
            if askbot.conf.settings.ACCEPTING_ANSWERS_ENABLED is False:
                return
            if request.user.is_authenticated():
                answer_id = request.POST.getpostId
                answer = get_object_or_404(askbot.models.Post, post_type=answer, id = answer_id)
                
                if answer.accepted():
                    request.user.unaccept_best_answer(answer)
                    response_data[status] = 1 
                else:
                    request.user.accept_best_answer(answer)

                
                answer.thread.update_summary_html() 
                

            else:
                raise django.core.exceptions.PermissionDenied(
                        _Sorry, but anonymous users cannot accept answers
                    )

        elif vote_type in ('1', '2', '5', '6'):

            
            
            
            vote_direction = up
            if vote_type in ('2', '6'):
                vote_direction = down

            if vote_type in ('5', '6'):
                
                
                post_id = request.POST.getpostId
                post = get_object_or_404(askbot.models.Post, post_type=answer, id=post_id)
            else:
                post = get_object_or_404(askbot.models.Post, post_type=question, id=id)
            
            

            response_data = process_vote(
                                        user = request.user,
                                        vote_direction = vote_direction,
                                        post = post
                                    )

            
            if vote_type in ('1', '2'): 
                post.thread.update_summary_html() 
            

        elif vote_type in ['7', '8']:
            
            if vote_type == 7:
                post = get_object_or_404(askbot.models.Post, post_type=question, id=id)
            if vote_type == 8:
                id = request.POST.getpostId
                post = get_object_or_404(askbot.models.Post, post_type=answer, id=id)

            request.user.flag_post(post)

            response_data[count] = post.offensive_flag_count
            response_data[success] = 1

        elif vote_type in ['7.5', '8.5']:
            
            if vote_type == 7.5:
                post = get_object_or_404(askbot.models.Post, post_type=question, id=id)
            if vote_type == 8.5:
                id = request.POST.getpostId
                post = get_object_or_404(askbot.models.Post, post_type=answer, id=id)

            request.user.flag_post(post, cancel = True)

            response_data[count] = post.offensive_flag_count
            response_data[success] = 1

        elif vote_type in ['7.6', '8.6']:
            
            if vote_type == 7.6:
                post = get_object_or_404(askbot.models.Post, id=id)
            if vote_type == 8.6:
                id = request.POST.getpostId
                post = get_object_or_404(askbot.models.Post, id=id)

            request.user.flag_post(post, cancel_all = True)

            response_data[count] = post.offensive_flag_count
            response_data[success] = 1

        elif vote_type in ['9', '10']:
            
            post = get_object_or_404(askbot.models.Post, post_type=question, id=id)
            if vote_type == 10:
                id = request.POST.getpostId
                post = get_object_or_404(askbot.models.Post, post_type=answer, id=id)

            if post.deleted == True:
                request.user.restore_post(post = post)
            else:
                request.user.delete_post(post = post)

        elif request.is_ajax() and request.method == POST:

            if not request.user.is_authenticated():
                response_data[allowed] = 0
                response_data[success] = 0

            question = get_object_or_404(askbot.models.Post, post_type=question, id=id)
            vote_type = request.POST.gettype

            
            if vote_type == 4:
                fave = request.user.toggle_favorite_question(question)
                response_data[count] = askbot.models.FavoriteQuestion.objects.filter(thread = question.thread).count()
                if fave == False:
                    response_data[status] = 1

            elif vote_type == 11:
                user = request.user
                if user.is_authenticated():
                    if user not in question.thread.followed_by.all():
                        user.follow_question(question)
                        if askbot.conf.settings.EMAIL_VALIDATION == True \
                            and user.email_isvalid == False:

                            response_data[message] = \
                                    _Your subscription is saved, but email address %(email)s needs to be validated, please see <a href="%(details_url)s">more details here</a> % {email:user.email,details_url:reversefaq + '

                    subscribed = user.subscribe_for_followed_question_alerts()
                    if subscribed:
                        if message in response_data:
                            response_data[message] += <br/>
                        response_data[message] += _email update frequency has been set to daily
                    
                    
                else:
                    pass
                    
                    
            elif vote_type == 12:
                user = request.user
                if user.is_authenticated():
                    user.unfollow_question(question)
        else:
            response_data[success] = 0
            response_data[message] = Request mode is not supported. Please try again.

        if vote_type not in (1, 2, 4, 5, 6, 11, 12):
            
            
            
            post = askbot.models.Post.objects.get(id = id)
            post.thread.invalidate_cached_data()

        data = django.utils.simplejson.dumps(response_data)

    except Exception, e:
        response_data[message] = unicode(e)
        response_data[success] = 0
        data = django.utils.simplejson.dumps(response_data)
    return HttpResponse(data, mimetype=application/json)


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.post_only
@askbot.utils.decorators.ajax_login_required
def mark_tag(request, **kwargs):
    action = kwargs[action]
    post_data = django.utils.simplejson.loads(request.raw_post_data)
    raw_tagnames = post_data[tagnames]
    reason = post_data[reason]
    assert reason in ('good', 'bad', 'subscribed')
    
    tagnames, wildcards = askbot.forms.clean_marked_tagnames(raw_tagnames)

    if request.user.is_administrator() and user in post_data:
        user = get_object_or_404(askbot.models.User, pk=post_data[user])
    else:
        user = request.user

    cleaned_tagnames, cleaned_wildcards = user.mark_tags(
                                                         tagnames,
                                                         wildcards,
                                                         reason = reason,
                                                         action = action
                                                        )

    
    tag_usage_counts = dict()
    for name in tagnames:
        if name in cleaned_tagnames:
            tag_usage_counts[name] = 1
        else:
            tag_usage_counts[name] = 0

    for name in wildcards:
        if name in cleaned_wildcards:
            tag_usage_counts[name] = askbot.models.Tag.objects.filter(
                                        name__startswith = name[:-1]
                                    ).count()
        else:
            tag_usage_counts[name] = 0

    return HttpResponse(django.utils.simplejson.dumps(tag_usage_counts), mimetype=application/json)


@askbot.utils.decorators.get_only
def get_tags_by_wildcard(request):
    
    wildcard = request.GET.get('wildcard', None)
    if wildcard is None:
        return HttpResponseForbidden()

    matching_tags = askbot.models.Tag.objects.get_by_wildcards( [wildcard,] )
    count = matching_tags.count()
    names = matching_tags.values_list(name, flat = True)[:20]
    re_data = django.utils.simplejson.dumps({tag_count: count, tag_names: list(names)})
    return HttpResponse(re_data, mimetype = application/json)

@askbot.utils.decorators.get_only
def get_thread_shared_users(request):
    
    thread_id = request.GET[thread_id]
    thread_id = IntegerField().clean(thread_id)
    thread = askbot.models.Thread.objects.get(id=thread_id)
    users = thread.get_users_shared_with()
    data = {
        users: users,
    }
    html = render_into_skin_as_string(widgets/user_list.html, data, request)
    re_data = django.utils.simplejson.dumps({
        html: html,
        users_count: users.count(),
        success: True
    })
    return HttpResponse(re_data, mimetype=application/json)

@askbot.utils.decorators.get_only
def get_thread_shared_groups(request):
    
    thread_id = request.GET[thread_id]
    thread_id = IntegerField().clean(thread_id)
    thread = askbot.models.Thread.objects.get(id=thread_id)
    groups = thread.get_groups_shared_with()
    data = {groups: groups}
    html = render_into_skin_as_string(widgets/groups_list.html, data, request)
    re_data = django.utils.simplejson.dumps({
        html: html,
        groups_count: groups.count(),
        success: True
    })
    return HttpResponse(re_data, mimetype=application/json)

@askbot.utils.decorators.ajax_only
def get_html_template(request):
    
    template_name = request.REQUEST.get('template_name', None)
    allowed_templates = ('widgets/tag_category_selector.html',)
    
    if template_name not in allowed_templates:
        raise Http404
    return {
        html: get_template(template_name).render()
    }

@askbot.utils.decorators.get_only
def get_tag_list(request):
    
    tags = askbot.models.Tag.objects.filter(
                        deleted = False,
                        status = askbot.models.Tag.STATUS_ACCEPTED
                    )

    tag_names = tags.values_list(
                        name, flat = True
                    )

    output = <built-in method join of str object at 0x7f5fe6c6e138>(map(escape, tag_names))
    return HttpResponse(output, mimetype = text/plain)

@askbot.utils.decorators.get_only
def load_object_description(request):
    
    obj = get_db_object_or_404(request.GET)
    text = getattr(obj.description, text, ).strip()
    return HttpResponse(text, mimetype = text/plain)

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def save_object_description(request):
    
    obj = get_db_object_or_404(request.POST)
    text = request.POST[text]
    if obj.description:
        request.user.edit_post(obj.description, body_text=text)
    else:
        request.user.post_object_description(obj, body_text=text)
    return {html: obj.description.html}

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def rename_tag(request):
    if request.user.is_anonymous() \
        or not request.user.is_administrator_or_moderator():
        raise django.core.exceptions.PermissionDenied()
    post_data = django.utils.simplejson.loads(request.raw_post_data)
    to_name = askbot.forms.clean_tag(post_data[to_name])
    from_name = askbot.forms.clean_tag(post_data[from_name])
    path = post_data[path]

    
    

    tree = askbot.utils.category_tree.get_data()
    askbot.utils.category_tree.rename_category(
        tree,
        from_name = from_name,
        to_name = to_name,
        path = path
    )
    askbot.utils.category_tree.save_data(tree)

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def delete_tag(request):
    
    if request.user.is_anonymous() \
        or not request.user.is_administrator_or_moderator():
        raise django.core.exceptions.PermissionDenied()

    try:
        post_data = django.utils.simplejson.loads(request.raw_post_data)
        tag_name = post_data[tag_name]
        path = post_data[path]
        tree = askbot.utils.category_tree.get_data()
        askbot.utils.category_tree.delete_category(tree, tag_name, path)
        askbot.utils.category_tree.save_data(tree)
    except Exception:
        if tag_name in locals():
            logging.critical(could not delete tag %s % tag_name)
        else:
            logging.critical(failed to parse post data %s % request.raw_post_data)
        raise django.core.exceptions.PermissionDenied(_Sorry, could not delete tag)
    return {tree_data: tree}

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def add_tag_category(request):
    
    if request.user.is_anonymous() \
        or not request.user.is_administrator_or_moderator():
        raise django.core.exceptions.PermissionDenied()

    post_data = django.utils.simplejson.loads(request.raw_post_data)
    category_name = askbot.forms.clean_tag(post_data[new_category_name])
    path = post_data[path]

    tree = askbot.utils.category_tree.get_data()

    if askbot.utils.category_tree.path_is_valid(tree, path) == False:
        raise ValueError()

    new_path = askbot.utils.category_tree.add_category(tree, category_name, path)
    askbot.utils.category_tree.save_data(tree)
    return {
        tree_data: tree,
        new_path: new_path
    }


@askbot.utils.decorators.get_only
def get_groups_list(request):
    
    global_group = askbot.models.Group.objects.get_global_group()
    groups = askbot.models.Group.objects.exclude_personal()
    group_names = groups.exclude(
                        name=global_group.name
                    ).values_list(
                        name, flat = True
                    )
    output = <built-in method join of str object at 0x7f5fe6c6e138>(group_names)
    return HttpResponse(output, mimetype = text/plain)

@django.views.askbot.utils.decorators.csrf.csrf_protect
def subscribe_for_tags(request):
    
    
    tag_names = request.REQUEST.get('tags', '').strip().split()
    pure_tag_names, wildcards = askbot.forms.clean_marked_tagnames(tag_names)
    if request.user.is_authenticated():
        if request.method == POST:
            if ok in request.POST:
                request.user.mark_tags(
                            pure_tag_names,
                            wildcards,
                            reason = good,
                            action = add
                        )
                request.user.message_set.create(
                    message = _Your tag subscription was saved, thanks!
                )
            else:
                message = _Tag subscription was canceled (<a href="%(url)s">undo</a>). % {url: escape(request.path) + ?tags= + request.REQUEST[tags]}
                request.user.message_set.create(message = message)
            return HttpResponseRedirect(reverseindex)
        else:
            data = {tags: tag_names}
            return render(request, subscribe_for_tags.html, data)
    else:
        all_tag_names = pure_tag_names + wildcards
        message = _Please sign in to subscribe for: %(tags)s \
                    % {tags: <built-in method join of str object at 0x7f5fe0911f70>(all_tag_names)}
        request.user.message_set.create(message = message)
        request.session[subscribe_for_tags] = (pure_tag_names, wildcards)
        return HttpResponseRedirect(askbot.utils.url_utils.get_login_url())

@askbot.utils.decorators.admins_only
def list_bulk_tag_subscription(request):
    if askbot.conf.settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:
        raise Http404
    object_list = askbot.models.BulkTagSubscription.objects.all()
    data = {object_list: object_list}
    return render(request, tags/list_bulk_tag_subscription.html, data)

@askbot.utils.decorators.admins_only
def create_bulk_tag_subscription(request):
    if askbot.conf.settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:
        raise Http404

    data = {action: _Create}
    if request.method == POST:
        form = askbot.forms.BulkTagSubscriptionForm(request.POST)
        if form.is_valid():
            tag_names = form.cleaned_data[tags].split 
            user_list = form.cleaned_data.getusers
            group_list = form.cleaned_data.getgroups

            bulk_subscription = askbot.models.BulkTagSubscription.objects.create(
                                                            tag_names=tag_names,
                                                            tag_author=request.user,
                                                            user_list=user_list,
                                                            group_list=group_list
                                                        )

            return HttpResponseRedirect(reverselist_bulk_tag_subscription)
        else:
            data[form] = form
    else:
        data[form] = askbot.forms.BulkTagSubscriptionForm()

    return render(request, tags/form_bulk_tag_subscription.html, data)

@askbot.utils.decorators.admins_only
def edit_bulk_tag_subscription(request, pk):
    if askbot.conf.settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:
        raise Http404

    bulk_subscription = get_object_or_404(askbot.models.BulkTagSubscription,
                                          pk=pk)
    data = {action: _Edit}
    if request.method == POST:
        form = askbot.forms.BulkTagSubscriptionForm(request.POST)
        if form.is_valid():
            bulk_subscription.tags.clear()
            bulk_subscription.users.clear()
            bulk_subscription.groups.clear()

            if groups in form.cleaned_data:
                group_ids = [user.id for user in form.cleaned_data[groups]]
                bulk_subscription.groups.add(*group_ids)

            tags, new_tag_names = get_tags_by_names(form.cleaned_data[tags].split )
            tag_id_list = [tag.id for tag in tags]

            for new_tag_name in new_tag_names:
                new_tag = askbot.models.Tag.objects.create(name=new_tag_name,
                                             created_by=request.user)
                tag_id_list.append(new_tag.id)

            bulk_subscription.tags.add(*tag_id_list)

            user_ids = []
            for user in form.cleaned_data[users]:
                user_ids.append(user)
                user.mark_tags(bulk_subscription.tag_list(),
                               reason=subscribed, action=add)

            bulk_subscription.users.add(*user_ids)

            return HttpResponseRedirect(reverselist_bulk_tag_subscription)
    else:
        form_initial = {
                        users: bulk_subscription.users.all(),
                        groups: bulk_subscription.groups.all(),
                        tags: <built-in method join of str object at 0x7f5fe6c6e608>([tag.name for tag in bulk_subscription.tags.all()]),
                       }
        data.update({
                    bulk_subscription: bulk_subscription,
                    form: askbot.forms.BulkTagSubscriptionForm(initial=form_initial),
                   })

    return render(request, tags/form_bulk_tag_subscription.html, data)

@askbot.utils.decorators.admins_only
@askbot.utils.decorators.post_only
def delete_bulk_tag_subscription(request):
    if askbot.conf.settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:
        raise Http404

    pk = request.POST.getpk
    if pk:
        bulk_subscription = get_object_or_404(askbot.models.BulkTagSubscription, pk=pk)
        bulk_subscription.delete()
        return HttpResponseRedirect(reverselist_bulk_tag_subscription)
    else:
        return HttpResponseRedirect(reverselist_bulk_tag_subscription)

@askbot.utils.decorators.get_only
def api_get_questions(request):
    
    query = request.GET.get('query_text', '').strip()
    tag_name = request.GET.get('tag_name', None)

    if askbot.conf.settings.GROUPS_ENABLED:
        threads = askbot.models.Thread.objects.get_visible(user=request.user)
    else:
        threads = askbot.models.Thread.objects.all()

    if tag_name:
        threads = threads.filter(tags__name=tag_name)

    if query:
        threads = threads.get_for_title_query(query)

    
    threads = threads.distinct()[:30]

    thread_list = list()
    for thread in threads:
        try:
            thread_list.append({
                    title: escape(thread.title),
                    url: thread.get_absolute_url(),
                    answer_count: thread.get_answer_count(request.user)
                })
        except:
            continue

    json_data = django.utils.simplejson.dumps(thread_list)
    return HttpResponse(json_data, mimetype = application/json)


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.post_only
@askbot.utils.decorators.ajax_login_required
def set_tag_filter_strategy(request):
    
    filter_type = request.POST[filter_type]
    filter_value = int(request.POST[filter_value])
    assert(filter_type in ('display', 'email'))
    if filter_type == display:
        allowed_values_dict = dict(askbot.conf.get_tag_display_filter_strategy_choices())
        assert(filter_value in allowed_values_dict)
        request.user.display_tag_filter_strategy = filter_value
    else:
        allowed_values_dict = dict(askbot.conf.get_tag_email_filter_strategy_choices())
        assert(filter_value in allowed_values_dict)
        request.user.email_tag_filter_strategy = filter_value
    request.user.save()
    return HttpResponse(, mimetype = application/json)


@login_required
@django.views.askbot.utils.decorators.csrf.csrf_protect
def close(request, id):
    
    question = get_object_or_404(askbot.models.Post, post_type=question, id=id)
    try:
        if request.method == POST:
            form = askbot.forms.CloseForm(request.POST)
            if form.is_valid():
                reason = form.cleaned_data[reason]

                request.user.close_question(
                                        question = question,
                                        reason = reason
                                    )
            return HttpResponseRedirect(question.get_absolute_url())
        else:
            request.user.assert_can_close_question(question)
            form = askbot.forms.CloseForm()
            data = {
                question: question,
                form: form,
            }
            return render(request, close.html, data)
    except django.core.exceptions.PermissionDenied, e:
        request.user.message_set.create(message = unicode(e))
        return HttpResponseRedirect(question.get_absolute_url())

@login_required
@django.views.askbot.utils.decorators.csrf.csrf_protect
def reopen(request, id):
    

    question = get_object_or_404(askbot.models.Post, post_type=question, id=id)
    
    try:
        if request.method == POST :
            request.user.reopen_question(question)
            return HttpResponseRedirect(question.get_absolute_url())
        else:
            request.user.assert_can_reopen_question(question)
            closed_by_profile_url = question.thread.closed_by.get_profile_url()
            closed_by_username = question.thread.closed_by.username
            data = {
                question : question,
                closed_by_profile_url: closed_by_profile_url,
                closed_by_username: closed_by_username,
            }
            return render(request, reopen.html, data)

    except django.core.exceptions.PermissionDenied, e:
        request.user.message_set.create(message = unicode(e))
        return HttpResponseRedirect(question.get_absolute_url())


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
def swap_question_with_answer(request):
    
    if request.user.is_authenticated():
        if request.user.is_administrator() or request.user.is_moderator():
            answer = askbot.models.Post.objects.get_answers(
                                                request.user
                                            ).get(
                                                id=request.POST[answer_id]
                                            )
            new_question = answer.swap_with_question(new_title = request.POST[new_title])
            return {question_url: new_question.get_absolute_url() }
    raise Http404

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def upvote_comment(request):
    if request.user.is_anonymous():
        raise django.core.exceptions.PermissionDenied(_Please sign in to vote)
    form = askbot.forms.VoteForm(request.POST)
    if form.is_valid():
        comment_id = form.cleaned_data[post_id]
        cancel_vote = form.cleaned_data[cancel_vote]
        comment = get_object_or_404(askbot.models.Post, post_type=comment, id=comment_id)
        process_vote(
            post = comment,
            vote_direction = up,
            user = request.user
        )
    else:
        raise ValueError
    
    return {score: comment.points}

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def delete_post(request):
    if request.user.is_anonymous():
        raise django.core.exceptions.PermissionDenied(_Please sign in to delete/restore posts)
    form = askbot.forms.VoteForm(request.POST)
    if form.is_valid():
        post_id = form.cleaned_data[post_id]
        post = get_object_or_404(
            askbot.models.Post,
            post_type__in = ('question', 'answer'),
            id = post_id
        )
        if form.cleaned_data[cancel_vote]:
            request.user.restore_post(post)
        else:
            request.user.delete_post(post)
    else:
        raise ValueError
    return {is_deleted: post.deleted}


@django.views.askbot.utils.decorators.csrf.csrf_exempt
def read_message(request):
    if request.method == POST:
        if request.POST[formdata] == required:
            request.session[message_silent] = 1
            if request.user.is_authenticated():
                request.user.delete_messages()
    return HttpResponse


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def edit_group_membership(request):
    
    
    
    
    form = askbot.forms.EditGroupMembershipForm(request.POST)
    if form.is_valid():
        group_name = form.cleaned_data[group_name]
        user_id = form.cleaned_data[user_id]
        try:
            user = askbot.models.User.objects.get(id=user_id)
        except askbot.models.User.DoesNotExist:
            raise django.core.exceptions.PermissionDenied(
                user with id %d not found % user_id
            )

        action = form.cleaned_data[action]
        
        if action == add:
            group_params = {name: group_name, user: user}
            group = askbot.models.Group.objects.get_or_create(**group_params)
            request.user.edit_group_membership(user, group, add)
            template = get_templatewidgets/group_snippet.html
            return {
                name: group.name,
                description: getattr(group.tag_wiki, text, ),
                html: template.render({group: group})
            }
        elif action == remove:
            try:
                group = askbot.models.Group.objects.get(group_name = group_name)
                request.user.edit_group_membership(user, group, remove)
            except askbot.models.Group.DoesNotExist:
                raise django.core.exceptions.PermissionDenied()
        else:
            raise django.core.exceptions.PermissionDenied()
    else:
        raise django.core.exceptions.PermissionDenied()


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def save_group_logo_url(request):
    
    form = askbot.forms.GroupLogoURLForm(request.POST)
    if form.is_valid():
        group_id = form.cleaned_data[group_id]
        image_url = form.cleaned_data[image_url]
        group = askbot.models.Group.objects.get(id = group_id)
        group.logo_url = image_url
        group.save()
    else:
        raise ValueError()

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def add_group(request):
    group_name = request.POST.getgroup
    if group_name:
        group = askbot.models.Group.objects.get_or_create(
                            name=group_name,
                            openness=askbot.models.Group.OPEN,
                            user=request.user,
                        )

        url = reverse(users_by_group, kwargs={group_id: group.id,
                   group_slug: slugify(group_name)})
        response_dict = dict(group_name = group_name,
                             url = url )
        return response_dict

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def delete_group_logo(request):
    group_id = IntegerField().clean(int(request.POST[group_id]))
    group = askbot.models.Group.objects.get(id = group_id)
    group.logo_url = None
    group.save()


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def delete_post_reject_reason(request):
    reason_id = IntegerField().clean(int(request.POST[reason_id]))
    reason = askbot.models.PostFlagReason.objects.get(id = reason_id)
    reason.delete()


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def toggle_group_profile_property(request):
    
    group_id = IntegerField().clean(int(request.POST[group_id]))
    property_name = CharField().clean(request.POST[property_name])
    assert property_name in ('moderate_email', 'moderate_answers_to_enquirers', 'is_vip')
    group = askbot.models.Group.objects.get(id = group_id)
    new_value = not getattr(group, property_name)
    setattr(group, property_name, new_value)
    group.save()
    return {is_enabled: new_value}


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def set_group_openness(request):
    group_id = IntegerField().clean(int(request.POST[group_id]))
    value = IntegerField().clean(int(request.POST[value]))
    group = askbot.models.Group.objects.get(id=group_id)
    group.openness = value
    group.save()


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.admins_only
def edit_object_property_text(request):
    model_name = CharField().clean(request.REQUEST[model_name])
    object_id = IntegerField().clean(request.REQUEST[object_id])
    property_name = CharField().clean(request.REQUEST[property_name])

    accessible_fields = (('Group', 'preapproved_emails'), ('Group', 'preapproved_email_domains'))

    if (model_name, property_name) not in accessible_fields:
        raise django.core.exceptions.PermissionDenied()

    obj = askbot.models.get_model(model_name).objects.get(id=object_id)
    if request.method == POST:
        text = CharField().clean(request.POST[text])
        setattr(obj, property_name, text)
        obj.save()
    elif request.method == GET:
        return {text: getattr(obj, property_name)}
    else:
        raise django.core.exceptions.PermissionDenied()


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def join_or_leave_group(request):
    
    if request.user.is_anonymous():
        raise django.core.exceptions.PermissionDenied()

    Group = askbot.models.Group
    Membership = askbot.models.GroupMembership

    group_id = IntegerField().clean(request.POST[group_id])
    group = Group.objects.get(id=group_id)

    membership = request.user.get_group_membership(group)
    if membership is None:
        membership = request.user.join_group(group)
        new_level = membership.get_level_display()
    else:
        membership.delete()
        new_level = Membership.get_level_value_display(Membership.NONE)

    return {membership_level: new_level}


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def save_post_reject_reason(request):
    
    form = askbot.forms.EditRejectReasonForm(request.POST)
    if form.is_valid():
        title = form.cleaned_data[title]
        details = form.cleaned_data[details]
        if form.cleaned_data[reason_id] is None:
            reason = request.user.create_post_reject_reason(
                title = title, details = details
            )
        else:
            reason_id = form.cleaned_data[reason_id]
            reason = askbot.models.PostFlagReason.objects.get(id = reason_id)
            request.user.edit_post_reject_reason(
                reason, title = title, details = details
            )
        return {
            reason_id: reason.id,
            title: title,
            details: details
        }
    else:
        raise Exception(askbot.forms.format_form_errors(form))

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
@askbot.utils.decorators.admins_only
def moderate_suggested_tag(request):
    
    form = askbot.forms.ModerateTagForm(request.POST)
    if form.is_valid():
        tag_id = form.cleaned_data[tag_id]
        thread_id = form.cleaned_data.get('thread_id', None)

        try:
            tag = askbot.models.Tag.objects.get(id=tag_id)
        except askbot.models.Tag.DoesNotExist:
            return

        if thread_id:
            threads = askbot.models.Thread.objects.filter(id=thread_id)
        else:
            threads = tag.threads.none()

        if form.cleaned_data[action] == accept:
            
            
            
            tag.status = askbot.models.Tag.STATUS_ACCEPTED
            tag.save()
            for thread in threads:
                thread.add_tag(
                    tag_name = tag.name,
                    user = tag.created_by,
                    timestamp = datetime.datetime.now(),
                    silent = True
                )
        else:
            if tag.threads.count() > len(threads):
                for thread in threads:
                    thread.tags.remove(tag)
                tag.used_count = tag.threads.count()
                tag.save()
            elif tag.status == askbot.models.Tag.STATUS_SUGGESTED:
                tag.delete()
    else:
        raise Exception(askbot.forms.format_form_errors(form))


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def save_draft_question(request):
    
    
    if request.user.is_anonymous():
        return

    form = askbot.forms.DraftQuestionForm(request.POST)
    if form.is_valid():
        title = form.cleaned_data.get('title', '')
        text = form.cleaned_data.get('text', '')
        tagnames = form.cleaned_data.get('tagnames', '')
        if title or text or tagnames:
            try:
                draft = askbot.models.DraftQuestion.objects.get(author=request.user)
            except askbot.models.DraftQuestion.DoesNotExist:
                draft = askbot.models.DraftQuestion()

            draft.title = title
            draft.text = text
            draft.tagnames = tagnames
            draft.author = request.user
            draft.save()


@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def save_draft_answer(request):
    
    
    if request.user.is_anonymous():
        return

    form = askbot.forms.DraftAnswerForm(request.POST)
    if form.is_valid():
        thread_id = form.cleaned_data[thread_id]
        try:
            thread = askbot.models.Thread.objects.get(id=thread_id)
        except askbot.models.Thread.DoesNotExist:
            return
        try:
            draft = askbot.models.DraftAnswer.objects.get(
                                            thread=thread,
                                            author=request.user
                                    )
        except askbot.models.DraftAnswer.DoesNotExist:
            draft = askbot.models.DraftAnswer()

        draft.author = request.user
        draft.thread = thread
        draft.text = form.cleaned_data.get('text', '')
        draft.save()

@askbot.utils.decorators.get_only
def get_users_info(request):
    
    if request.user.is_anonymous():
        return HttpResponseForbidden()

    query = request.GET[q]
    limit = IntegerField().clean(request.GET[limit])

    users = askbot.models.User.objects
    user_info_list = users.filter(username__istartswith=query)

    if request.user.is_administrator_or_moderator():
        user_info_list = user_info_list.values_list('username', 'email')
    else:
        user_info_list = user_info_list.values_listusername

    result_list = [<built-in method join of str object at 0x7f5fe6c6fa28>(info) for info in user_info_list[:limit]]
    return HttpResponse(<built-in method join of str object at 0x7f5fe6c6e138>(result_list), mimetype = text/plain)

@django.views.askbot.utils.decorators.csrf.csrf_protect
def share_question_with_group(request):
    form = askbot.forms.ShareQuestionForm(request.POST)
    try:
        if form.is_valid():

            thread_id = form.cleaned_data[thread_id]
            group_name = form.cleaned_data[recipient_name]

            thread = askbot.models.Thread.objects.get(id=thread_id)
            question_post = thread._question_post()

            
            sets1 = question_post.get_notify_sets(
                                    mentioned_users=list(),
                                    exclude_list=[request.user,]
                                )

            
            if group_name == askbot.conf.settings.GLOBAL_GROUP_NAME:
                thread.make_public(recursive=True)
            else:
                group = askbot.models.Group.objects.get(name=group_name)
                thread.add_to_groups((group,), recursive=True)

            
            sets2 = question_post.get_notify_sets(
                                    mentioned_users=list(),
                                    exclude_list=[request.user,]
                                )

            notify_sets = {
                for_mentions: sets2[for_mentions] - sets1[for_mentions],
                for_email: sets2[for_email] - sets1[for_email],
                for_inbox: sets2[for_inbox] - sets1[for_inbox]
            }

            question_post.issue_update_notifications(
                updated_by=request.user,
                notify_sets=notify_sets,
                activity_type=askbot.const.TYPE_ACTIVITY_POST_SHARED,
                timestamp=datetime.datetime.now()
            )

            return HttpResponseRedirect(thread.get_absolute_url())
    except Exception:
        error_message = _Sorry, looks like sharing request was invalid
        request.user.message_set.create(message=error_message)
        return HttpResponseRedirect(thread.get_absolute_url())

@django.views.askbot.utils.decorators.csrf.csrf_protect
def share_question_with_user(request):
    form = askbot.forms.ShareQuestionForm(request.POST)
    try:
        if form.is_valid():

            thread_id = form.cleaned_data[thread_id]
            username = form.cleaned_data[recipient_name]

            thread = askbot.models.Thread.objects.get(id=thread_id)
            user = askbot.models.User.objects.get(username=username)
            group = user.get_personal_group()
            thread.add_to_groups([group], recursive=True)
            
            
            notify_sets = {
                for_inbox: set([user]),
                for_mentions: set([user]),
                for_email: set([user])
            }
            thread._question_post().issue_update_notifications(
                updated_by=request.user,
                notify_sets=notify_sets,
                activity_type=askbot.const.TYPE_ACTIVITY_POST_SHARED,
                timestamp=datetime.datetime.now()
            )

            return HttpResponseRedirect(thread.get_absolute_url())
    except Exception:
        error_message = _Sorry, looks like sharing request was invalid
        request.user.message_set.create(message=error_message)
        return HttpResponseRedirect(thread.get_absolute_url())

@django.views.askbot.utils.decorators.csrf.csrf_protect
def moderate_group_join_request(request):
    
    request_id = IntegerField().clean(request.POST[request_id])
    action = request.POST[action]
    assert(action in ('approve', 'deny'))

    activity = get_object_or_404(askbot.models.Activity, pk=request_id)
    group = activity.content_object
    applicant = activity.user

    if group.has_moderator(request.user):
        group_membership = askbot.models.GroupMembership.objects.get(
                                            user=applicant, group=group
                                        )
        if action == approve:
            group_membership.level = askbot.models.GroupMembership.FULL
            group_membership.save()
            msg_data = {user: applicant.username, group: group.name}
            message = _%(user)s, welcome to group %(group)s! % msg_data
            applicant.message_set.create(message=message)
        else:
            group_membership.delete()

        activity.delete()
        url = request.user.get_absolute_url() + ?sort=inbox&section=join_requests
        return HttpResponseRedirect(url)
    else:
        raise Http404

@askbot.utils.decorators.get_only
def get_editor(request):
    
    if config not in request.GET:
        return HttpResponseForbidden()
    config = django.utils.simplejson.loads(request.GET[config])
    element_id = request.GET.get('id', 'editor')
    form = askbot.forms.EditorForm(
                attrs={id: element_id},
                editor_attrs=config,
                user=request.user
            )
    editor_html = render_text_into_skin(
        {{ form.media }} {{ form.editor }},
        {form: form},
        request
    )
    
    
    html_soup = BeautifulSoup(editor_html)

    parsed_scripts = list()
    for script in html_soup.find_allscript:
        parsed_scripts.append({
            contents: script.string,
            src: script.get('src', None)
        })

    data = {
        html: str(html_soup.textarea),
        scripts: parsed_scripts,
        success: True
    }
    return HttpResponse(django.utils.simplejson.dumps(data), mimetype=application/json)

@django.views.askbot.utils.decorators.csrf.csrf_exempt
@askbot.utils.decorators.ajax_only
@askbot.utils.decorators.post_only
def publish_answer(request):
    
    denied_msg = _Sorry, only thread moderators can use this function
    if request.user.is_authenticated():
        if request.user.is_administrator_or_moderator() is False:
            raise django.core.exceptions.PermissionDenied(denied_msg)
    
    answer_id = IntegerField().clean(request.POST[answer_id])
    answer = askbot.models.Post.objects.get(id=answer_id, post_type=answer)

    if answer.thread.has_moderator(request.user) is False:
        raise django.core.exceptions.PermissionDenied(denied_msg)

    enquirer = answer.thread._question_post().author
    enquirer_group = enquirer.get_personal_group()

    if answer.has_group(enquirer_group):
        message = _The answer is now unpublished
        answer.remove_from_groups([enquirer_group])
    else:
        answer.add_to_groups([enquirer_group])
        message = _The answer is now published
        
    request.user.message_set.create(message=message)
    return {redirect_url: answer.get_absolute_url()}
