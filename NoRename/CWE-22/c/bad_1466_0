







                                           ZopfliInitOptions(),
                                           ZopfliOptions */

static struct {
    char *prog;
    int ind;
    int outd;
    char inf[PATH_MAX+1];
    char *outf;
    int verbosity;
    int headis;
    int pipeout;
    int keep;
    int force;
    int form;
    unsigned char magic1;
    int recurse;
    char *sufx;
    char *name;
    time_t mtime;
    int list;
    int first;
    int decode;
    int level;
    ZopfliOptions zopts;
    int rsync;
    int procs;
    int setdict;
    size_t block;


    time_t stamp;
    char *hname;
    unsigned long zip_crc;
    unsigned long zip_clen;
    unsigned long zip_ulen;


    unsigned char in_buf[32768U];
    unsigned char *in_next;
    size_t in_left;
    int in_eof;
    int in_short;
    off_t in_tot;
    off_t out_tot;
    unsigned long out_check;



    unsigned char in_buf2[32768U];
    size_t in_len;
    int in_which;
    lock *load_state;
    thread *load_thread;

} g;


static int complain(char *fmt, ...)
{
    va_list ap;

    if (g.verbosity > 0) {
        fprintf(stderr, "%s: ", g.prog);
        va_start(ap, fmt);
        vfprintf(stderr, fmt, ap);
        va_end(ap);
        putc('\n', stderr);
        fflush(stderr);
    }
    return 0;
}


static int bail(char *why, char *what)
{
    if (g.outd != -1 && g.outf != NULL)
        unlink(g.outf);
    complain("abort: %s%s", why, what);
    exit(1);
    return 0;
}

static size_t readn(int desc, unsigned char *buf, size_t len)
{
    ssize_t ret;
    size_t got;

    got = 0;
    while (len) {
        ret = read(desc, buf, len);
        if (ret < 0)
            bail("read error on ", g.inf);
        if (ret == 0)
            break;
        buf += ret;
        len -= ret;
        got += ret;
    }
    return got;
}


static void writen(int desc, unsigned char *buf, size_t len)
{
    ssize_t ret;

    while (len) {
        ret = write(desc, buf, len);
        if (ret < 1) {
            complain("write error code %d", errno);
            bail("write error on ", g.outf);
        }
        buf += ret;
        len -= ret;
    }
}



static unsigned long time2dos(time_t t)
{
    struct tm *tm;
    unsigned long dos;

    if (t == 0)
        t = time(NULL);
    tm = localtime(&t);
    if (tm->tm_year < 80 || tm->tm_year > 207)
        return 0;
    dos = (tm->tm_year - 80) << 25;
    dos += (tm->tm_mon + 1) << 21;
    dos += tm->tm_mday << 16;
    dos += tm->tm_hour << 11;
    dos += tm->tm_min << 5;
    dos += (tm->tm_sec + 1) >> 1;
    return dos;
}







static unsigned long put_header(void)
{
    unsigned long len;
    unsigned char head[30];

    if (g.form > 1) {

        ((*(head)=((0x04034b50UL)&0xffff)&0xff,(head)[1]=((0x04034b50UL)&0xffff)>>8),(*((head)+2)=((0x04034b50UL)>>16)&0xff,((head)+2)[1]=((0x04034b50UL)>>16)>>8));
        (*(head + 4)=20&0xff,(head + 4)[1]=0);
        (*(head + 6)=8&0xff,(head + 6)[1]=0);
        (*(head + 8)=8&0xff,(head + 8)[1]=0);
        ((*(head + 10)=((time2dos(g.mtime))&0xffff)&0xff,(head + 10)[1]=((time2dos(g.mtime))&0xffff)>>8),(*((head + 10)+2)=((time2dos(g.mtime))>>16)&0xff,((head + 10)+2)[1]=((time2dos(g.mtime))>>16)>>8));
        ((*(head + 14)=(0&0xffff)&0xff,(head + 14)[1]=(0&0xffff)>>8),(*((head + 14)+2)=0&0xff,((head + 14)+2)[1]=0));
        ((*(head + 18)=(0&0xffff)&0xff,(head + 18)[1]=(0&0xffff)>>8),(*((head + 18)+2)=0&0xff,((head + 18)+2)[1]=0));
        ((*(head + 22)=(0&0xffff)&0xff,(head + 22)[1]=(0&0xffff)>>8),(*((head + 22)+2)=0&0xff,((head + 22)+2)[1]=0));
        (*(head + 26)=(g.name == NULL ? 1 : strlen(g.name))&0xff,(head + 26)[1]=(g.name == NULL ? 1 : strlen(g.name))>>8);

        (*(head + 28)=9&0xff,(head + 28)[1]=0);
        writen(g.outd, head, 30);
        len = 30;


        if (g.name == NULL)
            writen(g.outd, (unsigned char *)"-", 1);
        else
            writen(g.outd, (unsigned char *)g.name, strlen(g.name));
        len += g.name == NULL ? 1 : strlen(g.name);


        (*(head)=(0x5455)&0xff,(head)[1]=(0x5455)>>8);
        (*(head + 2)=5&0xff,(head + 2)[1]=0);
        head[4] = 1;
        ((*(head + 5)=((g.mtime)&0xffff)&0xff,(head + 5)[1]=((g.mtime)&0xffff)>>8),(*((head + 5)+2)=((g.mtime)>>16)&0xff,((head + 5)+2)[1]=((g.mtime)>>16)>>8));
        writen(g.outd, head, 9);
        len += 9;
    }
    else if (g.form) {
        head[0] = 0x78;
        head[1] = (g.level >= 9 ? 3 :
                   (g.level == 1 ? 0 :
                    (g.level >= 6 || g.level == Z_DEFAULT_COMPRESSION ?
                        1 : 2))) << 6;
        head[1] += 31 - (((head[0] << 8) + head[1]) % 31);
        writen(g.outd, head, 2);
        len = 2;
    }
    else {
        head[0] = 31;
        head[1] = 139;
        head[2] = 8;
        head[3] = g.name != NULL ? 8 : 0;
        ((*(head + 4)=((g.mtime)&0xffff)&0xff,(head + 4)[1]=((g.mtime)&0xffff)>>8),(*((head + 4)+2)=((g.mtime)>>16)&0xff,((head + 4)+2)[1]=((g.mtime)>>16)>>8));
        head[8] = g.level >= 9 ? 2 : (g.level == 1 ? 4 : 0);
        head[9] = 3;
        writen(g.outd, head, 10);
        len = 10;
        if (g.name != NULL)
            writen(g.outd, (unsigned char *)g.name, strlen(g.name) + 1);
        if (g.name != NULL)
            len += strlen(g.name) + 1;
    }
    return len;
}


static void put_trailer(unsigned long ulen, unsigned long clen,
                       unsigned long check, unsigned long head)
{
    unsigned char tail[46];

    if (g.form > 1) {
        unsigned long cent;


        ((*(tail)=((0x08074b50UL)&0xffff)&0xff,(tail)[1]=((0x08074b50UL)&0xffff)>>8),(*((tail)+2)=((0x08074b50UL)>>16)&0xff,((tail)+2)[1]=((0x08074b50UL)>>16)>>8));
        ((*(tail + 4)=((check)&0xffff)&0xff,(tail + 4)[1]=((check)&0xffff)>>8),(*((tail + 4)+2)=((check)>>16)&0xff,((tail + 4)+2)[1]=((check)>>16)>>8));
        ((*(tail + 8)=((clen)&0xffff)&0xff,(tail + 8)[1]=((clen)&0xffff)>>8),(*((tail + 8)+2)=((clen)>>16)&0xff,((tail + 8)+2)[1]=((clen)>>16)>>8));
        ((*(tail + 12)=((ulen)&0xffff)&0xff,(tail + 12)[1]=((ulen)&0xffff)>>8),(*((tail + 12)+2)=((ulen)>>16)&0xff,((tail + 12)+2)[1]=((ulen)>>16)>>8));
        writen(g.outd, tail, 16);


        ((*(tail)=((0x02014b50UL)&0xffff)&0xff,(tail)[1]=((0x02014b50UL)&0xffff)>>8),(*((tail)+2)=((0x02014b50UL)>>16)&0xff,((tail)+2)[1]=((0x02014b50UL)>>16)>>8));
        tail[4] = 63;
        tail[5] = 255;
        (*(tail + 6)=20&0xff,(tail + 6)[1]=0);
        (*(tail + 8)=8&0xff,(tail + 8)[1]=0);
        (*(tail + 10)=8&0xff,(tail + 10)[1]=0);
        ((*(tail + 12)=((time2dos(g.mtime))&0xffff)&0xff,(tail + 12)[1]=((time2dos(g.mtime))&0xffff)>>8),(*((tail + 12)+2)=((time2dos(g.mtime))>>16)&0xff,((tail + 12)+2)[1]=((time2dos(g.mtime))>>16)>>8));
        ((*(tail + 16)=((check)&0xffff)&0xff,(tail + 16)[1]=((check)&0xffff)>>8),(*((tail + 16)+2)=((check)>>16)&0xff,((tail + 16)+2)[1]=((check)>>16)>>8));
        ((*(tail + 20)=((clen)&0xffff)&0xff,(tail + 20)[1]=((clen)&0xffff)>>8),(*((tail + 20)+2)=((clen)>>16)&0xff,((tail + 20)+2)[1]=((clen)>>16)>>8));
        ((*(tail + 24)=((ulen)&0xffff)&0xff,(tail + 24)[1]=((ulen)&0xffff)>>8),(*((tail + 24)+2)=((ulen)>>16)&0xff,((tail + 24)+2)[1]=((ulen)>>16)>>8));
        (*(tail + 28)=(g.name == NULL ? 1 : strlen(g.name))&0xff,(tail + 28)[1]=(g.name == NULL ? 1 : strlen(g.name))>>8);

        (*(tail + 30)=9&0xff,(tail + 30)[1]=0);
        (*(tail + 32)=0&0xff,(tail + 32)[1]=0);
        (*(tail + 34)=0&0xff,(tail + 34)[1]=0);
        (*(tail + 36)=0&0xff,(tail + 36)[1]=0);
        ((*(tail + 38)=(0&0xffff)&0xff,(tail + 38)[1]=(0&0xffff)>>8),(*((tail + 38)+2)=0&0xff,((tail + 38)+2)[1]=0));
        ((*(tail + 42)=(0&0xffff)&0xff,(tail + 42)[1]=(0&0xffff)>>8),(*((tail + 42)+2)=0&0xff,((tail + 42)+2)[1]=0));
        writen(g.outd, tail, 46);
        cent = 46;


        if (g.name == NULL)
            writen(g.outd, (unsigned char *)"-", 1);
        else
            writen(g.outd, (unsigned char *)g.name, strlen(g.name));
        cent += g.name == NULL ? 1 : strlen(g.name);


        (*(tail)=(0x5455)&0xff,(tail)[1]=(0x5455)>>8);
        (*(tail + 2)=5&0xff,(tail + 2)[1]=0);
        tail[4] = 1;
        ((*(tail + 5)=((g.mtime)&0xffff)&0xff,(tail + 5)[1]=((g.mtime)&0xffff)>>8),(*((tail + 5)+2)=((g.mtime)>>16)&0xff,((tail + 5)+2)[1]=((g.mtime)>>16)>>8));
        writen(g.outd, tail, 9);
        cent += 9;


        ((*(tail)=((0x06054b50UL)&0xffff)&0xff,(tail)[1]=((0x06054b50UL)&0xffff)>>8),(*((tail)+2)=((0x06054b50UL)>>16)&0xff,((tail)+2)[1]=((0x06054b50UL)>>16)>>8));
        (*(tail + 4)=0&0xff,(tail + 4)[1]=0);
        (*(tail + 6)=0&0xff,(tail + 6)[1]=0);
        (*(tail + 8)=1&0xff,(tail + 8)[1]=0);
        (*(tail + 10)=1&0xff,(tail + 10)[1]=0);
        ((*(tail + 12)=((cent)&0xffff)&0xff,(tail + 12)[1]=((cent)&0xffff)>>8),(*((tail + 12)+2)=((cent)>>16)&0xff,((tail + 12)+2)[1]=((cent)>>16)>>8));
        ((*(tail + 16)=((head + clen + 16)&0xffff)&0xff,(tail + 16)[1]=((head + clen + 16)&0xffff)>>8),(*((tail + 16)+2)=((head + clen + 16)>>16)&0xff,((tail + 16)+2)[1]=((head + clen + 16)>>16)>>8));
        (*(tail + 20)=0&0xff,(tail + 20)[1]=0);
        writen(g.outd, tail, 22);
    }
    else if (g.form) {
        (*(tail)=(check)>>24,(tail)[1]=(check)>>16,(tail)[2]=(check)>>8,(tail)[3]=(check));
        writen(g.outd, tail, 4);
    }
    else {
        ((*(tail)=((check)&0xffff)&0xff,(tail)[1]=((check)&0xffff)>>8),(*((tail)+2)=((check)>>16)&0xff,((tail)+2)[1]=((check)>>16)>>8));
        ((*(tail + 4)=((ulen)&0xffff)&0xff,(tail + 4)[1]=((ulen)&0xffff)>>8),(*((tail + 4)+2)=((ulen)>>16)&0xff,((tail + 4)+2)[1]=((ulen)>>16)>>8));
        writen(g.outd, tail, 8);
    }
}

static unsigned long gf2_matrix_times(unsigned long *mat, unsigned long vec)
{
    unsigned long sum;

    sum = 0;
    while (vec) {
        if (vec & 1)
            sum ^= *mat;
        vec >>= 1;
        mat++;
    }
    return sum;
}

static void gf2_matrix_square(unsigned long *square, unsigned long *mat)
{
    int n;

    for (n = 0; n < 32; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}

static unsigned long crc32_comb(unsigned long crc1, unsigned long crc2,
                               size_t len2)
{
    int n;
    unsigned long row;
    unsigned long even[32];
    unsigned long odd[32];


    if (len2 == 0)
        return crc1;


    odd[0] = 0xedb88320UL;
    row = 1;
    for (n = 1; n < 32; n++) {
        odd[n] = row;
        row <<= 1;
    }


    gf2_matrix_square(even, odd);


    gf2_matrix_square(odd, even);



    do {

        gf2_matrix_square(even, odd);
        if (len2 & 1)
            crc1 = gf2_matrix_times(even, crc1);
        len2 >>= 1;


        if (len2 == 0)
            break;


        gf2_matrix_square(odd, even);
        if (len2 & 1)
            crc1 = gf2_matrix_times(odd, crc1);
        len2 >>= 1;


    } while (len2 != 0);


    crc1 ^= crc2;
    return crc1;
}




static unsigned long adler32_comb(unsigned long adler1, unsigned long adler2,
                                 size_t len2)
{
    unsigned long sum1;
    unsigned long sum2;
    unsigned rem;


    rem = (unsigned)(len2 % 65521U);
    sum1 = adler1 & 0xffff;
    sum2 = (rem * sum1) % 65521U;
    sum1 += (adler2 & 0xffff) + 65521U - 1;
    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + 65521U - rem;
    if (sum1 >= 65521U) sum1 -= 65521U;
    if (sum1 >= 65521U) sum1 -= 65521U;
    if (sum2 >= (65521U << 1)) sum2 -= (65521U << 1);
    if (sum2 >= 65521U) sum2 -= 65521U;
    return sum1 | (sum2 << 16);
}

struct space {
    lock *use;
    unsigned char *buf;
    size_t size;
    size_t len;
    struct pool *pool;
    struct space *next;
};


struct pool {
    lock *have;
    struct space *head;
    size_t size;
    int limit;
    int made;
};




static void new_pool(struct pool *pool, size_t size, int limit)
{
    pool->have = new_lock(0);
    pool->head = NULL;
    pool->size = size;
    pool->limit = limit;
    pool->made = 0;
}



static struct space *get_space(struct pool *pool)
{
    struct space *space;


    possess(pool->have);
    if (pool->limit == 0)
        wait_for(pool->have, NOT_TO_BE, 0);


    if (pool->head != NULL) {
        space = pool->head;
        possess(space->use);
        pool->head = space->next;
        twist(pool->have, BY, -1);
        twist(space->use, TO, 1);
        space->len = 0;
        return space;
    }


    assert(pool->limit != 0);
    if (pool->limit > 0)
        pool->limit--;
    pool->made++;
    release(pool->have);
    space = malloc(sizeof(struct space));
    if (space == NULL)
        bail("not enough memory", "");
    space->use = new_lock(1);
    space->buf = malloc(pool->size);
    if (space->buf == NULL)
        bail("not enough memory", "");
    space->size = pool->size;
    space->len = 0;
    space->pool = pool;
    return space;
}




static size_t grow(size_t size)
{
    size_t was, top;
    int shift;

    was = size;
    size += size >> 2;
    top = size;
    for (shift = 0; top > 7; shift++)
        top >>= 1;
    if (top == 7)
        size = (size_t)1 << (shift + 3);
    if (size < 16)
        size = 16;
    if (size <= was)
        size = (size_t)0 - 1;
    return size;
}


static void grow_space(struct space *space)
{
    size_t more;


    more = grow(space->size);
    if (more == space->size)
        bail("not enough memory", "");


    space->buf = realloc(space->buf, more);
    if (space->buf == NULL)
        bail("not enough memory", "");
    space->size = more;
}



static void use_space(struct space *space)
{
    possess(space->use);
    twist(space->use, BY, 1);
}


static void drop_space(struct space *space)
{
    int use;
    struct pool *pool;

    possess(space->use);
    use = peek_lock(space->use);
    assert(use != 0);
    if (use == 1) {
        pool = space->pool;
        possess(pool->have);
        space->next = pool->head;
        pool->head = space;
        twist(pool->have, BY, 1);
    }
    twist(space->use, BY, -1);
}



static int free_pool(struct pool *pool)
{
    int count;
    struct space *space;

    possess(pool->have);
    count = 0;
    while ((space = pool->head) != NULL) {
        pool->head = space->next;
        free(space->buf);
        free_lock(space->use);
        free(space);
        count++;
    }
    assert(count == pool->made);
    release(pool->have);
    free_lock(pool->have);
    return count;
}


static struct pool in_pool;
static struct pool out_pool;
static struct pool dict_pool;
static struct pool lens_pool;






struct job {
    long seq;
    int more;
    struct space *in;
    struct space *out;
    struct space *lens;
    unsigned long check;
    lock *calc;
    struct job *next;
};


static lock *compress_have = NULL;
static struct job *compress_head, **compress_tail;


static lock *write_first;
static struct job *write_head;


static int cthreads = 0;


static thread *writeth = NULL;


static void setup_jobs(void)
{

    if (compress_have != NULL)
        return;


    compress_have = new_lock(0);
    compress_head = NULL;
    compress_tail = &compress_head;
    write_first = new_lock(-1);
    write_head = NULL;




    new_pool(&in_pool, g.block, (((g.procs)<<1)+3));
    new_pool(&out_pool, ((g.block)+((g.block)>>4)+32768U), -1);
    new_pool(&dict_pool, 32768U, -1);
    new_pool(&lens_pool, g.block >> 11, -1);
}



static void finish_jobs(void)
{
    struct job job;
    int caught;


    if (compress_have == NULL)
        return;


    possess(compress_have);
    job.seq = -1;
    job.next = NULL;
    compress_head = &job;
    compress_tail = &(job.next);
    twist(compress_have, BY, 1);


    caught = join_all();
                                                    ;
    assert(caught == cthreads);
    cthreads = 0;


    caught = free_pool(&lens_pool);
                                                        ;
    caught = free_pool(&dict_pool);
                                                     ;
    caught = free_pool(&out_pool);
                                                 ;
    caught = free_pool(&in_pool);
                                                ;
    free_lock(write_first);
    free_lock(compress_have);
    compress_have = NULL;
}





static void deflate_engine(z_stream *strm, struct space *out, int flush)
{
    size_t room;

    do {
        room = out->size - out->len;
        if (room == 0) {
            grow_space(out);
            room = out->size - out->len;
        }
        strm->next_out = out->buf + out->len;
        strm->avail_out = room < UINT_MAX ? (unsigned)room : UINT_MAX;
        (void)deflate(strm, flush);
        out->len = strm->next_out - out->buf;
    } while (strm->avail_out == 0);
    assert(strm->avail_in == 0);
}






static void compress_thread(void *dummy)
{
    struct job *job;
    struct job *here, **prior;
    unsigned long check;
    unsigned char *next;
    size_t left;
    size_t len;



    struct space *temp = NULL;
    z_stream strm;

    (void)dummy;


    strm.zfree = Z_NULL;
    strm.zalloc = Z_NULL;
    strm.opaque = Z_NULL;
    if (deflateInit2(&strm, 6, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK)
        bail("not enough memory", "");


    for (;;) {

        possess(compress_have);
        wait_for(compress_have, NOT_TO_BE, 0);
        job = compress_head;
        assert(job != NULL);
        if (job->seq == -1)
            break;
        compress_head = job->next;
        if (job->next == NULL)
            compress_tail = &compress_head;
        twist(compress_have, BY, -1);




                                                ;
        if (g.level <= 9) {
            (void)deflateReset(&strm);
            (void)deflateParams(&strm, g.level, Z_DEFAULT_STRATEGY);
        }
        else {
            temp = get_space(&out_pool);
            temp->len = 0;
        }




        if (job->out != NULL) {
            len = job->out->len;
            left = len < 32768U ? len : 32768U;
            if (g.level <= 9)
                deflateSetDictionary(&strm, job->out->buf + (len - left),
                                     left);
            else {
                memcpy(temp->buf, job->out->buf + (len - left), left);
                temp->len = left;
            }
            drop_space(job->out);
        }


        job->out = get_space(&out_pool);
        if (g.level <= 9) {
            strm.next_in = job->in->buf;
            strm.next_out = job->out->buf;
        }
        else
            memcpy(temp->buf + temp->len, job->in->buf, job->in->len);


        next = job->lens == NULL ? NULL : job->lens->buf;
        left = job->in->len;
        job->out->len = 0;
        do {

            len = next == NULL ? 128 : *next++;
            if (len < 128)
                len = (len << 8) + (*next++) + 64;
            else if (len == 128)
                len = left;
            else if (len < 192)
                len &= 0x3f;
            else if (len < 224){
                len = ((len & 0x1f) << 16) + (*next++ << 8);
                len += *next++ + 32832U;
            }
            else {
                len = ((len & 0x1f) << 24) + (*next++ << 16);
                len += *next++ << 8;
                len += *next++ + 2129984UL;
            }
            left -= len;

            if (g.level <= 9) {




                while (len > (UINT_MAX - (UINT_MAX >> 1))) {
                    strm.avail_in = (UINT_MAX - (UINT_MAX >> 1));
                    deflate_engine(&strm, job->out, Z_NO_FLUSH);
                    len -= (UINT_MAX - (UINT_MAX >> 1));
                }




                strm.avail_in = (unsigned)len;
                if (left || job->more) {

                    deflate_engine(&strm, job->out, Z_SYNC_FLUSH);

                }
                else
                    deflate_engine(&strm, job->out, Z_FINISH);
            }
            else {

                unsigned char bits, *out;
                size_t outsize;

                out = NULL;
                outsize = 0;
                bits = 0;
                ZopfliDeflatePart(&g.zopts, 2, !(left || job->more),
                                  temp->buf, temp->len, temp->len + len,
                                  &bits, &out, &outsize);
                assert(job->out->len + outsize + 5 <= job->out->size);
                memcpy(job->out->buf + job->out->len, out, outsize);
                free(out);
                job->out->len += outsize;
                if (left || job->more) {
                    bits &= 7;
                    if (bits & 1) {
                        if (bits == 7)
                            job->out->buf[job->out->len++] = 0;
                        job->out->buf[job->out->len++] = 0;
                        job->out->buf[job->out->len++] = 0;
                        job->out->buf[job->out->len++] = 0xff;
                        job->out->buf[job->out->len++] = 0xff;
                    }
                    else if (bits) {
                        do {
                            job->out->buf[job->out->len - 1] += 2 << bits;
                            job->out->buf[job->out->len++] = 0;
                            bits += 2;
                        } while (bits < 8);
                    }
                }
                temp->len += len;
            }
        } while (left);
        if (g.level > 9)
            drop_space(temp);
        if (job->lens != NULL) {
            drop_space(job->lens);
            job->lens = NULL;
        }
                                                                             ;


        use_space(job->in);


        possess(write_first);
        prior = &write_head;
        while ((here = *prior) != NULL) {
            if (here->seq > job->seq)
                break;
            prior = &(here->next);
        }
        job->next = here;
        *prior = job;
        twist(write_first, TO, write_head->seq);




        len = job->in->len;
        next = job->in->buf;
        check = (g.form == 1 ? adler32(0L,Z_NULL,0) : crc32(0L,Z_NULL,0));
        while (len > (UINT_MAX - (UINT_MAX >> 1))) {
            check = (g.form == 1 ? adler32(check,next,(UINT_MAX - (UINT_MAX >> 1))) : crc32(check,next,(UINT_MAX - (UINT_MAX >> 1))));
            len -= (UINT_MAX - (UINT_MAX >> 1));
            next += (UINT_MAX - (UINT_MAX >> 1));
        }
        check = (g.form == 1 ? adler32(check,next,(unsigned)len) : crc32(check,next,(unsigned)len));
        drop_space(job->in);
        job->check = check;
                                                                          ;
        possess(job->calc);
        twist(job->calc, TO, 1);


    }


    release(compress_have);
    (void)deflateEnd(&strm);
}




static void write_thread(void *dummy)
{
    long seq;
    struct job *job;
    size_t len;
    int more;
    unsigned long head;
    unsigned long ulen;
    unsigned long clen;
    unsigned long check;

    (void)dummy;


                                      ;
    head = put_header();


    ulen = clen = 0;
    check = (g.form == 1 ? adler32(0L,Z_NULL,0) : crc32(0L,Z_NULL,0));
    seq = 0;
    do {

        possess(write_first);
        wait_for(write_first, TO_BE, seq);
        job = write_head;
        write_head = job->next;
        twist(write_first, TO, write_head == NULL ? -1 : write_head->seq);


        more = job->more;
        len = job->in->len;
        drop_space(job->in);
        ulen += (unsigned long)len;
        clen += (unsigned long)(job->out->len);


                                       ;
        writen(g.outd, job->out->buf, job->out->len);
        drop_space(job->out);
                                                              ;



        possess(job->calc);
        wait_for(job->calc, TO_BE, 1);
        release(job->calc);
        check = (g.form == 1 ? adler32_comb(check,job->check,len) : crc32_comb(check,job->check,len));


        free_lock(job->calc);
        free(job);


        seq++;
    } while (more);


    put_trailer(ulen, clen, check, head);


    possess(compress_have);
    assert(compress_head == NULL && peek_lock(compress_have) == 0);
    release(compress_have);
    possess(write_first);
    assert(write_head == NULL);
    twist(write_first, TO, -1);
}


static void append_len(struct job *job, size_t len)
{
    struct space *lens;

    assert(len < 539000896UL);
    if (job->lens == NULL)
        job->lens = get_space(&lens_pool);
    lens = job->lens;
    if (lens->size < lens->len + 3)
        grow_space(lens);
    if (len < 64)
        lens->buf[lens->len++] = len + 128;
    else if (len < 32832U) {
        len -= 64;
        lens->buf[lens->len++] = len >> 8;
        lens->buf[lens->len++] = len;
    }
    else if (len < 2129984UL) {
        len -= 32832U;
        lens->buf[lens->len++] = (len >> 16) + 192;
        lens->buf[lens->len++] = len >> 8;
        lens->buf[lens->len++] = len;
    }
    else {
        len -= 2129984UL;
        lens->buf[lens->len++] = (len >> 24) + 224;
        lens->buf[lens->len++] = len >> 16;
        lens->buf[lens->len++] = len >> 8;
        lens->buf[lens->len++] = len;
    }
}





static void parallel_compress(void)
{
    long seq;
    struct space *curr;
    struct space *next;
    struct space *hold;
    struct space *dict;
    struct job *job;
    int more;
    unsigned hash;
    unsigned char *scan;
    unsigned char *end;
    unsigned char *last;
    size_t left;
    size_t len;


    setup_jobs();


    writeth = launch(write_thread, NULL);



    seq = 0;
    next = get_space(&in_pool);
    next->len = readn(g.ind, next->buf, next->size);
    hold = NULL;
    dict = NULL;
    scan = next->buf;
    hash = (((1U << 12) - 1) >> 1);
    left = 0;
    do {

        job = malloc(sizeof(struct job));
        if (job == NULL)
            bail("not enough memory", "");
        job->calc = new_lock(0);


        curr = next;
        next = hold;
        hold = NULL;


        if (next == NULL) {
            next = get_space(&in_pool);
            next->len = readn(g.ind, next->buf, next->size);
        }



        job->lens = NULL;
        if (g.rsync && curr->len) {





            if (left == 0) {

                last = curr->buf;
                end = curr->buf + curr->len;
                while (scan < end) {
                    hash = ((hash << 1) ^ *scan++) & ((1U << 12) - 1);
                    if (hash == (((1U << 12) - 1) >> 1)) {
                        len = scan - last;
                        append_len(job, len);
                        last = scan;
                    }
                }


                left = scan - last;
                scan = next->buf;
            }





            last = next->buf;
            len = curr->size - curr->len;
            if (len > next->len)
                len = next->len;
            end = next->buf + len;
            while (scan < end) {
                hash = ((hash << 1) ^ *scan++) & ((1U << 12) - 1);
                if (hash == (((1U << 12) - 1) >> 1)) {
                    len = (scan - last) + left;
                    left = 0;
                    append_len(job, len);
                    last = scan;
                }
            }
            append_len(job, 0);



            len = (job->lens->len == 1 ? scan : last) - next->buf;
            if (len) {

                memcpy(curr->buf + curr->len, next->buf, len);
                curr->len += len;
                memmove(next->buf, next->buf + len, next->len - len);
                next->len -= len;
                scan -= len;
                left = 0;
            }
            else if (job->lens->len != 1 && left && next->len) {




                hold = next;
                next = get_space(&in_pool);
                memcpy(next->buf, curr->buf + (curr->len - left), left);
                next->len = left;
                curr->len -= left;
            }
            else {


                left = 0;
            }
        }


        job->in = curr;


        more = next->len != 0;
        job->more = more;


        job->out = dict;
        if (more && g.setdict) {
            if (curr->len >= 32768U || job->out == NULL) {
                dict = curr;
                use_space(dict);
            }
            else {
                dict = get_space(&dict_pool);
                len = 32768U - curr->len;
                memcpy(dict->buf, job->out->buf + (job->out->len - len), len);
                memcpy(dict->buf + len, curr->buf, curr->len);
                dict->len = 32768U;
            }
        }


        job->seq = seq;
                                                             ;
        if (++seq < 1)
            bail("input too long: ", g.inf);


        if (cthreads < seq && cthreads < g.procs) {
            (void)launch(compress_thread, NULL);
            cthreads++;
        }


        possess(compress_have);
        job->next = NULL;
        *compress_tail = job;
        compress_tail = &(job->next);
        twist(compress_have, BY, 1);
    } while (more);
    drop_space(next);



    join(writeth);
    writeth = NULL;
                                     ;
}

static void single_compress(int reset)
{
    size_t got;
    size_t more;
    size_t start;
    size_t have;
    size_t hist;
    int fresh;
    unsigned hash;
    unsigned char *scan;
    size_t left;
    unsigned long head;
    unsigned long ulen;
    unsigned long clen;
    unsigned long check;
    static unsigned out_size;
    static unsigned char *in, *next, *out;
    static z_stream *strm = NULL;


    if (reset) {
        if (strm != NULL) {
            (void)deflateEnd(strm);
            free(strm);
            free(out);
            free(next);
            free(in);
            strm = NULL;
        }
        return;
    }


    if (strm == NULL) {
        out_size = g.block > (UINT_MAX - (UINT_MAX >> 1)) ? (UINT_MAX - (UINT_MAX >> 1)) : (unsigned)g.block;
        if ((in = malloc(g.block + 32768U)) == NULL ||
            (next = malloc(g.block + 32768U)) == NULL ||
            (out = malloc(out_size)) == NULL ||
            (strm = malloc(sizeof(z_stream))) == NULL)
            bail("not enough memory", "");
        strm->zfree = Z_NULL;
        strm->zalloc = Z_NULL;
        strm->opaque = Z_NULL;
        if (deflateInit2(strm, 6, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) !=
                         Z_OK)
            bail("not enough memory", "");
    }


    head = put_header();


    if (g.level <= 9) {
        (void)deflateReset(strm);
        (void)deflateParams(strm, g.level, Z_DEFAULT_STRATEGY);
    }


    got = 0;
    more = readn(g.ind, next, g.block);
    ulen = (unsigned long)more;
    start = 0;
    hist = 0;
    clen = 0;
    have = 0;
    check = (g.form == 1 ? adler32(0L,Z_NULL,0) : crc32(0L,Z_NULL,0));
    hash = (((1U << 12) - 1) >> 1);
    do {

        if (got == 0) {
            scan = in; in = next; next = scan;
            strm->next_in = in + start;
            got = more;
            if (g.level > 9) {
                left = start + more - hist;
                if (left > 32768U)
                    left = 32768U;
                memcpy(next, in + ((start + more) - left), left);
                start = left;
                hist = 0;
            }
            else
                start = 0;
            more = readn(g.ind, next + start, g.block);
            ulen += (unsigned long)more;
        }


        left = 0;
        if (g.rsync && got) {
            scan = strm->next_in;
            left = got;
            do {
                if (left == 0) {


                    if (more == 0 || got == g.block)
                        break;



                    if (g.level > 9) {
                        left = (strm->next_in - in) - hist;
                        if (left > 32768U)
                            left = 32768U;
                    }
                    memmove(in, strm->next_in - left, left + got);
                    hist = 0;
                    strm->next_in = in + left;
                    scan = in + left + got;
                    left = more > g.block - got ? g.block - got : more;
                    memcpy(scan, next + start, left);
                    got += left;
                    more -= left;
                    start += left;


                    if (more == 0) {
                        more = readn(g.ind, next, g.block);
                        ulen += (unsigned long)more;
                        start = 0;
                    }
                }
                left--;
                hash = ((hash << 1) ^ *scan++) & ((1U << 12) - 1);
            } while (hash != (((1U << 12) - 1) >> 1));
            got -= left;
        }


        fresh = 0;
        if (!g.setdict) {
            have += got;
            if (have > g.block) {
                fresh = 1;
                have = got;
            }
        }

        if (g.level <= 9) {

            if (fresh)
                (void)deflateReset(strm);


            while (got > (UINT_MAX - (UINT_MAX >> 1))) {
                strm->avail_in = (UINT_MAX - (UINT_MAX >> 1));
                check = (g.form == 1 ? adler32(check,strm->next_in,strm->avail_in) : crc32(check,strm->next_in,strm->avail_in));
                do { do { strm->avail_out = out_size; strm->next_out = out; (void)deflate(strm, Z_NO_FLUSH); writen(g.outd, out, out_size - strm->avail_out); clen += out_size - strm->avail_out; } while (strm->avail_out == 0); assert(strm->avail_in == 0); } while 0;
                got -= (UINT_MAX - (UINT_MAX >> 1));
            }


            strm->avail_in = (unsigned)got;
            got = left;
            check = (g.form == 1 ? adler32(check,strm->next_in,strm->avail_in) : crc32(check,strm->next_in,strm->avail_in));
            if (more || got) {

                do { do { strm->avail_out = out_size; strm->next_out = out; (void)deflate(strm, Z_SYNC_FLUSH); writen(g.outd, out, out_size - strm->avail_out); clen += out_size - strm->avail_out; } while (strm->avail_out == 0); assert(strm->avail_in == 0); } while 0;

            }
            else
                do { do { strm->avail_out = out_size; strm->next_out = out; (void)deflate(strm, Z_FINISH); writen(g.outd, out, out_size - strm->avail_out); clen += out_size - strm->avail_out; } while (strm->avail_out == 0); assert(strm->avail_in == 0); } while 0;
        }
        else {

            unsigned char bits, *out;
            size_t outsize, off;


            off = strm->next_in - in;
            if (fresh)
                hist = off;

            out = NULL;
            outsize = 0;
            bits = 0;
            ZopfliDeflatePart(&g.zopts, 2, !(more || left),
                              in + hist, off - hist, (off - hist) + got,
                              &bits, &out, &outsize);
            bits &= 7;
            if ((more || left) && bits) {
                if (bits & 1) {
                    writen(g.outd, out, outsize);
                    if (bits == 7)
                        writen(g.outd, (unsigned char *)"\0", 1);
                    writen(g.outd, (unsigned char *)"\0\0\xff\xff", 4);
                }
                else {
                    assert(outsize > 0);
                    writen(g.outd, out, outsize - 1);
                    do {
                        out[outsize - 1] += 2 << bits;
                        writen(g.outd, out + outsize - 1, 1);
                        out[outsize - 1] = 0;
                        bits += 2;
                    } while (bits < 8);
                    writen(g.outd, out + outsize - 1, 1);
                }
            }
            else
                writen(g.outd, out, outsize);
            free(out);
            while (got > (UINT_MAX - (UINT_MAX >> 1))) {
                check = (g.form == 1 ? adler32(check,strm->next_in,(UINT_MAX - (UINT_MAX >> 1))) : crc32(check,strm->next_in,(UINT_MAX - (UINT_MAX >> 1))));
                strm->next_in += (UINT_MAX - (UINT_MAX >> 1));
                got -= (UINT_MAX - (UINT_MAX >> 1));
            }
            check = (g.form == 1 ? adler32(check,strm->next_in,(unsigned)got) : crc32(check,strm->next_in,(unsigned)got));
            strm->next_in += got;
            got = left;
        }


    } while (more || got);


    put_trailer(ulen, clen, check, head);
}





static void load_read(void *dummy)
{
    size_t len;

    (void)dummy;

                                                 ;
    do {
        possess(g.load_state);
        wait_for(g.load_state, TO_BE, 1);
        g.in_len = len = readn(g.ind, g.in_which ? g.in_buf : g.in_buf2, 32768U);
                                                                ;
        twist(g.load_state, TO, 0);
    } while (len == 32768U);
                                               ;
}







static size_t load(void)
{

    if (g.in_short) {
        g.in_eof = 1;
        g.in_left = 0;
        return 0;
    }




    if (g.procs > 1) {

        if (g.in_which == -1) {
            g.in_which = 1;
            g.load_state = new_lock(1);
            g.load_thread = launch(load_read, NULL);
        }


        possess(g.load_state);
        wait_for(g.load_state, TO_BE, 0);
        release(g.load_state);


        g.in_next = g.in_which ? g.in_buf : g.in_buf2;
        g.in_left = g.in_len;



        if (g.in_len == 32768U) {
            g.in_which = 1 - g.in_which;
            possess(g.load_state);
            twist(g.load_state, TO, 1);
        }


        else {
            join(g.load_thread);
            free_lock(g.load_state);
            g.in_which = -1;
        }
    }
    else

    {

        g.in_left = readn(g.ind, g.in_next = g.in_buf, 32768U);
    }


    if (g.in_left < 32768U) {
        g.in_short = 1;


        if (g.in_left == 0)
            g.in_eof = 1;
    }


    g.in_tot += g.in_left;
    return g.in_left;
}


static void in_init(void)
{
    g.in_left = 0;
    g.in_eof = 0;
    g.in_short = 0;
    g.in_tot = 0;

    g.in_which = -1;

}

static time_t dos2time(unsigned long dos)
{
    struct tm tm;

    if (dos == 0)
        return time(NULL);
    tm.tm_year = ((int)(dos >> 25) & 0x7f) + 80;
    tm.tm_mon = ((int)(dos >> 21) & 0xf) - 1;
    tm.tm_mday = (int)(dos >> 16) & 0x1f;
    tm.tm_hour = (int)(dos >> 11) & 0x1f;
    tm.tm_min = (int)(dos >> 5) & 0x3f;
    tm.tm_sec = (int)(dos << 1) & 0x3e;
    tm.tm_isdst = -1;
    return mktime(&tm);
}


static long tolong(unsigned long val)
{
    return (long)(val & 0x7fffffffUL) - (long)(val & 0x80000000UL);
}




static int read_extra(unsigned len, int save)
{
    unsigned id, size, tmp2;
    unsigned long tmp4;


    while (len >= 4) {
        id = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        size = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (g.in_eof)
            return -1;
        len -= 4;
        if (size > len)
            break;
        len -= size;
        if (id == 0x0001) {

            if (g.zip_ulen == 0xffffffffUL && size >= 8) {
                g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                do { size_t togo = 4; while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
                size -= 8;
            }
            if (g.zip_clen == 0xffffffffUL && size >= 8) {
                g.zip_clen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                do { size_t togo = 4; while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
                size -= 8;
            }
        }
        if (save) {
            if ((id == 0x000d || id == 0x5855) && size >= 8) {

                do { size_t togo = 4; while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
                g.stamp = tolong((tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16)));
                size -= 8;
            }
            if (id == 0x5455 && size >= 5) {

                size--;
                if ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)) & 1) {
                    g.stamp = tolong((tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16)));
                    size -= 4;
                }
            }
        }
        do { size_t togo = (size); while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
    }
    do { size_t togo = (len); while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
    return 0;
}

static int get_header(int save)
{
    unsigned magic;
    int method;
    int flags;
    unsigned fname, extra;
    unsigned tmp2;
    unsigned long tmp4;


    if (save) {
        g.stamp = 0;
        do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
    }


    g.form = -1;
    g.magic1 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
    if (g.in_eof)
        return -1;
    magic = g.magic1 << 8;
    magic += (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
    if (g.in_eof)
        return -2;
    if (magic % 31 == 0) {
        g.form = 1;
        return (int)((magic >> 8) & 0xf);
    }
    if (magic == 0x1f9d)
        return 257;
    if (magic == 0x504b) {
        magic = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (g.in_eof)
            return -3;
        if (magic == 0x0201 || magic == 0x0806)
            return -5;
        if (magic != 0x0403)
            return -4;
        do { size_t togo = 2; while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
        flags = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (g.in_eof)
            return -3;
        if (flags & 0xfff0)
            return -4;
        method = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
        if ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)) != 0 || flags & 1)
            method = 256;
        if (g.in_eof)
            return -3;
        if (save)
            g.stamp = dos2time((tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16)));
        else
            do { size_t togo = 4; while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
        g.zip_crc = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
        g.zip_clen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
        g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
        fname = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        extra = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (save) {
            char *next = g.hname = malloc(fname + 1);
            if (g.hname == NULL)
                bail("not enough memory", "");
            while (fname > g.in_left) {
                memcpy(next, g.in_next, g.in_left);
                fname -= g.in_left;
                next += g.in_left;
                if (load() == 0)
                    return -3;
            }
            memcpy(next, g.in_next, fname);
            g.in_left -= fname;
            g.in_next += fname;
            next += fname;
            *next = 0;
        }
        else
            do { size_t togo = (fname); while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
        read_extra(extra, save);
        g.form = 2 + ((flags & 8) >> 3);
        return g.in_eof ? -3 : method;
    }
    if (magic != 0x1f8b) {
        g.in_left++;
        g.in_next--;
        return -2;
    }


    method = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
    flags = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
    if (g.in_eof)
        return -1;
    if (flags & 0xe0)
        return -4;


    if (save)
        g.stamp = tolong((tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16)));
    else
        do { size_t togo = 4; while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;


    do { size_t togo = 2; while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;


    if (flags & 4) {
        extra = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (g.in_eof)
            return -3;
        do { size_t togo = (extra); while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;
    }


    if ((flags & 8) && save) {
        unsigned char *end;
        size_t copy, have, size = 128;
        g.hname = malloc(size);
        if (g.hname == NULL)
            bail("not enough memory", "");
        have = 0;
        do {
            if (g.in_left == 0 && load() == 0)
                return -3;
            end = memchr(g.in_next, 0, g.in_left);
            copy = end == NULL ? g.in_left : (size_t)(end - g.in_next) + 1;
            if (have + copy > size) {
                while (have + copy > (size <<= 1))
                    ;
                g.hname = realloc(g.hname, size);
                if (g.hname == NULL)
                    bail("not enough memory", "");
            }
            memcpy(g.hname + have, g.in_next, copy);
            have += copy;
            g.in_left -= copy;
            g.in_next += copy;
        } while (end == NULL);
    }
    else if (flags & 8)
        while ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)) != 0)
            if (g.in_eof)
                return -3;


    if (flags & 16)
        while ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)) != 0)
            if (g.in_eof)
                return -3;


    if (flags & 2)
        do { size_t togo = 2; while (togo > g.in_left) { togo -= g.in_left; if (load() == 0) return -1; } g.in_left -= togo; g.in_next += togo; } while 0;


    g.form = 0;
    return method;
}




static size_t compressed_suffix(char *nm)
{
    size_t len;

    len = strlen(nm);
    if (len > 4) {
        nm += len - 4;
        len = 4;
        if (strcmp(nm, ".zip") == 0 || strcmp(nm, ".ZIP") == 0 ||
            strcmp(nm, ".tgz") == 0)
            return 4;
    }
    if (len > 3) {
        nm += len - 3;
        len = 3;
        if (strcmp(nm, ".gz") == 0 || strcmp(nm, "-gz") == 0 ||
            strcmp(nm, ".zz") == 0 || strcmp(nm, "-zz") == 0)
            return 3;
    }
    if (len > 2) {
        nm += len - 2;
        if (strcmp(nm, ".z") == 0 || strcmp(nm, "-z") == 0 ||
            strcmp(nm, "_z") == 0 || strcmp(nm, ".Z") == 0)
            return 2;
    }
    return 0;
}






static void show_info(int method, unsigned long check, off_t len, int cont)
{
    size_t max;
    size_t n;
    time_t now;
    char mod[26];
    char tag[49];


    max = g.verbosity > 1 ? 16 : 48;
    memset(tag, 0, max + 1);
    if (cont)
        strncpy(tag, "<...>", max + 1);
    else if (g.hname == NULL) {
        n = strlen(g.inf) - compressed_suffix(g.inf);
        strncpy(tag, g.inf, n > max + 1 ? max + 1 : n);
        if (strcmp(g.inf + n, ".tgz") == 0 && n < max + 1)
            strncpy(tag + n, ".tar", max + 1 - n);
    }
    else
        strncpy(tag, g.hname, max + 1);
    if (tag[max])
        strcpy(tag + max - 3, "...");


    if (g.stamp) {
        strcpy(mod, ctime(&g.stamp));
        now = time(NULL);
        if (strcmp(mod + 20, ctime(&now) + 20) != 0)
            strcpy(mod + 11, mod + 19);
    }
    else
        strcpy(mod + 4, "------ -----");
    mod[16] = 0;


    if (g.first) {
        if (g.verbosity > 1)
            fputs("method    check    timestamp    ", stdout);
        if (g.verbosity > 0)
            puts("compressed   original reduced  name");
        g.first = 0;
    }


    if (g.verbosity > 1) {
        if (g.form == 3 && !g.decode)
            printf("zip%3d  --------  %s  ", method, mod + 4);
        else if (g.form > 1)
            printf("zip%3d  %08lx  %s  ", method, check, mod + 4);
        else if (g.form == 1)
            printf("zlib%2d  %08lx  %s  ", method, check, mod + 4);
        else if (method == 257)
            printf("lzw     --------  %s  ", mod + 4);
        else
            printf("gzip%2d  %08lx  %s  ", method, check, mod + 4);
    }
    if (g.verbosity > 0) {
        if ((g.form == 3 && !g.decode) ||
            (method == 8 && g.in_tot > (len + (len >> 10) + 12)) ||
            (method == 257 && g.in_tot > len + (len >> 1) + 3))

            printf("%10jd %10jd?  unk    %s\n",
                   (intmax_t)g.in_tot, (intmax_t)len, tag);
        else
            printf("%10jd %10jd %6.1f%%  %s\n",
                   (intmax_t)g.in_tot, (intmax_t)len,
                   len == 0 ? 0 : 100 * (len - g.in_tot)/(double)len,
                   tag);

    }
}




static void list_info(void)
{
    int method;
    size_t n;
    off_t at;
    unsigned char tail[8];
    unsigned long check, len;


    in_init();


    method = get_header(1);
    if (method < 0) {
        do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
        if (method != -1 && g.verbosity > 1)
            complain("%s not a compressed file -- skipping", g.inf);
        return;
    }


    if (g.form > 1) {
        g.in_tot = g.zip_clen;
        show_info(method, g.zip_crc, g.zip_ulen, 0);
        return;
    }


    if (g.form == 1) {
        at = lseek(g.ind, 0, SEEK_END);
        if (at == -1) {
            check = 0;
            do {
                len = g.in_left < 4 ? g.in_left : 4;
                g.in_next += g.in_left - len;
                while (len--)
                    check = (check << 8) + *g.in_next++;
            } while (load() != 0);
            check &= 0xffffffffUL;
        }
        else {
            g.in_tot = at;
            lseek(g.ind, -4, SEEK_END);
            readn(g.ind, tail, 4);
            check = (((unsigned long)((((unsigned)((tail)[0]) << 8) + (tail)[1])) << 16) + (((unsigned)(((tail) + 2)[0]) << 8) + ((tail) + 2)[1]));
        }
        g.in_tot -= 6;
        show_info(method, check, 0, 0);
        return;
    }


    if (method == 257) {
        at = lseek(g.ind, 0, SEEK_END);
        if (at == -1)
            while (load() != 0)
                ;
        else
            g.in_tot = at;
        g.in_tot -= 3;
        show_info(method, 0, 0, 0);
        return;
    }


    if (g.in_short) {
        if (g.in_left < 8) {
            complain("%s not a valid gzip file -- skipping", g.inf);
            return;
        }
        g.in_tot = g.in_left - 8;
        memcpy(tail, g.in_next + (g.in_left - 8), 8);
    }
    else if ((at = lseek(g.ind, -8, SEEK_END)) != -1) {
        g.in_tot = at - g.in_tot + g.in_left;
        readn(g.ind, tail, 8);
    }
    else {
        at = g.in_tot - g.in_left;
        do {
            n = g.in_left < 8 ? g.in_left : 8;
            memcpy(tail, g.in_next + (g.in_left - n), n);
            load();
        } while (g.in_left == 32768U);
        if (g.in_left < 8) {
            if (n + g.in_left < 8) {
                complain("%s not a valid gzip file -- skipping", g.inf);
                return;
            }
            if (g.in_left) {
                if (n + g.in_left > 8)
                    memcpy(tail, tail + n - (8 - g.in_left), 8 - g.in_left);
                memcpy(tail + 8 - g.in_left, g.in_next, g.in_left);
            }
        }
        else
            memcpy(tail, g.in_next + (g.in_left - 8), 8);
        g.in_tot -= at + 8;
    }
    if (g.in_tot < 2) {
        complain("%s not a valid gzip file -- skipping", g.inf);
        return;
    }


    check = (((tail)[0] + ((unsigned)((tail)[1]) << 8)) + ((unsigned long)((((tail) + 2)[0] + ((unsigned)(((tail) + 2)[1]) << 8))) << 16));
    len = (((tail + 4)[0] + ((unsigned)((tail + 4)[1]) << 8)) + ((unsigned long)((((tail + 4) + 2)[0] + ((unsigned)(((tail + 4) + 2)[1]) << 8))) << 16));


    show_info(method, check, len, 0);
    do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
}



static void cat(void)
{

    writen(g.outd, &g.magic1, 1);
    g.out_tot = 1;




    while (g.in_left) {
        writen(g.outd, g.in_next, g.in_left);
        g.out_tot += g.in_left;
        g.in_left = 0;
        load();
    }
}




static unsigned inb(void *desc, unsigned char **buf)
{
    (void)desc;
    load();
    *buf = g.in_next;
    return g.in_left;
}



static unsigned char out_buf[32768U];



static unsigned char out_copy[32768U];
static size_t out_len;


static lock *outb_write_more = NULL;
static lock *outb_check_more;


static void outb_write(void *dummy)
{
    size_t len;

    (void)dummy;

                                                  ;
    do {
        possess(outb_write_more);
        wait_for(outb_write_more, TO_BE, 1);
        len = out_len;
        if (len && g.decode == 1)
            writen(g.outd, out_copy, len);
                                                     ;
        twist(outb_write_more, TO, 0);
    } while (len);
                                                ;
}


static void outb_check(void *dummy)
{
    size_t len;

    (void)dummy;

                                                  ;
    do {
        possess(outb_check_more);
        wait_for(outb_check_more, TO_BE, 1);
        len = out_len;
        g.out_check = (g.form == 1 ? adler32(g.out_check,out_copy,len) : crc32(g.out_check,out_copy,len));
                                                       ;
        twist(outb_check_more, TO, 0);
    } while (len);
                                                ;
}






static int outb(void *desc, unsigned char *buf, unsigned len)
{

    static thread *wr, *ch;

    if (g.procs > 1) {

        if (outb_write_more == NULL) {
            outb_write_more = new_lock(0);
            outb_check_more = new_lock(0);
            wr = launch(outb_write, NULL);
            ch = launch(outb_check, NULL);
        }


        possess(outb_check_more);
        wait_for(outb_check_more, TO_BE, 0);
        possess(outb_write_more);
        wait_for(outb_write_more, TO_BE, 0);


        out_len = len;
        g.out_tot += len;
        memcpy(out_copy, buf, len);
        twist(outb_write_more, TO, 1);
        twist(outb_check_more, TO, 1);



        if (len == 0) {
            join(ch);
            join(wr);
            free_lock(outb_check_more);
            free_lock(outb_write_more);
            outb_write_more = NULL;
        }




        return 0;
    }


    (void)desc;


    if (len) {
        if (g.decode == 1)
            writen(g.outd, buf, len);
        g.out_check = (g.form == 1 ? adler32(g.out_check,buf,len) : crc32(g.out_check,buf,len));
        g.out_tot += len;
    }
    return 0;
}





static void infchk(void)
{
    int ret, cont, was;
    unsigned long check, len;
    z_stream strm;
    unsigned tmp2;
    unsigned long tmp4;
    off_t clen;

    cont = 0;
    do {

        g.in_tot = g.in_left;
        g.out_tot = 0;
        g.out_check = (g.form == 1 ? adler32(0L,Z_NULL,0) : crc32(0L,Z_NULL,0));
        strm.zalloc = Z_NULL;
        strm.zfree = Z_NULL;
        strm.opaque = Z_NULL;
        ret = inflateBackInit(&strm, 15, out_buf);
        if (ret != Z_OK)
            bail("not enough memory", "");


        strm.avail_in = g.in_left;
        strm.next_in = g.in_next;
        ret = inflateBack(&strm, inb, NULL, outb, NULL);
        if (ret != Z_STREAM_END)
            bail("corrupted input -- invalid deflate data: ", g.inf);
        g.in_left = strm.avail_in;
        g.in_next = strm.next_in;
        inflateBackEnd(&strm);
        outb(NULL, NULL, 0);


        clen = g.in_tot - g.in_left;


        if (g.form > 1) {
            if (g.form == 3) {

                g.zip_crc = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                g.zip_clen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                if (g.in_eof)
                    bail("corrupted zip entry -- missing trailer: ", g.inf);


                if (g.zip_crc != g.out_check) {
                    if (g.zip_crc != 0x08074b50UL || g.zip_clen != g.out_check)
                        bail("corrupted zip entry -- crc32 mismatch: ", g.inf);
                    g.zip_crc = g.zip_clen;
                    g.zip_clen = g.zip_ulen;
                    g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                }


                else if (g.zip_crc == 0x08074b50UL &&
                         g.zip_clen == g.zip_crc &&
                         ((clen & 0xffffffffUL) != g.zip_crc ||
                          g.zip_ulen == g.zip_crc)) {
                    g.zip_crc = g.zip_clen;
                    g.zip_clen = g.zip_ulen;
                    g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                }


                if (g.zip_ulen != (g.out_tot & 0xffffffffUL)) {
                    g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                    (void)(tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                }
                if (g.in_eof)
                    bail("corrupted zip entry -- missing trailer: ", g.inf);
            }
            if (g.zip_clen != (clen & 0xffffffffUL) ||
                g.zip_ulen != (g.out_tot & 0xffffffffUL))
                bail("corrupted zip entry -- length mismatch: ", g.inf);
            check = g.zip_crc;
        }
        else if (g.form == 1) {
            check = (unsigned long)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 24;
            check += (unsigned long)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 16;
            check += (unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8;
            check += (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
            if (g.in_eof)
                bail("corrupted zlib stream -- missing trailer: ", g.inf);
            if (check != g.out_check)
                bail("corrupted zlib stream -- adler32 mismatch: ", g.inf);
        }
        else {
            check = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
            len = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
            if (g.in_eof)
                bail("corrupted gzip stream -- missing trailer: ", g.inf);
            if (check != g.out_check)
                bail("corrupted gzip stream -- crc32 mismatch: ", g.inf);
            if (len != (g.out_tot & 0xffffffffUL))
                bail("corrupted gzip stream -- length mismatch: ", g.inf);
        }


        if (g.list) {
            g.in_tot = clen;
            show_info(8, check, g.out_tot, cont);
            cont = 1;
        }



        was = g.form;
    } while (was == 0 && (ret = get_header(0)) == 8 && g.form == 0);


    if (was == 0 && ret == -2 && g.force && g.pipeout && g.decode != 2 &&
        !g.list)
        cat();
    else if (was > 1 && get_header(0) != -5)
        complain("entries after the first in %s were ignored", g.inf);
    else if ((was == 0 && ret != -1) || (was == 1 && ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), !g.in_eof)))
        complain("%s OK, has trailing junk which was ignored", g.inf);
}





typedef uint_fast32_t bits_t;






static void unlzw(void)
{
    unsigned bits;
    unsigned mask;
    bits_t buf;
    unsigned left;
    off_t mark;
    unsigned code;
    unsigned max;
    unsigned flags;
    unsigned end;
    unsigned prev;
    unsigned final;
    unsigned stack;
    unsigned outcnt;



    uint_least16_t prefix[65536];
    unsigned char suffix[65536];
    unsigned char match[65282];


    g.out_tot = 0;
    if ((g.in_left == 0 && (g.in_eof || load() == 0)))
        bail("lzw premature end: ", g.inf);
    flags = (g.in_left--, *g.in_next++);
    if (flags & 0x60)
        bail("unknown lzw flags set: ", g.inf);
    max = flags & 0x1f;
    if (max < 9 || max > 16)
        bail("lzw bits out of range: ", g.inf);
    if (max == 9)
        max = 10;
    flags &= 0x80;


    mark = g.in_tot - g.in_left;


    bits = 9;
    mask = 0x1ff;
    end = flags ? 256 : 255;



    if ((g.in_left == 0 && (g.in_eof || load() == 0)))
        return;
    buf = (g.in_left--, *g.in_next++);
    if ((g.in_left == 0 && (g.in_eof || load() == 0)))
        bail("lzw premature end: ", g.inf);
    buf += (g.in_left--, *g.in_next++) << 8;
    final = prev = buf & mask;
    buf >>= bits;
    left = 16 - bits;
    if (prev > 255)
        bail("invalid lzw code: ", g.inf);
    out_buf[0] = final;
    outcnt = 1;


    stack = 0;
    for (;;) {

        if (end >= mask && bits < max) {




            {
                unsigned rem = ((g.in_tot - g.in_left) - mark) % bits;
                if (rem)
                    rem = bits - rem;
                while (rem > g.in_left) {
                    rem -= g.in_left;
                    if (load() == 0)
                        break;
                }
                g.in_left -= rem;
                g.in_next += rem;
            }
            buf = 0;
            left = 0;


            mark = g.in_tot - g.in_left;


            bits++;
            mask <<= 1;
            mask++;
        }


        if ((g.in_left == 0 && (g.in_eof || load() == 0)))
            break;
        buf += (bits_t)((g.in_left--, *g.in_next++)) << left;
        left += 8;
        if (left < bits) {
            if ((g.in_left == 0 && (g.in_eof || load() == 0)))
                bail("lzw premature end: ", g.inf);
            buf += (bits_t)((g.in_left--, *g.in_next++)) << left;
            left += 8;
        }
        code = buf & mask;
        buf >>= bits;
        left -= bits;


        if (code == 256 && flags) {

            {
                unsigned rem = ((g.in_tot - g.in_left) - mark) % bits;
                if (rem)
                    rem = bits - rem;
                while (rem > g.in_left) {
                    rem -= g.in_left;
                    if (load() == 0)
                        break;
                }
                g.in_left -= rem;
                g.in_next += rem;
            }
            buf = 0;
            left = 0;


            mark = g.in_tot - g.in_left;


            bits = 9;
            mask = 0x1ff;
            end = 255;
            continue;
        }


        {
            unsigned temp = code;
            if (code > end) {



                if (code != end + 1 || prev > end)
                    bail("invalid lzw code: ", g.inf);
                match[stack++] = final;
                code = prev;
            }


            while (code >= 256) {
                match[stack++] = suffix[code];
                code = prefix[code];
            }
            match[stack++] = code;
            final = code;


            if (end < mask) {
                end++;
                prefix[end] = prev;
                suffix[end] = final;
            }


            prev = temp;
        }


        while (stack > 32768U - outcnt) {
            while (outcnt < 32768U)
                out_buf[outcnt++] = match[--stack];
            g.out_tot += outcnt;
            if (g.decode == 1)
                writen(g.outd, out_buf, outcnt);
            outcnt = 0;
        }
        do {
            out_buf[outcnt++] = match[--stack];
        } while (stack);
    }


    g.out_tot += outcnt;
    if (outcnt && g.decode == 1)
        writen(g.outd, out_buf, outcnt);
}




static char *justname(char *path)
{
    char *p;

    p = strrchr(path, '/');
    return p == NULL ? path : p + 1;
}





static void copymeta(char *from, char *to)
{
    struct stat st;
    struct timeval times[2];


    if (stat(from, &st) != 0 || (st.st_mode & S_IFMT) != S_IFREG)
        return;


    (void)chmod(to, st.st_mode & 7777);


    (void)chown(to, st.st_uid, st.st_gid);


    times[0].tv_sec = st.st_atime;
    times[0].tv_usec = 0;
    times[1].tv_sec = st.st_mtime;
    times[1].tv_usec = 0;
    (void)utimes(to, times);
}


static void touch(char *path, time_t t)
{
    struct timeval times[2];

    times[0].tv_sec = t;
    times[0].tv_usec = 0;
    times[1].tv_sec = t;
    times[1].tv_usec = 0;
    (void)utimes(path, times);
}



static void process(char *path)
{
    int method = -1;
    size_t len;
    struct stat st;

    static char *sufs[] = {".z", "-z", "_z", ".Z", ".gz", "-gz", ".zz", "-zz",
                           ".zip", ".ZIP", ".tgz", NULL};


    if (path == NULL) {
        strcpy(g.inf, "<stdin>");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {

        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail("name too long: ", path);
        }
        len = strlen(g.inf);



        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }





            if (errno) {
                g.inf[len] = 0;
                complain("%s does not exist -- skipping", g.inf);
                return;
            }
            len = strlen(g.inf);
        }



        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain("%s is a special file or device -- skipping", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain("%s is a symbolic link -- skipping", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain("%s is a directory -- skipping", g.inf);
            return;
        }


        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;



            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = malloc(hold);
            if (roll == NULL)
                bail("not enough memory", "");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = realloc(roll, hold);
                    if (bigger == NULL) {
                        free(roll);
                        bail("not enough memory", "");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);


            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail("path too long", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), "...");
                    bail("path too long: ", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;


            free(roll);
            return;
        }


        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain("%s ends with %s -- skipping", g.inf, g.sufx);
            return;
        }


        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain("%s does not have compressed suffix -- skipping",
                         g.inf);
                return;
            }
            len -= suf;
        }


        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail("read error on ", g.inf);


        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
                          ;


    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&

                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? "%s is not compressed -- skipping" :
                         "%s has unknown compression method -- skipping",
                         g.inf);
            return;
        }


        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }


    if (g.list) {
        list_info();
        do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
        if (g.ind != 0)
            close(g.ind);
        return;
    }


    if (path == NULL || g.pipeout) {

        g.outf = malloc(strlen("<stdout>") + 1);
        if (g.outf == NULL)
            bail("not enough memory", "");
        strcpy(g.outf, "<stdout>");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail("trying to write compressed data to a terminal",
                 " (use -f to force)");
    }
    else {
        char *to, *repl;


        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
        }


        repl = g.decode && strcmp(to + len, ".tgz") ? "" : ".tar";


        g.outf = malloc(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
        if (g.outf == NULL)
            bail("not enough memory", "");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 600);


        if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, "%s exists -- overwrite (y/n)? ", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              600);
        }


        if (g.outd < 0 && errno == EEXIST) {
            complain("%s exists -- skipping", g.outf);
            do { if ((g.outf) != NULL) { free(g.outf); g.outf = NULL; } } while 0;
            do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
            if (g.ind != 0)
                close(g.ind);
            return;
        }


        if (g.outd < 0)
            bail("write error on ", g.outf);
    }
                           ;
    do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;


    if (g.verbosity > 1)
        fprintf(stderr, "%s to %s ", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }

    else if (g.procs > 1)
        parallel_compress();

    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }


    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail("write error on ", g.outf);
        g.outd = -1;
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    do { if ((g.outf) != NULL) { free(g.outf); g.outf = NULL; } } while 0;
}

static char *helptext[] = {
"Usage: pigz [options] [files ...]",
"  will compress files in place, adding the suffix '.gz'.  If no files are",



"  specified, stdin will be compressed to stdout.  pigz does what gzip does,",
"  but spreads the work over multiple processors and cores when compressing.",

"",
"Options:",
"  -0 to -9, -11        Compression level (11 is much slower, a few % better)",
"  --fast, --best       Compression levels 1 and 9 respectively",
"  -b, --blocksize mmm  Set compression block size to mmmK (default 128K)",
"  -c, --stdout         Write all processed output to stdout (won't delete)",
"  -d, --decompress     Decompress the compressed input",
"  -f, --force          Force overwrite, compress .gz, links, and to terminal",
"  -F  --first          Do iterations first, before block split for -11",
"  -h, --help           Display a help screen and quit",
"  -i, --independent    Compress blocks independently for damage recovery",
"  -I, --iterations n   Number of iterations for -11 optimization",
"  -k, --keep           Do not delete original file after processing",
"  -K, --zip            Compress to PKWare zip (.zip) single entry format",
"  -l, --list           List the contents of the compressed input",
"  -L, --license        Display the pigz license and quit",
"  -M, --maxsplits n    Maximum number of split blocks for -11",
"  -n, --no-name        Do not store or restore file name in/from header",
"  -N, --name           Store/restore file name and mod time in/from header",
"  -O  --oneblock       Do not split into smaller blocks for -11",

"  -p, --processes n    Allow up to n compression threads (default is the",
"                       number of online processors, or 8 if unknown)",

"  -q, --quiet          Print no messages, even on error",
"  -r, --recursive      Process the contents of all subdirectories",
"  -R, --rsyncable      Input-determined block locations for rsync",
"  -S, --suffix .sss    Use suffix .sss instead of .gz (for compression)",
"  -t, --test           Test the integrity of the compressed input",
"  -T, --no-time        Do not store or restore mod time in/from header",



"  -v, --verbose        Provide more verbose output",

"  -V  --version        Show the version of pigz",
"  -z, --zlib           Compress to zlib (.zz) instead of gzip format",
"  --                   All arguments after \"--\" are treated as files"
};


static void help(void)
{
    int n;

    if (g.verbosity == 0)
        return;
    for (n = 0; n < (int)(sizeof(helptext) / sizeof(char *)); n++)
        fprintf(stderr, "%s\n", helptext[n]);
    fflush(stderr);
    exit(0);
}




static int nprocs(int n)
{

    return n;
}




static void defaults(void)
{
    g.level = Z_DEFAULT_COMPRESSION;







    ZopfliInitOptions(&g.zopts);



    g.procs = nprocs(8);

    g.block = 131072UL;
    g.rsync = 0;
    g.setdict = 1;
    g.verbosity = 1;
    g.headis = 3;
    g.pipeout = 0;
    g.sufx = ".gz";
    g.decode = 0;
    g.list = 0;
    g.keep = 0;
    g.force = 0;
    g.recurse = 0;
    g.form = 0;
}


static char *longopts[][2] = {
    {"LZW", "Z"}, {"ascii", "a"}, {"best", "9"}, {"bits", "Z"},
    {"blocksize", "b"}, {"decompress", "d"}, {"fast", "1"}, {"first", "F"},
    {"force", "f"}, {"help", "h"}, {"independent", "i"}, {"iterations", "I"},
    {"keep", "k"}, {"license", "L"}, {"list", "l"}, {"maxsplits", "M"},
    {"name", "N"}, {"no-name", "n"}, {"no-time", "T"}, {"oneblock", "O"},
    {"processes", "p"}, {"quiet", "q"}, {"recursive", "r"}, {"rsyncable", "R"},
    {"silent", "q"}, {"stdout", "c"}, {"suffix", "S"}, {"test", "t"},
    {"to-stdout", "c"}, {"uncompress", "d"}, {"verbose", "v"},
    {"version", "V"}, {"zip", "K"}, {"zlib", "z"}};





static void new_opts(void)
{
    single_compress(1);

    finish_jobs();

}


static size_t num(char *arg)
{
    char *str = arg;
    size_t val = 0;

    if (*str == 0)
        bail("internal error: empty parameter", "");
    do {
        if (*str < '0' || *str > '9' ||
            (val && ((~(size_t)0) - (*str - '0')) / val < 10))
            bail("invalid numeric parameter: ", arg);
        val = val * 10 + (*str - '0');
    } while (*++str);
    return val;
}


static int option(char *arg)
{
    static int get = 0;
    char bad[3] = "-X";


    if (get && (arg == NULL || *arg == '-')) {
        bad[1] = "bpSIM"[get - 1];
        bail("missing parameter after ", bad);
    }
    if (arg == NULL)
        return 0;


    if (*arg == '-') {

        if (*++arg == 0)
            return 1;


        if (*arg == '-') {
            int j;

            arg++;
            for (j = (sizeof(longopts) / (sizeof(char *) << 1)) - 1; j >= 0; j--)
                if (strcmp(arg, longopts[j][0]) == 0) {
                    arg = longopts[j][1];
                    break;
                }
            if (j < 0)
                bail("invalid option: ", arg - 2);
        }


        do {


            if (get) {
                if (get == 3)
                    bail("invalid usage: -s must be followed by space", "");
                break;
            }


            bad[1] = *arg;
            switch (*arg) {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                g.level = *arg - '0';
                while (arg[1] >= '0' && arg[1] <= '9') {
                    if (g.level && (INT_MAX - (arg[1] - '0')) / g.level < 10)
                        bail("only levels 0..9 and 11 are allowed", "");
                    g.level = g.level * 10 + *++arg - '0';
                }
                if (g.level == 10 || g.level > 11)
                    bail("only levels 0..9 and 11 are allowed", "");
                new_opts();
                break;
            case 'F': g.zopts.blocksplittinglast = 1; break;
            case 'I': get = 4; break;
            case 'K': g.form = 2; g.sufx = ".zip"; break;
            case 'L':
                fputs("pigz 2.3.2\n", stderr);
                fputs("Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013"
                      " Mark Adler\n",
                      stderr);
                fputs("Subject to the terms of the zlib license.\n",
                      stderr);
                fputs("No warranty is provided or implied.\n", stderr);
                exit(0);
            case 'M': get = 5; break;
            case 'N': g.headis |= 0xf; break;
            case 'O': g.zopts.blocksplitting = 0; break;
            case 'R': g.rsync = 1; break;
            case 'S': get = 3; break;
            case 'T': g.headis &= ~0xa; break;
            case 'V': fputs("pigz 2.3.2\n", stderr); exit(0);
            case 'Z':
                bail("invalid option: LZW output not supported: ", bad);
            case 'a':
                bail("invalid option: ascii conversion not supported: ", bad);
            case 'b': get = 1; break;
            case 'c': g.pipeout = 1; break;
            case 'd': if (!g.decode) g.headis >>= 2; g.decode = 1; break;
            case 'f': g.force = 1; break;
            case 'h': help(); break;
            case 'i': g.setdict = 0; break;
            case 'k': g.keep = 1; break;
            case 'l': g.list = 1; break;
            case 'n': g.headis &= ~5; break;
            case 'p': get = 2; break;
            case 'q': g.verbosity = 0; break;
            case 'r': g.recurse = 1; break;
            case 't': g.decode = 2; break;
            case 'v': g.verbosity++; break;
            case 'z': g.form = 1; g.sufx = ".zz"; break;
            default:
                bail("invalid option: ", bad);
            }
        } while (*++arg);
        if (*arg == 0)
            return 0;
    }


    if (get) {
        size_t n;

        if (get == 1) {
            n = num(arg);
            g.block = n << 10;
            if (g.block < 32768U)
                bail("block size too small (must be >= 32K)", "");
            if (n != g.block >> 10 ||
                ((g.block)+((g.block)>>4)+32768U) < g.block ||
                (ssize_t)((g.block)+((g.block)>>4)+32768U) < 0 ||
                g.block > (1UL << 29))
                bail("block size too large: ", arg);
            new_opts();
        }
        else if (get == 2) {
            n = num(arg);
            g.procs = (int)n;
            if (g.procs < 1)
                bail("invalid number of processes: ", arg);
            if ((size_t)g.procs != n || (((g.procs)<<1)+3) < 1)
                bail("too many processes: ", arg);




            new_opts();
        }
        else if (get == 3)
            g.sufx = arg;
        else if (get == 4)
            g.zopts.numiterations = num(arg);
        else if (get == 5)
            g.zopts.blocksplittingmax = num(arg);
        get = 0;
        return 0;
    }


    return 1;
}


static void cut_short(int sig)
{
    (void)sig;
                                  ;
    if (g.outd != -1 && g.outf != NULL)
        unlink(g.outf);
              ;
    _exit(1);
}




int main(int argc, char **argv)
{
    int n;
    int noop;
    unsigned long done;
    char *opts, *p;


    g.outf = NULL;
    g.first = 1;
    g.hname = NULL;


    p = strrchr(argv[0], '/');
    p = p == NULL ? argv[0] : p + 1;
    g.prog = *p ? p : "pigz";


    signal(SIGINT, cut_short);

    yarn_prefix = g.prog;
    yarn_abort = cut_short;







    defaults();


    opts = getenv("GZIP");
    if (opts != NULL) {
        while (*opts) {
            while (*opts == ' ' || *opts == '\t')
                opts++;
            p = opts;
            while (*p && *p != ' ' && *p != '\t')
                p++;
            n = *p;
            *p = 0;
            if (option(opts))
                bail("cannot provide files in GZIP environment variable", "");
            opts = p + (n ? 1 : 0);
        }
        option(NULL);
    }


    opts = getenv("PIGZ");
    if (opts != NULL) {
        while (*opts) {
            while (*opts == ' ' || *opts == '\t')
                opts++;
            p = opts;
            while (*p && *p != ' ' && *p != '\t')
                p++;
            n = *p;
            *p = 0;
            if (option(opts))
                bail("cannot provide files in PIGZ environment variable", "");
            opts = p + (n ? 1 : 0);
        }
        option(NULL);
    }


    if (strcmp(g.prog, "unpigz") == 0 || strcmp(g.prog, "gunzip") == 0) {
        if (!g.decode)
            g.headis >>= 2;
        g.decode = 1;
    }
    if ((n = strlen(g.prog)) > 2 && strcmp(g.prog + n - 3, "cat") == 0) {
        if (!g.decode)
            g.headis >>= 2;
        g.decode = 1;
        g.pipeout = 1;
    }


    if (argc < 2 && isatty(g.decode ? 0 : 1))
        help();


    done = noop = 0;
    for (n = 1; n < argc; n++)
        if (noop == 0 && strcmp(argv[n], "--") == 0) {
            noop = 1;
            option(NULL);
        }
        else if (noop || option(argv[n])) {
            if (done == 1 && g.pipeout && !g.decode && !g.list && g.form > 1)
                complain("warning: output will be concatenated zip files -- "
                         "will not be able to extract");
            process(strcmp(argv[n], "-") ? argv[n] : NULL);
            done++;
        }
    option(NULL);


    if (done == 0)
        process(NULL);


    new_opts();
              ;
    return 0;
}
