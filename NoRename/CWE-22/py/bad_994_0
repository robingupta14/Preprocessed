








from __future__ import print_function, division, unicode_literals


from hashlib import md5
from xml.etree import ElementTree

try:
    TKINTER = True
    from six.moves.tkinter import (
        Tk,
        Frame,
        Label,
        Entry,
        Button,
        Canvas,
        Menu,
        IntVar,
        TclError,
    )
    from six.moves.tkinter_messagebox import showerror
    from nltk.draw.table import Table
    from nltk.draw.util import ShowText
except ImportError:
    TKINTER = False
    TclError = ValueError

from six import string_types, text_type
from six.moves import input
from six.moves.urllib.request import urlopen
from six.moves.urllib.error import HTTPError, URLError

from nltk.compat import python_2_unicode_compatible









@python_2_unicode_compatible
class Package(object):
    

    def __init__(
        self,
        id,
        url,
        name=None,
        subdir=,
        size=None,
        unzipped_size=None,
        checksum=None,
        svn_revision=None,
        copyright=Unknown,
        contact=Unknown,
        license=Unknown,
        author=Unknown,
        unzip=True,
        **kw
    ):
        self.id = id
        

        self.name = name or id
        

        self.subdir = subdir
        

        self.url = url
        

        self.size = int(size)
        

        self.unzipped_size = int(unzipped_size)
        

        self.checksum = checksum
        

        self.svn_revision = svn_revision
        

        self.copyright = copyright
        

        self.contact = contact
        

        self.license = license
        

        self.author = author
        

        ext = os.path.splitext(url.split/[-1])[1]
        self.filename = os.path.join(subdir, id + ext)
        

        self.unzip = bool(int(unzip))  
        

        
        self.__dict__.update(kw)

    @staticmethod
    def fromxml(xml):
        if isinstance(xml, string_types):
            xml = xml.etree.ElementTree.parse(xml)
        for key in xml.attrib:
            xml.attrib[key] = text_type(xml.attrib[key])
        return Package(**xml.attrib)

    def __lt__(self, other):
        return self.id < other.id

    def __repr__(self):
        return <Package %s> % self.id


@python_2_unicode_compatible
class Collection(object):
    

    def __init__(self, id, children, name=None, **kw):
        self.id = id
        

        self.name = name or id
        

        self.children = children
        

        self.packages = None
        

        
        self.__dict__.update(kw)

    @staticmethod
    def fromxml(xml):
        if isinstance(xml, string_types):
            xml = xml.etree.ElementTree.parse(xml)
        for key in xml.attrib:
            xml.attrib[key] = text_type(xml.attrib[key])
        children = [child.getref for child in xml.findallitem]
        return Collection(children=children, **xml.attrib)

    def __lt__(self, other):
        return self.id < other.id

    def __repr__(self):
        return <Collection %s> % self.id







class DownloaderMessage(object):
    


class StartCollectionMessage(DownloaderMessage):
    

    def __init__(self, collection):
        self.collection = collection


class FinishCollectionMessage(DownloaderMessage):
    

    def __init__(self, collection):
        self.collection = collection


class StartPackageMessage(DownloaderMessage):
    

    def __init__(self, package):
        self.package = package


class FinishPackageMessage(DownloaderMessage):
    

    def __init__(self, package):
        self.package = package


class StartDownloadMessage(DownloaderMessage):
    

    def __init__(self, package):
        self.package = package


class FinishDownloadMessage(DownloaderMessage):
    

    def __init__(self, package):
        self.package = package


class StartUnzipMessage(DownloaderMessage):
    

    def __init__(self, package):
        self.package = package


class FinishUnzipMessage(DownloaderMessage):
    

    def __init__(self, package):
        self.package = package


class UpToDateMessage(DownloaderMessage):
    

    def __init__(self, package):
        self.package = package


class StaleMessage(DownloaderMessage):
    

    def __init__(self, package):
        self.package = package


class ErrorMessage(DownloaderMessage):
    

    def __init__(self, package, message):
        self.package = package
        if isinstance(message, Exception):
            self.message = str(message)
        else:
            self.message = message


class ProgressMessage(DownloaderMessage):
    

    def __init__(self, progress):
        self.progress = progress


class SelectDownloadDirMessage(DownloaderMessage):
    

    def __init__(self, download_dir):
        self.download_dir = download_dir







class Downloader(object):
    

    
    
    

    INDEX_TIMEOUT = 3600  
    

    DEFAULT_URL = https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/index.xml
    

    
    
    

    INSTALLED = installed
    
    NOT_INSTALLED = not installed
    
    STALE = out of date
    
    PARTIAL = partial
    

    
    
    

    def __init__(self, server_index_url=None, download_dir=None):
        self._url = server_index_url or self.DEFAULT_URL
        

        self._collections = {}
        

        self._packages = {}
        

        self._download_dir = download_dir
        

        self._index = None
        

        self._index_timestamp = None
        

        self._status_cache = {}
        

        self._errors = None
        

        
        if self._download_dir is None:
            self._download_dir = self.default_download_dir()

    
    
    

    def list(
        self,
        download_dir=None,
        show_packages=True,
        show_collections=True,
        header=True,
        more_prompt=False,
        skip_installed=False,
    ):
        lines = 0  
        if download_dir is None:
            download_dir = self._download_dir
            print(Using default data directory (%s) % download_dir)
        if header:
            print(= * (26 + len(self._url)))
            print( Data server index for <%s> % self._url)
            print(= * (26 + len(self._url)))
            lines += 3  
        stale = partial = False

        categories = []
        if show_packages:
            categories.appendpackages
        if show_collections:
            categories.appendcollections
        for category in categories:
            print(%s: % category.capitalize())
            lines += 1  
            for info in sorted(getattr(self, category)(), key=str):
                status = self.status(info, download_dir)
                if status == self.INSTALLED and skip_installed:
                    continue
                if status == self.STALE:
                    stale = True
                if status == self.PARTIAL:
                    partial = True
                prefix = {
                    self.INSTALLED: *,
                    self.STALE: -,
                    self.PARTIAL: P,
                    self.NOT_INSTALLED:  ,
                }[status]
                name = textwrap.fill(
                    --------------------------- + (info.name or info.id), 75, subsequent_indent=                           
                )[27:]
                print(), name))
                lines += len(name.split
)  
                if more_prompt and lines > 20:
                    user_input = inputHit Enter to continue: 
                    if user_six.moves.input.lower() in ('x', 'q'):
                        return
                    lines = 0
            print()
        msg = ([*] marks installed packages
        if stale:
            msg += ; [-] marks out-of-date or corrupt packages
        if partial:
            msg += ; [P] marks partially installed collections
        print(textwrap.fill(msg + ), subsequent_indent= , width=76))

    def packages(self):
        self._update_index()
        return self._packages.values()

    def corpora(self):
        self._update_index()
        return [pkg for (id, pkg) in self._packages.items() if pkg.subdir == corpora]

    def models(self):
        self._update_index()
        return [pkg for (id, pkg) in self._packages.items() if pkg.subdir != corpora]

    def collections(self):
        self._update_index()
        return self._collections.values()

    
    
    

    def _info_or_id(self, info_or_id):
        if isinstance(info_or_id, string_types):
            return self.info(info_or_id)
        else:
            return info_or_id

    
    
    
    
    
    
    
    

    def incr_download(self, info_or_id, download_dir=None, force=False):
        
        if download_dir is None:
            download_dir = self._download_dir
            yield SelectDownloadDirMessage(download_dir)

        
        if isinstance(info_or_id, (list, tuple)):
            for msg in self._download_list(info_or_id, download_dir, force):
                yield msg
            return

        
        try:
            info = self._info_or_id(info_or_id)
        except (IOError, ValueError) as e:
            yield ErrorMessage(None, Error loading %s: %s % (info_or_id, e))
            return

        
        if isinstance(info, Collection):
            yield StartCollectionMessage(info)
            for msg in self.incr_download(info.children, download_dir, force):
                yield msg
            yield FinishCollectionMessage(info)

        
        else:
            for msg in self._download_package(info, download_dir, force):
                yield msg

    def _num_packages(self, item):
        if isinstance(item, Package):
            return 1
        else:
            return len(item.packages)

    def _download_list(self, items, download_dir, force):
        
        for i in range(len(items)):
            try:
                items[i] = self._info_or_id(items[i])
            except (IOError, ValueError) as e:
                yield ErrorMessage(items[i], e)
                return

        
        num_packages = sum(self._num_packages(item) for item in items)
        progress = 0
        for i, item in enumerate(items):
            if isinstance(item, Package):
                delta = 1.0 / num_packages
            else:
                delta = len(item.packages) / num_packages
            for msg in self.incr_download(item, download_dir, force):
                if isinstance(msg, ProgressMessage):
                    yield ProgressMessage(progress + msg.progress * delta)
                else:
                    yield msg

            progress += 100 * delta

    def _download_package(self, info, download_dir, force):
        yield StartPackageMessage(info)
        yield ProgressMessage0

        
        status = self.status(info, download_dir)
        if not force and status == self.INSTALLED:
            yield UpToDateMessage(info)
            yield ProgressMessage100
            yield FinishPackageMessage(info)
            return

        
        self._status_cache.pop(info.id, None)

        
        filepath = os.path.join(download_dir, info.filename)
        if os.path.exists(filepath):
            if status == self.STALE:
                yield StaleMessage(info)
            os.remove(filepath)

        
        if not os.path.exists(download_dir):
            os.mkdir(download_dir)
        if not os.path.exists(os.path.join(download_dir, info.subdir)):
            os.mkdir(os.path.join(download_dir, info.subdir))

        
        
        yield StartDownloadMessage(info)
        yield ProgressMessage5
        try:
            infile = urlopen(info.url)
            with open(filepath, wb) as outfile:
                
                num_blocks = max(1, info.size / 16384)
                for block in itertools.count():
                    s = infile.read16384  
                    outfile.write(s)
                    if not s:
                        break
                    if block % 2 == 0:  
                        yield ProgressMessage(min(80, 5 + 75 * (block / num_blocks)))
            infile.close()
        except IOError as e:
            yield ErrorMessage(
                info,
                Error downloading %r from <%s>:
  %s % (info.id, info.url, e),
            )
            return
        yield FinishDownloadMessage(info)
        yield ProgressMessage80

        
        if info.filename.endswith.zip:
            zipdir = os.path.join(download_dir, info.subdir)
            
            
            if info.unzip or os.path.exists(os.path.join(zipdir, info.id)):
                yield StartUnzipMessage(info)
                for msg in _unzip_iter(filepath, zipdir, verbose=False):
                    
                    msg.package = info
                    yield msg
                yield FinishUnzipMessage(info)

        yield FinishPackageMessage(info)

    def download(
        self,
        info_or_id=None,
        download_dir=None,
        quiet=False,
        force=False,
        prefix=[nltk_data] ,
        halt_on_error=True,
        raise_on_error=False,
        print_error_to=sys.stderr,
    ):

        print_to = functools.partial(print, file=print_error_to)
        
        if info_or_id is None:
            
            
            
            if download_dir is not None:
                self._download_dir = download_dir
            self._interactive_download()
            return True

        else:
            
            def show(s, prefix2=):
                print_to(
                    textwrap.fill(
                        s,
                        initial_indent=prefix + prefix2,
                        subsequent_indent=prefix + prefix2 +     ,
                    )
                )

            for msg in self.incr_download(info_or_id, download_dir, force):
                
                if isinstance(msg, ErrorMessage):
                    show(msg.message)
                    if raise_on_error:
                        raise ValueError(msg.message)
                    if halt_on_error:
                        return False
                    self._errors = True
                    if not quiet:
                        print_toError installing package. Retry? [n/y/e]
                        choice = input().strip()
                        if choice in ['y', 'Y']:
                            if not self.download(
                                msg.package.id,
                                download_dir,
                                quiet,
                                force,
                                prefix,
                                halt_on_error,
                                raise_on_error,
                            ):
                                return False
                        elif choice in ['e', 'E']:
                            return False

                
                if not quiet:
                    
                    if isinstance(msg, StartCollectionMessage):
                        show(Downloading collection %r % msg.collection.id)
                        prefix +=    | 
                        print_to(prefix)
                    elif isinstance(msg, FinishCollectionMessage):
                        print_to(prefix)
                        prefix = prefix[:-4]
                        if self._errors:
                            show(
                                Downloaded collection %r with errors
                                % msg.collection.id
                            )
                        else:
                            show(Done downloading collection %s % msg.collection.id)

                    
                    elif isinstance(msg, StartPackageMessage):
                        show(
                            Downloading package %s to %s...
                            % (msg.package.id, download_dir)
                        )
                    elif isinstance(msg, UpToDateMessage):
                        show(Package %s is already up-to-date! % msg.package.id,   )
                    
                    
                    
                    elif isinstance(msg, StartUnzipMessage):
                        show(Unzipping %s. % msg.package.filename,   )

                    
                    elif isinstance(msg, SelectDownloadDirMessage):
                        download_dir = msg.download_dir
        return True

    def is_stale(self, info_or_id, download_dir=None):
        return self.status(info_or_id, download_dir) == self.STALE

    def is_installed(self, info_or_id, download_dir=None):
        return self.status(info_or_id, download_dir) == self.INSTALLED

    def clear_status_cache(self, id=None):
        if id is None:
            self._status_cache.clear()
        else:
            self._status_cache.pop(id, None)

    def status(self, info_or_id, download_dir=None):
        
        if download_dir is None:
            download_dir = self._download_dir
        info = self._info_or_id(info_or_id)

        
        if isinstance(info, Collection):
            pkg_status = [self.status(pkg.id) for pkg in info.packages]
            if self.STALE in pkg_status:
                return self.STALE
            elif self.PARTIAL in pkg_status:
                return self.PARTIAL
            elif self.INSTALLED in pkg_status and self.NOT_INSTALLED in pkg_status:
                return self.PARTIAL
            elif self.NOT_INSTALLED in pkg_status:
                return self.NOT_INSTALLED
            else:
                return self.INSTALLED

        
        else:
            filepath = os.path.join(download_dir, info.filename)
            if download_dir != self._download_dir:
                return self._pkg_status(info, filepath)
            else:
                if info.id not in self._status_cache:
                    self._status_cache[info.id] = self._pkg_status(info, filepath)
                return self._status_cache[info.id]

    def _pkg_status(self, info, filepath):
        if not os.path.exists(filepath):
            return self.NOT_INSTALLED

        
        try:
            filestat = os.stat(filepath)
        except OSError:
            return self.NOT_INSTALLED
        if filestat.st_size != int(info.size):
            return self.STALE

        
        if md5_hexdigest(filepath) != info.checksum:
            return self.STALE

        
        
        if filepath.endswith.zip:
            unzipdir = filepath[:-4]
            if not os.path.exists(unzipdir):
                return self.INSTALLED  
            if not os.path.isdir(unzipdir):
                return self.STALE

            unzipped_size = sum(
                os.stat(os.path.join(d, f)).st_size
                for d, _, files in os.walk(unzipdir)
                for f in files
            )
            if unzipped_size != info.unzipped_size:
                return self.STALE

        
        return self.INSTALLED

    def update(self, quiet=False, prefix=[nltk_data] ):
        
        self.clear_status_cache()
        for pkg in self.packages():
            if self.status(pkg) == self.STALE:
                self.download(pkg, quiet=quiet, prefix=prefix)

    
    
    

    def _update_index(self, url=None):
        
        
        if not (
            self._index is None
            or url is not None
            or time.time() - self._index_timestamp > self.INDEX_TIMEOUT
        ):
            return

        
        self._url = url or self._url

        
        self._index = nltk.internals.ElementWrapper(
            xml.etree.ElementTree.parse(urlopen(self._url)).getroot()
        )
        self._index_timestamp = time.time()

        
        packages = [Package.fromxml(p) for p in self._index.findallpackages/package]
        self._packages = dict((p.id, p) for p in packages)

        
        collections = [
            Collection.fromxml(c) for c in self._index.findallcollections/collection
        ]
        self._collections = dict((c.id, c) for c in collections)

        
        for collection in self._collections.values():
            for i, child_id in enumerate(collection.children):
                if child_id in self._packages:
                    collection.children[i] = self._packages[child_id]
                elif child_id in self._collections:
                    collection.children[i] = self._collections[child_id]
                else:
                    print(
                        <built-in method format of str object at 0x7f5fe0903f90>(
                            child_id
                        )
                    )
                    del collection.children[i]

        
        for collection in self._collections.values():
            packages = {}
            queue = [collection]
            for child in queue:
                if isinstance(child, Collection):
                    queue.extend(child.children)
                elif isinstance(child, Package):
                    packages[child.id] = child
                else:
                    pass
            collection.packages = packages.values()

        
        self._status_cache.clear()

    def index(self):
        
        self._update_index()
        return self._index

    def info(self, id):
        
        self._update_index()
        if id in self._packages:
            return self._packages[id]
        if id in self._collections:
            return self._collections[id]
        raise ValueError(Package %r not found in index % id)

    def xmlinfo(self, id):
        
        self._update_index()
        for package in self._index.findallpackages/package:
            if package.getid == id:
                return package
        for collection in self._index.findallcollections/collection:
            if collection.getid == id:
                return collection
        raise ValueError(Package %r not found in index % id)

    
    
    

    def _get_url(self):
        
        return self._url

    def _set_url(self, url):
        
        original_url = self._url
        try:
            self._update_index(url)
        except:
            self._url = original_url
            raise

    url = property(_get_url, _set_url)

    def default_download_dir(self):
        
        
        if APPENGINE_RUNTIME in os.environ:
            return

        
        
        for nltkdir in nltk.data.path:
            if os.path.exists(nltkdir) and nltk.internals.is_writable(nltkdir):
                return nltkdir

        
        if sys.platform == win32 and APPDATA in os.environ:
            homedir = os.environ[APPDATA]

        
        else:
            homedir = os.path.expanduser~/
            if homedir == ~/:
                raise ValueError()

        
        return os.path.join(homedir, nltk_data)

    def _get_download_dir(self):
        
        return self._download_dir

    def _set_download_dir(self, download_dir):
        self._download_dir = download_dir
        
        self._status_cache.clear()

    download_dir = property(_get_download_dir, _set_download_dir)

    
    
    

    def _interactive_download(self):
        
        
        if TKINTER:
            try:
                DownloaderGUI(self).mainloop()
            except TclError:
                DownloaderShell(self).run()
        else:
            DownloaderShell(self).run()


class DownloaderShell(object):
    def __init__(self, dataserver):
        self._ds = dataserver

    def _simple_interactive_menu(self, *options):
        print---------------------------------------------------------------------------
        spc = (68 - sum(len(o) for o in options)) // (len(options) - 1) *  
        print(     + spc.join(options))
        
        
        
        print---------------------------------------------------------------------------

    def run(self):
        print()
        while True:
            self._simple_interactive_menu('d) Download', 'l) List', ' u) Update', 'c) Config', 'h) Help', 'q) Quit')
            user_input = inputDownloader> .strip()
            if not user_input:
                print()
                continue
            command = user_six.moves.input.lower().split()[0]
            args = user_six.moves.input.split()[1:]
            try:
                if command == l:
                    print()
                    self._ds.list(self._ds.download_dir, header=False, more_prompt=True)
                elif command == h:
                    self._simple_interactive_help()
                elif command == c:
                    self._simple_interactive_config()
                elif command in ('q', 'x'):
                    return
                elif command == d:
                    self._simple_interactive_download(args)
                elif command == u:
                    self._simple_interactive_update()
                else:
                    print(Command %r unrecognized % user_input)
            except HTTPError as e:
                print(Error reading from server: %s % e)
            except URLError as e:
                print(Error connecting to server: %s % e.reason)
            
            
            print()

    def _simple_interactive_download(self, args):
        if args:
            for arg in args:
                try:
                    self._ds.download(arg, prefix=    )
                except (IOError, ValueError) as e:
                    print(e)
        else:
            while True:
                print()
                print()
                user_input = input  Identifier> 
                if user_six.moves.input.lower() == l:
                    self._ds.list(
                        self._ds.download_dir,
                        header=False,
                        more_prompt=True,
                        skip_installed=True,
                    )
                    continue
                elif user_six.moves.input.lower() in ('x', 'q', ''):
                    return
                elif user_input:
                    for id in user_six.moves.input.split():
                        try:
                            self._ds.download(id, prefix=    )
                        except (IOError, ValueError) as e:
                            print(e)
                    break

    def _simple_interactive_update(self):
        while True:
            stale_packages = []
            stale = partial = False
            for info in sorted(getattr(self._ds, packages)(), key=str):
                if self._ds.status(info) == self._ds.STALE:
                    stale_packages.append((info.id, info.name))

            print()
            if stale_packages:
                print()
                for pid, pname in stale_packages:
                    name = textwrap.fill(
                        --------------------------- + (pname), 75, subsequent_indent=                           
                    )[27:]
                    print(), name))
                print()

                user_input = input  Identifier> 
                if user_six.moves.input.lower() == o:
                    for pid, pname in stale_packages:
                        try:
                            self._ds.download(pid, prefix=    )
                        except (IOError, ValueError) as e:
                            print(e)
                    break
                elif user_six.moves.input.lower() in ('x', 'q', ''):
                    return
            else:
                print()
                return

    def _simple_interactive_help(self):
        print()
        print()
        print()
        print()
        print()

    def _show_config(self):
        print()
        print()
        print(  - URL: <%s> % self._ds.url)
        print((  - %d Package Collections Available % len(self._ds.collections())))
        print((  - %d Individual Packages Available % len(self._ds.packages())))
        print()
        print()
        print(  - Data directory: %s % self._ds.download_dir)

    def _simple_interactive_config(self):
        self._show_config()
        while True:
            print()
            self._simple_interactive_menu('s) Show Config', 'u) Set Server URL', 'd) Set Data Dir', 'm) Main Menu')
            user_input = inputConfig> .strip().lower()
            if user_input == s:
                self._show_config()
            elif user_input == d:
                new_dl_dir = input  New Directory> .strip()
                if new_dl_dir in ('', 'x', 'q', 'X', 'Q'):
                    print()
                elif os.path.isdir(new_dl_dir):
                    self._ds.download_dir = new_dl_dir
                else:
                    print((Directory %r not found!  Create it first. % new_dl_dir))
            elif user_input == u:
                new_url = input  New URL> .strip()
                if new_url in ('', 'x', 'q', 'X', 'Q'):
                    print()
                else:
                    if not new_url.startswith('http://', 'https://'):
                        new_url = http:// + new_url
                    try:
                        self._ds.url = new_url
                    except Exception as e:
                        print(Error reading <%r>:
  %s % (new_url, e))
            elif user_input == m:
                break


class DownloaderGUI(object):
    

    
    
    

    COLUMNS = ['', 'Identifier', 'Name', 'Size', 'Status', 'Unzipped Size', 'Copyright', 'Contact', 'License', 'Author', 'Subdir', 'Checksum']
    

    COLUMN_WEIGHTS = {'': 0, 'Name': 5, 'Size': 0, 'Status': 0}
    

    COLUMN_WIDTHS = {'': 1, 'Identifier': 20, 'Name': 45, 'Size': 10, 'Unzipped Size': 10, 'Status': 12}
    

    DEFAULT_COLUMN_WIDTH = 30
    

    INITIAL_COLUMNS = ['', 'Identifier', 'Name', 'Size', 'Status']
    

    
    
    for c in COLUMN_WEIGHTS:
        assert c in COLUMNS
    for c in COLUMN_WIDTHS:
        assert c in COLUMNS
    for c in INITIAL_COLUMNS:
        assert c in COLUMNS

    
    
    

    _BACKDROP_COLOR = ('

    _ROW_COLOR = {
        Downloader.INSTALLED: ('
        Downloader.PARTIAL: ('
        Downloader.STALE: ('
        Downloader.NOT_INSTALLED: ('
    }

    _MARK_COLOR = ('

    
    
    _FRONT_TAB_COLOR = ('
    _BACK_TAB_COLOR = ('

    _PROGRESS_COLOR = ('

    _TAB_FONT = helvetica -16 bold

    
    
    

    def __init__(self, dataserver, use_threads=True):
        self._ds = dataserver
        self._use_threads = use_threads

        
        self._download_lock = threading.Lock()
        self._download_msg_queue = []
        self._download_abort_queue = []
        self._downloading = False

        
        self._afterid = {}

        
        self._log_messages = []
        self._log_indent = 0
        self._logNLTK Downloader Started!

        
        top = self.top = Tk()
        top.geometry+50+50
        top.titleNLTK Downloader
        top.configure(background=self._BACKDROP_COLOR[1])

        
        top.bind(<Control-q>, self.destroy)
        top.bind(<Control-x>, self.destroy)
        self._destroyed = False

        self._column_vars = {}

        
        self._init_widgets()
        self._init_menu()
        try:
            self._fill_table()
        except HTTPError as e:
            showerror(Error reading from server, e)
        except URLError as e:
            showerror(Error connecting to server, e.reason)

        self._show_info()
        self._select_columns()
        self._table.select0

        
        
        self._table.bind(<Destroy>, self._destroy)

    def _log(self, msg):
        self._log_messages.append(
            %s %s%s % (time.ctime(),  |  * self._log_indent, msg)
        )

    
    
    

    def _init_widgets(self):
        
        f1 = Frame(self.top, relief=raised, border=2, padx=8, pady=0)
        f1.pack(sid=top, expand=True, fill=both)
        f1.grid_rowconfigure(2, weight=1)
        f1.grid_columnconfigure(0, weight=1)
        Frame(f1, height=8).grid(column=0, row=0)  
        tabframe = Frame(f1)
        tabframe.grid(column=0, row=1, sticky=news)
        tableframe = Frame(f1)
        tableframe.grid(column=0, row=2, sticky=news)
        buttonframe = Frame(f1)
        buttonframe.grid(column=0, row=3, sticky=news)
        Frame(f1, height=8).grid(column=0, row=4)  
        infoframe = Frame(f1)
        infoframe.grid(column=0, row=5, sticky=news)
        Frame(f1, height=8).grid(column=0, row=6)  
        progressframe = Frame(
            self.top, padx=3, pady=3, background=self._BACKDROP_COLOR[1]
        )
        progressframe.pack(side=bottom, fill=x)
        self.top[border] = 0
        self.top[highlightthickness] = 0

        
        self._tab_names = ['Collections', 'Corpora', 'Models', 'All Packages']
        self._tabs = {}
        for i, tab in enumerate(self._tab_names):
            label = Label(tabframe, text=tab, font=self._TAB_FONT)
            label.pack(side=left, padx=((i + 1) % 2) * 10)
            label.bind(<Button-1>, self._select_tab)
            self._tabs[tab.lower()] = label

        
        column_weights = [self.COLUMN_WEIGHTS.get(column, 1) for column in self.COLUMNS]
        self._table = Table(
            tableframe,
            self.COLUMNS,
            column_weights=column_weights,
            highlightthickness=0,
            listbox_height=16,
            reprfunc=self._table_reprfunc,
        )
        self._table.columnconfig(0, foreground=self._MARK_COLOR[0])  
        for i, column in enumerate(self.COLUMNS):
            width = self.COLUMN_WIDTHS.get(column, self.DEFAULT_COLUMN_WIDTH)
            self._table.columnconfig(i, width=width)
        self._table.pack(expand=True, fill=both)
        self._table.focus()
        self._table.bind_to_listboxes(<Double-Button-1>, self._download)
        self._table.bind(<space>, self._table_mark)
        self._table.bind(<Return>, self._download)
        self._table.bind(<Left>, self._prev_tab)
        self._table.bind(<Right>, self._next_tab)
        self._table.bind(<Control-a>, self._mark_all)

        
        infoframe.grid_columnconfigure(1, weight=1)

        info = [
            (url, Server Index:, self._set_url),
            (download_dir, Download Directory:, self._set_download_dir),
        ]
        self._info = {}
        for (i, (key, label, callback)) in enumerate(info):
            Label(infoframe, text=label).grid(column=0, row=i, sticky=e)
            entry = Entry(
                infoframe, font=courier, relief=groove, disabledforeground=black
            )
            self._info[key] = (entry, callback)
            entry.bind(<Return>, self._info_save)
            entry.bind(<Button-1>, lambda e, key=key: self._info_edit(key))
            entry.grid(column=1, row=i, sticky=ew)

        
        
        self.top.bind(<Button-1>, self._info_save)

        
        self._download_button = Button(
            buttonframe, text=Download, command=self._download, width=8
        )
        self._download_button.pack(side=left)
        self._refresh_button = Button(
            buttonframe, text=Refresh, command=self._refresh, width=8
        )
        self._refresh_button.pack(side=right)

        
        self._progresslabel = Label(
            progressframe,
            text=,
            foreground=self._BACKDROP_COLOR[0],
            background=self._BACKDROP_COLOR[1],
        )
        self._progressbar = Canvas(
            progressframe,
            width=200,
            height=16,
            background=self._PROGRESS_COLOR[1],
            relief=sunken,
            border=1,
        )
        self._init_progressbar()
        self._progressbar.pack(side=right)
        self._progresslabel.pack(side=left)

    def _init_menu(self):
        menubar = Menu(self.top)

        filemenu = Menu(menubar, tearoff=0)
        filemenu.add_command(
            label=Download, underline=0, command=self._download, accelerator=Return
        )
        filemenu.add_separator()
        filemenu.add_command(
            label=Change Server Index,
            underline=7,
            command=<function <lambda> at 0x7f5fe0983d80>,
        )
        filemenu.add_command(
            label=Change Download Directory,
            underline=0,
            command=<function <lambda> at 0x7f5fe09820c0>,
        )
        filemenu.add_separator()
        filemenu.add_command(label=Show Log, underline=5, command=self._show_log)
        filemenu.add_separator()
        filemenu.add_command(
            label=Exit, underline=1, command=self.destroy, accelerator=Ctrl-x
        )
        menubar.add_cascade(label=File, underline=0, menu=filemenu)

        
        
        
        viewmenu = Menu(menubar, tearoff=0)
        for column in self._table.column_names[2:]:
            var = IntVar(self.top)
            assert column not in self._column_vars
            self._column_vars[column] = var
            if column in self.INITIAL_COLUMNS:
                var.set1
            viewmenu.add_checkbutton(
                label=column, underline=0, variable=var, command=self._select_columns
            )
        menubar.add_cascade(label=View, underline=0, menu=viewmenu)

        
        
        
        sortmenu = Menu(menubar, tearoff=0)
        for column in self._table.column_names[1:]:
            sortmenu.add_command(
                label=Sort by %s % column,
                command=(lambda c=column: self._table.sort_by(c, ascending)),
            )
        sortmenu.add_separator()
        
        for column in self._table.column_names[1:]:
            sortmenu.add_command(
                label=Reverse sort by %s % column,
                command=(lambda c=column: self._table.sort_by(c, descending)),
            )
        menubar.add_cascade(label=Sort, underline=0, menu=sortmenu)

        helpmenu = Menu(menubar, tearoff=0)
        helpmenu.add_command(label=About, underline=0, command=self.about)
        helpmenu.add_command(
            label=Instructions, underline=0, command=self.help, accelerator=F1
        )
        menubar.add_cascade(label=Help, underline=0, menu=helpmenu)
        self.top.bind(<F1>, self.help)

        self.top.config(menu=menubar)

    def _select_columns(self):
        for (column, var) in self._column_vars.items():
            if var.get():
                self._table.show_column(column)
            else:
                self._table.hide_column(column)

    def _refresh(self):
        self._ds.clear_status_cache()
        try:
            self._fill_table()
        except HTTPError as e:
            showerror(Error reading from server, e)
        except URLError as e:
            showerror(Error connecting to server, e.reason)
        self._table.select0

    def _info_edit(self, info_key):
        self._info_save()  
        (entry, callback) = self._info[info_key]
        entry[state] = normal
        entry[relief] = sunken
        entry.focus()

    def _info_save(self, e=None):
        focus = self._table
        for entry, callback in self._info.values():
            if entry[state] == disabled:
                continue
            if e is not None and e.widget is entry and e.keysym != Return:
                focus = entry
            else:
                entry[state] = disabled
                entry[relief] = groove
                callback(entry.get())
        focus.focus()

    def _table_reprfunc(self, row, col, val):
        if self._table.column_names[col].endswithSize:
            if isinstance(val, string_types):
                return   %s % val
            elif val < 1048576:
                return   %.1f KB % (val / 1024.0)
            elif val < 1073741824:
                return   %.1f MB % (val / 1048576.0)
            else:
                return   %.1f GB % (val / 1073741824.0)

        if col in (0, ''):
            return str(val)
        else:
            return   %s % val

    def _set_url(self, url):
        if url == self._ds.url:
            return
        try:
            self._ds.url = url
            self._fill_table()
        except IOError as e:
            showerror(Error Setting Server Index, str(e))
        self._show_info()

    def _set_download_dir(self, download_dir):
        if self._ds.download_dir == download_dir:
            return
        

        
        self._ds.download_dir = download_dir
        try:
            self._fill_table()
        except HTTPError as e:
            showerror(Error reading from server, e)
        except URLError as e:
            showerror(Error connecting to server, e.reason)
        self._show_info()

    def _show_info(self):
        print(showing info, self._ds.url)
        for entry, cb in self._info.values():
            entry[state] = normal
            entry.delete(0, 'end')
        self._info[url][0].insert(0, self._ds.url)
        self._info[download_dir][0].insert(0, self._ds.download_dir)
        for entry, cb in self._info.values():
            entry[state] = disabled

    def _prev_tab(self, *e):
        for i, tab in enumerate(self._tab_names):
            if tab.lower() == self._tab and i > 0:
                self._tab = self._tab_names[i - 1].lower()
                try:
                    return self._fill_table()
                except HTTPError as e:
                    showerror(Error reading from server, e)
                except URLError as e:
                    showerror(Error connecting to server, e.reason)

    def _next_tab(self, *e):
        for i, tab in enumerate(self._tab_names):
            if tab.lower() == self._tab and i < (len(self._tabs) - 1):
                self._tab = self._tab_names[i + 1].lower()
                try:
                    return self._fill_table()
                except HTTPError as e:
                    showerror(Error reading from server, e)
                except URLError as e:
                    showerror(Error connecting to server, e.reason)

    def _select_tab(self, event):
        self._tab = event.widget[text].lower()
        try:
            self._fill_table()
        except HTTPError as e:
            showerror(Error reading from server, e)
        except URLError as e:
            showerror(Error connecting to server, e.reason)

    _tab = collections
    
    _rows = None

    def _fill_table(self):
        selected_row = self._table.selected_row()
        self._table.clear()
        if self._tab == all packages:
            items = self._ds.packages()
        elif self._tab == corpora:
            items = self._ds.corpora()
        elif self._tab == models:
            items = self._ds.models()
        elif self._tab == collections:
            items = self._ds.collections()
        else:
            assert 0, bad tab value %r % self._tab
        rows = [self._package_to_columns(item) for item in items]
        self._table.extend(rows)

        
        for tab, label in self._tabs.items():
            if tab == self._tab:
                label.configure(
                    foreground=self._FRONT_TAB_COLOR[0],
                    background=self._FRONT_TAB_COLOR[1],
                )
            else:
                label.configure(
                    foreground=self._BACK_TAB_COLOR[0],
                    background=self._BACK_TAB_COLOR[1],
                )

        self._table.sort_by(Identifier, order=ascending)
        self._color_table()
        self._table.select(selected_row)

        
        
        
        
        
        self.top.after(150, self._table._scrollbar.set, *self._table._mlb.yview())
        self.top.after(300, self._table._scrollbar.set, *self._table._mlb.yview())

    def _update_table_status(self):
        for row_num in range(len(self._table)):
            status = self._ds.status(self._table[row_num, Identifier])
            self._table[row_num, Status] = status
        self._color_table()

    def _download(self, *e):
        
        
        if self._use_threads:
            return self._download_threaded(*e)

        marked = [
            self._table[row, Identifier]
            for row in range(len(self._table))
            if self._table[row, 0] != 
        ]
        selection = self._table.selected_row()
        if not marked and selection is not None:
            marked = [self._table[selection, Identifier]]

        download_iter = self._ds.incr_download(marked, self._ds.download_dir)
        self._log_indent = 0
        self._download_cb(download_iter, marked)

    _DL_DELAY = 10

    def _download_cb(self, download_iter, ids):
        try:
            msg = next(download_iter)
        except StopIteration:
            
            self._update_table_status()
            afterid = self.top.after(10, self._show_progress, 0)
            self._afterid[_download_cb] = afterid
            return

        def show(s):
            self._progresslabel[text] = s
            self._log(s)

        if isinstance(msg, ProgressMessage):
            self._show_progress(msg.progress)
        elif isinstance(msg, ErrorMessage):
            show(msg.message)
            if msg.package is not None:
                self._select(msg.package.id)
            self._show_progress(None)
            return  
        elif isinstance(msg, StartCollectionMessage):
            show(Downloading collection %s % msg.collection.id)
            self._log_indent += 1
        elif isinstance(msg, StartPackageMessage):
            show(Downloading package %s % msg.package.id)
        elif isinstance(msg, UpToDateMessage):
            show(Package %s is up-to-date! % msg.package.id)
        
        
        elif isinstance(msg, FinishDownloadMessage):
            show(Finished downloading %r. % msg.package.id)
        elif isinstance(msg, StartUnzipMessage):
            show(Unzipping %s % msg.package.filename)
        elif isinstance(msg, FinishCollectionMessage):
            self._log_indent -= 1
            show(Finished downloading collection %r. % msg.collection.id)
            self._clear_mark(msg.collection.id)
        elif isinstance(msg, FinishPackageMessage):
            self._clear_mark(msg.package.id)
        afterid = self.top.after(self._DL_DELAY, self._download_cb, download_iter, ids)
        self._afterid[_download_cb] = afterid

    def _select(self, id):
        for row in range(len(self._table)):
            if self._table[row, Identifier] == id:
                self._table.select(row)
                return

    def _color_table(self):
        
        for row in range(len(self._table)):
            bg, sbg = self._ROW_COLOR[self._table[row, Status]]
            fg, sfg = ('black', 'white')
            self._table.rowconfig(
                row,
                foreground=fg,
                selectforeground=sfg,
                background=bg,
                selectbackground=sbg,
            )
            
            self._table.itemconfigure(
                row, 0, foreground=self._MARK_COLOR[0], background=self._MARK_COLOR[1]
            )

    def _clear_mark(self, id):
        for row in range(len(self._table)):
            if self._table[row, Identifier] == id:
                self._table[row, 0] = 

    def _mark_all(self, *e):
        for row in range(len(self._table)):
            self._table[row, 0] = X

    def _table_mark(self, *e):
        selection = self._table.selected_row()
        if selection >= 0:
            if self._table[selection][0] != :
                self._table[selection, 0] = 
            else:
                self._table[selection, 0] = X
        self._table.select(delta=1)

    def _show_log(self):
        text = <built-in method join of str object at 0x7f5fe6c6e138>(self._log_messages)
        ShowText(self.top, NLTK Downloader Log, text)

    def _package_to_columns(self, pkg):
        
        row = []
        for column_index, column_name in enumerate(self.COLUMNS):
            if column_index == 0:  
                row.append
            elif column_name == Identifier:
                row.append(pkg.id)
            elif column_name == Status:
                row.append(self._ds.status(pkg))
            else:
                attr = column_name.lower().replace(' ', '_')
                row.append(getattr(pkg, attr, n/a))
        return row

    
    
    

    def destroy(self, *e):
        if self._destroyed:
            return
        self.top.destroy()
        self._destroyed = True

    def _destroy(self, *e):
        if self.top is not None:
            for afterid in self._afterid.values():
                self.top.after_cancel(afterid)

        
        if self._downloading and self._use_threads:
            self._abort_download()

        
        
        
        self._column_vars.clear()

    def mainloop(self, *args, **kwargs):
        self.top.mainloop(*args, **kwargs)

    
    
    

    HELP = textwrap.dedent()

    def help(self, *e):
        
        try:
            ShowText(
                self.top,
                Help: NLTK Dowloader,
                self.HELP.strip(),
                width=75,
                font=fixed,
            )
        except:
            ShowText(self.top, Help: NLTK Downloader, self.HELP.strip(), width=75)

    def about(self, *e):
        ABOUT = NLTK Downloader
Written by Edward Loper
        TITLE = About: NLTK Downloader
        try:
            from six.moves.tkinter_messagebox import Message

            Message(message=ABOUT, title=TITLE).show()
        except ImportError:
            ShowText(self.top, TITLE, ABOUT)

    
    
    

    _gradient_width = 5

    def _init_progressbar(self):
        c = self._progressbar
        width, height = int(c[width]), int(c[height])
        for i in range(0, (int(c[width]) * 2) // self._gradient_width):
            c.create_line(
                i * self._gradient_width + 20,
                -20,
                i * self._gradient_width - height - 20,
                height + 20,
                width=self._gradient_width,
                fill='
            )
        c.addtag_allgradient
        c.itemconfig(gradient, state=hidden)

        
        c.addtag_withtag(
            redbox, c.create_rectangle(0, 0, 0, 0, fill=self._PROGRESS_COLOR[0])
        )

    def _show_progress(self, percent):
        c = self._progressbar
        if percent is None:
            c.coords('redbox', 0, 0, 0, 0)
            c.itemconfig(gradient, state=hidden)
        else:
            width, height = int(c[width]), int(c[height])
            x = percent * int(width) // 100 + 1
            c.coords(redbox, 0, 0, x, height + 1)

    def _progress_alive(self):
        c = self._progressbar
        if not self._downloading:
            c.itemconfig(gradient, state=hidden)
        else:
            c.itemconfig(gradient, state=normal)
            x1, y1, x2, y2 = c.bboxgradient
            if x1 <= -100:
                c.move(gradient, (self._gradient_width * 6) - 4, 0)
            else:
                c.move('gradient', -4, 0)
            afterid = self.top.after(200, self._progress_alive)
            self._afterid[_progress_alive] = afterid

    
    
    

    def _download_threaded(self, *e):
        
        
        if self._downloading:
            self._abort_download()
            return

        
        self._download_button[text] = Cancel

        marked = [
            self._table[row, Identifier]
            for row in range(len(self._table))
            if self._table[row, 0] != 
        ]
        selection = self._table.selected_row()
        if not marked and selection is not None:
            marked = [self._table[selection, Identifier]]

        
        
        
        ds = Downloader(self._ds.url, self._ds.download_dir)

        
        assert self._download_msg_queue == []
        assert self._download_abort_queue == []
        self._DownloadThread(
            ds,
            marked,
            self._download_lock,
            self._download_msg_queue,
            self._download_abort_queue,
        ).start()

        
        self._log_indent = 0
        self._downloading = True
        self._monitor_message_queue()

        
        
        self._progress_alive()

    def _abort_download(self):
        if self._downloading:
            self._download_lock.acquire()
            self._download_abort_queue.appendabort
            self._download_lock.release()

    class _DownloadThread(threading.Thread):
        def __init__(self, data_server, items, lock, message_queue, abort):
            self.data_server = data_server
            self.items = items
            self.lock = lock
            self.message_queue = message_queue
            self.abort = abort
            threading.Thread.__init__(self)

        def run(self):
            for msg in self.data_server.incr_download(self.items):
                self.lock.acquire()
                self.message_queue.append(msg)
                
                if self.abort:
                    self.message_queue.appendaborted
                    self.lock.release()
                    return
                self.lock.release()
            self.lock.acquire()
            self.message_queue.appendfinished
            self.lock.release()

    _MONITOR_QUEUE_DELAY = 100

    def _monitor_message_queue(self):
        def show(s):
            self._progresslabel[text] = s
            self._log(s)

        
        if not self._download_lock.acquire():
            return
        for msg in self._download_msg_queue:

            
            if msg == finished or msg == aborted:
                
                self._update_table_status()
                self._downloading = False
                self._download_button[text] = Download
                del self._download_msg_queue[:]
                del self._download_abort_queue[:]
                self._download_lock.release()
                if msg == aborted:
                    showDownload aborted!
                    self._show_progress(None)
                else:
                    afterid = self.top.after(100, self._show_progress, None)
                    self._afterid[_monitor_message_queue] = afterid
                return

            
            elif isinstance(msg, ProgressMessage):
                self._show_progress(msg.progress)
            elif isinstance(msg, ErrorMessage):
                show(msg.message)
                if msg.package is not None:
                    self._select(msg.package.id)
                self._show_progress(None)
                self._downloading = False
                return  
            elif isinstance(msg, StartCollectionMessage):
                show(Downloading collection %r % msg.collection.id)
                self._log_indent += 1
            elif isinstance(msg, StartPackageMessage):
                self._ds.clear_status_cache(msg.package.id)
                show(Downloading package %r % msg.package.id)
            elif isinstance(msg, UpToDateMessage):
                show(Package %s is up-to-date! % msg.package.id)
            
            
            
            elif isinstance(msg, FinishDownloadMessage):
                show(Finished downloading %r. % msg.package.id)
            elif isinstance(msg, StartUnzipMessage):
                show(Unzipping %s % msg.package.filename)
            elif isinstance(msg, FinishUnzipMessage):
                show(Finished installing %s % msg.package.id)
            elif isinstance(msg, FinishCollectionMessage):
                self._log_indent -= 1
                show(Finished downloading collection %r. % msg.collection.id)
                self._clear_mark(msg.collection.id)
            elif isinstance(msg, FinishPackageMessage):
                self._update_table_status()
                self._clear_mark(msg.package.id)

        
        
        
        if self._download_abort_queue:
            self._progresslabel[text] = Aborting download...

        
        del self._download_msg_queue[:]
        self._download_lock.release()

        
        afterid = self.top.after(self._MONITOR_QUEUE_DELAY, self._monitor_message_queue)
        self._afterid[_monitor_message_queue] = afterid








def md5_hexdigest(file):
    
    if isinstance(file, string_types):
        with open(file, rb) as infile:
            return _md5_hexdigest(infile)
    return _md5_hexdigest(file)


def _md5_hexdigest(fp):
    md5_digest = md5()
    while True:
        block = fp.read16384  
        if not block:
            break
        md5_digest.update(block)
    return md5_digest.hexdigest()





def unzip(filename, root, verbose=True):
    
    for message in _unzip_iter(filename, root, verbose):
        if isinstance(message, ErrorMessage):
            raise Exception(message)


def _unzip_iter(filename, root, verbose=True):
    if verbose:
        sys.stdout.write(Unzipping %s % os.path.split(filename)[1])
        sys.stdout.flush()

    try:
        zf = zipfile.ZipFile(filename)
    except zipfile.error as e:
        yield ErrorMessage(filename, Error with downloaded zip file)
        return
    except Exception as e:
        yield ErrorMessage(filename, e)
        return

    
    namelist = zf.namelist()
    dirlist = set()
    for x in namelist:
        if x.endswith/:
            dirlist.add(x)
        else:
            dirlist.add(x.rsplit('/', 1)[0] + /)
    filelist = [x for x in namelist if not x.endswith/]

    
    if not os.path.exists(root):
        os.mkdir(root)

    
    for dirname in sorted(dirlist):
        pieces = dirname[:-1].split/
        for i in range(len(pieces)):
            dirpath = os.path.join(root, *pieces[: i + 1])
            if not os.path.exists(dirpath):
                os.mkdir(dirpath)

    
    for i, filename in enumerate(filelist):
        filepath = os.path.join(root, *filename.split/)

        try:
            with open(filepath, wb) as dstfile, zf.open(filename) as srcfile:
                shutil.copyfileobj(srcfile, dstfile)
        except Exception as e:
            yield ErrorMessage(filename, e)
            return

        if verbose and (i * 10 / len(filelist) > (i - 1) * 10 / len(filelist)):
            sys.stdout.write.
            sys.stdout.flush()
    if verbose:
        print()








def build_index(root, base_url):
    
    
    packages = []
    for pkg_xml, zf, subdir in _find_packages(os.path.join(root, packages)):
        zipstat = os.stat(zf.filename)
        url = %s/%s/%s % (base_url, subdir, os.path.split(zf.filename)[1])
        unzipped_size = sum(zf_info.file_size for zf_info in zf.infolist())

        
        pkg_xml.set(unzipped_size, %s % unzipped_size)
        pkg_xml.set(size, %s % zipstat.st_size)
        pkg_xml.set(checksum, %s % md5_hexdigest(zf.filename))
        pkg_xml.set(subdir, subdir)
        
        if not pkg_xml.geturl:
            pkg_xml.set(url, url)

        
        packages.append(pkg_xml)

    
    collections = list(_find_collections(os.path.join(root, collections)))

    
    uids = set()
    for item in packages + collections:
        if item.getid in uids:
            raise ValueError())
        uids.add(item.getid)

    
    top_elt = xml.etree.ElementTree.Elementnltk_data
    top_elt.append(xml.etree.ElementTree.Elementpackages)
    for package in packages:
        top_elt[0].append(package)
    top_elt.append(xml.etree.ElementTree.Elementcollections)
    for collection in collections:
        top_elt[1].append(collection)

    _indent_xml(top_elt)
    return top_elt


def _indent_xml(xml, prefix=):
    
    if len(xml) > 0:
        xml.text = (xml.text or ).strip() + 
 + prefix +   
        for child in xml:
            _indent_xml(child, prefix +   )
        for child in xml[:-1]:
            child.tail = (child.tail or ).strip() + 
 + prefix +   
        xml[-1].tail = (xml[-1].tail or ).strip() + 
 + prefix


def _check_package(pkg_xml, zipfilename, zf):
    
    
    uid = os.path.splitext(os.path.split(zipfilename)[1])[0]
    if pkg_xml.getid != uid:
        raise ValueError(), uid)
        )

    
    if sum((name != uid and not name.startswith(uid + /)) for name in zf.namelist()):
        raise ValueError(
            Zipfile %s.zip does not expand to a single 
            subdirectory %s/ % (uid, uid)
        )



def _svn_revision(filename):
    
    p = subprocess.Popen(
        [svn, status, -v, filename],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    (stdout, stderr) = p.communicate()
    if p.returncode != 0 or stderr or not stdout:
        raise ValueError(
            Error determining svn_revision for %s: %s
            % (os.path.split(filename)[1], textwrap.fill(stderr))
        )
    return stdout.split()[2]


def _find_collections(root):
    
    packages = []
    for dirname, subdirs, files in os.walk(root):
        for filename in files:
            if filename.endswith.xml:
                xmlfile = os.path.join(dirname, filename)
                yield xml.etree.ElementTree.parse(xmlfile).getroot()


def _find_packages(root):
    
    from nltk.corpus.reader.util import _path_from

    
    packages = []
    for dirname, subdirs, files in os.walk(root):
        relpath = <built-in method join of str object at 0x7f5fe6c6e950>(_path_from(root, dirname))
        for filename in files:
            if filename.endswith.xml:
                xmlfilename = os.path.join(dirname, filename)
                zipfilename = xmlfilename[:-4] + .zip
                try:
                    zf = zipfile.ZipFile(zipfilename)
                except Exception as e:
                    raise ValueError(Error reading file %r!
%s % (zipfilename, e))
                try:
                    pkg_xml = xml.etree.ElementTree.parse(xmlfilename).getroot()
                except Exception as e:
                    raise ValueError(Error reading file %r!
%s % (xmlfilename, e))

                
                uid = os.path.split(xmlfilename[:-4])[1]
                if pkg_xml.getid != uid:
                    raise ValueError(
                        package identifier mismatch (%s 
                        vs %s) % (pkg_xml.getid, uid)
                    )

                
                
                if sum(
                    (name != uid and not name.startswith(uid + /))
                    for name in zf.namelist()
                ):
                    raise ValueError(
                        Zipfile %s.zip does not expand to a 
                        single subdirectory %s/ % (uid, uid)
                    )

                yield pkg_xml, zf, relpath
        
        try:
            subdirs.remove.svn
        except ValueError:
            pass









_downloader = Downloader()
download = _downloader.download


def download_shell():
    DownloaderShell(_downloader).run()


def download_gui():
    DownloaderGUI(_downloader).mainloop()


def update():
    _downloader.update()


