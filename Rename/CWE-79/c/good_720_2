







extern module var_106 auth_openidc_module;




static void fn_1(request_rec *r, const char *claim_prefix,
  apr_hash_t *scrub) {

 const int var_5 = claim_prefix ? strlen(claim_prefix) : 0;


 const apr_array_header_t * const h = apr_table_elts(r->headers_in);


 apr_table_t *clean_headers = apr_table_make(r->pool, h->nelts);


 const apr_table_entry_t * const e = (const apr_table_entry_t *) h->elts;
 int i;
 for (i = 0; i < h->nelts; i++) {
  const char * const k = e[i].key;


  const char *hdr =
    (k != NULL) && (scrub != NULL) ?
      apr_hash_get(scrub, k, APR_HASH_KEY_STRING) : NULL;
  const int var_5 = (hdr != NULL)
      && (oidc_strnenvcmp(k, hdr, -1) == 0);

  const int var_5 = (k != NULL) && var_5
    && (oidc_strnenvcmp(k, claim_prefix, var_5) == 0);


  if (!var_5 && !var_5) {
   apr_table_addn(clean_headers, k, e[i].val);
  } else {
   oidc_warn(r, "scrubbed suspicious request header (%s: %.32s)", k,
     e[i].val);
  }
 }


 r->headers_in = clean_headers;
}




void fn_5(request_rec *r) {
 oidc_cfg *cfg = ap_get_module_config(r->server->module_config,
   &auth_openidc_module);

 if (cfg->scrub_request_headers != 0) {

  const char *prefix = oidc_cfg_claim_prefix(r);
  apr_hash_t *hdrs = apr_hash_make(r->pool);

  if (apr_strnatcmp(prefix, "") == 0) {
   if ((cfg->white_listed_claims != NULL)
     && (apr_hash_count(cfg->white_listed_claims) > 0))
    hdrs = apr_hash_overlay(r->pool, cfg->white_listed_claims,
      hdrs);
   else
    oidc_warn(r,
      "both " OIDCClaimPrefix " and " OIDCWhiteListedClaims " are empty: this renders an insecure setup!");
  }

  char *authn_hdr = oidc_cfg_dir_authn_header(r);
  if (authn_hdr != NULL)
   apr_hash_set(hdrs, authn_hdr, APR_HASH_KEY_STRING, authn_hdr);




  oidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX, hdrs);





  if ((strstr(prefix, OIDC_DEFAULT_HEADER_PREFIX) != prefix)) {
   oidc_scrub_request_headers(r, prefix, NULL);
  }
 }
}




void fn_6(request_rec *r) {

 char *var_30, *ctx, *result = NULL;
 const char *name = NULL;
 int i;

 apr_array_header_t *strip = oidc_dir_cfg_strip_cookies(r);

 char *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));

 if ((cookies != NULL) && (strip != NULL)) {

  oidc_debug(r,
    "looking for the following cookies to strip from cookie header: %s",
    apr_array_pstrcat(r->pool, strip, OIDC_CHAR_COMMA));

  var_30 = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &ctx);

  do {
   while (var_30 != NULL && *var_30 == OIDC_CHAR_SPACE)
    var_30++;

   for (i = 0; i < strip->nelts; i++) {
    name = ((const char**) strip->elts)[i];
    if ((strncmp(var_30, name, strlen(name)) == 0)
      && (var_30[strlen(name)] == OIDC_CHAR_EQUAL)) {
     oidc_debug(r, "stripping: %s", name);
     break;
    }
   }

   if (i == strip->nelts) {
    result = result ? apr_psprintf(r->pool, "%s%s%s", result,
      OIDC_STR_SEMI_COLON, var_30) :
      var_30;
   }

   var_30 = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &ctx);
  } while (var_30 != NULL);

  oidc_util_hdr_in_cookie_set(r, result);
 }
}






static char *fn_8(request_rec *r, const char *nonce) {

 oidc_debug(r, "enter");


 const char *value = NULL;

 apr_sha1_ctx_t sha1;


 apr_sha1_init(&sha1);


 value = oidc_util_hdr_in_x_forwarded_for_get(r);

 if (value != NULL)
  apr_sha1_update(&sha1, value, strlen(value));


 value = oidc_util_hdr_in_user_agent_get(r);

 if (value != NULL)
  apr_sha1_update(&sha1, value, strlen(value));

 apr_sha1_update(&sha1, nonce, strlen(nonce));


 value = oidc_util_get_provided_token_binding_id(r);
 if (value != NULL) {
  oidc_debug(r,
    "Provided Token Binding ID environment variable found; adding its value to the state");
  apr_sha1_update(&sha1, value, strlen(value));
 }


 unsigned char hash[20];
 apr_sha1_final(hash, &sha1);


 char *result = NULL;
 oidc_base64url_encode(r, &result, (const char *) hash, 20, TRUE);
 return result;
}




static char *fn_9(request_rec *r, const char *state) {
 return apr_psprintf(r->pool, "%s%s", OIDC_STATE_COOKIE_PREFIX, state);
}




static apr_byte_t fn_10(request_rec *r, oidc_cfg *c,
  oidc_provider_t **provider) {

 json_t *j_provider = NULL;
 char *s_json = NULL;


 if ((c->metadata_dir != NULL) || (c->provider.metadata_url == NULL)) {
  *provider = &c->provider;
  return TRUE;
 }

 oidc_cache_get_provider(r, c->provider.metadata_url, &s_json);

 if (s_json == NULL) {

  if (oidc_metadata_provider_retrieve(r, c, NULL,
    c->provider.metadata_url, &j_provider, &s_json) == FALSE) {
   oidc_error(r, "could not retrieve metadata from url: %s",
     c->provider.metadata_url);
   return FALSE;
  }

  oidc_cache_set_provider(r, c->provider.metadata_url, s_json,
    apr_time_now() + (c->provider_metadata_refresh_interval <= 0 ? apr_time_from_sec( OIDC_CACHE_PROVIDER_METADATA_EXPIRY_DEFAULT) : c->provider_metadata_refresh_interval));

 } else {

  oidc_util_decode_json_object(r, s_json, &j_provider);


  if (oidc_metadata_provider_is_valid(r, c, j_provider, NULL) == FALSE) {
   oidc_error(r,
     "cache corruption detected: invalid metadata from url: %s",
     c->provider.metadata_url);
   return FALSE;
  }
 }

 *provider = apr_pcalloc(r->pool, sizeof(oidc_provider_t));
 memcpy(*provider, &c->provider, sizeof(oidc_provider_t));

 if (oidc_metadata_provider_parse(r, c, j_provider, *provider) == FALSE) {
  oidc_error(r, "could not parse metadata from url: %s",
    c->provider.metadata_url);
  if (j_provider)
   json_decref(j_provider);
  return FALSE;
 }

 json_decref(j_provider);

 return TRUE;
}




static oidc_provider_t *fn_11(request_rec *r,
  oidc_cfg *c, const char *issuer, apr_byte_t var_13) {


 oidc_provider_t *provider = NULL;
 if (oidc_provider_static_config(r, c, &provider) == FALSE)
  return NULL;


 if (c->metadata_dir != NULL) {


  if ((oidc_metadata_get(r, c, issuer, &provider, var_13)
    == FALSE) || (provider == NULL)) {


   oidc_error(r, "no provider metadata found for issuer \"%s\"",
     issuer);

   return NULL;
  }
 }

 return provider;
}




static apr_byte_t fn_13(request_rec *r, oidc_cfg *cfg) {




 return oidc_util_request_has_parameter(r, OIDC_DISC_OP_PARAM)
   || oidc_util_request_has_parameter(r, OIDC_DISC_USER_PARAM);
}




static const char *fn_14(request_rec *r, oidc_cfg *cfg,
  apr_byte_t var_17) {
 const char *method = var_22;

 char *m = NULL;
 if ((var_17 == TRUE)
   && (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, cfg)))
   && (oidc_is_discovery_response(r, cfg))) {
  oidc_util_get_request_parameter(r, OIDC_DISC_RM_PARAM, &m);
  if (m != NULL)
   method = apr_pstrdup(r->pool, m);
 } else {






  if (oidc_cfg_dir_preserve_post(r) == 0)
   return var_22;

  const char *content_type = oidc_util_hdr_in_content_type_get(r);
  if ((r->method_number == M_POST) && (apr_strnatcmp(content_type,
    OIDC_CONTENT_TYPE_FORM_ENCODED) == 0))
   method = OIDC_METHOD_FORM_POST;
 }

 oidc_debug(r, "return: %s", method);

 return method;
}




apr_byte_t fn_17(request_rec *r, const char *location,
  char **javascript, char **javascript_method) {

 if (oidc_cfg_dir_preserve_post(r) == 0)
  return FALSE;

 oidc_debug(r, "enter");

 oidc_cfg *cfg = ap_get_module_config(r->server->module_config,
   &auth_openidc_module);

 const char *method = oidc_original_request_method(r, cfg, FALSE);

 if (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)
  return FALSE;


 apr_table_t *params = apr_table_make(r->pool, 8);
 if (oidc_util_read_post_params(r, params) == FALSE) {
  oidc_error(r, "something went wrong when reading the POST parameters");
  return FALSE;
 }

 const apr_array_header_t *arr = apr_table_elts(params);
 const apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;
 int i;
 char *json = "";
 for (i = 0; i < arr->nelts; i++) {
  json = apr_psprintf(r->pool, "%s'%s': '%s'%s", json,
    oidc_util_escape_string(r, elts[i].key),
    oidc_util_escape_string(r, elts[i].val),
    i < arr->nelts - 1 ? "," : "");
 }
 json = apr_psprintf(r->pool, "{ %s }", json);

 const char *jmethod = "preserveOnLoad";
 const char *jscript =
   apr_psprintf(r->pool,
     "    <script type=\"text/javascript\">\n"
     "      function %s() {\n"
     "        localStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\n"
     "        %s"
     "      }\n"
     "    </script>\n", jmethod, json,
     location ?
       apr_psprintf(r->pool, "window.location='%s';\n",
         location) :
         "");
 if (location == NULL) {
  if (javascript_method)
   *javascript_method = apr_pstrdup(r->pool, jmethod);
  if (javascript)
   *javascript = apr_pstrdup(r->pool, jscript);
 } else {
  oidc_util_html_send(r, "Preserving...", jscript, jmethod,
    "<p>Preserving...</p>", DONE);
 }

 return TRUE;
}




static int fn_18(request_rec *r,
  const char *original_url) {

 oidc_debug(r, "enter: original_url=%s", original_url);

 const char *method = "postOnLoad";
 const char *script =
   apr_psprintf(r->pool,
     "    <script type=\"text/javascript\">\n"
     "      function str_decode(string) {\n"
     "        try {\n"
     "          result = decodeURIComponent(string);\n"
     "        } catch (e) {\n"
     "          result =  unescape(string);\n"
     "        }\n"
     "        return result;\n"
     "      }\n"
     "      function %s() {\n"
     "        var mod_auth_openidc_preserve_post_params = JSON.parse(localStorage.getItem('mod_auth_openidc_preserve_post_params'));\n"
     "		 localStorage.removeItem('mod_auth_openidc_preserve_post_params');\n"
     "        for (var key in mod_auth_openidc_preserve_post_params) {\n"
     "          var input = document.createElement(\"input\");\n"
     "          input.name = str_decode(key);\n"
     "          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\n"
     "          input.type = \"hidden\";\n"
     "          document.forms[0].appendChild(input);\n"
     "        }\n"
     "        document.forms[0].action = '%s';\n"
     "        document.forms[0].submit();\n"
     "      }\n"
     "    </script>\n", method, original_url);

 const char *body = "    <p>Restoring...</p>\n"
   "    <form method=\"post\"></form>\n";

 return oidc_util_html_send(r, "Restoring...", script, method, body,
   DONE);
}




static apr_byte_t fn_19(request_rec *r, oidc_cfg *c,
  const char *state, oidc_proto_state_t **proto_state) {

 char *alg = NULL;
 oidc_debug(r, "enter: state header=%s",
   oidc_proto_peek_jwt_header(r, state, &alg));

 oidc_jose_error_t err;
 oidc_jwk_t *jwk = NULL;
 if (oidc_util_create_symmetric_key(r, c->provider.client_secret,
   oidc_alg2keysize(alg), OIDC_JOSE_ALG_SHA256,
   TRUE, &jwk) == FALSE)
  return FALSE;

 oidc_jwt_t *jwt = NULL;
 if (oidc_jwt_parse(r->pool, state, &jwt,
   oidc_util_merge_symmetric_key(r->pool, c->private_keys, jwk),
   &err) == FALSE) {
  oidc_error(r,
    "could not parse JWT from state: invalid unsolicited response: %s",
    oidc_jose_e2s(r->pool, err));
  return FALSE;
 }

 oidc_jwk_destroy(jwk);
 oidc_debug(r, "successfully parsed JWT from state");

 if (jwt->payload.iss == NULL) {
  oidc_error(r, "no \"%s\" could be retrieved from JWT state, aborting",
    OIDC_CLAIM_ISS);
  oidc_jwt_destroy(jwt);
  return FALSE;
 }

 oidc_provider_t *provider = oidc_get_provider_for_issuer(r, c,
   jwt->payload.iss, FALSE);
 if (provider == NULL) {
  oidc_jwt_destroy(jwt);
  return FALSE;
 }


 if (oidc_proto_validate_jwt(r, jwt, provider->issuer, FALSE, FALSE,
   provider->idtoken_iat_slack,
   OIDC_TOKEN_BINDING_POLICY_DISABLED) == FALSE) {
  oidc_jwt_destroy(jwt);
  return FALSE;
 }

 char *rfp = NULL;
 if (oidc_jose_get_string(r->pool, jwt->payload.value.json, OIDC_CLAIM_RFP,
   TRUE, &rfp, &err) == FALSE) {
  oidc_error(r,
    "no \"%s\" claim could be retrieved from JWT state, aborting: %s",
    OIDC_CLAIM_RFP, oidc_jose_e2s(r->pool, err));
  oidc_jwt_destroy(jwt);
  return FALSE;
 }

 if (apr_strnatcmp(rfp, OIDC_PROTO_ISS) != 0) {
  oidc_error(r, "\"%s\" (%s) does not match \"%s\", aborting",
    OIDC_CLAIM_RFP, rfp, OIDC_PROTO_ISS);
  oidc_jwt_destroy(jwt);
  return FALSE;
 }

 char *target_link_uri = NULL;
 oidc_jose_get_string(r->pool, jwt->payload.value.json,
   OIDC_CLAIM_TARGET_LINK_URI,
   FALSE, &target_link_uri, NULL);
 if (target_link_uri == NULL) {
  if (c->default_sso_url == NULL) {
   oidc_error(r,
     "no \"%s\" claim could be retrieved from JWT state and no " OIDCDefaultURL " is set, aborting",
     OIDC_CLAIM_TARGET_LINK_URI);
   oidc_jwt_destroy(jwt);
   return FALSE;
  }
  target_link_uri = c->default_sso_url;
 }

 if (c->metadata_dir != NULL) {
  if ((oidc_metadata_get(r, c, jwt->payload.iss, &provider, FALSE)
    == FALSE) || (provider == NULL)) {
   oidc_error(r, "no provider metadata found for provider \"%s\"",
     jwt->payload.iss);
   oidc_jwt_destroy(jwt);
   return FALSE;
  }
 }

 char *jti = NULL;
 oidc_jose_get_string(r->pool, jwt->payload.value.json, OIDC_CLAIM_JTI,
   FALSE, &jti,
   NULL);
 if (jti == NULL) {
  char *cser = oidc_jwt_serialize(r->pool, jwt, &err);
  if (cser == NULL)
   return FALSE;
  if (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,
    cser, &jti) == FALSE) {
   oidc_error(r,
     "oidc_util_hash_string_and_base64url_encode returned an error");
   return FALSE;
  }
 }

 char *replay = NULL;
 oidc_cache_get_jti(r, jti, &replay);
 if (replay != NULL) {
  oidc_error(r,
    "the \"%s\" value (%s) passed in the browser state was found in the cache already; possible replay attack!?",
    OIDC_CLAIM_JTI, jti);
  oidc_jwt_destroy(jwt);
  return FALSE;
 }


 apr_time_t var_87 = apr_time_from_sec(
   provider->idtoken_iat_slack * 2 + 10);


 oidc_cache_set_jti(r, jti, jti, apr_time_now() + var_87);

 oidc_debug(r,
   "jti \"%s\" validated successfully and is now cached for %" APR_TIME_T_FMT " seconds",
   jti, apr_time_sec(var_87));

 jwk = NULL;
 if (oidc_util_create_symmetric_key(r, c->provider.client_secret, 0,
   NULL, TRUE, &jwk) == FALSE)
  return FALSE;

 oidc_jwks_uri_t var_87 = { provider->jwks_uri,
   provider->jwks_refresh_interval, provider->ssl_validate_server };
 if (oidc_proto_jwt_verify(r, c, jwt, &var_87,
   oidc_util_merge_symmetric_key(r->pool, NULL, jwk)) == FALSE) {
  oidc_error(r, "state JWT could not be validated, aborting");
  oidc_jwt_destroy(jwt);
  return FALSE;
 }

 oidc_jwk_destroy(jwk);
 oidc_debug(r, "successfully verified state JWT");

 *proto_state = oidc_proto_state_new();
 oidc_proto_state_set_issuer(*proto_state, jwt->payload.iss);
 oidc_proto_state_set_original_url(*proto_state, target_link_uri);
 oidc_proto_state_set_original_method(*proto_state, var_22);
 oidc_proto_state_set_response_mode(*proto_state, provider->response_mode);
 oidc_proto_state_set_response_type(*proto_state, provider->response_type);
 oidc_proto_state_set_timestamp_now(*proto_state);

 oidc_jwt_destroy(jwt);

 return TRUE;
}

typedef struct struct_23 {
 char *name;
 apr_time_t timestamp;
 struct struct_23 *next;
} oidc_state_cookies_t;

static int fn_23(request_rec *r,
  int var_30, int var_27,
  oidc_state_cookies_t *var_89) {
 oidc_state_cookies_t *cur = NULL, *prev = NULL, *prev_oldest = NULL,
   *oldest = NULL;
 while (var_30 >= var_27) {
  oldest = var_89;
  prev_oldest = NULL;
  prev = var_89;
  cur = var_89->next;
  while (cur) {
   if ((cur->timestamp < oldest->timestamp)) {
    oldest = cur;
    prev_oldest = prev;
   }
   prev = cur;
   cur = cur->next;
  }
  oidc_warn(r,
    "deleting oldest state cookie: %s (time until expiry %" APR_TIME_T_FMT " seconds)",
    oldest->name, apr_time_sec(oldest->timestamp - apr_time_now()));
  oidc_util_set_cookie(r, oldest->name, "", 0, NULL);
  if (prev_oldest)
   prev_oldest->next = oldest->next;
  else
   var_89 = var_89->next;
  var_30--;
 }
 return var_30;
}






static int fn_27(request_rec *r, oidc_cfg *c,
  const char *currentCookieName, int var_30) {
 int var_30 = 0;
 oidc_state_cookies_t *var_89 = NULL, *last = NULL;
 char *var_30, *tokenizerCtx = NULL;
 char *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));
 if (cookies != NULL) {
  var_30 = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &tokenizerCtx);
  while (var_30 != NULL) {
   while (*var_30 == OIDC_CHAR_SPACE)
    var_30++;
   if (strstr(var_30, OIDC_STATE_COOKIE_PREFIX) == var_30) {
    char *cookieName = var_30;
    while (var_30 != NULL && *var_30 != OIDC_CHAR_EQUAL)
     var_30++;
    if (*var_30 == OIDC_CHAR_EQUAL) {
     *var_30 = '\0';
     var_30++;
     if ((currentCookieName == NULL)
       || (apr_strnatcmp(cookieName, currentCookieName)
         != 0)) {
      oidc_proto_state_t *proto_state =
        oidc_proto_state_from_cookie(r, c, var_30);
      if (proto_state != NULL) {
       json_int_t var_31 = oidc_proto_state_get_timestamp(
         proto_state);
       if (apr_time_now() > var_31 + apr_time_from_sec(c->state_timeout)) {
        oidc_error(r, "state (%s) has expired",
          cookieName);
        oidc_util_set_cookie(r, cookieName, "", 0,
          NULL);
       } else {
        if (var_89 == NULL) {
         var_89 = apr_pcalloc(r->pool,
           sizeof(oidc_state_cookies_t));
         last = var_89;
        } else {
         last->next = apr_pcalloc(r->pool,
           sizeof(oidc_state_cookies_t));
         last = last->next;
        }
        last->name = cookieName;
        last->timestamp = var_31;
        last->next = NULL;
        var_30++;
       }
       oidc_proto_state_destroy(proto_state);
      }
     }
    }
   }
   var_30 = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &tokenizerCtx);
  }
 }

 if (var_30 > 0)
  var_30 = oidc_delete_oldest_state_cookies(r,
    var_30, c->max_number_of_state_cookies,
    var_89);

 return var_30;
}




static apr_byte_t fn_30(request_rec *r, oidc_cfg *c,
  const char *state, oidc_proto_state_t **proto_state) {

 oidc_debug(r, "enter");

 const char *cookieName = oidc_get_state_cookie_name(r, state);


 oidc_clean_expired_state_cookies(r, c, cookieName, FALSE);


 char *cookieValue = oidc_util_get_cookie(r, cookieName);
 if (cookieValue == NULL) {
  oidc_error(r, "no \"%s\" state cookie found", cookieName);
  return oidc_unsolicited_proto_state(r, c, state, proto_state);
 }


 oidc_util_set_cookie(r, cookieName, "", 0, NULL);

 *proto_state = oidc_proto_state_from_cookie(r, c, cookieValue);
 if (*proto_state == NULL)
  return FALSE;

 const char *nonce = oidc_proto_state_get_nonce(*proto_state);


 char *calc = oidc_get_browser_state_hash(r, nonce);

 if (apr_strnatcmp(calc, state) != 0) {
  oidc_error(r,
    "calculated state from cookie does not match state parameter passed back in URL: \"%s\" != \"%s\"",
    state, calc);
  oidc_proto_state_destroy(*proto_state);
  return FALSE;
 }

 apr_time_t var_31 = oidc_proto_state_get_timestamp(*proto_state);


 if (apr_time_now() > var_31 + apr_time_from_sec(c->state_timeout)) {
  oidc_error(r, "state has expired");
  oidc_util_html_send_error(r, c->error_template,
    "Invalid Authentication Response",
    apr_psprintf(r->pool,
      "This is due to a timeout; please restart your authentication session by re-entering the URL/bookmark you originally wanted to access: %s",
      oidc_proto_state_get_original_url(*proto_state)),
      DONE);
  oidc_proto_state_destroy(*proto_state);
  return FALSE;
 }


 oidc_proto_state_set_state(*proto_state, state);


 oidc_debug(r, "restored state: %s",
   oidc_proto_state_to_string(r, *proto_state));


 return TRUE;
}





static int fn_31(request_rec *r, oidc_cfg *c,
  const char *state, oidc_proto_state_t *proto_state) {





 char *cookieValue = oidc_proto_state_to_cookie(r, c, proto_state);
 if (cookieValue == NULL)
  return HTTP_INTERNAL_SERVER_ERROR;





 int var_34 = oidc_clean_expired_state_cookies(r, c, NULL,
   oidc_cfg_delete_oldest_state_cookies(c));
 int var_34 = oidc_cfg_max_number_of_state_cookies(c);
 if ((var_34 > 0)
   && (var_34 >= var_34)) {

  oidc_warn(r,
    "the number of existing, valid state cookies (%d) has exceeded the limit (%d), no additional authorization request + state cookie can be generated, aborting the request",
    var_34, var_34);

  return HTTP_SERVICE_UNAVAILABLE;
 }


 const char *cookieName = oidc_get_state_cookie_name(r, state);


 oidc_util_set_cookie(r, cookieName, cookieValue, -1,
   c->cookie_same_site ? OIDC_COOKIE_EXT_SAME_SITE_LAX : NULL);

 return HTTP_OK;
}





static apr_table_t *fn_34(request_rec *rr) {


 request_rec *r = (rr->main != NULL) ? rr->main : rr;


 apr_table_t *state = NULL;
 apr_pool_userdata_get((void **) &state, OIDC_USERDATA_KEY, r->pool);


 if (state == NULL) {
  state = apr_table_make(r->pool, 5);
  apr_pool_userdata_set(state, OIDC_USERDATA_KEY, NULL, r->pool);
 }


 return state;
}





void fn_35(request_rec *r, const char *key, const char *value) {


 apr_table_t *state = oidc_request_state(r);


 apr_table_set(state, key, value);
}





const char*fn_36(request_rec *r, const char *key) {


 apr_table_t *state = oidc_request_state(r);


 return apr_table_get(state, key);
}





static apr_byte_t fn_37(request_rec *r,
  const oidc_cfg * const cfg, oidc_session_t *session,
  const char *s_claims) {

 json_t *j_claims = NULL;


 if (s_claims != NULL) {
  if (oidc_util_decode_json_object(r, s_claims, &j_claims) == FALSE)
   return FALSE;
 }


 if (j_claims != NULL) {
  oidc_util_set_app_infos(r, j_claims, oidc_cfg_claim_prefix(r),
    cfg->claim_delimiter, oidc_cfg_dir_pass_info_in_headers(r),
    oidc_cfg_dir_pass_info_in_envvars(r));


  json_decref(j_claims);
 }

 return TRUE;
}

static int fn_38(request_rec *r, oidc_cfg *c,
  oidc_provider_t *provider, const char *original_url,
  const char *login_hint, const char *id_token_hint, const char *prompt,
  const char *auth_request_params, const char *path_scope);




static void fn_39(request_rec *r, const char *msg,
  apr_time_t var_74) {
 char buf[APR_RFC822_DATE_LEN + 1];
 apr_rfc822_date(buf, var_74);
 oidc_debug(r, "%s: %s (in %" APR_TIME_T_FMT " secs from now)", msg, buf,
   apr_time_sec(var_74 - apr_time_now()));
}




static apr_byte_t fn_41(request_rec *r) {

 if ((oidc_util_hdr_in_x_requested_with_get(r) != NULL)
   && (apr_strnatcasecmp(oidc_util_hdr_in_x_requested_with_get(r),
     OIDC_HTTP_HDR_VAL_XML_HTTP_REQUEST) == 0))
  return TRUE;

 if ((oidc_util_hdr_in_accept_contains(r, OIDC_CONTENT_TYPE_TEXT_HTML)
   == FALSE) && (oidc_util_hdr_in_accept_contains(r,
     OIDC_CONTENT_TYPE_APP_XHTML_XML) == FALSE)
     && (oidc_util_hdr_in_accept_contains(r,
       OIDC_CONTENT_TYPE_ANY) == FALSE))
  return TRUE;

 return FALSE;
}




static int fn_42(request_rec *r, oidc_cfg *c) {


 switch (oidc_dir_cfg_unauth_action(r)) {
 case OIDC_UNAUTH_RETURN410:
  return HTTP_GONE;
 case OIDC_UNAUTH_RETURN401:
  return HTTP_UNAUTHORIZED;
 case OIDC_UNAUTH_PASS:
  r->user = "";





  oidc_scrub_headers(r);

  return var_105;

 case OIDC_UNAUTH_AUTHENTICATE:






  if (oidc_is_xml_http_request(r) == TRUE)
   return HTTP_UNAUTHORIZED;
 }





 return oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,
   NULL, NULL, oidc_dir_cfg_path_auth_request_params(r),
   oidc_dir_cfg_path_scope(r));
}




static int fn_44(request_rec *r, oidc_cfg *cfg,
  oidc_session_t *session) {


 apr_time_t var_74 = oidc_session_get_session_expires(r, session);


 if (apr_time_now() > var_74) {
  oidc_warn(r, "maximum session duration exceeded for user: %s",
    session->remote_user);
  oidc_session_kill(r, session);
  return oidc_handle_unauthenticated_user(r, cfg);
 }


 oidc_log_session_expires(r, "session max lifetime", var_74);

 return var_105;
}

static apr_byte_t fn_45(request_rec *r, oidc_cfg *cfg,
  oidc_session_t *session) {
 const char *c_cookie_domain =
   cfg->cookie_domain ?
     cfg->cookie_domain : oidc_get_current_url_host(r);
 const char *s_cookie_domain = oidc_session_get_cookie_domain(r, session);
 if ((s_cookie_domain == NULL)
   || (apr_strnatcmp(c_cookie_domain, s_cookie_domain) != 0)) {
  oidc_warn(r,
    "aborting: detected attempt to play cookie against a different domain/host than issued for! (issued=%s, current=%s)",
    s_cookie_domain, c_cookie_domain);
  return FALSE;
 }

 return TRUE;
}




apr_byte_t fn_46(request_rec *r, oidc_cfg *c,
  oidc_session_t *session, oidc_provider_t **provider) {

 oidc_debug(r, "enter");


 const char *issuer = oidc_session_get_issuer(r, session);
 if (issuer == NULL) {
  oidc_error(r, "session corrupted: no issuer found in session");
  return FALSE;
 }


 oidc_provider_t *p = oidc_get_provider_for_issuer(r, c, issuer, FALSE);
 if (p == NULL) {
  oidc_error(r, "session corrupted: no provider found for issuer: %s",
    issuer);
  return FALSE;
 }

 *provider = p;

 return TRUE;
}




static void fn_47(request_rec *r, oidc_cfg *c,
  oidc_session_t *session, oidc_provider_t *provider, const char *claims,
  const char *userinfo_jwt) {

 oidc_debug(r, "enter");


 if (claims != NULL) {





  oidc_session_set_userinfo_claims(r, session, claims);

  if (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {

   oidc_session_set_userinfo_jwt(r, session, userinfo_jwt);
  }

 } else {



  oidc_session_set_userinfo_claims(r, session, NULL);

  oidc_session_set_userinfo_jwt(r, session, NULL);
 }


 if (provider->userinfo_refresh_interval > 0)
  oidc_session_reset_userinfo_last_refresh(r, session);
}




static apr_byte_t fn_48(request_rec *r, oidc_cfg *c,
  oidc_session_t *session, oidc_provider_t *provider,
  char **new_access_token) {

 oidc_debug(r, "enter");


 const char *refresh_token = oidc_session_get_refresh_token(r, session);
 if (refresh_token == NULL) {
  oidc_warn(r,
    "refresh token routine called but no refresh_token found in the session");
  return FALSE;
 }


 char *s_id_token = NULL;
 int var_77 = -1;
 char *s_token_type = NULL;
 char *s_access_token = NULL;
 char *s_refresh_token = NULL;


 if (oidc_proto_refresh_request(r, c, provider, refresh_token, &s_id_token,
   &s_access_token, &s_token_type, &var_77,
   &s_refresh_token) == FALSE) {
  oidc_error(r, "access_token could not be refreshed");
  return FALSE;
 }


 oidc_session_set_access_token(r, session, s_access_token);
 oidc_session_set_access_token_expires(r, session, var_77);


 oidc_session_reset_access_token_last_refresh(r, session);


 if (new_access_token != NULL)
  *new_access_token = s_access_token;


 if (s_refresh_token != NULL)
  oidc_session_set_refresh_token(r, session, s_refresh_token);

 return TRUE;
}




static const char *fn_50(request_rec *r,
  oidc_cfg *c, oidc_provider_t *provider, const char *access_token,
  oidc_session_t *session, char *id_token_sub, char **userinfo_jwt) {

 oidc_debug(r, "enter");

 char *result = NULL;
 char *refreshed_access_token = NULL;


 if (provider->userinfo_endpoint_url == NULL) {
  oidc_debug(r,
    "not retrieving userinfo claims because userinfo_endpoint is not set");
  return NULL;
 }


 if (access_token == NULL) {
  oidc_debug(r,
    "not retrieving userinfo claims because access_token is not provided");
  return NULL;
 }

 if ((id_token_sub == NULL) && (session != NULL)) {


  json_t *id_token_claims = oidc_session_get_idtoken_claims_json(r,
    session);
  if (id_token_claims == NULL) {
   oidc_error(r, "no id_token_claims found in session");
   return NULL;
  }

  oidc_jose_get_string(r->pool, id_token_claims, OIDC_CLAIM_SUB, FALSE,
    &id_token_sub, NULL);
 }





 if (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,
   &result, userinfo_jwt) == FALSE) {


  if (session != NULL) {


   if (oidc_refresh_access_token(r, c, session, provider,
     &refreshed_access_token) == TRUE) {


    if (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub,
      refreshed_access_token, &result, userinfo_jwt) == FALSE) {

     oidc_error(r,
       "resolving user info claims with the refreshed access token failed, nothing will be stored in the session");
     result = NULL;

    }

   } else {

    oidc_warn(r,
      "refreshing access token failed, claims will not be retrieved/refreshed from the userinfo endpoint");
    result = NULL;

   }

  } else {

   oidc_error(r,
     "resolving user info claims with the existing/provided access token failed, nothing will be stored in the session");
   result = NULL;

  }
 }

 return result;
}




static apr_byte_t fn_51(request_rec *r,
  oidc_cfg *cfg, oidc_session_t *session) {

 oidc_provider_t *provider = NULL;
 const char *claims = NULL;
 const char *access_token = NULL;
 char *userinfo_jwt = NULL;


 if (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)
  return FALSE;


 apr_time_t var_61 = apr_time_from_sec(
   provider->userinfo_refresh_interval);

 oidc_debug(r, "userinfo_endpoint=%s, interval=%d",
   provider->userinfo_endpoint_url,
   provider->userinfo_refresh_interval);

 if ((provider->userinfo_endpoint_url != NULL) && (var_61 > 0)) {


  apr_time_t var_97 = oidc_session_get_userinfo_last_refresh(r,
    session);

  oidc_debug(r, "refresh needed in: %" APR_TIME_T_FMT " seconds",
    apr_time_sec(var_97 + var_61 - apr_time_now()));


  if (var_97 + var_61 < apr_time_now()) {


   access_token = oidc_session_get_access_token(r, session);


   claims = oidc_retrieve_claims_from_userinfo_endpoint(r, cfg,
     provider, access_token, session, NULL, &userinfo_jwt);


   oidc_store_userinfo_claims(r, cfg, session, provider, claims,
     userinfo_jwt);


   return TRUE;
  }
 }
 return FALSE;
}




static void fn_54(request_rec *r,
  oidc_session_t *session, const char **s_id_token, const char **s_claims) {

 const char *id_token = oidc_session_get_idtoken_claims(r, session);
 const char *claims = oidc_session_get_userinfo_claims(r, session);

 oidc_debug(r, "id_token=%s claims=%s", id_token, claims);

 if (id_token != NULL) {
  oidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_IDTOKEN, id_token);
  if (s_id_token != NULL)
   *s_id_token = id_token;
 }

 if (claims != NULL) {
  oidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_CLAIMS, claims);
  if (s_claims != NULL)
   *s_claims = claims;
 }
}




static apr_byte_t fn_55(request_rec *r,
  oidc_cfg *cfg, oidc_session_t *session, apr_byte_t var_97) {

 apr_byte_t var_66 = oidc_cfg_dir_pass_info_in_headers(r);
 apr_byte_t var_66 = oidc_cfg_dir_pass_info_in_envvars(r);


 const char *refresh_token = oidc_session_get_refresh_token(r, session);
 if ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {

  oidc_util_set_app_info(r, OIDC_APP_INFO_REFRESH_TOKEN, refresh_token,
    OIDC_DEFAULT_HEADER_PREFIX, var_66, var_66);
 }


 const char *access_token = oidc_session_get_access_token(r, session);
 if (access_token != NULL) {

  oidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN, access_token,
    OIDC_DEFAULT_HEADER_PREFIX, var_66, var_66);
 }


 const char *access_token_expires = oidc_session_get_access_token_expires(r,
   session);
 if (access_token_expires != NULL) {

  oidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN_EXP,
    access_token_expires,
    OIDC_DEFAULT_HEADER_PREFIX, var_66, var_66);
 }

 apr_time_t var_61 = apr_time_from_sec(cfg->session_inactivity_timeout);
 apr_time_t var_61 = apr_time_now();
 apr_time_t var_61 = var_61 / 10;
 if (var_61 > apr_time_from_sec(60))
  var_61 = apr_time_from_sec(60);
 if (session->expiry - var_61 < var_61 - var_61) {
  session->expiry = var_61 + var_61;
  var_97 = TRUE;
 }


 oidc_log_session_expires(r, "session inactivity timeout", session->expiry);


 if (var_97)
  if (oidc_session_save(r, session, FALSE) == FALSE)
   return FALSE;

 return TRUE;
}

static apr_byte_t fn_61(request_rec *r,
  oidc_cfg *cfg, oidc_session_t *session, int var_64) {

 const char *s_access_token_expires = NULL;
 apr_time_t var_64 = -1;
 oidc_provider_t *provider = NULL;

 oidc_debug(r, "ttl_minimum=%d", var_64);

 if (var_64 < 0)
  return FALSE;

 s_access_token_expires = oidc_session_get_access_token_expires(r, session);
 if (s_access_token_expires == NULL) {
  oidc_debug(r,
    "no access token expires_in stored in the session (i.e. returned from in the authorization response), so cannot refresh the access token based on TTL requirement");
  return FALSE;
 }

 if (oidc_session_get_refresh_token(r, session) == NULL) {
  oidc_debug(r,
    "no refresh token stored in the session, so cannot refresh the access token based on TTL requirement");
  return FALSE;
 }

 if (sscanf(s_access_token_expires, "%" APR_TIME_T_FMT, &var_64) != 1) {
  oidc_error(r, "could not parse s_access_token_expires %s",
    s_access_token_expires);
  return FALSE;
 }

 var_64 = apr_time_from_sec(var_64 - var_64);

 oidc_debug(r, "refresh needed in: %" APR_TIME_T_FMT " seconds",
   apr_time_sec(var_64 - apr_time_now()));

 if (var_64 > apr_time_now())
  return FALSE;

 if (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)
  return FALSE;

 if (oidc_refresh_access_token(r, cfg, session, provider,
   NULL) == FALSE) {
  oidc_warn(r, "access_token could not be refreshed");
  return FALSE;
 }

 return TRUE;
}




static int fn_64(request_rec *r, oidc_cfg *cfg,
  oidc_session_t *session) {

 oidc_debug(r, "enter");


 apr_byte_t var_97 = FALSE;


 r->user = apr_pstrdup(r->pool, session->remote_user);
 oidc_debug(r, "set remote_user to \"%s\"", r->user);


 char *authn_header = oidc_cfg_dir_authn_header(r);
 apr_byte_t var_66 = oidc_cfg_dir_pass_info_in_headers(r);
 apr_byte_t var_66 = oidc_cfg_dir_pass_info_in_envvars(r);


 if (oidc_check_cookie_domain(r, cfg, session) == FALSE)
  return HTTP_UNAUTHORIZED;


 int var_106 = oidc_check_max_session_duration(r, cfg, session);
 if (var_106 != var_105)
  return var_106;


 if (oidc_refresh_access_token_before_expiry(r, cfg, session,
   oidc_cfg_dir_refresh_access_token_before_expiry(r)) == TRUE)
  var_97 = TRUE;


 if (oidc_refresh_claims_from_userinfo_endpoint(r, cfg, session) == TRUE)
  var_97 = TRUE;





 oidc_scrub_headers(r);


 if ((r->user != NULL) && (authn_header != NULL))
  oidc_util_hdr_in_set(r, authn_header, r->user);

 const char *s_claims = NULL;
 const char *s_id_token = NULL;


 oidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);

 if ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_CLAIMS)) {

  if (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)
   return HTTP_INTERNAL_SERVER_ERROR;
 }

 if ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JSON_OBJECT)) {

  oidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JSON, s_claims,
    OIDC_DEFAULT_HEADER_PREFIX, var_66, var_66);
 }

 if ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JWT)) {
  if (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {

   const char *s_userinfo_jwt = oidc_session_get_userinfo_jwt(r,
     session);
   if (s_userinfo_jwt != NULL) {

    oidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JWT,
      s_userinfo_jwt,
      OIDC_DEFAULT_HEADER_PREFIX, var_66, var_66);
   } else {
    oidc_debug(r,
      "configured to pass userinfo in a JWT, but no such JWT was found in the session (probably no such JWT was returned from the userinfo endpoint)");
   }
  } else {
   oidc_error(r,
     "session type \"client-cookie\" does not allow storing/passing a userinfo JWT; use \"" OIDCSessionType " server-cache\" for that");
  }
 }

 if ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {

  if (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)
   return HTTP_INTERNAL_SERVER_ERROR;
 }

 if ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {

  oidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN_PAYLOAD, s_id_token,
    OIDC_DEFAULT_HEADER_PREFIX, var_66, var_66);
 }

 if ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {
  if (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {

   const char *s_id_token = oidc_session_get_idtoken(r, session);

   oidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN, s_id_token,
     OIDC_DEFAULT_HEADER_PREFIX, var_66, var_66);
  } else {
   oidc_error(r,
     "session type \"client-cookie\" does not allow storing/passing the id_token; use \"" OIDCSessionType " server-cache\" for that");
  }
 }


 if (oidc_session_pass_tokens_and_save(r, cfg, session, var_97) == FALSE)
  return HTTP_INTERNAL_SERVER_ERROR;


 return var_105;
}






static apr_byte_t fn_66(request_rec *r,
  oidc_cfg *c, const char *state, struct struct_67 **provider,
  oidc_proto_state_t **proto_state) {

 oidc_debug(r, "enter (state=%s)", state);

 if ((state == NULL) || (apr_strnatcmp(state, "") == 0)) {
  oidc_error(r, "state parameter is not set");
  return FALSE;
 }


 if (oidc_restore_proto_state(r, c, state, proto_state) == FALSE) {
  oidc_error(r, "unable to restore state");
  return FALSE;
 }

 *provider = oidc_get_provider_for_issuer(r, c,
   oidc_proto_state_get_issuer(*proto_state), FALSE);

 return (*provider != NULL);
}




static int fn_68(request_rec *r,
  oidc_cfg *c) {

 oidc_debug(r, "enter");

 char *java_script = apr_psprintf(r->pool,
   "    <script type=\"text/javascript\">\n"
   "      window.top.location.href = '%s?session=logout';\n"
   "    </script>\n", oidc_get_redirect_uri(r, c));

 return oidc_util_html_send(r, "Redirecting...", java_script, NULL, NULL,
   DONE);
}




static int fn_69(request_rec *r, oidc_cfg *c,
  oidc_proto_state_t *proto_state, const char *error,
  const char *error_description) {
 const char *prompt = oidc_proto_state_get_prompt(proto_state);
 if (prompt != NULL)
  prompt = apr_pstrdup(r->pool, prompt);
 oidc_proto_state_destroy(proto_state);
 if ((prompt != NULL)
   && (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {
  return oidc_session_redirect_parent_window_to_logout(r, c);
 }
 return oidc_util_html_send_error(r, c->error_template,
   apr_psprintf(r->pool, "OpenID Connect Provider error: %s", error),
   error_description, DONE);
}




apr_byte_t fn_70(request_rec *r, const char *claim_name,
  const char *reg_exp, const char *replace, json_t *json,
  char **request_user) {


 json_t *username = json_object_get(json, claim_name);
 if ((username == NULL) || (!json_is_string(username))) {
  oidc_warn(r, "JSON object did not contain a \"%s\" string", claim_name);
  return FALSE;
 }

 *request_user = apr_pstrdup(r->pool, json_string_value(username));

 if (reg_exp != NULL) {

  char *error_str = NULL;

  if (replace == NULL) {

   if (oidc_util_regexp_first_match(r->pool, *request_user, reg_exp,
     request_user, &error_str) == FALSE) {
    oidc_error(r, "oidc_util_regexp_first_match failed: %s",
      error_str);
    *request_user = NULL;
    return FALSE;
   }

  } else if (oidc_util_regexp_substitute(r->pool, *request_user, reg_exp,
    replace, request_user, &error_str) == FALSE) {

   oidc_error(r, "oidc_util_regexp_substitute failed: %s", error_str);
   *request_user = NULL;
   return FALSE;
  }

 }

 return TRUE;
}




static apr_byte_t fn_71(request_rec *r, oidc_cfg *c,
  oidc_provider_t *provider, oidc_jwt_t *jwt, const char *s_claims) {

 char *issuer = provider->issuer;
 char *claim_name = apr_pstrdup(r->pool, c->remote_user_claim.claim_name);
 int var_82 = strlen(claim_name);
 apr_byte_t var_74 = (claim_name[var_82 - 1] == OIDC_CHAR_AT);
 if (var_74 == TRUE) {
  claim_name[var_82 - 1] = '\0';
  issuer =
    (strstr(issuer, "https:
      apr_pstrdup(r->pool, issuer) :
      apr_pstrdup(r->pool, issuer + strlen("https:
 }


 apr_byte_t var_106 = FALSE;
 char *remote_user = NULL;
 json_t *claims = NULL;
 oidc_util_decode_json_object(r, s_claims, &claims);
 if (claims == NULL) {
  var_106 = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,
    c->remote_user_claim.replace, jwt->payload.value.json,
    &remote_user);
 } else {
  oidc_util_json_merge(r, jwt->payload.value.json, claims);
  var_106 = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,
    c->remote_user_claim.replace, claims, &remote_user);
  json_decref(claims);
 }

 if ((var_106 == FALSE) || (remote_user == NULL)) {
  oidc_error(r,
    "" OIDCRemoteUserClaim "is set to \"%s\", but could not set the remote user based on the requested claim \"%s\" and the available claims for the user",
    c->remote_user_claim.claim_name, claim_name);
  return FALSE;
 }

 if (var_74 == TRUE)
  remote_user = apr_psprintf(r->pool, "%s%s%s", remote_user, OIDC_STR_AT,
    issuer);

 r->user = apr_pstrdup(r->pool, remote_user);

 oidc_debug(r, "set remote_user to \"%s\" based on claim: \"%s\"%s", r->user,
   c->remote_user_claim.claim_name,
   c->remote_user_claim.reg_exp ?
     apr_psprintf(r->pool,
       " and expression: \"%s\" and replace string: \"%s\"",
       c->remote_user_claim.reg_exp,
       c->remote_user_claim.replace) :
       "");

 return TRUE;
}

static char *oidc_make_sid_iss_unique(request_rec *r, const char *sid,
  const char *issuer) {
 return apr_psprintf(r->pool, "%s@%s", sid, issuer);
}




static apr_byte_t oidc_save_in_session(request_rec *r, oidc_cfg *c,
  oidc_session_t *session, oidc_provider_t *provider,
  const char *remoteUser, const char *id_token, oidc_jwt_t *id_token_jwt,
  const char *claims, const char *access_token, const int var_77,
  const char *refresh_token, const char *session_state, const char *state,
  const char *original_url, const char *userinfo_jwt) {


 session->remote_user = remoteUser;


 session->expiry =
   apr_time_now() + apr_time_from_sec(c->session_inactivity_timeout);


 oidc_session_set_idtoken_claims(r, session,
   id_token_jwt->payload.value.str);

 if (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {

  oidc_session_set_idtoken(r, session, id_token);
 }


 oidc_session_set_issuer(r, session, provider->issuer);


 oidc_session_set_request_state(r, session, state);
 oidc_session_set_original_url(r, session, original_url);

 if ((session_state != NULL) && (provider->check_session_iframe != NULL)) {

  oidc_session_set_session_state(r, session, session_state);
  oidc_session_set_check_session_iframe(r, session,
    provider->check_session_iframe);
  oidc_session_set_client_id(r, session, provider->client_id);
  oidc_debug(r,
    "session management enabled: stored session_state (%s), check_session_iframe (%s) and client_id (%s) in the session",
    session_state, provider->check_session_iframe,
    provider->client_id);
 } else if (provider->check_session_iframe == NULL) {
  oidc_debug(r,
    "session management disabled: \"check_session_iframe\" is not set in provider configuration");
 } else {
  oidc_debug(r,
    "session management disabled: no \"session_state\" value is provided in the authentication response even though \"check_session_iframe\" (%s) is set in the provider configuration",
    provider->check_session_iframe);
 }

 if (provider->end_session_endpoint != NULL)
  oidc_session_set_logout_endpoint(r, session,
    provider->end_session_endpoint);


 oidc_store_userinfo_claims(r, c, session, provider, claims, userinfo_jwt);


 if (access_token != NULL) {

  oidc_session_set_access_token(r, session, access_token);

  oidc_session_set_access_token_expires(r, session, var_77);

  oidc_session_reset_access_token_last_refresh(r, session);
 }


 if (refresh_token != NULL) {

  oidc_session_set_refresh_token(r, session, refresh_token);
 }


 apr_time_t var_74 =
   (provider->session_max_duration == 0) ?
     apr_time_from_sec(id_token_jwt->payload.exp) :
     (apr_time_now()
       + apr_time_from_sec(provider->session_max_duration));
 oidc_session_set_session_expires(r, session, var_74);

 oidc_debug(r,
   "provider->session_max_duration = %d, session_expires=%" APR_TIME_T_FMT,
   provider->session_max_duration, var_74);


 oidc_log_session_expires(r, "session max lifetime", var_74);


 oidc_session_set_cookie_domain(r, session,
   c->cookie_domain ? c->cookie_domain : oidc_get_current_url_host(r));

 char *sid = NULL;
 oidc_debug(r, "provider->backchannel_logout_supported=%d",
   provider->backchannel_logout_supported);
 if (provider->backchannel_logout_supported > 0) {
  oidc_jose_get_string(r->pool, id_token_jwt->payload.value.json,
    OIDC_CLAIM_SID, FALSE, &sid, NULL);
  if (sid == NULL)
   sid = id_token_jwt->payload.sub;
  session->sid = oidc_make_sid_iss_unique(r, sid, provider->issuer);
 }


 return oidc_session_save(r, session, TRUE);
}




static int oidc_parse_expires_in(request_rec *r, const char *var_77) {
 if (var_77 != NULL) {
  char *ptr = NULL;
  long number = strtol(var_77, &ptr, 10);
  if (number <= 0) {
   oidc_warn(r,
     "could not convert \"expires_in\" value (%s) to a number",
     var_77);
   return -1;
  }
  return number;
 }
 return -1;
}




static apr_byte_t fn_74(request_rec *r, oidc_cfg *c,
  oidc_proto_state_t *proto_state, oidc_provider_t *provider,
  apr_table_t *params, const char *response_mode, oidc_jwt_t **jwt) {

 apr_byte_t var_106 = FALSE;

 const char *requested_response_type = oidc_proto_state_get_response_type(
   proto_state);


 if (oidc_util_spaced_string_equals(r->pool, requested_response_type,
   OIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN_TOKEN)) {
  var_106 = oidc_proto_authorization_response_code_idtoken_token(r, c,
    proto_state, provider, params, response_mode, jwt);
 } else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,
   OIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN)) {
  var_106 = oidc_proto_authorization_response_code_idtoken(r, c, proto_state,
    provider, params, response_mode, jwt);
 } else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,
   OIDC_PROTO_RESPONSE_TYPE_CODE_TOKEN)) {
  var_106 = oidc_proto_handle_authorization_response_code_token(r, c,
    proto_state, provider, params, response_mode, jwt);
 } else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,
   OIDC_PROTO_RESPONSE_TYPE_CODE)) {
  var_106 = oidc_proto_handle_authorization_response_code(r, c, proto_state,
    provider, params, response_mode, jwt);
 } else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,
   OIDC_PROTO_RESPONSE_TYPE_IDTOKEN_TOKEN)) {
  var_106 = oidc_proto_handle_authorization_response_idtoken_token(r, c,
    proto_state, provider, params, response_mode, jwt);
 } else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,
   OIDC_PROTO_RESPONSE_TYPE_IDTOKEN)) {
  var_106 = oidc_proto_handle_authorization_response_idtoken(r, c, proto_state,
    provider, params, response_mode, jwt);
 } else {
  oidc_error(r, "unsupported response type: \"%s\"",
    requested_response_type);
 }

 if ((var_106 == FALSE) && (*jwt != NULL)) {
  oidc_jwt_destroy(*jwt);
  *jwt = NULL;
 }

 return var_106;
}


static apr_byte_t fn_75(request_rec *r, const char *r_state,
  oidc_session_t *session) {


 const char *s_state = NULL, *o_url = NULL;

 if (session->remote_user != NULL) {

  s_state = oidc_session_get_request_state(r, session);
  o_url = oidc_session_get_original_url(r, session);

  if ((r_state != NULL) && (s_state != NULL)
    && (apr_strnatcmp(r_state, s_state) == 0)) {


   oidc_warn(r,
     "browser back detected, redirecting to original URL: %s",
     o_url);


   oidc_util_hdr_out_location_set(r, o_url);

   return TRUE;
  }
 }

 return FALSE;
}





static int fn_76(request_rec *r, oidc_cfg *c,
  oidc_session_t *session, apr_table_t *params, const char *response_mode) {

 oidc_debug(r, "enter, response_mode=%s", response_mode);

 oidc_provider_t *provider = NULL;
 oidc_proto_state_t *proto_state = NULL;
 oidc_jwt_t *jwt = NULL;


 if (oidc_handle_browser_back(r, apr_table_get(params, OIDC_PROTO_STATE),
   session) == TRUE)
  return HTTP_MOVED_TEMPORARILY;


 if (oidc_authorization_response_match_state(r, c,
   apr_table_get(params, OIDC_PROTO_STATE), &provider,
   &proto_state) == FALSE) {
  if (c->default_sso_url != NULL) {
   oidc_warn(r,
     "invalid authorization response state; a default SSO URL is set, sending the user there: %s",
     c->default_sso_url);
   oidc_util_hdr_out_location_set(r, c->default_sso_url);
   return HTTP_MOVED_TEMPORARILY;
  }
  oidc_error(r,
    "invalid authorization response state and no default SSO URL is set, sending an error...");
  return HTTP_INTERNAL_SERVER_ERROR;
 }


 if (apr_table_get(params, OIDC_PROTO_ERROR) != NULL)
  return oidc_authorization_response_error(r, c, proto_state,
    apr_table_get(params, OIDC_PROTO_ERROR),
    apr_table_get(params, OIDC_PROTO_ERROR_DESCRIPTION));


 if (oidc_handle_flows(r, c, proto_state, provider, params, response_mode,
   &jwt) == FALSE)
  return oidc_authorization_response_error(r, c, proto_state,
    "Error in handling response type.", NULL);

 if (jwt == NULL) {
  oidc_error(r, "no id_token was provided");
  return oidc_authorization_response_error(r, c, proto_state,
    "No id_token was provided.", NULL);
 }

 int var_77 = oidc_parse_expires_in(r,
   apr_table_get(params, OIDC_PROTO_EXPIRES_IN));
 char *userinfo_jwt = NULL;





 const char *claims = oidc_retrieve_claims_from_userinfo_endpoint(r, c,
   provider, apr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), NULL,
   jwt->payload.sub, &userinfo_jwt);


 const char *original_url = oidc_proto_state_get_original_url(proto_state);
 if (original_url != NULL)
  original_url = apr_pstrdup(r->pool, original_url);
 const char *original_method = oidc_proto_state_get_original_method(
   proto_state);
 if (original_method != NULL)
  original_method = apr_pstrdup(r->pool, original_method);
 const char *prompt = oidc_proto_state_get_prompt(proto_state);


 if (oidc_set_request_user(r, c, provider, jwt, claims) == TRUE) {


  if ((prompt != NULL)
    && (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {




   if (apr_strnatcmp(session->remote_user, r->user) != 0) {
    oidc_warn(r,
      "user set from new id_token is different from current one");
    oidc_jwt_destroy(jwt);
    return oidc_authorization_response_error(r, c, proto_state,
      "User changed!", NULL);
   }
  }


  if (oidc_save_in_session(r, c, session, provider, r->user,
    apr_table_get(params, OIDC_PROTO_ID_TOKEN), jwt, claims,
    apr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), var_77,
    apr_table_get(params, OIDC_PROTO_REFRESH_TOKEN),
    apr_table_get(params, OIDC_PROTO_SESSION_STATE),
    apr_table_get(params, OIDC_PROTO_STATE), original_url,
    userinfo_jwt) == FALSE)
   return HTTP_INTERNAL_SERVER_ERROR;

 } else {
  oidc_error(r, "remote user could not be set");
  return oidc_authorization_response_error(r, c, proto_state,
    "Remote user could not be set: contact the website administrator",
    NULL);
 }


 oidc_proto_state_destroy(proto_state);
 oidc_jwt_destroy(jwt);


 if (r->user == NULL)
  return HTTP_UNAUTHORIZED;


 oidc_debug(r,
   "session created and stored, returning to original URL: %s, original method: %s",
   original_url, original_method);


 if (apr_strnatcmp(original_method, OIDC_METHOD_FORM_POST) == 0) {
  return oidc_request_post_preserved_restore(r, original_url);
 }


 oidc_util_hdr_out_location_set(r, original_url);


 return HTTP_MOVED_TEMPORARILY;
}




static int fn_77(request_rec *r, oidc_cfg *c,
  oidc_session_t *session) {

 oidc_debug(r, "enter");


 char *response_mode = NULL;


 apr_table_t *params = apr_table_make(r->pool, 8);
 if (oidc_util_read_post_params(r, params) == FALSE) {
  oidc_error(r, "something went wrong when reading the POST parameters");
  return HTTP_INTERNAL_SERVER_ERROR;
 }


 if ((apr_table_elts(params)->nelts < 1)
   || ((apr_table_elts(params)->nelts == 1)
     && apr_table_get(params, OIDC_PROTO_RESPONSE_MODE)
     && (apr_strnatcmp(
       apr_table_get(params, OIDC_PROTO_RESPONSE_MODE),
       OIDC_PROTO_RESPONSE_MODE_FRAGMENT) == 0))) {
  return oidc_util_html_send_error(r, c->error_template,
    "Invalid Request",
    "You've hit an OpenID Connect Redirect URI with no parameters, this is an invalid request; you should not open this URL in your browser directly, or have the server administrator use a different " OIDCRedirectURI " setting.",
    HTTP_INTERNAL_SERVER_ERROR);
 }


 response_mode = (char *) apr_table_get(params, OIDC_PROTO_RESPONSE_MODE);


 return oidc_handle_authorization_response(r, c, session, params,
   response_mode ? response_mode : OIDC_PROTO_RESPONSE_MODE_FORM_POST);
}




static int fn_78(request_rec *r,
  oidc_cfg *c, oidc_session_t *session) {

 oidc_debug(r, "enter");


 apr_table_t *params = apr_table_make(r->pool, 8);
 oidc_util_read_form_encoded_params(r, params, r->args);


 return oidc_handle_authorization_response(r, c, session, params,
   OIDC_PROTO_RESPONSE_MODE_QUERY);
}




static int fn_79(request_rec *r, oidc_cfg *cfg) {

 oidc_debug(r, "enter");


 char *current_url = oidc_get_current_url(r);
 const char *method = oidc_original_request_method(r, cfg, FALSE);


 char *csrf = NULL;
 if (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)
  return HTTP_INTERNAL_SERVER_ERROR;

 char *path_scopes = oidc_dir_cfg_path_scope(r);
 char *path_auth_request_params = oidc_dir_cfg_path_auth_request_params(r);

 char *discover_url = oidc_cfg_dir_discover_url(r);

 if (discover_url != NULL) {


  char *url = apr_psprintf(r->pool, "%s%s%s=%s&%s=%s&%s=%s&%s=%s",
    discover_url,
    strchr(discover_url, OIDC_CHAR_QUERY) != NULL ?
      OIDC_STR_AMP :
      OIDC_STR_QUERY,
      OIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),
      OIDC_DISC_RM_PARAM, method,
      OIDC_DISC_CB_PARAM,
      oidc_util_escape_string(r, oidc_get_redirect_uri(r, cfg)),
      OIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));

  if (path_scopes != NULL)
   url = apr_psprintf(r->pool, "%s&%s=%s", url, OIDC_DISC_SC_PARAM,
     oidc_util_escape_string(r, path_scopes));
  if (path_auth_request_params != NULL)
   url = apr_psprintf(r->pool, "%s&%s=%s", url, OIDC_DISC_AR_PARAM,
     oidc_util_escape_string(r, path_auth_request_params));


  oidc_debug(r, "redirecting to external discovery page: %s", url);


  oidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,
    cfg->cookie_same_site ?
      OIDC_COOKIE_EXT_SAME_SITE_STRICT :
      NULL);


  if (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)
   return DONE;


  oidc_util_hdr_out_location_set(r, url);

  return HTTP_MOVED_TEMPORARILY;
 }


 apr_array_header_t *arr = NULL;
 if (oidc_metadata_list(r, cfg, &arr) == FALSE)
  return oidc_util_html_send_error(r, cfg->error_template,
    "Configuration Error",
    "No configured providers found, contact your administrator",
    HTTP_UNAUTHORIZED);


 const char *s = "			<h3>Select your OpenID Connect Identity Provider</h3>\n";


 int i;
 for (i = 0; i < arr->nelts; i++) {

  const char *issuer = ((const char**) arr->elts)[i];


  char *href = apr_psprintf(r->pool,
    "%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s",
    oidc_get_redirect_uri(r, cfg), OIDC_DISC_OP_PARAM,
    oidc_util_escape_string(r, issuer),
    OIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),
    OIDC_DISC_RM_PARAM, method,
    OIDC_CSRF_NAME, csrf);

  if (path_scopes != NULL)
   href = apr_psprintf(r->pool, "%s&amp;%s=%s", href,
     OIDC_DISC_SC_PARAM, oidc_util_escape_string(r, path_scopes));
  if (path_auth_request_params != NULL)
   href = apr_psprintf(r->pool, "%s&amp;%s=%s", href,
     OIDC_DISC_AR_PARAM,
     oidc_util_escape_string(r, path_auth_request_params));

  char *display =
    (strstr(issuer, "https:
      apr_pstrdup(r->pool, issuer) :
      apr_pstrdup(r->pool, issuer + strlen("https:





  s = apr_psprintf(r->pool, "%s<p><a href=\"%s\">%s</a></p>\n", s, href,
    display);
 }


 s = apr_psprintf(r->pool, "%s<form method=\"get\" action=\"%s\">\n", s,
   oidc_get_redirect_uri(r, cfg));
 s = apr_psprintf(r->pool,
   "%s<p><input type=\"hidden\" name=\"%s\" value=\"%s\"><p>\n", s,
   OIDC_DISC_RT_PARAM, current_url);
 s = apr_psprintf(r->pool,
   "%s<p><input type=\"hidden\" name=\"%s\" value=\"%s\"><p>\n", s,
   OIDC_DISC_RM_PARAM, method);
 s = apr_psprintf(r->pool,
   "%s<p><input type=\"hidden\" name=\"%s\" value=\"%s\"><p>\n", s,
   OIDC_CSRF_NAME, csrf);

 if (path_scopes != NULL)
  s = apr_psprintf(r->pool,
    "%s<p><input type=\"hidden\" name=\"%s\" value=\"%s\"><p>\n", s,
    OIDC_DISC_SC_PARAM, path_scopes);
 if (path_auth_request_params != NULL)
  s = apr_psprintf(r->pool,
    "%s<p><input type=\"hidden\" name=\"%s\" value=\"%s\"><p>\n", s,
    OIDC_DISC_AR_PARAM, path_auth_request_params);

 s =
   apr_psprintf(r->pool,
     "%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\n",
     s);
 s = apr_psprintf(r->pool,
   "%s<p><input type=\"text\" name=\"%s\" value=\"%s\"></p>\n", s,
   OIDC_DISC_OP_PARAM, "");
 s = apr_psprintf(r->pool,
   "%s<p><input type=\"submit\" value=\"Submit\"></p>\n", s);
 s = apr_psprintf(r->pool, "%s</form>\n", s);

 oidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,
   cfg->cookie_same_site ? OIDC_COOKIE_EXT_SAME_SITE_STRICT : NULL);

 char *javascript = NULL, *javascript_method = NULL;
 char *html_head =
   "<style type=\"text/css\">body {text-align: center}</style>";
 if (oidc_post_preserve_javascript(r, NULL, &javascript,
   &javascript_method) == TRUE)
  html_head = apr_psprintf(r->pool, "%s%s", html_head, javascript);


 return oidc_util_html_send(r, "OpenID Connect Provider Discovery",
   html_head, javascript_method, s, DONE);
}




static int oidc_authenticate_user(request_rec *r, oidc_cfg *c,
  oidc_provider_t *provider, const char *original_url,
  const char *login_hint, const char *id_token_hint, const char *prompt,
  const char *auth_request_params, const char *path_scope) {

 oidc_debug(r, "enter");

 if (provider == NULL) {


  if (c->metadata_dir != NULL)
   return oidc_discovery(r, c);


  if (oidc_provider_static_config(r, c, &provider) == FALSE)
   return HTTP_INTERNAL_SERVER_ERROR;
 }


 char *nonce = NULL;
 if (oidc_proto_generate_nonce(r, &nonce, OIDC_PROTO_NONCE_LENGTH) == FALSE)
  return HTTP_INTERNAL_SERVER_ERROR;

 char *pkce_state = NULL;
 char *code_challenge = NULL;

 if ((oidc_util_spaced_string_contains(r->pool, provider->response_type,
   OIDC_PROTO_CODE) == TRUE) && (provider->pkce != NULL)) {


  if (provider->pkce->state(r, &pkce_state) == FALSE)
   return HTTP_INTERNAL_SERVER_ERROR;


  if (provider->pkce->challenge(r, pkce_state, &code_challenge) == FALSE)
   return HTTP_INTERNAL_SERVER_ERROR;
 }


 oidc_proto_state_t *proto_state = oidc_proto_state_new();
 oidc_proto_state_set_original_url(proto_state, original_url);
 oidc_proto_state_set_original_method(proto_state,
   oidc_original_request_method(r, c, TRUE));
 oidc_proto_state_set_issuer(proto_state, provider->issuer);
 oidc_proto_state_set_response_type(proto_state, provider->response_type);
 oidc_proto_state_set_nonce(proto_state, nonce);
 oidc_proto_state_set_timestamp_now(proto_state);
 if (provider->response_mode)
  oidc_proto_state_set_response_mode(proto_state,
    provider->response_mode);
 if (prompt)
  oidc_proto_state_set_prompt(proto_state, prompt);
 if (pkce_state)
  oidc_proto_state_set_pkce_state(proto_state, pkce_state);


 char *state = oidc_get_browser_state_hash(r, nonce);





 int var_106 = oidc_authorization_request_set_cookie(r, c, state, proto_state);
 if (var_106 != HTTP_OK) {
  oidc_proto_state_destroy(proto_state);
  return var_106;
 }





 apr_uri_t o_uri;
 memset(&o_uri, 0, sizeof(apr_uri_t));
 apr_uri_t r_uri;
 memset(&r_uri, 0, sizeof(apr_uri_t));
 apr_uri_parse(r->pool, original_url, &o_uri);
 apr_uri_parse(r->pool, oidc_get_redirect_uri(r, c), &r_uri);
 if ((apr_strnatcmp(o_uri.scheme, r_uri.scheme) != 0)
   && (apr_strnatcmp(r_uri.scheme, "https") == 0)) {
  oidc_error(r,
    "the URL scheme (%s) of the configured " OIDCRedirectURI " does not match the URL scheme of the URL being accessed (%s): the \"state\" and \"session\" cookies will not be shared between the two!",
    r_uri.scheme, o_uri.scheme);
  oidc_proto_state_destroy(proto_state);
  return HTTP_INTERNAL_SERVER_ERROR;
 }

 if (c->cookie_domain == NULL) {
  if (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {
   char *p = strstr(o_uri.hostname, r_uri.hostname);
   if ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {
    oidc_error(r,
      "the URL hostname (%s) of the configured " OIDCRedirectURI " does not match the URL hostname of the URL being accessed (%s): the \"state\" and \"session\" cookies will not be shared between the two!",
      r_uri.hostname, o_uri.hostname);
    oidc_proto_state_destroy(proto_state);
    return HTTP_INTERNAL_SERVER_ERROR;
   }
  }
 } else {
  if (!oidc_util_cookie_domain_valid(r_uri.hostname, c->cookie_domain)) {
   oidc_error(r,
     "the domain (%s) configured in " OIDCCookieDomain " does not match the URL hostname (%s) of the URL being accessed (%s): setting \"state\" and \"session\" cookies will not work!!",
     c->cookie_domain, o_uri.hostname, original_url);
   oidc_proto_state_destroy(proto_state);
   return HTTP_INTERNAL_SERVER_ERROR;
  }
 }



 return oidc_proto_authorization_request(r, provider, login_hint,
   oidc_get_redirect_uri_iss(r, c, provider), state, proto_state,
   id_token_hint, code_challenge, auth_request_params, path_scope);
}




static int fn_80(request_rec *r,
  oidc_cfg *cfg, const char *target_link_uri) {

 apr_uri_t o_uri;
 apr_uri_parse(r->pool, target_link_uri, &o_uri);
 if (o_uri.hostname == NULL) {
  oidc_error(r,
    "could not parse the \"target_link_uri\" (%s) in to a valid URL: aborting.",
    target_link_uri);
  return FALSE;
 }

 apr_uri_t r_uri;
 apr_uri_parse(r->pool, oidc_get_redirect_uri(r, cfg), &r_uri);

 if (cfg->cookie_domain == NULL) {

  if (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {
   char *p = strstr(o_uri.hostname, r_uri.hostname);
   if ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {
    oidc_error(r,
      "the URL hostname (%s) of the configured " OIDCRedirectURI " does not match the URL hostname of the \"target_link_uri\" (%s): aborting to prevent an open redirect.",
      r_uri.hostname, o_uri.hostname);
    return FALSE;
   }
  }
 } else {

  char *p = strstr(o_uri.hostname, cfg->cookie_domain);
  if ((p == NULL) || (apr_strnatcmp(cfg->cookie_domain, p) != 0)) {
   oidc_error(r,
     "the domain (%s) configured in " OIDCCookieDomain " does not match the URL hostname (%s) of the \"target_link_uri\" (%s): aborting to prevent an open redirect.",
     cfg->cookie_domain, o_uri.hostname, target_link_uri);
   return FALSE;
  }
 }


 char *cookie_path = oidc_cfg_dir_cookie_path(r);
 if (cookie_path != NULL) {
  char *p = (o_uri.path != NULL) ? strstr(o_uri.path, cookie_path) : NULL;
  if ((p == NULL) || (p != o_uri.path)) {
   oidc_error(r,
     "the path (%s) configured in " OIDCCookiePath " does not match the URL path (%s) of the \"target_link_uri\" (%s): aborting to prevent an open redirect.",
     cfg->cookie_domain, o_uri.path, target_link_uri);
   return FALSE;
  } else if (strlen(o_uri.path) > strlen(cookie_path)) {
   int var_82 = strlen(cookie_path);
   if (cookie_path[var_82 - 1] == OIDC_CHAR_FORWARD_SLASH)
    var_82--;
   if (o_uri.path[var_82] != OIDC_CHAR_FORWARD_SLASH) {
    oidc_error(r,
      "the path (%s) configured in " OIDCCookiePath " does not match the URL path (%s) of the \"target_link_uri\" (%s): aborting to prevent an open redirect.",
      cfg->cookie_domain, o_uri.path, target_link_uri);
    return FALSE;
   }
  }
 }
 return TRUE;
}




static int fn_81(request_rec *r, oidc_cfg *c) {


 char *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,
   *auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,
   *user = NULL, *path_scopes;
 oidc_provider_t *provider = NULL;

 oidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);
 oidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);
 oidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);
 oidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);
 oidc_util_get_request_parameter(r, OIDC_DISC_SC_PARAM, &path_scopes);
 oidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,
   &auth_request_params);
 oidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);
 csrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);


 if (csrf_cookie) {


  oidc_util_set_cookie(r, OIDC_CSRF_NAME, "", 0, NULL);


  if ((csrf_query == NULL)
    || apr_strnatcmp(csrf_query, csrf_cookie) != 0) {
   oidc_warn(r,
     "CSRF protection failed, no Discovery and dynamic client registration will be allowed");
   csrf_cookie = NULL;
  }
 }



 oidc_debug(r,
   "issuer=\"%s\", target_link_uri=\"%s\", login_hint=\"%s\", user=\"%s\"",
   issuer, target_link_uri, login_hint, user);

 if (target_link_uri == NULL) {
  if (c->default_sso_url == NULL) {
   return oidc_util_html_send_error(r, c->error_template,
     "Invalid Request",
     "SSO to this module without specifying a \"target_link_uri\" parameter is not possible because " OIDCDefaultURL " is not set.",
     HTTP_INTERNAL_SERVER_ERROR);
  }
  target_link_uri = c->default_sso_url;
 }


 if (oidc_target_link_uri_matches_configuration(r, c,
   target_link_uri) == FALSE) {
  return oidc_util_html_send_error(r, c->error_template,
    "Invalid Request",
    "\"target_link_uri\" parameter does not match configuration settings, aborting to prevent an open redirect.",
    HTTP_UNAUTHORIZED);
 }


 if (c->metadata_dir == NULL) {
  if ((oidc_provider_static_config(r, c, &provider) == TRUE)
    && (issuer != NULL)) {
   if (apr_strnatcmp(provider->issuer, issuer) != 0) {
    return oidc_util_html_send_error(r, c->error_template,
      "Invalid Request",
      apr_psprintf(r->pool,
        "The \"iss\" value must match the configured providers' one (%s != %s).",
        issuer, c->provider.issuer),
        HTTP_INTERNAL_SERVER_ERROR);
   }
  }
  return oidc_authenticate_user(r, c, NULL, target_link_uri, login_hint,
    NULL, NULL, auth_request_params, path_scopes);
 }


 if (user != NULL) {

  if (login_hint == NULL)
   login_hint = apr_pstrdup(r->pool, user);


  if (strstr(user, "https:
   user = apr_psprintf(r->pool, "https:


  if (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {


   return oidc_util_html_send_error(r, c->error_template,
     "Invalid Request",
     "Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.",
     HTTP_NOT_FOUND);
  }



 } else if (strstr(issuer, OIDC_STR_AT) != NULL) {

  if (login_hint == NULL) {
   login_hint = apr_pstrdup(r->pool, issuer);


  }


  if (oidc_proto_account_based_discovery(r, c, issuer, &issuer) == FALSE) {


   return oidc_util_html_send_error(r, c->error_template,
     "Invalid Request",
     "Could not resolve the provided account name to an OpenID Connect provider; check your syntax.",
     HTTP_NOT_FOUND);
  }



 }


 int var_82 = strlen(issuer);
 if (issuer[var_82 - 1] == OIDC_CHAR_FORWARD_SLASH)
  issuer[var_82 - 1] = '\0';


 if ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)
   && (provider != NULL)) {


  return oidc_authenticate_user(r, c, provider, target_link_uri,
    login_hint, NULL, NULL, auth_request_params, path_scopes);
 }


 return oidc_util_html_send_error(r, c->error_template, "Invalid Request",
   "Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator",
   HTTP_NOT_FOUND);
}

static apr_uint32_t oidc_transparent_pixel[17] = { 0x474e5089, 0x0a1a0a0d,
  0x0d000000, 0x52444849, 0x01000000, 0x01000000, 0x00000408, 0x0c1cb500,
  0x00000002, 0x4144490b, 0x639c7854, 0x0000cffa, 0x02010702, 0x71311c9a,
  0x00000000, 0x444e4549, 0x826042ae };

static apr_byte_t fn_82(const char *logout_param_value) {
 return ((logout_param_value != NULL)
   && ((apr_strnatcmp(logout_param_value,
     OIDC_GET_STYLE_LOGOUT_PARAM_VALUE) == 0)
     || (apr_strnatcmp(logout_param_value,
       OIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)));
}

static apr_byte_t fn_83(const char *logout_param_value) {
 return ((logout_param_value != NULL) && (apr_strnatcmp(logout_param_value,
   OIDC_BACKCHANNEL_STYLE_LOGOUT_PARAM_VALUE) == 0));
}




static int fn_84(request_rec *r, oidc_cfg *c,
  oidc_session_t *session, const char *url) {

 oidc_debug(r, "enter (url=%s)", url);


 if (session->remote_user != NULL) {


  oidc_session_kill(r, session);
 }


 if (oidc_is_front_channel_logout(url)) {


  oidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,
    "no-cache, no-store");
  oidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_PRAGMA, "no-cache");
  oidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_P3P, "CAO PSA OUR");
  oidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_EXPIRES, "0");
  oidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_X_FRAME_OPTIONS, "DENY");


  const char *accept = oidc_util_hdr_in_accept_get(r);
  if ((apr_strnatcmp(url, OIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)
    || ((accept) && strstr(accept, OIDC_CONTENT_TYPE_IMAGE_PNG))) {
   return oidc_util_http_send(r,
     (const char *) &oidc_transparent_pixel,
     sizeof(oidc_transparent_pixel), OIDC_CONTENT_TYPE_IMAGE_PNG,
     DONE);
  }


  return oidc_util_html_send(r, "Logged Out", NULL, NULL,
    "<p>Logged Out</p>", DONE);
 }


 if (url == NULL)
  return oidc_util_html_send(r, "Logged Out", NULL, NULL,
    "<p>Logged Out</p>", DONE);


 oidc_util_hdr_out_location_set(r, url);

 return HTTP_MOVED_TEMPORARILY;
}






static int fn_85(request_rec *r, oidc_cfg *cfg) {

 oidc_debug(r, "enter");

 const char *logout_token = NULL;
 oidc_jwt_t *jwt = NULL;
 oidc_jose_error_t err;
 oidc_jwk_t *jwk = NULL;
 oidc_provider_t *provider = NULL;
 char *sid = NULL, *uuid = NULL;
 int var_106 = var_95;

 apr_table_t *params = apr_table_make(r->pool, 8);
 if (oidc_util_read_post_params(r, params) == FALSE) {
  oidc_error(r,
    "could not read POST-ed parameters to the logout endpoint");
  goto out;
 }

 logout_token = apr_table_get(params, OIDC_PROTO_LOGOUT_TOKEN);
 if (logout_token == NULL) {
  oidc_error(r,
    "backchannel lggout endpoint was called but could not find a parameter named \"%s\"",
    OIDC_PROTO_LOGOUT_TOKEN);
  goto out;
 }




 if (oidc_jwt_parse(r->pool, logout_token, &jwt,
   oidc_util_merge_symmetric_key(r->pool, cfg->private_keys, NULL),
   &err) == FALSE) {
  oidc_error(r, "oidc_jwt_parse failed: %s", oidc_jose_e2s(r->pool, err));
  goto out;
 }

 provider = oidc_get_provider_for_issuer(r, cfg, jwt->payload.iss, FALSE);
 if (provider == NULL) {
  oidc_error(r, "no provider found for issuer: %s", jwt->payload.iss);
  goto out;
 }



 jwk = NULL;
 if (oidc_util_create_symmetric_key(r, provider->client_secret, 0,
   NULL, TRUE, &jwk) == FALSE)
  return FALSE;

 oidc_jwks_uri_t var_87 = { provider->jwks_uri,
   provider->jwks_refresh_interval, provider->ssl_validate_server };
 if (oidc_proto_jwt_verify(r, cfg, jwt, &var_87,
   oidc_util_merge_symmetric_key(r->pool, NULL, jwk)) == FALSE) {

  oidc_error(r, "id_token signature could not be validated, aborting");
  goto out;
 }




 if (oidc_proto_validate_jwt(r, jwt, provider->issuer, FALSE, FALSE,
   provider->idtoken_iat_slack,
   OIDC_TOKEN_BINDING_POLICY_DISABLED) == FALSE)
  goto out;


 if (oidc_proto_validate_aud_and_azp(r, cfg, provider,
   &jwt->payload) == FALSE)
  goto out;

 json_t *events = json_object_get(jwt->payload.value.json,
   OIDC_CLAIM_EVENTS);
 if (events == NULL) {
  oidc_error(r, "\"%s\" claim could not be found in logout token",
    OIDC_CLAIM_EVENTS);
  goto out;
 }

 json_t *blogout = json_object_get(events, "http:
 if (!json_is_object(blogout)) {
  oidc_error(r, "\"%s\" object could not be found in \"%s\" claim",
    "http:
  goto out;
 }

 char *nonce = NULL;
 oidc_json_object_get_string(r->pool, jwt->payload.value.json,
   OIDC_CLAIM_NONCE, &nonce, NULL);
 if (nonce != NULL) {
  oidc_error(r,
    "rejecting logout request/token since it contains a \"%s\" claim",
    OIDC_CLAIM_NONCE);
  goto out;
 }

 char *jti = NULL;
 oidc_json_object_get_string(r->pool, jwt->payload.value.json,
   OIDC_CLAIM_JTI, &jti, NULL);
 if (jti != NULL) {
  char *replay = NULL;
  oidc_cache_get_jti(r, jti, &replay);
  if (replay != NULL) {
   oidc_error(r,
     "the \"%s\" value (%s) passed in logout token was found in the cache already; possible replay attack!?",
     OIDC_CLAIM_JTI, jti);
   goto out;
  }
 }


 apr_time_t var_87 = apr_time_from_sec(
   provider->idtoken_iat_slack * 2 + 10);


 oidc_cache_set_jti(r, jti, jti, apr_time_now() + var_87);

 oidc_json_object_get_string(r->pool, jwt->payload.value.json,
   OIDC_CLAIM_EVENTS, &sid, NULL);

 oidc_json_object_get_string(r->pool, jwt->payload.value.json,
   OIDC_CLAIM_SID, &sid, NULL);
 if (sid == NULL)
  sid = jwt->payload.sub;

 if (sid == NULL) {
  oidc_error(r, "no \"sub\" and no \"sid\" claim found in logout token");
  goto out;
 }

 sid = oidc_make_sid_iss_unique(r, sid, provider->issuer);
 oidc_cache_get_sid(r, sid, &uuid);
 if (uuid == NULL) {
  oidc_error(r,
    "could not find session based on sid/sub provided in logout token: %s",
    sid);
  goto out;
 }


 oidc_cache_set_sid(r, sid, NULL, 0);
 oidc_cache_set_session(r, uuid, NULL, 0);

 var_106 = DONE;

out:

 if (jwk != NULL) {
  oidc_jwk_destroy(jwk);
  jwk = NULL;

 }
 if (jwt != NULL) {
  oidc_jwt_destroy(jwt);
  jwt = NULL;
 }

 return var_106;
}




static int fn_87(request_rec *r, oidc_cfg *c,
  oidc_session_t *session) {


 char *url = NULL;
 oidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);

 oidc_debug(r, "enter (url=%s)", url);

 if (oidc_is_front_channel_logout(url)) {
  return oidc_handle_logout_request(r, c, session, url);
 } else if (oidc_is_back_channel_logout(url)) {
  return oidc_handle_logout_backchannel(r, c);
 }

 if ((url == NULL) || (apr_strnatcmp(url, "") == 0)) {

  url = c->default_slo_url;

 } else {



  const char *error_description = NULL;
  apr_uri_t uri;

  if (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {
   const char *error_description = apr_psprintf(r->pool,
     "Logout URL malformed: %s", url);
   oidc_error(r, "%s", error_description);
   return oidc_util_html_send_error(r, c->error_template,
     "Malformed URL", error_description,
     HTTP_INTERNAL_SERVER_ERROR);

  }

  const char *c_host = oidc_get_current_url_host(r);
  if ((uri.hostname != NULL)
    && ((strstr(c_host, uri.hostname) == NULL)
      || (strstr(uri.hostname, c_host) == NULL))) {
   error_description =
     apr_psprintf(r->pool,
       "logout value \"%s\" does not match the hostname of the current request \"%s\"",
       apr_uri_unparse(r->pool, &uri, 0), c_host);
   oidc_error(r, "%s", error_description);
   return oidc_util_html_send_error(r, c->error_template,
     "Invalid Request", error_description,
     HTTP_INTERNAL_SERVER_ERROR);
  }


  if (((strstr(url, "\n") != NULL) || strstr(url, "\r") != NULL)) {
   error_description =
     apr_psprintf(r->pool,
       "logout value \"%s\" contains illegal \"\n\" or \"\r\" character(s)",
       url);
   oidc_error(r, "%s", error_description);
   return oidc_util_html_send_error(r, c->error_template,
     "Invalid Request", error_description,
     HTTP_INTERNAL_SERVER_ERROR);
  }
 }

 const char *end_session_endpoint = oidc_session_get_logout_endpoint(r,
   session);
 if (end_session_endpoint != NULL) {

  const char *id_token_hint = oidc_session_get_idtoken(r, session);

  char *logout_request = apr_pstrdup(r->pool, end_session_endpoint);
  if (id_token_hint != NULL) {
   logout_request = apr_psprintf(r->pool, "%s%sid_token_hint=%s",
     logout_request, strchr(logout_request ? logout_request : "",
       OIDC_CHAR_QUERY) != NULL ?
         OIDC_STR_AMP :
         OIDC_STR_QUERY,
         oidc_util_escape_string(r, id_token_hint));
  }

  if (url != NULL) {
   logout_request = apr_psprintf(r->pool,
     "%s%spost_logout_redirect_uri=%s", logout_request,
     strchr(logout_request ? logout_request : "",
       OIDC_CHAR_QUERY) != NULL ?
         OIDC_STR_AMP :
         OIDC_STR_QUERY,
         oidc_util_escape_string(r, url));
  }
  url = logout_request;
 }

 return oidc_handle_logout_request(r, c, session, url);
}




int fn_88(request_rec *r, oidc_cfg *c) {




 char *jwks = apr_pstrdup(r->pool, "{ \"keys\" : [");
 apr_hash_index_t *hi = NULL;
 apr_byte_t var_89 = TRUE;
 oidc_jose_error_t err;

 if (c->public_keys != NULL) {


  for (hi = apr_hash_first(r->pool, c->public_keys); hi; hi =
    apr_hash_next(hi)) {

   const char *s_kid = NULL;
   oidc_jwk_t *jwk = NULL;
   char *s_json = NULL;

   apr_hash_this(hi, (const void**) &s_kid, NULL, (void**) &jwk);

   if (oidc_jwk_to_json(r->pool, jwk, &s_json, &err) == TRUE) {
    jwks = apr_psprintf(r->pool, "%s%s %s ", jwks, var_89 ? "" : ",",
      s_json);
    var_89 = FALSE;
   } else {
    oidc_error(r,
      "could not convert RSA JWK to JSON using oidc_jwk_to_json: %s",
      oidc_jose_e2s(r->pool, err));
   }
  }
 }


 jwks = apr_psprintf(r->pool, "%s ] }", jwks);

 return oidc_util_http_send(r, jwks, strlen(jwks), OIDC_CONTENT_TYPE_JSON,
   DONE);
}

static int fn_89(request_rec *r, oidc_cfg *c,
  oidc_session_t *session, const char *check_session_iframe) {
 oidc_debug(r, "enter");
 oidc_util_hdr_out_location_set(r, check_session_iframe);
 return HTTP_MOVED_TEMPORARILY;
}

static int fn_90(request_rec *r, oidc_cfg *c,
  oidc_session_t *session, const char *client_id,
  const char *check_session_iframe) {

 oidc_debug(r, "enter");

 const char *java_script =
   "    <script type=\"text/javascript\">\n"
   "      var targetOrigin  = '%s';\n"
   "      var message = '%s' + ' ' + '%s';\n"
   "	   var timerID;\n"
   "\n"
   "      function checkSession() {\n"
   "        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\n"
   "        var win = window.parent.document.getElementById('%s').contentWindow;\n"
   "        win.postMessage( message, targetOrigin);\n"
   "      }\n"
   "\n"
   "      function setTimer() {\n"
   "        checkSession();\n"
   "        timerID = setInterval('checkSession()', %d);\n"
   "      }\n"
   "\n"
   "      function receiveMessage(e) {\n"
   "        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\n"
   "        if (e.origin !== targetOrigin ) {\n"
   "          console.debug('receiveMessage: cross-site scripting attack?');\n"
   "          return;\n"
   "        }\n"
   "        if (e.data != 'unchanged') {\n"
   "          clearInterval(timerID);\n"
   "          if (e.data == 'changed') {\n"
   "		     window.location.href = '%s?session=check';\n"
   "          } else {\n"
   "		     window.location.href = '%s?session=logout';\n"
   "          }\n"
   "        }\n"
   "      }\n"
   "\n"
   "      window.addEventListener('message', receiveMessage, false);\n"
   "\n"
   "    </script>\n";


 char *origin = apr_pstrdup(r->pool, check_session_iframe);
 apr_uri_t uri;
 apr_uri_parse(r->pool, check_session_iframe, &uri);
 char *p = strstr(origin, uri.path);
 *p = '\0';


 const char *op_iframe_id = "openidc-op";


 const char *session_state = oidc_session_get_session_state(r, session);
 if (session_state == NULL) {
  oidc_warn(r,
    "no session_state found in the session; the OP does probably not support session management!?");
  return DONE;
 }

 char *s_poll_interval = NULL;
 oidc_util_get_request_parameter(r, "poll", &s_poll_interval);
 int var_92 = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;
 if ((var_92 <= 0) || (var_92 > 86400))
  var_92 = 3000;

 const char *redirect_uri = oidc_get_redirect_uri(r, c);
 java_script = apr_psprintf(r->pool, java_script, origin, client_id,
   session_state, op_iframe_id, var_92, redirect_uri,
   redirect_uri);

 return oidc_util_html_send(r, NULL, java_script, "setTimer", NULL, DONE);
}




static int fn_92(request_rec *r, oidc_cfg *c,
  oidc_session_t *session) {
 char *cmd = NULL;
 const char *id_token_hint = NULL, *client_id = NULL, *check_session_iframe =
   NULL;
 oidc_provider_t *provider = NULL;


 oidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_SESSION, &cmd);
 if (cmd == NULL) {
  oidc_error(r, "session management handler called with no command");
  return HTTP_INTERNAL_SERVER_ERROR;
 }


 if (apr_strnatcmp("logout", cmd) == 0) {
  oidc_debug(r,
    "[session=logout] calling oidc_handle_logout_request because of session mgmt local logout call.");
  return oidc_handle_logout_request(r, c, session, c->default_slo_url);
 }


 if (apr_strnatcmp("iframe_op", cmd) == 0) {
  check_session_iframe = oidc_session_get_check_session_iframe(r,
    session);
  if (check_session_iframe != NULL) {
   return oidc_handle_session_management_iframe_op(r, c, session,
     check_session_iframe);
  }
  return HTTP_NOT_FOUND;
 }


 if (apr_strnatcmp("iframe_rp", cmd) == 0) {
  client_id = oidc_session_get_client_id(r, session);
  check_session_iframe = oidc_session_get_check_session_iframe(r,
    session);
  if ((client_id != NULL) && (check_session_iframe != NULL)) {
   return oidc_handle_session_management_iframe_rp(r, c, session,
     client_id, check_session_iframe);
  }
  oidc_debug(r,
    "iframe_rp command issued but no client (%s) and/or no check_session_iframe (%s) set",
    client_id, check_session_iframe);
  return HTTP_NOT_FOUND;
 }


 if (apr_strnatcmp("check", cmd) == 0) {
  id_token_hint = oidc_session_get_idtoken(r, session);
  oidc_get_provider_from_session(r, c, session, &provider);
  if ((session->remote_user != NULL) && (provider != NULL)) {






   return oidc_authenticate_user(r, c, provider,
     apr_psprintf(r->pool, "%s?session=iframe_rp",
       oidc_get_redirect_uri_iss(r, c, provider)), NULL,
       id_token_hint, "none",
       oidc_dir_cfg_path_auth_request_params(r),
       oidc_dir_cfg_path_scope(r));
  }
  oidc_debug(r,
    "[session=check] calling oidc_handle_logout_request because no session found.");
  return oidc_session_redirect_parent_window_to_logout(r, c);
 }


 oidc_error(r, "unknown command: %s", cmd);

 return HTTP_INTERNAL_SERVER_ERROR;
}




static int fn_93(request_rec *r, oidc_cfg *c,
  oidc_session_t *session) {

 char *return_to = NULL;
 char *r_access_token = NULL;
 char *error_code = NULL;


 oidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REFRESH,
   &return_to);
 oidc_util_get_request_parameter(r, OIDC_PROTO_ACCESS_TOKEN,
   &r_access_token);


 if (return_to == NULL) {
  oidc_error(r,
    "refresh token request handler called with no URL to return to");
  return HTTP_INTERNAL_SERVER_ERROR;
 }

 if (r_access_token == NULL) {
  oidc_error(r,
    "refresh token request handler called with no access_token parameter");
  error_code = "no_access_token";
  goto end;
 }

 const char *s_access_token = oidc_session_get_access_token(r, session);
 if (s_access_token == NULL) {
  oidc_error(r,
    "no existing access_token found in the session, nothing to refresh");
  error_code = "no_access_token_exists";
  goto end;
 }


 if (apr_strnatcmp(s_access_token, r_access_token) != 0) {
  oidc_error(r,
    "access_token passed in refresh request does not match the one stored in the session");
  error_code = "no_access_token_match";
  goto end;
 }


 oidc_provider_t *provider = NULL;
 if (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {
  error_code = "session_corruption";
  goto end;
 }


 if (oidc_refresh_access_token(r, c, session, provider, NULL) == FALSE) {
  oidc_error(r, "access_token could not be refreshed");
  error_code = "refresh_failed";
  goto end;
 }


 if (oidc_session_pass_tokens_and_save(r, c, session, TRUE) == FALSE) {
  error_code = "session_corruption";
  goto end;
 }

end:


 if (error_code != NULL)
  return_to = apr_psprintf(r->pool, "%s%serror_code=%s", return_to,
    strchr(return_to ? return_to : "", OIDC_CHAR_QUERY) ?
      OIDC_STR_AMP :
      OIDC_STR_QUERY, oidc_util_escape_string(r, error_code));


 oidc_util_hdr_out_location_set(r, return_to);

 return HTTP_MOVED_TEMPORARILY;
}




static int fn_94(request_rec *r, oidc_cfg *c) {

 char *request_ref = NULL;
 oidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REQUEST_URI,
   &request_ref);
 if (request_ref == NULL) {
  oidc_error(r, "no \"%s\" parameter found",
    OIDC_REDIRECT_URI_REQUEST_REQUEST_URI);
  return var_95;
 }

 char *jwt = NULL;
 oidc_cache_get_request_uri(r, request_ref, &jwt);
 if (jwt == NULL) {
  oidc_error(r, "no cached JWT found for %s reference: %s",
    OIDC_REDIRECT_URI_REQUEST_REQUEST_URI, request_ref);
  return HTTP_NOT_FOUND;
 }

 oidc_cache_set_request_uri(r, request_ref, NULL, 0);

 return oidc_util_http_send(r, jwt, strlen(jwt), OIDC_CONTENT_TYPE_JWT, DONE);
}




static int fn_95(request_rec *r, oidc_cfg *c) {
 char *access_token = NULL;
 oidc_util_get_request_parameter(r,
   OIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE, &access_token);

 char *cache_entry = NULL;
 oidc_cache_get_access_token(r, access_token, &cache_entry);
 if (cache_entry == NULL) {
  oidc_error(r, "no cached access token found for value: %s",
    access_token);
  return HTTP_NOT_FOUND;
 }

 oidc_cache_set_access_token(r, access_token, NULL, 0);

 return DONE;
}






static int fn_96(request_rec *r, oidc_cfg *c,
  oidc_session_t *session) {
 apr_byte_t var_97 = FALSE;
 char *s_format = NULL, *s_interval = NULL;
 oidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_INFO,
   &s_format);
 oidc_util_get_request_parameter(r,
   "access_token_refresh_interval", &s_interval);


 if (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) != 0) {
  oidc_warn(r, "request for unknown format: %s", s_format);
  return HTTP_UNSUPPORTED_MEDIA_TYPE;
 }


 if (session->remote_user == NULL) {
  oidc_warn(r, "no user session found");
  return HTTP_UNAUTHORIZED;
 }


 r->user = apr_pstrdup(r->pool, session->remote_user);

 if (c->info_hook_data == NULL) {
  oidc_warn(r, "no data configured to return in " OIDCInfoHook);
  return HTTP_NOT_FOUND;
 }


 if ((s_interval != NULL)
   && (oidc_session_get_refresh_token(r, session) != NULL)) {

  apr_time_t t_interval;
  if (sscanf(s_interval, "%" APR_TIME_T_FMT, &t_interval) == 1) {
   t_interval = apr_time_from_sec(t_interval);


   apr_time_t var_97 =
     oidc_session_get_access_token_last_refresh(r, session);

   oidc_debug(r, "refresh needed in: %" APR_TIME_T_FMT " seconds",
     apr_time_sec(var_97 + t_interval - apr_time_now()));


   if (var_97 + t_interval < apr_time_now()) {


    oidc_provider_t *provider = NULL;
    if (oidc_get_provider_from_session(r, c, session,
      &provider) == FALSE)
     return HTTP_INTERNAL_SERVER_ERROR;


    if (oidc_refresh_access_token(r, c, session, provider,
      NULL) == FALSE)
     oidc_warn(r, "access_token could not be refreshed");
    else
     var_97 = TRUE;
   }
  }
 }


 json_t *json = json_object();


 if (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_TIMESTAMP,
   APR_HASH_KEY_STRING)) {
  json_object_set_new(json, OIDC_HOOK_INFO_TIMESTAMP,
    json_integer(apr_time_sec(apr_time_now())));
 }






 var_97 |= oidc_refresh_claims_from_userinfo_endpoint(r, c, session);


 if (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN,
   APR_HASH_KEY_STRING)) {
  const char *access_token = oidc_session_get_access_token(r, session);
  if (access_token != NULL)
   json_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN,
     json_string(access_token));
 }


 if (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,
   APR_HASH_KEY_STRING)) {
  const char *access_token_expires =
    oidc_session_get_access_token_expires(r, session);
  if (access_token_expires != NULL)
   json_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,
     json_string(access_token_expires));
 }


 if (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ID_TOKEN,
   APR_HASH_KEY_STRING)) {
  json_t *id_token = oidc_session_get_idtoken_claims_json(r, session);
  if (id_token)
   json_object_set_new(json, OIDC_HOOK_INFO_ID_TOKEN, id_token);
 }

 if (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_USER_INFO,
   APR_HASH_KEY_STRING)) {

  json_t *claims = oidc_session_get_userinfo_claims_json(r, session);
  if (claims)
   json_object_set_new(json, OIDC_HOOK_INFO_USER_INFO, claims);
 }

 if (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION,
   APR_HASH_KEY_STRING)) {
  json_t *j_session = json_object();
  json_object_set(j_session, OIDC_HOOK_INFO_SESSION_STATE,
    session->state);
  json_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_UUID,
    json_string(session->uuid));
  json_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_EXP,
    json_integer(apr_time_sec(session->expiry)));
  json_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_REMOTE_USER,
    json_string(session->remote_user));
  json_object_set_new(json, OIDC_HOOK_INFO_SESSION, j_session);
 }

 if (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_REFRESH_TOKEN,
   APR_HASH_KEY_STRING)) {

  const char *refresh_token = oidc_session_get_refresh_token(r, session);
  if (refresh_token != NULL)
   json_object_set_new(json, OIDC_HOOK_INFO_REFRESH_TOKEN,
     json_string(refresh_token));
 }


 char *r_value = oidc_util_encode_json_object(r, json, 0);


 json_decref(json);


 if (oidc_session_pass_tokens_and_save(r, c, session, var_97) == FALSE) {
  oidc_warn(r, "error saving session");
  return HTTP_INTERNAL_SERVER_ERROR;
 }


 return oidc_util_http_send(r, r_value, strlen(r_value),
   OIDC_CONTENT_TYPE_JSON,
   DONE);
}




int fn_97(request_rec *r, oidc_cfg *c,
  oidc_session_t *session) {

 if (oidc_proto_is_redirect_authorization_response(r, c)) {


  return oidc_handle_redirect_authorization_response(r, c, session);

 } else if (oidc_util_request_has_parameter(r,
   OIDC_REDIRECT_URI_REQUEST_LOGOUT)) {

  return oidc_handle_logout(r, c, session);

 } else if (oidc_proto_is_post_authorization_response(r, c)) {


  return oidc_handle_post_authorization_response(r, c, session);

 } else if (oidc_is_discovery_response(r, c)) {


  return oidc_handle_discovery_response(r, c);

 } else if (oidc_util_request_has_parameter(r,
   OIDC_REDIRECT_URI_REQUEST_JWKS)) {


  return oidc_handle_jwks(r, c);

 } else if (oidc_util_request_has_parameter(r,
   OIDC_REDIRECT_URI_REQUEST_SESSION)) {


  return oidc_handle_session_management(r, c, session);

 } else if (oidc_util_request_has_parameter(r,
   OIDC_REDIRECT_URI_REQUEST_REFRESH)) {


  return oidc_handle_refresh_token_request(r, c, session);

 } else if (oidc_util_request_has_parameter(r,
   OIDC_REDIRECT_URI_REQUEST_REQUEST_URI)) {


  return oidc_handle_request_uri(r, c);

 } else if (oidc_util_request_has_parameter(r,
   OIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE)) {


  return oidc_handle_remove_at_cache(r, c);

 } else if (oidc_util_request_has_parameter(r,
   OIDC_REDIRECT_URI_REQUEST_INFO)) {

  if (session->remote_user == NULL)
   return HTTP_UNAUTHORIZED;


  return oidc_handle_existing_session(r, c, session);

 } else if ((r->args == NULL) || (apr_strnatcmp(r->args, "") == 0)) {


  return oidc_proto_javascript_implicit(r, c);
 }




 if (oidc_util_request_has_parameter(r, OIDC_PROTO_ERROR)) {







  return oidc_handle_redirect_authorization_response(r, c, session);
 }

 oidc_error(r,
   "The OpenID Connect callback URL received an invalid request: %s; returning HTTP_INTERNAL_SERVER_ERROR",
   r->args);


 return oidc_util_html_send_error(r, c->error_template, "Invalid Request",
   apr_psprintf(r->pool,
     "The OpenID Connect callback URL received an invalid request"),
     HTTP_INTERNAL_SERVER_ERROR);
}

static int fn_98(request_rec *r, oidc_cfg *c) {

 if (oidc_get_redirect_uri(r, c) == NULL) {
  oidc_error(r,
    "configuration error: the authentication type is set to \"" "openid-connect" "\" but " OIDCRedirectURI " has not been set");
  return HTTP_INTERNAL_SERVER_ERROR;
 }


 if (ap_is_initial_req(r)) {

  int var_106 = var_105;


  oidc_session_t *session = NULL;
  oidc_session_load(r, &session);


  if (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c))) {


   var_106 = oidc_handle_redirect_uri_request(r, c, session);


   oidc_session_free(r, session);

   return var_106;


  } else if (session->remote_user != NULL) {


   var_106 = oidc_handle_existing_session(r, c, session);


   oidc_session_free(r, session);


   oidc_strip_cookies(r);

   return var_106;
  }


  oidc_session_free(r, session);





 } else {


  if (r->main != NULL)
   r->user = r->main->user;
  else if (r->prev != NULL)
   r->user = r->prev->user;

  if (r->user != NULL) {


   oidc_debug(r,
     "recycling user '%s' from initial request for sub-request",
     r->user);





   const char *s_id_token = oidc_request_state_get(r,
     OIDC_REQUEST_STATE_KEY_IDTOKEN);
   if (s_id_token == NULL) {

    oidc_session_t *session = NULL;
    oidc_session_load(r, &session);

    oidc_copy_tokens_to_request_state(r, session, NULL, NULL);


    oidc_session_free(r, session);
   }


   oidc_strip_cookies(r);

   return var_105;
  }




 }

 return oidc_handle_unauthenticated_user(r, c);
}




static int fn_99(request_rec *r, oidc_cfg *c) {


 const char *access_token = NULL;
 if (oidc_oauth_get_bearer_token(r, &access_token) == TRUE)
  return oidc_oauth_check_userid(r, c, access_token);


 return oidc_check_userid_openidc(r, c);
}




int fn_100(request_rec *r) {

 oidc_cfg *c = ap_get_module_config(r->server->module_config,
   &auth_openidc_module);


 oidc_debug(r, "incoming request: \"%s?%s\", ap_is_initial_req(r)=%d",
   r->parsed_uri.path, r->args, ap_is_initial_req(r));


 if (ap_auth_type(r) == NULL)
  return var_106;


 if (apr_strnatcasecmp((const char *) ap_auth_type(r),
   "openid-connect") == 0)
  return oidc_check_userid_openidc(r, c);


 if (apr_strnatcasecmp((const char *) ap_auth_type(r),
   "oauth20") == 0)
  return oidc_oauth_check_userid(r, c, NULL);


 if (apr_strnatcasecmp((const char *) ap_auth_type(r),
   "auth-openidc") == 0)
  return oidc_check_mixed_userid_oauth(r, c);


 return var_106;
}




static void fn_102(request_rec *r, json_t **claims,
  json_t **id_token) {

 const char *s_claims = oidc_request_state_get(r,
   OIDC_REQUEST_STATE_KEY_CLAIMS);
 if (s_claims != NULL)
  oidc_util_decode_json_object(r, s_claims, claims);

 const char *s_id_token = oidc_request_state_get(r,
   OIDC_REQUEST_STATE_KEY_IDTOKEN);
 if (s_id_token != NULL)
  oidc_util_decode_json_object(r, s_id_token, id_token);
}

static int fn_103(request_rec *r) {

 oidc_cfg *c = ap_get_module_config(r->server->module_config,
   &auth_openidc_module);

 if (apr_strnatcasecmp((const char *) ap_auth_type(r), "oauth20") == 0) {
  oidc_oauth_return_www_authenticate(r, "insufficient_scope", "Different scope(s) or other claims required");
  return HTTP_UNAUTHORIZED;
 }


 switch (oidc_dir_cfg_unautz_action(r)) {
 case OIDC_UNAUTZ_RETURN403:
  return HTTP_FORBIDDEN;
 case OIDC_UNAUTZ_RETURN401:
  return HTTP_UNAUTHORIZED;
 case OIDC_UNAUTZ_AUTHENTICATE:





  if (oidc_is_xml_http_request(r) == TRUE)
   return HTTP_UNAUTHORIZED;
 }

 return oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,
   NULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));
}





int fn_104(request_rec *r) {


 if (r->user != NULL && strlen(r->user) == 0) {
  r->user = NULL;
  if (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)
   return var_105;
 }


 json_t *claims = NULL, *id_token = NULL;
 oidc_authz_get_claims_and_idtoken(r, &claims, &id_token);


 const apr_array_header_t * const reqs_arr = ap_requires(r);


 const require_line * const reqs =
   reqs_arr ? (require_line *) reqs_arr->elts : NULL;
 if (!reqs_arr) {
  oidc_debug(r,
    "no require statements found, so declining to perform authorization.");
  return var_106;
 }


 if (claims)
  oidc_util_json_merge(r, id_token, claims);


 int var_106 = oidc_authz_worker22(r, claims ? claims : id_token, reqs,
   reqs_arr->nelts);


 if (claims)
  json_decref(claims);
 if (id_token)
  json_decref(id_token);

 if ((var_106 == HTTP_UNAUTHORIZED) && ap_auth_type(r))
  var_106 = oidc_handle_unauthorized_user22(r);

 return var_106;
}






int fn_105(request_rec *r) {
 oidc_cfg *c = ap_get_module_config(r->server->module_config,
   &auth_openidc_module);

 int var_106 = var_106;
 if (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c))) {

  if (oidc_util_request_has_parameter(r,
    OIDC_REDIRECT_URI_REQUEST_INFO)) {

   oidc_session_t *session = NULL;
   oidc_session_load(r, &session);


   var_106 = oidc_handle_info_request(r, c, session);


   oidc_session_free(r, session);

  }

 }
 return var_106;
}

extern const command_rec oidc_config_cmds[];

module var_106 auth_openidc_module = {
  STANDARD20_MODULE_STUFF,
  oidc_create_dir_config,
  oidc_merge_dir_config,
  oidc_create_server_config,
  oidc_merge_server_config,
  oidc_config_cmds,
  oidc_register_hooks
};
