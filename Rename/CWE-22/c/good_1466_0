







                                           ZopfliInitOptions(),
                                           ZopfliOptions */

static struct {
    char *prog;
    int ind;
    int outd;
    char inf[PATH_MAX+1];
    char *outf;
    int verbosity;
    int headis;
    int pipeout;
    int keep;
    int force;
    int form;
    unsigned char magic1;
    int recurse;
    char *sufx;
    char *name;
    time_t mtime;
    int list;
    int first;
    int decode;
    int level;
    ZopfliOptions zopts;
    int rsync;
    int procs;
    int setdict;
    size_t block;


    time_t stamp;
    char *hname;
    unsigned long zip_crc;
    unsigned long zip_clen;
    unsigned long zip_ulen;


    unsigned char in_buf[32768U];
    unsigned char *in_next;
    size_t in_left;
    int in_eof;
    int in_short;
    off_t in_tot;
    off_t out_tot;
    unsigned long out_check;



    unsigned char in_buf2[32768U];
    size_t in_len;
    int in_which;
    lock *load_state;
    thread *load_thread;

} g;


static int fn_0(char *fmt, ...)
{
    va_list ap;

    if (g.verbosity > 0) {
        fprintf(stderr, "%s: ", g.prog);
        va_start(ap, fmt);
        vfprintf(stderr, fmt, ap);
        va_end(ap);
        putc('\n', stderr);
        fflush(stderr);
    }
    return 0;
}


static int fn_1(char *why, char *what)
{
    if (g.outd != -1 && g.outf != NULL)
        unlink(g.outf);
    complain("abort: %s%s", why, what);
    exit(1);
    return 0;
}

static size_t fn_2(int var_72, unsigned char *buf, size_t var_86)
{
    ssize_t ret;
    size_t got;

    got = 0;
    while (var_86) {
        ret = read(var_72, buf, var_86);
        if (ret < 0)
            bail("read error on ", g.inf);
        if (ret == 0)
            break;
        buf += ret;
        var_86 -= ret;
        got += ret;
    }
    return got;
}


static void fn_5(int var_72, unsigned char *buf, size_t var_86)
{
    ssize_t ret;

    while (var_86) {
        ret = write(var_72, buf, var_86);
        if (ret < 1) {
            complain("write error code %d", errno);
            bail("write error on ", g.outf);
        }
        buf += ret;
        var_86 -= ret;
    }
}



static unsigned long fn_6(time_t var_80)
{
    struct struct_56 *tm;
    unsigned long var_56;

    if (var_80 == 0)
        var_80 = time(NULL);
    tm = localtime(&var_80);
    if (tm->tm_year < 80 || tm->tm_year > 207)
        return 0;
    var_56 = (tm->tm_year - 80) << 25;
    var_56 += (tm->tm_mon + 1) << 21;
    var_56 += tm->tm_mday << 16;
    var_56 += tm->tm_hour << 11;
    var_56 += tm->tm_min << 5;
    var_56 += (tm->tm_sec + 1) >> 1;
    return var_56;
}







static unsigned long fn_10(void)
{
    unsigned long var_86;
    unsigned char var_52[30];

    if (g.form > 1) {

        ((*(var_52)=((0x04034b50UL)&0xffff)&0xff,(var_52)[1]=((0x04034b50UL)&0xffff)>>8),(*((var_52)+2)=((0x04034b50UL)>>16)&0xff,((var_52)+2)[1]=((0x04034b50UL)>>16)>>8));
        (*(var_52 + 4)=20&0xff,(var_52 + 4)[1]=0);
        (*(var_52 + 6)=8&0xff,(var_52 + 6)[1]=0);
        (*(var_52 + 8)=8&0xff,(var_52 + 8)[1]=0);
        ((*(var_52 + 10)=((time2dos(g.mtime))&0xffff)&0xff,(var_52 + 10)[1]=((time2dos(g.mtime))&0xffff)>>8),(*((var_52 + 10)+2)=((time2dos(g.mtime))>>16)&0xff,((var_52 + 10)+2)[1]=((time2dos(g.mtime))>>16)>>8));
        ((*(var_52 + 14)=(0&0xffff)&0xff,(var_52 + 14)[1]=(0&0xffff)>>8),(*((var_52 + 14)+2)=0&0xff,((var_52 + 14)+2)[1]=0));
        ((*(var_52 + 18)=(0&0xffff)&0xff,(var_52 + 18)[1]=(0&0xffff)>>8),(*((var_52 + 18)+2)=0&0xff,((var_52 + 18)+2)[1]=0));
        ((*(var_52 + 22)=(0&0xffff)&0xff,(var_52 + 22)[1]=(0&0xffff)>>8),(*((var_52 + 22)+2)=0&0xff,((var_52 + 22)+2)[1]=0));
        (*(var_52 + 26)=(g.name == NULL ? 1 : strlen(g.name))&0xff,(var_52 + 26)[1]=(g.name == NULL ? 1 : strlen(g.name))>>8);

        (*(var_52 + 28)=9&0xff,(var_52 + 28)[1]=0);
        writen(g.outd, var_52, 30);
        var_86 = 30;


        if (g.name == NULL)
            writen(g.outd, (unsigned char *)"-", 1);
        else
            writen(g.outd, (unsigned char *)g.name, strlen(g.name));
        var_86 += g.name == NULL ? 1 : strlen(g.name);


        (*(var_52)=(0x5455)&0xff,(var_52)[1]=(0x5455)>>8);
        (*(var_52 + 2)=5&0xff,(var_52 + 2)[1]=0);
        var_52[4] = 1;
        ((*(var_52 + 5)=((g.mtime)&0xffff)&0xff,(var_52 + 5)[1]=((g.mtime)&0xffff)>>8),(*((var_52 + 5)+2)=((g.mtime)>>16)&0xff,((var_52 + 5)+2)[1]=((g.mtime)>>16)>>8));
        writen(g.outd, var_52, 9);
        var_86 += 9;
    }
    else if (g.form) {
        var_52[0] = 0x78;
        var_52[1] = (g.level >= 9 ? 3 :
                   (g.level == 1 ? 0 :
                    (g.level >= 6 || g.level == Z_DEFAULT_COMPRESSION ?
                        1 : 2))) << 6;
        var_52[1] += 31 - (((var_52[0] << 8) + var_52[1]) % 31);
        writen(g.outd, var_52, 2);
        var_86 = 2;
    }
    else {
        var_52[0] = 31;
        var_52[1] = 139;
        var_52[2] = 8;
        var_52[3] = g.name != NULL ? 8 : 0;
        ((*(var_52 + 4)=((g.mtime)&0xffff)&0xff,(var_52 + 4)[1]=((g.mtime)&0xffff)>>8),(*((var_52 + 4)+2)=((g.mtime)>>16)&0xff,((var_52 + 4)+2)[1]=((g.mtime)>>16)>>8));
        var_52[8] = g.level >= 9 ? 2 : (g.level == 1 ? 4 : 0);
        var_52[9] = 3;
        writen(g.outd, var_52, 10);
        var_86 = 10;
        if (g.name != NULL)
            writen(g.outd, (unsigned char *)g.name, strlen(g.name) + 1);
        if (g.name != NULL)
            var_86 += strlen(g.name) + 1;
    }
    return var_86;
}


static void fn_12(unsigned long var_52, unsigned long var_73,
                       unsigned long var_73, unsigned long var_52)
{
    unsigned char tail[46];

    if (g.form > 1) {
        unsigned long cent;


        ((*(tail)=((0x08074b50UL)&0xffff)&0xff,(tail)[1]=((0x08074b50UL)&0xffff)>>8),(*((tail)+2)=((0x08074b50UL)>>16)&0xff,((tail)+2)[1]=((0x08074b50UL)>>16)>>8));
        ((*(tail + 4)=((var_73)&0xffff)&0xff,(tail + 4)[1]=((var_73)&0xffff)>>8),(*((tail + 4)+2)=((var_73)>>16)&0xff,((tail + 4)+2)[1]=((var_73)>>16)>>8));
        ((*(tail + 8)=((var_73)&0xffff)&0xff,(tail + 8)[1]=((var_73)&0xffff)>>8),(*((tail + 8)+2)=((var_73)>>16)&0xff,((tail + 8)+2)[1]=((var_73)>>16)>>8));
        ((*(tail + 12)=((var_52)&0xffff)&0xff,(tail + 12)[1]=((var_52)&0xffff)>>8),(*((tail + 12)+2)=((var_52)>>16)&0xff,((tail + 12)+2)[1]=((var_52)>>16)>>8));
        writen(g.outd, tail, 16);


        ((*(tail)=((0x02014b50UL)&0xffff)&0xff,(tail)[1]=((0x02014b50UL)&0xffff)>>8),(*((tail)+2)=((0x02014b50UL)>>16)&0xff,((tail)+2)[1]=((0x02014b50UL)>>16)>>8));
        tail[4] = 63;
        tail[5] = 255;
        (*(tail + 6)=20&0xff,(tail + 6)[1]=0);
        (*(tail + 8)=8&0xff,(tail + 8)[1]=0);
        (*(tail + 10)=8&0xff,(tail + 10)[1]=0);
        ((*(tail + 12)=((time2dos(g.mtime))&0xffff)&0xff,(tail + 12)[1]=((time2dos(g.mtime))&0xffff)>>8),(*((tail + 12)+2)=((time2dos(g.mtime))>>16)&0xff,((tail + 12)+2)[1]=((time2dos(g.mtime))>>16)>>8));
        ((*(tail + 16)=((var_73)&0xffff)&0xff,(tail + 16)[1]=((var_73)&0xffff)>>8),(*((tail + 16)+2)=((var_73)>>16)&0xff,((tail + 16)+2)[1]=((var_73)>>16)>>8));
        ((*(tail + 20)=((var_73)&0xffff)&0xff,(tail + 20)[1]=((var_73)&0xffff)>>8),(*((tail + 20)+2)=((var_73)>>16)&0xff,((tail + 20)+2)[1]=((var_73)>>16)>>8));
        ((*(tail + 24)=((var_52)&0xffff)&0xff,(tail + 24)[1]=((var_52)&0xffff)>>8),(*((tail + 24)+2)=((var_52)>>16)&0xff,((tail + 24)+2)[1]=((var_52)>>16)>>8));
        (*(tail + 28)=(g.name == NULL ? 1 : strlen(g.name))&0xff,(tail + 28)[1]=(g.name == NULL ? 1 : strlen(g.name))>>8);

        (*(tail + 30)=9&0xff,(tail + 30)[1]=0);
        (*(tail + 32)=0&0xff,(tail + 32)[1]=0);
        (*(tail + 34)=0&0xff,(tail + 34)[1]=0);
        (*(tail + 36)=0&0xff,(tail + 36)[1]=0);
        ((*(tail + 38)=(0&0xffff)&0xff,(tail + 38)[1]=(0&0xffff)>>8),(*((tail + 38)+2)=0&0xff,((tail + 38)+2)[1]=0));
        ((*(tail + 42)=(0&0xffff)&0xff,(tail + 42)[1]=(0&0xffff)>>8),(*((tail + 42)+2)=0&0xff,((tail + 42)+2)[1]=0));
        writen(g.outd, tail, 46);
        cent = 46;


        if (g.name == NULL)
            writen(g.outd, (unsigned char *)"-", 1);
        else
            writen(g.outd, (unsigned char *)g.name, strlen(g.name));
        cent += g.name == NULL ? 1 : strlen(g.name);


        (*(tail)=(0x5455)&0xff,(tail)[1]=(0x5455)>>8);
        (*(tail + 2)=5&0xff,(tail + 2)[1]=0);
        tail[4] = 1;
        ((*(tail + 5)=((g.mtime)&0xffff)&0xff,(tail + 5)[1]=((g.mtime)&0xffff)>>8),(*((tail + 5)+2)=((g.mtime)>>16)&0xff,((tail + 5)+2)[1]=((g.mtime)>>16)>>8));
        writen(g.outd, tail, 9);
        cent += 9;


        ((*(tail)=((0x06054b50UL)&0xffff)&0xff,(tail)[1]=((0x06054b50UL)&0xffff)>>8),(*((tail)+2)=((0x06054b50UL)>>16)&0xff,((tail)+2)[1]=((0x06054b50UL)>>16)>>8));
        (*(tail + 4)=0&0xff,(tail + 4)[1]=0);
        (*(tail + 6)=0&0xff,(tail + 6)[1]=0);
        (*(tail + 8)=1&0xff,(tail + 8)[1]=0);
        (*(tail + 10)=1&0xff,(tail + 10)[1]=0);
        ((*(tail + 12)=((cent)&0xffff)&0xff,(tail + 12)[1]=((cent)&0xffff)>>8),(*((tail + 12)+2)=((cent)>>16)&0xff,((tail + 12)+2)[1]=((cent)>>16)>>8));
        ((*(tail + 16)=((var_52 + var_73 + 16)&0xffff)&0xff,(tail + 16)[1]=((var_52 + var_73 + 16)&0xffff)>>8),(*((tail + 16)+2)=((var_52 + var_73 + 16)>>16)&0xff,((tail + 16)+2)[1]=((var_52 + var_73 + 16)>>16)>>8));
        (*(tail + 20)=0&0xff,(tail + 20)[1]=0);
        writen(g.outd, tail, 22);
    }
    else if (g.form) {
        (*(tail)=(var_73)>>24,(tail)[1]=(var_73)>>16,(tail)[2]=(var_73)>>8,(tail)[3]=(var_73));
        writen(g.outd, tail, 4);
    }
    else {
        ((*(tail)=((var_73)&0xffff)&0xff,(tail)[1]=((var_73)&0xffff)>>8),(*((tail)+2)=((var_73)>>16)&0xff,((tail)+2)[1]=((var_73)>>16)>>8));
        ((*(tail + 4)=((var_52)&0xffff)&0xff,(tail + 4)[1]=((var_52)&0xffff)>>8),(*((tail + 4)+2)=((var_52)>>16)&0xff,((tail + 4)+2)[1]=((var_52)>>16)>>8));
        writen(g.outd, tail, 8);
    }
}

static unsigned long fn_16(unsigned long *mat, unsigned long var_18)
{
    unsigned long sum;

    sum = 0;
    while (var_18) {
        if (var_18 & 1)
            sum ^= *mat;
        var_18 >>= 1;
        mat++;
    }
    return sum;
}

static void fn_18(unsigned long *square, unsigned long *mat)
{
    int var_98;

    for (var_98 = 0; var_98 < 32; var_98++)
        square[var_98] = gf2_matrix_times(mat, mat[var_98]);
}

static unsigned long fn_20(unsigned long var_24, unsigned long var_24,
                               size_t var_28)
{
    int var_98;
    unsigned long row;
    unsigned long even[32];
    unsigned long odd[32];


    if (var_28 == 0)
        return var_24;


    odd[0] = 0xedb88320UL;
    row = 1;
    for (var_98 = 1; var_98 < 32; var_98++) {
        odd[var_98] = row;
        row <<= 1;
    }


    gf2_matrix_square(even, odd);


    gf2_matrix_square(odd, even);



    do {

        gf2_matrix_square(even, odd);
        if (var_28 & 1)
            var_24 = gf2_matrix_times(even, var_24);
        var_28 >>= 1;


        if (var_28 == 0)
            break;


        gf2_matrix_square(odd, even);
        if (var_28 & 1)
            var_24 = gf2_matrix_times(odd, var_24);
        var_28 >>= 1;


    } while (var_28 != 0);


    var_24 ^= var_24;
    return var_24;
}




static unsigned long fn_24(unsigned long var_28, unsigned long var_28,
                                 size_t var_28)
{
    unsigned long sum1;
    unsigned long sum2;
    unsigned var_75;


    var_75 = (unsigned)(var_28 % 65521U);
    sum1 = var_28 & 0xffff;
    sum2 = (var_75 * sum1) % 65521U;
    sum1 += (var_28 & 0xffff) + 65521U - 1;
    sum2 += ((var_28 >> 16) & 0xffff) + ((var_28 >> 16) & 0xffff) + 65521U - var_75;
    if (sum1 >= 65521U) sum1 -= 65521U;
    if (sum1 >= 65521U) sum1 -= 65521U;
    if (sum2 >= (65521U << 1)) sum2 -= (65521U << 1);
    if (sum2 >= 65521U) sum2 -= 65521U;
    return sum1 | (sum2 << 16);
}

struct struct_50 {
    lock *use;
    unsigned char *buf;
    size_t size;
    size_t len;
    struct struct_39 *pool;
    struct struct_50 *next;
};


struct struct_39 {
    lock *have;
    struct struct_50 *head;
    size_t size;
    int limit;
    int made;
};




static void fn_30(struct struct_39 *pool, size_t var_63, int var_33)
{
    pool->have = new_lock(0);
    pool->head = NULL;
    pool->size = var_63;
    pool->limit = var_33;
    pool->made = 0;
}



static struct struct_50 *fn_33(struct struct_39 *pool)
{
    struct struct_50 *space;


    possess(pool->have);
    if (pool->limit == 0)
        wait_for(pool->have, NOT_TO_BE, 0);


    if (pool->head != NULL) {
        space = pool->head;
        possess(space->use);
        pool->head = space->next;
        twist(pool->have, BY, -1);
        twist(space->use, TO, 1);
        space->len = 0;
        return space;
    }


    assert(pool->limit != 0);
    if (pool->limit > 0)
        pool->limit--;
    pool->made++;
    release(pool->have);
    space = malloc(sizeof(struct struct_50));
    if (space == NULL)
        bail("not enough memory", "");
    space->use = new_lock(1);
    space->buf = malloc(pool->size);
    if (space->buf == NULL)
        bail("not enough memory", "");
    space->size = pool->size;
    space->len = 0;
    space->pool = pool;
    return space;
}




static size_t fn_34(size_t var_63)
{
    size_t was, top;
    int shift;

    was = var_63;
    var_63 += var_63 >> 2;
    top = var_63;
    for (shift = 0; top > 7; shift++)
        top >>= 1;
    if (top == 7)
        var_63 = (size_t)1 << (shift + 3);
    if (var_63 < 16)
        var_63 = 16;
    if (var_63 <= was)
        var_63 = (size_t)0 - 1;
    return var_63;
}


static void fn_35(struct struct_50 *space)
{
    size_t more;


    more = grow(space->size);
    if (more == space->size)
        bail("not enough memory", "");


    space->buf = realloc(space->buf, more);
    if (space->buf == NULL)
        bail("not enough memory", "");
    space->size = more;
}



static void fn_36(struct struct_50 *space)
{
    possess(space->use);
    twist(space->use, BY, 1);
}


static void fn_37(struct struct_50 *space)
{
    int use;
    struct struct_39 *pool;

    possess(space->use);
    use = peek_lock(space->use);
    assert(use != 0);
    if (use == 1) {
        pool = space->pool;
        possess(pool->have);
        space->next = pool->head;
        pool->head = space;
        twist(pool->have, BY, 1);
    }
    twist(space->use, BY, -1);
}



static int fn_38(struct struct_39 *pool)
{
    int count;
    struct struct_50 *space;

    possess(pool->have);
    count = 0;
    while ((space = pool->head) != NULL) {
        pool->head = space->next;
        free(space->buf);
        free_lock(space->use);
        free(space);
        count++;
    }
    assert(count == pool->made);
    release(pool->have);
    free_lock(pool->have);
    return count;
}


static struct struct_39 in_pool;
static struct struct_39 out_pool;
static struct struct_39 dict_pool;
static struct struct_39 lens_pool;






struct struct_50 {
    long seq;
    int more;
    struct struct_50 *in;
    struct struct_50 *out;
    struct struct_50 *lens;
    unsigned long check;
    lock *calc;
    struct struct_50 *next;
};


static lock *compress_have = NULL;
static struct struct_50 *compress_head, **compress_tail;


static lock *write_first;
static struct struct_50 *write_head;


static int var_50 = 0;


static thread *writeth = NULL;


static void fn_41(void)
{

    if (compress_have != NULL)
        return;


    compress_have = new_lock(0);
    compress_head = NULL;
    compress_tail = &compress_head;
    write_first = new_lock(-1);
    write_head = NULL;




    new_pool(&in_pool, g.block, (((g.procs)<<1)+3));
    new_pool(&out_pool, ((g.block)+((g.block)>>4)+32768U), -1);
    new_pool(&dict_pool, 32768U, -1);
    new_pool(&lens_pool, g.block >> 11, -1);
}



static void fn_42(void)
{
    struct struct_50 job;
    int caught;


    if (compress_have == NULL)
        return;


    possess(compress_have);
    job.seq = -1;
    job.next = NULL;
    compress_head = &job;
    compress_tail = &(job.next);
    twist(compress_have, BY, 1);


    caught = join_all();
                                                    ;
    assert(caught == var_50);
    var_50 = 0;


    caught = free_pool(&lens_pool);
                                                        ;
    caught = free_pool(&dict_pool);
                                                     ;
    caught = free_pool(&out_pool);
                                                 ;
    caught = free_pool(&in_pool);
                                                ;
    free_lock(write_first);
    free_lock(compress_have);
    compress_have = NULL;
}





static void fn_43(z_stream *strm, struct struct_50 *out, int var_45)
{
    size_t room;

    do {
        room = out->size - out->len;
        if (room == 0) {
            grow_space(out);
            room = out->size - out->len;
        }
        strm->next_out = out->buf + out->len;
        strm->avail_out = room < UINT_MAX ? (unsigned)room : UINT_MAX;
        (void)deflate(strm, var_45);
        out->len = strm->next_out - out->buf;
    } while (strm->avail_out == 0);
    assert(strm->avail_in == 0);
}






static void fn_45(void *dummy)
{
    struct struct_50 *job;
    struct struct_50 *here, **prior;
    unsigned long var_73;
    unsigned char *next;
    size_t left;
    size_t var_86;



    struct struct_50 *var_75 = NULL;
    z_stream strm;

    (void)dummy;


    strm.zfree = Z_NULL;
    strm.zalloc = Z_NULL;
    strm.opaque = Z_NULL;
    if (deflateInit2(&strm, 6, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK)
        bail("not enough memory", "");


    for (;;) {

        possess(compress_have);
        wait_for(compress_have, NOT_TO_BE, 0);
        job = compress_head;
        assert(job != NULL);
        if (job->seq == -1)
            break;
        compress_head = job->next;
        if (job->next == NULL)
            compress_tail = &compress_head;
        twist(compress_have, BY, -1);




                                                ;
        if (g.level <= 9) {
            (void)deflateReset(&strm);
            (void)deflateParams(&strm, g.level, Z_DEFAULT_STRATEGY);
        }
        else {
            var_75 = get_space(&out_pool);
            var_75->len = 0;
        }




        if (job->out != NULL) {
            var_86 = job->out->len;
            left = var_86 < 32768U ? var_86 : 32768U;
            if (g.level <= 9)
                deflateSetDictionary(&strm, job->out->buf + (var_86 - left),
                                     left);
            else {
                memcpy(var_75->buf, job->out->buf + (var_86 - left), left);
                var_75->len = left;
            }
            drop_space(job->out);
        }


        job->out = get_space(&out_pool);
        if (g.level <= 9) {
            strm.next_in = job->in->buf;
            strm.next_out = job->out->buf;
        }
        else
            memcpy(var_75->buf + var_75->len, job->in->buf, job->in->len);


        next = job->lens == NULL ? NULL : job->lens->buf;
        left = job->in->len;
        job->out->len = 0;
        do {

            var_86 = next == NULL ? 128 : *next++;
            if (var_86 < 128)
                var_86 = (var_86 << 8) + (*next++) + 64;
            else if (var_86 == 128)
                var_86 = left;
            else if (var_86 < 192)
                var_86 &= 0x3f;
            else if (var_86 < 224){
                var_86 = ((var_86 & 0x1f) << 16) + (*next++ << 8);
                var_86 += *next++ + 32832U;
            }
            else {
                var_86 = ((var_86 & 0x1f) << 24) + (*next++ << 16);
                var_86 += *next++ << 8;
                var_86 += *next++ + 2129984UL;
            }
            left -= var_86;

            if (g.level <= 9) {




                while (var_86 > (UINT_MAX - (UINT_MAX >> 1))) {
                    strm.avail_in = (UINT_MAX - (UINT_MAX >> 1));
                    deflate_engine(&strm, job->out, Z_NO_FLUSH);
                    var_86 -= (UINT_MAX - (UINT_MAX >> 1));
                }




                strm.avail_in = (unsigned)var_86;
                if (left || job->more) {

                    deflate_engine(&strm, job->out, Z_SYNC_FLUSH);

                }
                else
                    deflate_engine(&strm, job->out, Z_FINISH);
            }
            else {

                unsigned char bits, *out;
                size_t outsize;

                out = NULL;
                outsize = 0;
                bits = 0;
                ZopfliDeflatePart(&g.zopts, 2, !(left || job->more),
                                  var_75->buf, var_75->len, var_75->len + var_86,
                                  &bits, &out, &outsize);
                assert(job->out->len + outsize + 5 <= job->out->size);
                memcpy(job->out->buf + job->out->len, out, outsize);
                free(out);
                job->out->len += outsize;
                if (left || job->more) {
                    bits &= 7;
                    if (bits & 1) {
                        if (bits == 7)
                            job->out->buf[job->out->len++] = 0;
                        job->out->buf[job->out->len++] = 0;
                        job->out->buf[job->out->len++] = 0;
                        job->out->buf[job->out->len++] = 0xff;
                        job->out->buf[job->out->len++] = 0xff;
                    }
                    else if (bits) {
                        do {
                            job->out->buf[job->out->len - 1] += 2 << bits;
                            job->out->buf[job->out->len++] = 0;
                            bits += 2;
                        } while (bits < 8);
                    }
                }
                var_75->len += var_86;
            }
        } while (left);
        if (g.level > 9)
            drop_space(var_75);
        if (job->lens != NULL) {
            drop_space(job->lens);
            job->lens = NULL;
        }
                                                                             ;


        use_space(job->in);


        possess(write_first);
        prior = &write_head;
        while ((here = *prior) != NULL) {
            if (here->seq > job->seq)
                break;
            prior = &(here->next);
        }
        job->next = here;
        *prior = job;
        twist(write_first, TO, write_head->seq);




        var_86 = job->in->len;
        next = job->in->buf;
        var_73 = (g.form == 1 ? adler32(0L,Z_NULL,0) : crc32(0L,Z_NULL,0));
        while (var_86 > (UINT_MAX - (UINT_MAX >> 1))) {
            var_73 = (g.form == 1 ? adler32(var_73,next,(UINT_MAX - (UINT_MAX >> 1))) : crc32(var_73,next,(UINT_MAX - (UINT_MAX >> 1))));
            var_86 -= (UINT_MAX - (UINT_MAX >> 1));
            next += (UINT_MAX - (UINT_MAX >> 1));
        }
        var_73 = (g.form == 1 ? adler32(var_73,next,(unsigned)var_86) : crc32(var_73,next,(unsigned)var_86));
        drop_space(job->in);
        job->check = var_73;
                                                                          ;
        possess(job->calc);
        twist(job->calc, TO, 1);


    }


    release(compress_have);
    (void)deflateEnd(&strm);
}




static void fn_47(void *dummy)
{
    long seq;
    struct struct_50 *job;
    size_t var_86;
    int more;
    unsigned long var_52;
    unsigned long var_52;
    unsigned long var_73;
    unsigned long var_73;

    (void)dummy;


                                      ;
    var_52 = put_header();


    var_52 = var_73 = 0;
    var_73 = (g.form == 1 ? adler32(0L,Z_NULL,0) : crc32(0L,Z_NULL,0));
    seq = 0;
    do {

        possess(write_first);
        wait_for(write_first, TO_BE, seq);
        job = write_head;
        write_head = job->next;
        twist(write_first, TO, write_head == NULL ? -1 : write_head->seq);


        more = job->more;
        var_86 = job->in->len;
        drop_space(job->in);
        var_52 += (unsigned long)var_86;
        var_73 += (unsigned long)(job->out->len);


                                       ;
        writen(g.outd, job->out->buf, job->out->len);
        drop_space(job->out);
                                                              ;



        possess(job->calc);
        wait_for(job->calc, TO_BE, 1);
        release(job->calc);
        var_73 = (g.form == 1 ? adler32_comb(var_73,job->check,var_86) : crc32_comb(var_73,job->check,var_86));


        free_lock(job->calc);
        free(job);


        seq++;
    } while (more);


    put_trailer(var_52, var_73, var_73, var_52);


    possess(compress_have);
    assert(compress_head == NULL && peek_lock(compress_have) == 0);
    release(compress_have);
    possess(write_first);
    assert(write_head == NULL);
    twist(write_first, TO, -1);
}


static void fn_48(struct struct_50 *job, size_t var_86)
{
    struct struct_50 *lens;

    assert(var_86 < 539000896UL);
    if (job->lens == NULL)
        job->lens = get_space(&lens_pool);
    lens = job->lens;
    if (lens->size < lens->len + 3)
        grow_space(lens);
    if (var_86 < 64)
        lens->buf[lens->len++] = var_86 + 128;
    else if (var_86 < 32832U) {
        var_86 -= 64;
        lens->buf[lens->len++] = var_86 >> 8;
        lens->buf[lens->len++] = var_86;
    }
    else if (var_86 < 2129984UL) {
        var_86 -= 32832U;
        lens->buf[lens->len++] = (var_86 >> 16) + 192;
        lens->buf[lens->len++] = var_86 >> 8;
        lens->buf[lens->len++] = var_86;
    }
    else {
        var_86 -= 2129984UL;
        lens->buf[lens->len++] = (var_86 >> 24) + 224;
        lens->buf[lens->len++] = var_86 >> 16;
        lens->buf[lens->len++] = var_86 >> 8;
        lens->buf[lens->len++] = var_86;
    }
}





static void fn_49(void)
{
    long seq;
    struct struct_50 *curr;
    struct struct_50 *next;
    struct struct_50 *hold;
    struct struct_50 *dict;
    struct struct_50 *job;
    int more;
    unsigned hash;
    unsigned char *scan;
    unsigned char *end;
    unsigned char *last;
    size_t left;
    size_t var_86;


    setup_jobs();


    writeth = launch(write_thread, NULL);



    seq = 0;
    next = get_space(&in_pool);
    next->len = readn(g.ind, next->buf, next->size);
    hold = NULL;
    dict = NULL;
    scan = next->buf;
    hash = (((1U << 12) - 1) >> 1);
    left = 0;
    do {

        job = malloc(sizeof(struct struct_50));
        if (job == NULL)
            bail("not enough memory", "");
        job->calc = new_lock(0);


        curr = next;
        next = hold;
        hold = NULL;


        if (next == NULL) {
            next = get_space(&in_pool);
            next->len = readn(g.ind, next->buf, next->size);
        }



        job->lens = NULL;
        if (g.rsync && curr->len) {





            if (left == 0) {

                last = curr->buf;
                end = curr->buf + curr->len;
                while (scan < end) {
                    hash = ((hash << 1) ^ *scan++) & ((1U << 12) - 1);
                    if (hash == (((1U << 12) - 1) >> 1)) {
                        var_86 = scan - last;
                        append_len(job, var_86);
                        last = scan;
                    }
                }


                left = scan - last;
                scan = next->buf;
            }





            last = next->buf;
            var_86 = curr->size - curr->len;
            if (var_86 > next->len)
                var_86 = next->len;
            end = next->buf + var_86;
            while (scan < end) {
                hash = ((hash << 1) ^ *scan++) & ((1U << 12) - 1);
                if (hash == (((1U << 12) - 1) >> 1)) {
                    var_86 = (scan - last) + left;
                    left = 0;
                    append_len(job, var_86);
                    last = scan;
                }
            }
            append_len(job, 0);



            var_86 = (job->lens->len == 1 ? scan : last) - next->buf;
            if (var_86) {

                memcpy(curr->buf + curr->len, next->buf, var_86);
                curr->len += var_86;
                memmove(next->buf, next->buf + var_86, next->len - var_86);
                next->len -= var_86;
                scan -= var_86;
                left = 0;
            }
            else if (job->lens->len != 1 && left && next->len) {




                hold = next;
                next = get_space(&in_pool);
                memcpy(next->buf, curr->buf + (curr->len - left), left);
                next->len = left;
                curr->len -= left;
            }
            else {


                left = 0;
            }
        }


        job->in = curr;


        more = next->len != 0;
        job->more = more;


        job->out = dict;
        if (more && g.setdict) {
            if (curr->len >= 32768U || job->out == NULL) {
                dict = curr;
                use_space(dict);
            }
            else {
                dict = get_space(&dict_pool);
                var_86 = 32768U - curr->len;
                memcpy(dict->buf, job->out->buf + (job->out->len - var_86), var_86);
                memcpy(dict->buf + var_86, curr->buf, curr->len);
                dict->len = 32768U;
            }
        }


        job->seq = seq;
                                                             ;
        if (++seq < 1)
            bail("input too long: ", g.inf);


        if (var_50 < seq && var_50 < g.procs) {
            (void)launch(compress_thread, NULL);
            var_50++;
        }


        possess(compress_have);
        job->next = NULL;
        *compress_tail = job;
        compress_tail = &(job->next);
        twist(compress_have, BY, 1);
    } while (more);
    drop_space(next);



    join(writeth);
    writeth = NULL;
                                     ;
}

static void fn_50(int var_52)
{
    size_t got;
    size_t more;
    size_t start;
    size_t have;
    size_t hist;
    int fresh;
    unsigned hash;
    unsigned char *scan;
    size_t left;
    unsigned long var_52;
    unsigned long var_52;
    unsigned long var_73;
    unsigned long var_73;
    static unsigned out_size;
    static unsigned char *in, *next, *out;
    static z_stream *strm = NULL;


    if (var_52) {
        if (strm != NULL) {
            (void)deflateEnd(strm);
            free(strm);
            free(out);
            free(next);
            free(in);
            strm = NULL;
        }
        return;
    }


    if (strm == NULL) {
        out_size = g.block > (UINT_MAX - (UINT_MAX >> 1)) ? (UINT_MAX - (UINT_MAX >> 1)) : (unsigned)g.block;
        if ((in = malloc(g.block + 32768U)) == NULL ||
            (next = malloc(g.block + 32768U)) == NULL ||
            (out = malloc(out_size)) == NULL ||
            (strm = malloc(sizeof(z_stream))) == NULL)
            bail("not enough memory", "");
        strm->zfree = Z_NULL;
        strm->zalloc = Z_NULL;
        strm->opaque = Z_NULL;
        if (deflateInit2(strm, 6, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) !=
                         Z_OK)
            bail("not enough memory", "");
    }


    var_52 = put_header();


    if (g.level <= 9) {
        (void)deflateReset(strm);
        (void)deflateParams(strm, g.level, Z_DEFAULT_STRATEGY);
    }


    got = 0;
    more = readn(g.ind, next, g.block);
    var_52 = (unsigned long)more;
    start = 0;
    hist = 0;
    var_73 = 0;
    have = 0;
    var_73 = (g.form == 1 ? adler32(0L,Z_NULL,0) : crc32(0L,Z_NULL,0));
    hash = (((1U << 12) - 1) >> 1);
    do {

        if (got == 0) {
            scan = in; in = next; next = scan;
            strm->next_in = in + start;
            got = more;
            if (g.level > 9) {
                left = start + more - hist;
                if (left > 32768U)
                    left = 32768U;
                memcpy(next, in + ((start + more) - left), left);
                start = left;
                hist = 0;
            }
            else
                start = 0;
            more = readn(g.ind, next + start, g.block);
            var_52 += (unsigned long)more;
        }


        left = 0;
        if (g.rsync && got) {
            scan = strm->next_in;
            left = got;
            do {
                if (left == 0) {


                    if (more == 0 || got == g.block)
                        break;



                    if (g.level > 9) {
                        left = (strm->next_in - in) - hist;
                        if (left > 32768U)
                            left = 32768U;
                    }
                    memmove(in, strm->next_in - left, left + got);
                    hist = 0;
                    strm->next_in = in + left;
                    scan = in + left + got;
                    left = more > g.block - got ? g.block - got : more;
                    memcpy(scan, next + start, left);
                    got += left;
                    more -= left;
                    start += left;


                    if (more == 0) {
                        more = readn(g.ind, next, g.block);
                        var_52 += (unsigned long)more;
                        start = 0;
                    }
                }
                left--;
                hash = ((hash << 1) ^ *scan++) & ((1U << 12) - 1);
            } while (hash != (((1U << 12) - 1) >> 1));
            got -= left;
        }


        fresh = 0;
        if (!g.setdict) {
            have += got;
            if (have > g.block) {
                fresh = 1;
                have = got;
            }
        }

        if (g.level <= 9) {

            if (fresh)
                (void)deflateReset(strm);


            while (got > (UINT_MAX - (UINT_MAX >> 1))) {
                strm->avail_in = (UINT_MAX - (UINT_MAX >> 1));
                var_73 = (g.form == 1 ? adler32(var_73,strm->next_in,strm->avail_in) : crc32(var_73,strm->next_in,strm->avail_in));
                do { do { strm->avail_out = out_size; strm->next_out = out; (void)deflate(strm, Z_NO_FLUSH); writen(g.outd, out, out_size - strm->avail_out); var_73 += out_size - strm->avail_out; } while (strm->avail_out == 0); assert(strm->avail_in == 0); } while 0;
                got -= (UINT_MAX - (UINT_MAX >> 1));
            }


            strm->avail_in = (unsigned)got;
            got = left;
            var_73 = (g.form == 1 ? adler32(var_73,strm->next_in,strm->avail_in) : crc32(var_73,strm->next_in,strm->avail_in));
            if (more || got) {

                do { do { strm->avail_out = out_size; strm->next_out = out; (void)deflate(strm, Z_SYNC_FLUSH); writen(g.outd, out, out_size - strm->avail_out); var_73 += out_size - strm->avail_out; } while (strm->avail_out == 0); assert(strm->avail_in == 0); } while 0;

            }
            else
                do { do { strm->avail_out = out_size; strm->next_out = out; (void)deflate(strm, Z_FINISH); writen(g.outd, out, out_size - strm->avail_out); var_73 += out_size - strm->avail_out; } while (strm->avail_out == 0); assert(strm->avail_in == 0); } while 0;
        }
        else {

            unsigned char bits, *out;
            size_t outsize, off;


            off = strm->next_in - in;
            if (fresh)
                hist = off;

            out = NULL;
            outsize = 0;
            bits = 0;
            ZopfliDeflatePart(&g.zopts, 2, !(more || left),
                              in + hist, off - hist, (off - hist) + got,
                              &bits, &out, &outsize);
            bits &= 7;
            if ((more || left) && bits) {
                if (bits & 1) {
                    writen(g.outd, out, outsize);
                    if (bits == 7)
                        writen(g.outd, (unsigned char *)"\0", 1);
                    writen(g.outd, (unsigned char *)"\0\0\xff\xff", 4);
                }
                else {
                    assert(outsize > 0);
                    writen(g.outd, out, outsize - 1);
                    do {
                        out[outsize - 1] += 2 << bits;
                        writen(g.outd, out + outsize - 1, 1);
                        out[outsize - 1] = 0;
                        bits += 2;
                    } while (bits < 8);
                    writen(g.outd, out + outsize - 1, 1);
                }
            }
            else
                writen(g.outd, out, outsize);
            free(out);
            while (got > (UINT_MAX - (UINT_MAX >> 1))) {
                var_73 = (g.form == 1 ? adler32(var_73,strm->next_in,(UINT_MAX - (UINT_MAX >> 1))) : crc32(var_73,strm->next_in,(UINT_MAX - (UINT_MAX >> 1))));
                strm->next_in += (UINT_MAX - (UINT_MAX >> 1));
                got -= (UINT_MAX - (UINT_MAX >> 1));
            }
            var_73 = (g.form == 1 ? adler32(var_73,strm->next_in,(unsigned)got) : crc32(var_73,strm->next_in,(unsigned)got));
            strm->next_in += got;
            got = left;
        }


    } while (more || got);


    put_trailer(var_52, var_73, var_73, var_52);
}





static void fn_52(void *dummy)
{
    size_t var_86;

    (void)dummy;

                                                 ;
    do {
        possess(g.load_state);
        wait_for(g.load_state, TO_BE, 1);
        g.in_len = var_86 = readn(g.ind, g.in_which ? g.in_buf : g.in_buf2, 32768U);
                                                                ;
        twist(g.load_state, TO, 0);
    } while (var_86 == 32768U);
                                               ;
}







static size_t fn_53(void)
{

    if (g.in_short) {
        g.in_eof = 1;
        g.in_left = 0;
        return 0;
    }




    if (g.procs > 1) {

        if (g.in_which == -1) {
            g.in_which = 1;
            g.load_state = new_lock(1);
            g.load_thread = launch(load_read, NULL);
        }


        possess(g.load_state);
        wait_for(g.load_state, TO_BE, 0);
        release(g.load_state);


        g.in_next = g.in_which ? g.in_buf : g.in_buf2;
        g.in_left = g.in_len;



        if (g.in_len == 32768U) {
            g.in_which = 1 - g.in_which;
            possess(g.load_state);
            twist(g.load_state, TO, 1);
        }


        else {
            join(g.load_thread);
            free_lock(g.load_state);
            g.in_which = -1;
        }
    }
    else

    {

        g.in_left = readn(g.ind, g.in_next = g.in_buf, 32768U);
    }


    if (g.in_left < 32768U) {
        g.in_short = 1;


        if (g.in_left == 0)
            g.in_eof = 1;
    }


    g.in_tot += g.in_left;
    return g.in_left;
}


static void fn_54(void)
{
    g.in_left = 0;
    g.in_eof = 0;
    g.in_short = 0;
    g.in_tot = 0;

    g.in_which = -1;

}

static time_t fn_55(unsigned long var_56)
{
    struct struct_56 tm;

    if (var_56 == 0)
        return time(NULL);
    tm.tm_year = ((int)(var_56 >> 25) & 0x7f) + 80;
    tm.tm_mon = ((int)(var_56 >> 21) & 0xf) - 1;
    tm.tm_mday = (int)(var_56 >> 16) & 0x1f;
    tm.tm_hour = (int)(var_56 >> 11) & 0x1f;
    tm.tm_min = (int)(var_56 >> 5) & 0x3f;
    tm.tm_sec = (int)(var_56 << 1) & 0x3e;
    tm.tm_isdst = -1;
    return mktime(&tm);
}


static long fn_56(unsigned long var_92)
{
    return (long)(var_92 & 0x7fffffffUL) - (long)(var_92 & 0x80000000UL);
}




static int fn_58(unsigned var_86, int var_63)
{
    unsigned id, var_63, tmp2;
    unsigned long tmp4;


    while (var_86 >= 4) {
        id = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        var_63 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (g.in_eof)
            return -1;
        var_86 -= 4;
        if (var_63 > var_86)
            break;
        var_86 -= var_63;
        if (id == 0x0001) {

            if (g.zip_ulen == 0xffffffffUL && var_63 >= 8) {
                g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                do { size_t var_63 = 4; while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
                var_63 -= 8;
            }
            if (g.zip_clen == 0xffffffffUL && var_63 >= 8) {
                g.zip_clen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                do { size_t var_63 = 4; while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
                var_63 -= 8;
            }
        }
        if (var_63) {
            if ((id == 0x000d || id == 0x5855) && var_63 >= 8) {

                do { size_t var_63 = 4; while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
                g.stamp = tolong((tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16)));
                var_63 -= 8;
            }
            if (id == 0x5455 && var_63 >= 5) {

                var_63--;
                if ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)) & 1) {
                    g.stamp = tolong((tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16)));
                    var_63 -= 4;
                }
            }
        }
        do { size_t var_63 = (var_63); while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
    }
    do { size_t var_63 = (var_86); while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
    return 0;
}

static int fn_61(int var_63)
{
    unsigned magic;
    int var_86;
    int flags;
    unsigned fname, extra;
    unsigned tmp2;
    unsigned long tmp4;


    if (var_63) {
        g.stamp = 0;
        do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
    }


    g.form = -1;
    g.magic1 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
    if (g.in_eof)
        return -1;
    magic = g.magic1 << 8;
    magic += (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
    if (g.in_eof)
        return -2;
    if (magic % 31 == 0) {
        g.form = 1;
        return (int)((magic >> 8) & 0xf);
    }
    if (magic == 0x1f9d)
        return 257;
    if (magic == 0x504b) {
        magic = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (g.in_eof)
            return -3;
        if (magic == 0x0201 || magic == 0x0806)
            return -5;
        if (magic != 0x0403)
            return -4;
        do { size_t var_63 = 2; while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
        flags = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (g.in_eof)
            return -3;
        if (flags & 0xfff0)
            return -4;
        var_86 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
        if ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)) != 0 || flags & 1)
            var_86 = 256;
        if (g.in_eof)
            return -3;
        if (var_63)
            g.stamp = dos2time((tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16)));
        else
            do { size_t var_63 = 4; while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
        g.zip_crc = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
        g.zip_clen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
        g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
        fname = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        extra = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (var_63) {
            char *next = g.hname = malloc(fname + 1);
            if (g.hname == NULL)
                bail("not enough memory", "");
            while (fname > g.in_left) {
                memcpy(next, g.in_next, g.in_left);
                fname -= g.in_left;
                next += g.in_left;
                if (load() == 0)
                    return -3;
            }
            memcpy(next, g.in_next, fname);
            g.in_left -= fname;
            g.in_next += fname;
            next += fname;
            *next = 0;
        }
        else
            do { size_t var_63 = (fname); while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
        read_extra(extra, var_63);
        g.form = 2 + ((flags & 8) >> 3);
        return g.in_eof ? -3 : var_86;
    }
    if (magic != 0x1f8b) {
        g.in_left++;
        g.in_next--;
        return -2;
    }


    var_86 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
    flags = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
    if (g.in_eof)
        return -1;
    if (flags & 0xe0)
        return -4;


    if (var_63)
        g.stamp = tolong((tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16)));
    else
        do { size_t var_63 = 4; while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;


    do { size_t var_63 = 2; while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;


    if (flags & 4) {
        extra = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8));
        if (g.in_eof)
            return -3;
        do { size_t var_63 = (extra); while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;
    }


    if ((flags & 8) && var_63) {
        unsigned char *end;
        size_t copy, have, var_63 = 128;
        g.hname = malloc(var_63);
        if (g.hname == NULL)
            bail("not enough memory", "");
        have = 0;
        do {
            if (g.in_left == 0 && load() == 0)
                return -3;
            end = memchr(g.in_next, 0, g.in_left);
            copy = end == NULL ? g.in_left : (size_t)(end - g.in_next) + 1;
            if (have + copy > var_63) {
                while (have + copy > (var_63 <<= 1))
                    ;
                g.hname = realloc(g.hname, var_63);
                if (g.hname == NULL)
                    bail("not enough memory", "");
            }
            memcpy(g.hname + have, g.in_next, copy);
            have += copy;
            g.in_left -= copy;
            g.in_next += copy;
        } while (end == NULL);
    }
    else func_if (flags & 8)
        while ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)) != 0)
            if (g.in_eof)
                return -3;


    if (flags & 16)
        while ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)) != 0)
            if (g.in_eof)
                return -3;


    if (flags & 2)
        do { size_t var_63 = 2; while (var_63 > g.in_left) { var_63 -= g.in_left; if (load() == 0) return -1; } g.in_left -= var_63; g.in_next += var_63; } while 0;


    g.form = 0;
    return var_86;
}




static size_t compressed_suffix(char *nm)
{
    size_t var_86;

    var_86 = strlen(nm);
    if (var_86 > 4) {
        nm += var_86 - 4;
        var_86 = 4;
        if (strcmp(nm, ".zip") == 0 || strcmp(nm, ".ZIP") == 0 ||
            strcmp(nm, ".tgz") == 0)
            return 4;
    }
    if (var_86 > 3) {
        nm += var_86 - 3;
        var_86 = 3;
        if (strcmp(nm, ".gz") == 0 || strcmp(nm, "-gz") == 0 ||
            strcmp(nm, ".zz") == 0 || strcmp(nm, "-zz") == 0)
            return 3;
    }
    if (var_86 > 2) {
        nm += var_86 - 2;
        if (strcmp(nm, ".z") == 0 || strcmp(nm, "-z") == 0 ||
            strcmp(nm, "_z") == 0 || strcmp(nm, ".Z") == 0)
            return 2;
    }
    return 0;
}






static void fn_63(int var_86, unsigned long var_73, off_t var_86, int var_73)
{
    size_t max;
    size_t var_98;
    time_t now;
    char mod[26];
    char tag[49];


    max = g.verbosity > 1 ? 16 : 48;
    memset(tag, 0, max + 1);
    if (var_73)
        strncpy(tag, "<...>", max + 1);
    else if (g.hname == NULL) {
        var_98 = strlen(g.inf) - compressed_suffix(g.inf);
        strncpy(tag, g.inf, var_98 > max + 1 ? max + 1 : var_98);
        if (strcmp(g.inf + var_98, ".tgz") == 0 && var_98 < max + 1)
            strncpy(tag + var_98, ".tar", max + 1 - var_98);
    }
    else
        strncpy(tag, g.hname, max + 1);
    if (tag[max])
        strcpy(tag + max - 3, "...");


    if (g.stamp) {
        strcpy(mod, ctime(&g.stamp));
        now = time(NULL);
        if (strcmp(mod + 20, ctime(&now) + 20) != 0)
            strcpy(mod + 11, mod + 19);
    }
    else
        strcpy(mod + 4, "------ -----");
    mod[16] = 0;


    if (g.first) {
        if (g.verbosity > 1)
            fputs("method    check    timestamp    ", stdout);
        if (g.verbosity > 0)
            puts("compressed   original reduced  name");
        g.first = 0;
    }


    if (g.verbosity > 1) {
        if (g.form == 3 && !g.decode)
            printf("zip%3d  --------  %s  ", var_86, mod + 4);
        else if (g.form > 1)
            printf("zip%3d  %08lx  %s  ", var_86, var_73, mod + 4);
        else if (g.form == 1)
            printf("zlib%2d  %08lx  %s  ", var_86, var_73, mod + 4);
        else if (var_86 == 257)
            printf("lzw     --------  %s  ", mod + 4);
        else
            printf("gzip%2d  %08lx  %s  ", var_86, var_73, mod + 4);
    }
    if (g.verbosity > 0) {
        if ((g.form == 3 && !g.decode) ||
            (var_86 == 8 && g.in_tot > (var_86 + (var_86 >> 10) + 12)) ||
            (var_86 == 257 && g.in_tot > var_86 + (var_86 >> 1) + 3))

            printf("%10jd %10jd?  unk    %s\n",
                   (intmax_t)g.in_tot, (intmax_t)var_86, tag);
        else
            printf("%10jd %10jd %6.1f%%  %s\n",
                   (intmax_t)g.in_tot, (intmax_t)var_86,
                   var_86 == 0 ? 0 : 100 * (var_86 - g.in_tot)/(double)var_86,
                   tag);

    }
}




static void fn_65(void)
{
    int var_86;
    size_t var_98;
    off_t at;
    unsigned char tail[8];
    unsigned long var_73, var_86;


    in_init();


    var_86 = get_header(1);
    if (var_86 < 0) {
        do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
        if (var_86 != -1 && g.verbosity > 1)
            complain("%s not a compressed file -- skipping", g.inf);
        return;
    }


    if (g.form > 1) {
        g.in_tot = g.zip_clen;
        var_84(var_86, g.zip_crc, g.zip_ulen, 0);
        return;
    }


    if (g.form == 1) {
        at = lseek(g.ind, 0, SEEK_END);
        if (at == -1) {
            var_73 = 0;
            do {
                var_86 = g.in_left < 4 ? g.in_left : 4;
                g.in_next += g.in_left - var_86;
                while (var_86--)
                    var_73 = (var_73 << 8) + *g.in_next++;
            } while (load() != 0);
            var_73 &= 0xffffffffUL;
        }
        else {
            g.in_tot = at;
            lseek(g.ind, -4, SEEK_END);
            readn(g.ind, tail, 4);
            var_73 = (((unsigned long)((((unsigned)((tail)[0]) << 8) + (tail)[1])) << 16) + (((unsigned)(((tail) + 2)[0]) << 8) + ((tail) + 2)[1]));
        }
        g.in_tot -= 6;
        var_84(var_86, var_73, 0, 0);
        return;
    }


    if (var_86 == 257) {
        at = lseek(g.ind, 0, SEEK_END);
        if (at == -1)
            while (load() != 0)
                ;
        else
            g.in_tot = at;
        g.in_tot -= 3;
        var_84(var_86, 0, 0, 0);
        return;
    }


    if (g.in_short) {
        if (g.in_left < 8) {
            complain("%s not a valid gzip file -- skipping", g.inf);
            return;
        }
        g.in_tot = g.in_left - 8;
        memcpy(tail, g.in_next + (g.in_left - 8), 8);
    }
    else if ((at = lseek(g.ind, -8, SEEK_END)) != -1) {
        g.in_tot = at - g.in_tot + g.in_left;
        readn(g.ind, tail, 8);
    }
    else {
        at = g.in_tot - g.in_left;
        do {
            var_98 = g.in_left < 8 ? g.in_left : 8;
            memcpy(tail, g.in_next + (g.in_left - var_98), var_98);
            load();
        } while (g.in_left == 32768U);
        if (g.in_left < 8) {
            if (var_98 + g.in_left < 8) {
                complain("%s not a valid gzip file -- skipping", g.inf);
                return;
            }
            if (g.in_left) {
                if (var_98 + g.in_left > 8)
                    memcpy(tail, tail + var_98 - (8 - g.in_left), 8 - g.in_left);
                memcpy(tail + 8 - g.in_left, g.in_next, g.in_left);
            }
        }
        else
            memcpy(tail, g.in_next + (g.in_left - 8), 8);
        g.in_tot -= at + 8;
    }
    if (g.in_tot < 2) {
        complain("%s not a valid gzip file -- skipping", g.inf);
        return;
    }


    var_73 = (((tail)[0] + ((unsigned)((tail)[1]) << 8)) + ((unsigned long)((((tail) + 2)[0] + ((unsigned)(((tail) + 2)[1]) << 8))) << 16));
    var_86 = (((tail + 4)[0] + ((unsigned)((tail + 4)[1]) << 8)) + ((unsigned long)((((tail + 4) + 2)[0] + ((unsigned)(((tail + 4) + 2)[1]) << 8))) << 16));


    var_84(var_86, var_73, var_86, 0);
    do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
}



static void fn_67(void)
{

    writen(g.outd, &g.magic1, 1);
    g.out_tot = 1;




    while (g.in_left) {
        writen(g.outd, g.in_next, g.in_left);
        g.out_tot += g.in_left;
        g.in_left = 0;
        load();
    }
}




static unsigned fn_68(void *var_72, unsigned char **buf)
{
    (void)var_72;
    load();
    *buf = g.in_next;
    return g.in_left;
}



static unsigned char out_buf[32768U];



static unsigned char out_copy[32768U];
static size_t out_len;


static lock *outb_write_more = NULL;
static lock *outb_check_more;


static void fn_69(void *dummy)
{
    size_t var_86;

    (void)dummy;

                                                  ;
    do {
        possess(outb_write_more);
        wait_for(outb_write_more, TO_BE, 1);
        var_86 = out_len;
        if (var_86 && g.decode == 1)
            writen(g.outd, out_copy, var_86);
                                                     ;
        twist(outb_write_more, TO, 0);
    } while (var_86);
                                                ;
}


static void fn_70(void *dummy)
{
    size_t var_86;

    (void)dummy;

                                                  ;
    do {
        possess(outb_check_more);
        wait_for(outb_check_more, TO_BE, 1);
        var_86 = out_len;
        g.out_check = (g.form == 1 ? adler32(g.out_check,out_copy,var_86) : crc32(g.out_check,out_copy,var_86));
                                                       ;
        twist(outb_check_more, TO, 0);
    } while (var_86);
                                                ;
}






static int fn_71(void *var_72, unsigned char *buf, unsigned var_86)
{

    static thread *wr, *ch;

    if (g.procs > 1) {

        if (outb_write_more == NULL) {
            outb_write_more = new_lock(0);
            outb_check_more = new_lock(0);
            wr = launch(outb_write, NULL);
            ch = launch(outb_check, NULL);
        }


        possess(outb_check_more);
        wait_for(outb_check_more, TO_BE, 0);
        possess(outb_write_more);
        wait_for(outb_write_more, TO_BE, 0);


        out_len = var_86;
        g.out_tot += var_86;
        memcpy(out_copy, buf, var_86);
        twist(outb_write_more, TO, 1);
        twist(outb_check_more, TO, 1);



        if (var_86 == 0) {
            join(ch);
            join(wr);
            free_lock(outb_check_more);
            free_lock(outb_write_more);
            outb_write_more = NULL;
        }




        return 0;
    }


    (void)var_72;


    if (var_86) {
        if (g.decode == 1)
            writen(g.outd, buf, var_86);
        g.out_check = (g.form == 1 ? adler32(g.out_check,buf,var_86) : crc32(g.out_check,buf,var_86));
        g.out_tot += var_86;
    }
    return 0;
}





static void fn_72(void)
{
    int ret, var_73, was;
    unsigned long var_73, var_86;
    z_stream strm;
    unsigned tmp2;
    unsigned long tmp4;
    off_t var_73;

    var_73 = 0;
    do {

        g.in_tot = g.in_left;
        g.out_tot = 0;
        g.out_check = (g.form == 1 ? adler32(0L,Z_NULL,0) : crc32(0L,Z_NULL,0));
        strm.zalloc = Z_NULL;
        strm.zfree = Z_NULL;
        strm.opaque = Z_NULL;
        ret = inflateBackInit(&strm, 15, out_buf);
        if (ret != Z_OK)
            bail("not enough memory", "");


        strm.avail_in = g.in_left;
        strm.next_in = g.in_next;
        ret = inflateBack(&strm, inb, NULL, outb, NULL);
        if (ret != Z_STREAM_END)
            bail("corrupted input -- invalid deflate data: ", g.inf);
        g.in_left = strm.avail_in;
        g.in_next = strm.next_in;
        inflateBackEnd(&strm);
        outb(NULL, NULL, 0);


        var_73 = g.in_tot - g.in_left;


        if (g.form > 1) {
            if (g.form == 3) {

                g.zip_crc = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                g.zip_clen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                if (g.in_eof)
                    bail("corrupted zip entry -- missing trailer: ", g.inf);


                if (g.zip_crc != g.out_check) {
                    if (g.zip_crc != 0x08074b50UL || g.zip_clen != g.out_check)
                        bail("corrupted zip entry -- crc32 mismatch: ", g.inf);
                    g.zip_crc = g.zip_clen;
                    g.zip_clen = g.zip_ulen;
                    g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                }


                else if (g.zip_crc == 0x08074b50UL &&
                         g.zip_clen == g.zip_crc &&
                         ((var_73 & 0xffffffffUL) != g.zip_crc ||
                          g.zip_ulen == g.zip_crc)) {
                    g.zip_crc = g.zip_clen;
                    g.zip_clen = g.zip_ulen;
                    g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                }


                if (g.zip_ulen != (g.out_tot & 0xffffffffUL)) {
                    g.zip_ulen = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                    (void)(tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
                }
                if (g.in_eof)
                    bail("corrupted zip entry -- missing trailer: ", g.inf);
            }
            if (g.zip_clen != (var_73 & 0xffffffffUL) ||
                g.zip_ulen != (g.out_tot & 0xffffffffUL))
                bail("corrupted zip entry -- length mismatch: ", g.inf);
            var_73 = g.zip_crc;
        }
        else if (g.form == 1) {
            var_73 = (unsigned long)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 24;
            var_73 += (unsigned long)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 16;
            var_73 += (unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8;
            var_73 += (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++));
            if (g.in_eof)
                bail("corrupted zlib stream -- missing trailer: ", g.inf);
            if (var_73 != g.out_check)
                bail("corrupted zlib stream -- adler32 mismatch: ", g.inf);
        }
        else {
            var_73 = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
            var_86 = (tmp4 = (tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8)), tmp4 + ((unsigned long)((tmp2 = (g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), tmp2 + ((unsigned)((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++))) << 8))) << 16));
            if (g.in_eof)
                bail("corrupted gzip stream -- missing trailer: ", g.inf);
            if (var_73 != g.out_check)
                bail("corrupted gzip stream -- crc32 mismatch: ", g.inf);
            if (var_86 != (g.out_tot & 0xffffffffUL))
                bail("corrupted gzip stream -- length mismatch: ", g.inf);
        }


        if (g.list) {
            g.in_tot = var_73;
            var_84(8, var_73, g.out_tot, var_73);
            var_73 = 1;
        }



        was = g.form;
    } while (was == 0 && (ret = get_header(0)) == 8 && g.form == 0);


    if (was == 0 && ret == -2 && g.force && g.pipeout && g.decode != 2 &&
        !g.list)
        cat();
    else if (was > 1 && get_header(0) != -5)
        complain("entries after the first in %s were ignored", g.inf);
    else if ((was == 0 && ret != -1) || (was == 1 && ((g.in_left == 0 && (g.in_eof || load() == 0) ? 0 : (g.in_left--, *g.in_next++)), !g.in_eof)))
        complain("%s OK, has trailing junk which was ignored", g.inf);
}





typedef uint_fast32_t bits_t;






static void fn_73(void)
{
    unsigned bits;
    unsigned mask;
    bits_t buf;
    unsigned left;
    off_t mark;
    unsigned var_75;
    unsigned max;
    unsigned flags;
    unsigned end;
    unsigned prev;
    unsigned final;
    unsigned stack;
    unsigned outcnt;



    uint_least16_t prefix[65536];
    unsigned char suffix[65536];
    unsigned char match[65282];


    g.out_tot = 0;
    if ((g.in_left == 0 && (g.in_eof || load() == 0)))
        bail("lzw premature end: ", g.inf);
    flags = (g.in_left--, *g.in_next++);
    if (flags & 0x60)
        bail("unknown lzw flags set: ", g.inf);
    max = flags & 0x1f;
    if (max < 9 || max > 16)
        bail("lzw bits out of range: ", g.inf);
    if (max == 9)
        max = 10;
    flags &= 0x80;


    mark = g.in_tot - g.in_left;


    bits = 9;
    mask = 0x1ff;
    end = flags ? 256 : 255;



    if ((g.in_left == 0 && (g.in_eof || load() == 0)))
        return;
    buf = (g.in_left--, *g.in_next++);
    if ((g.in_left == 0 && (g.in_eof || load() == 0)))
        bail("lzw premature end: ", g.inf);
    buf += (g.in_left--, *g.in_next++) << 8;
    final = prev = buf & mask;
    buf >>= bits;
    left = 16 - bits;
    if (prev > 255)
        bail("invalid lzw code: ", g.inf);
    out_buf[0] = final;
    outcnt = 1;


    stack = 0;
    for (;;) {

        if (end >= mask && bits < max) {




            {
                unsigned var_75 = ((g.in_tot - g.in_left) - mark) % bits;
                if (var_75)
                    var_75 = bits - var_75;
                while (var_75 > g.in_left) {
                    var_75 -= g.in_left;
                    if (load() == 0)
                        break;
                }
                g.in_left -= var_75;
                g.in_next += var_75;
            }
            buf = 0;
            left = 0;


            mark = g.in_tot - g.in_left;


            bits++;
            mask <<= 1;
            mask++;
        }


        if ((g.in_left == 0 && (g.in_eof || load() == 0)))
            break;
        buf += (bits_t)((g.in_left--, *g.in_next++)) << left;
        left += 8;
        if (left < bits) {
            if ((g.in_left == 0 && (g.in_eof || load() == 0)))
                bail("lzw premature end: ", g.inf);
            buf += (bits_t)((g.in_left--, *g.in_next++)) << left;
            left += 8;
        }
        var_75 = buf & mask;
        buf >>= bits;
        left -= bits;


        if (var_75 == 256 && flags) {

            {
                unsigned var_75 = ((g.in_tot - g.in_left) - mark) % bits;
                if (var_75)
                    var_75 = bits - var_75;
                while (var_75 > g.in_left) {
                    var_75 -= g.in_left;
                    if (load() == 0)
                        break;
                }
                g.in_left -= var_75;
                g.in_next += var_75;
            }
            buf = 0;
            left = 0;


            mark = g.in_tot - g.in_left;


            bits = 9;
            mask = 0x1ff;
            end = 255;
            continue;
        }


        {
            unsigned var_75 = var_75;
            if (var_75 > end) {



                if (var_75 != end + 1 || prev > end)
                    bail("invalid lzw code: ", g.inf);
                match[stack++] = final;
                var_75 = prev;
            }


            while (var_75 >= 256) {
                match[stack++] = suffix[var_75];
                var_75 = prefix[var_75];
            }
            match[stack++] = var_75;
            final = var_75;


            if (end < mask) {
                end++;
                prefix[end] = prev;
                suffix[end] = final;
            }


            prev = var_75;
        }


        while (stack > 32768U - outcnt) {
            while (outcnt < 32768U)
                out_buf[outcnt++] = match[--stack];
            g.out_tot += outcnt;
            if (g.decode == 1)
                writen(g.outd, out_buf, outcnt);
            outcnt = 0;
        }
        do {
            out_buf[outcnt++] = match[--stack];
        } while (stack);
    }


    g.out_tot += outcnt;
    if (outcnt && g.decode == 1)
        writen(g.outd, out_buf, outcnt);
}




static char *fn_75(char *path)
{
    char *p;

    p = strrchr(path, '/');
    return p == NULL ? path : p + 1;
}





static void fn_76(char *from, char *to)
{
    struct struct_81 st;
    struct struct_80 times[2];


    if (stat(from, &st) != 0 || (st.st_mode & S_IFMT) != S_IFREG)
        return;


    (void)chmod(to, st.st_mode & 7777);


    (void)chown(to, st.st_uid, st.st_gid);


    times[0].tv_sec = st.st_atime;
    times[0].tv_usec = 0;
    times[1].tv_sec = st.st_mtime;
    times[1].tv_usec = 0;
    (void)utimes(to, times);
}


static void fn_79(char *path, time_t var_80)
{
    struct struct_80 times[2];

    times[0].tv_sec = var_80;
    times[0].tv_usec = 0;
    times[1].tv_sec = var_80;
    times[1].tv_usec = 0;
    (void)utimes(path, times);
}



static void fn_80(char *path)
{
    int var_86 = -1;
    size_t var_86;
    struct struct_81 st;

    static char *var_82[] = {".z", "-z", "_z", ".Z", ".gz", "-gz", ".zz", "-zz",
                           ".zip", ".ZIP", ".tgz", NULL};


    if (path == NULL) {
        strcpy(g.inf, "<stdin>");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        var_86 = 0;
    }
    else {

        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail("name too long: ", path);
        }
        var_86 = strlen(g.inf);



        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = var_82;
                do {
                    if (*try == NULL || var_86 + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + var_86, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }





            if (errno) {
                g.inf[var_86] = 0;
                complain("%s does not exist -- skipping", g.inf);
                return;
            }
            var_86 = strlen(g.inf);
        }



        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain("%s is a special file or device -- skipping", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain("%s is a symbolic link -- skipping", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain("%s is a directory -- skipping", g.inf);
            return;
        }


        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t var_86, hold;
            DIR *here;
            struct struct_82 *next;



            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = malloc(hold);
            if (roll == NULL)
                bail("not enough memory", "");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                var_86 = strlen(next->d_name) + 1;
                if (item + var_86 + 1 > roll + hold) {
                    do {
                        hold <<= 1;
                    } while (item + var_86 + 1 > roll + hold);
                    bigger = realloc(roll, hold);
                    if (bigger == NULL) {
                        free(roll);
                        bail("not enough memory", "");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += var_86;
                *item = 0;
            }
            closedir(here);


            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail("path too long", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), "...");
                    bail("path too long: ", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;


            free(roll);
            return;
        }


        if (!(g.force || g.list || g.decode) && var_86 >= strlen(g.sufx) &&
                strcmp(g.inf + var_86 - strlen(g.sufx), g.sufx) == 0) {
            complain("%s ends with %s -- skipping", g.inf, g.sufx);
            return;
        }


        if (g.decode == 1 && !g.pipeout && !g.list) {
            int var_84 = compressed_suffix(g.inf);
            if (var_84 == 0) {
                complain("%s does not have compressed suffix -- skipping",
                         g.inf);
                return;
            }
            var_86 -= var_84;
        }


        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail("read error on ", g.inf);


        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
                          ;


    g.hname = NULL;
    if (g.decode) {
        in_init();
        var_86 = get_header(1);
        if (var_86 != 8 && var_86 != 257 &&

                !(var_86 == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
            if (g.ind != 0)
                close(g.ind);
            if (var_86 != -1)
                complain(var_86 < 0 ? "%s is not compressed -- skipping" :
                         "%s has unknown compression method -- skipping",
                         g.inf);
            return;
        }


        if (g.decode == 2) {
            if (var_86 == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    var_84(var_86, 0, g.out_tot, 0);
                }
            }
            do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }


    if (g.list) {
        var_84();
        do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
        if (g.ind != 0)
            close(g.ind);
        return;
    }


    if (path == NULL || g.pipeout) {

        g.outf = malloc(strlen("<stdout>") + 1);
        if (g.outf == NULL)
            bail("not enough memory", "");
        strcpy(g.outf, "<stdout>");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail("trying to write compressed data to a terminal",
                 " (use -f to force)");
    }
    else {
        char *to = g.inf, *sufx = "";
        size_t var_86 = 0;


        if (g.decode) {


            if ((g.headis & 1) != 0 && g.hname != NULL) {
                var_86 = justname(g.inf) - g.inf;
                to = justname(g.hname);
                var_86 = strlen(to);
            }

            else if (strcmp(to + var_86, ".tgz") == 0)
                sufx = ".tar";
        }
        else

            sufx = g.sufx;


        g.outf = malloc(var_86 + var_86 + strlen(sufx) + 1);
        if (g.outf == NULL)
            bail("not enough memory", "");
        memcpy(g.outf, g.inf, var_86);
        memcpy(g.outf + var_86, to, var_86);
        strcpy(g.outf + var_86 + var_86, sufx);
        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 600);


        if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, "%s exists -- overwrite (y/n)? ", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              600);
        }


        if (g.outd < 0 && errno == EEXIST) {
            complain("%s exists -- skipping", g.outf);
            do { if ((g.outf) != NULL) { free(g.outf); g.outf = NULL; } } while 0;
            do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;
            if (g.ind != 0)
                close(g.ind);
            return;
        }


        if (g.outd < 0)
            bail("write error on ", g.outf);
    }
                           ;
    do { if ((g.hname) != NULL) { free(g.hname); g.hname = NULL; } } while 0;


    if (g.verbosity > 1)
        fprintf(stderr, "%s to %s ", g.inf, g.outf);
    if (g.decode) {
        if (var_86 == 8)
            infchk();
        else if (var_86 == 257)
            unlzw();
        else
            cat();
    }

    else if (g.procs > 1)
        parallel_compress();

    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }


    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail("write error on ", g.outf);
        g.outd = -1;
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    do { if ((g.outf) != NULL) { free(g.outf); g.outf = NULL; } } while 0;
}

static char *helptext[] = {
"Usage: pigz [options] [files ...]",
"  will compress files in place, adding the suffix '.gz'.  If no files are",



"  specified, stdin will be compressed to stdout.  pigz does what gzip does,",
"  but spreads the work over multiple processors and cores when compressing.",

"",
"Options:",
"  -0 to -9, -11        Compression level (11 is much slower, a few % better)",
"  --fast, --best       Compression levels 1 and 9 respectively",
"  -b, --blocksize mmm  Set compression block size to mmmK (default 128K)",
"  -c, --stdout         Write all processed output to stdout (won't delete)",
"  -d, --decompress     Decompress the compressed input",
"  -f, --force          Force overwrite, compress .gz, links, and to terminal",
"  -F  --first          Do iterations first, before block split for -11",
"  -h, --help           Display a help screen and quit",
"  -i, --independent    Compress blocks independently for damage recovery",
"  -I, --iterations n   Number of iterations for -11 optimization",
"  -k, --keep           Do not delete original file after processing",
"  -K, --zip            Compress to PKWare zip (.zip) single entry format",
"  -l, --list           List the contents of the compressed input",
"  -L, --license        Display the pigz license and quit",
"  -M, --maxsplits n    Maximum number of split blocks for -11",
"  -n, --no-name        Do not store or restore file name in/from header",
"  -N, --name           Store/restore file name and mod time in/from header",
"  -O  --oneblock       Do not split into smaller blocks for -11",

"  -p, --processes n    Allow up to n compression threads (default is the",
"                       number of online processors, or 8 if unknown)",

"  -q, --quiet          Print no messages, even on error",
"  -r, --recursive      Process the contents of all subdirectories",
"  -R, --rsyncable      Input-determined block locations for rsync",
"  -S, --suffix .sss    Use suffix .sss instead of .gz (for compression)",
"  -t, --test           Test the integrity of the compressed input",
"  -T, --no-time        Do not store or restore mod time in/from header",



"  -v, --verbose        Provide more verbose output",

"  -V  --version        Show the version of pigz",
"  -z, --zlib           Compress to zlib (.zz) instead of gzip format",
"  --                   All arguments after \"--\" are treated as files"
};


static void fn_86(void)
{
    int var_98;

    if (g.verbosity == 0)
        return;
    for (var_98 = 0; var_98 < (int)(sizeof(helptext) / sizeof(char *)); var_98++)
        fprintf(stderr, "%s\n", helptext[var_98]);
    fflush(stderr);
    exit(0);
}




static int fn_87(int var_98)
{

    return var_98;
}




static void fn_88(void)
{
    g.level = Z_DEFAULT_COMPRESSION;







    ZopfliInitOptions(&g.zopts);



    g.procs = nprocs(8);

    g.block = 131072UL;
    g.rsync = 0;
    g.setdict = 1;
    g.verbosity = 1;
    g.headis = 3;
    g.pipeout = 0;
    g.sufx = ".gz";
    g.decode = 0;
    g.list = 0;
    g.keep = 0;
    g.force = 0;
    g.recurse = 0;
    g.form = 0;
}


static char *longopts[][2] = {
    {"LZW", "Z"}, {"ascii", "a"}, {"best", "9"}, {"bits", "Z"},
    {"blocksize", "b"}, {"decompress", "d"}, {"fast", "1"}, {"first", "F"},
    {"force", "f"}, {"help", "h"}, {"independent", "i"}, {"iterations", "I"},
    {"keep", "k"}, {"license", "L"}, {"list", "l"}, {"maxsplits", "M"},
    {"name", "N"}, {"no-name", "n"}, {"no-time", "T"}, {"oneblock", "O"},
    {"processes", "p"}, {"quiet", "q"}, {"recursive", "r"}, {"rsyncable", "R"},
    {"silent", "q"}, {"stdout", "c"}, {"suffix", "S"}, {"test", "t"},
    {"to-stdout", "c"}, {"uncompress", "d"}, {"verbose", "v"},
    {"version", "V"}, {"zip", "K"}, {"zlib", "z"}};





static void fn_89(void)
{
    single_compress(1);

    finish_jobs();

}


static size_t fn_90(char *var_94)
{
    char *str = var_94;
    size_t var_92 = 0;

    if (*str == 0)
        bail("internal error: empty parameter", "");
    do {
        if (*str < '0' || *str > '9' ||
            (var_92 && ((~(size_t)0) - (*str - '0')) / var_92 < 10))
            bail("invalid numeric parameter: ", var_94);
        var_92 = var_92 * 10 + (*str - '0');
    } while (*++str);
    return var_92;
}


static int fn_92(char *var_94)
{
    static int var_94 = 0;
    char bad[3] = "-X";


    if (var_94 && (var_94 == NULL || *var_94 == '-')) {
        bad[1] = "bpSIM"[var_94 - 1];
        bail("missing parameter after ", bad);
    }
    if (var_94 == NULL)
        return 0;


    if (*var_94 == '-') {

        if (*++var_94 == 0)
            return 1;


        if (*var_94 == '-') {
            int j;

            var_94++;
            for (j = (sizeof(longopts) / (sizeof(char *) << 1)) - 1; j >= 0; j--)
                if (strcmp(var_94, longopts[j][0]) == 0) {
                    var_94 = longopts[j][1];
                    break;
                }
            if (j < 0)
                bail("invalid option: ", var_94 - 2);
        }


        do {


            if (var_94) {
                if (var_94 == 3)
                    bail("invalid usage: -s must be followed by space", "");
                break;
            }


            bad[1] = *var_94;
            switch (*var_94) {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                g.level = *var_94 - '0';
                while (var_94[1] >= '0' && var_94[1] <= '9') {
                    if (g.level && (INT_MAX - (var_94[1] - '0')) / g.level < 10)
                        bail("only levels 0..9 and 11 are allowed", "");
                    g.level = g.level * 10 + *++var_94 - '0';
                }
                if (g.level == 10 || g.level > 11)
                    bail("only levels 0..9 and 11 are allowed", "");
                new_opts();
                break;
            case 'F': g.zopts.blocksplittinglast = 1; break;
            case 'I': var_94 = 4; break;
            case 'K': g.form = 2; g.sufx = ".zip"; break;
            case 'L':
                fputs("pigz 2.3.2\n", stderr);
                fputs("Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013"
                      " Mark Adler\n",
                      stderr);
                fputs("Subject to the terms of the zlib license.\n",
                      stderr);
                fputs("No warranty is provided or implied.\n", stderr);
                exit(0);
            case 'M': var_94 = 5; break;
            case 'N': g.headis |= 0xf; break;
            case 'O': g.zopts.blocksplitting = 0; break;
            case 'R': g.rsync = 1; break;
            case 'S': var_94 = 3; break;
            case 'T': g.headis &= ~0xa; break;
            case 'V': fputs("pigz 2.3.2\n", stderr); exit(0);
            case 'Z':
                bail("invalid option: LZW output not supported: ", bad);
            case 'a':
                bail("invalid option: ascii conversion not supported: ", bad);
            case 'b': var_94 = 1; break;
            case 'c': g.pipeout = 1; break;
            case 'd': if (!g.decode) g.headis >>= 2; g.decode = 1; break;
            case 'f': g.force = 1; break;
            case 'h': help(); break;
            case 'i': g.setdict = 0; break;
            case 'k': g.keep = 1; break;
            case 'l': g.list = 1; break;
            case 'n': g.headis &= ~5; break;
            case 'p': var_94 = 2; break;
            case 'q': g.verbosity = 0; break;
            case 'r': g.recurse = 1; break;
            case 't': g.decode = 2; break;
            case 'v': g.verbosity++; break;
            case 'z': g.form = 1; g.sufx = ".zz"; break;
            default:
                bail("invalid option: ", bad);
            }
        } while (*++var_94);
        if (*var_94 == 0)
            return 0;
    }


    if (var_94) {
        size_t var_98;

        if (var_94 == 1) {
            var_98 = num(var_94);
            g.block = var_98 << 10;
            if (g.block < 32768U)
                bail("block size too small (must be >= 32K)", "");
            if (var_98 != g.block >> 10 ||
                ((g.block)+((g.block)>>4)+32768U) < g.block ||
                (ssize_t)((g.block)+((g.block)>>4)+32768U) < 0 ||
                g.block > (1UL << 29))
                bail("block size too large: ", var_94);
            new_opts();
        }
        else if (var_94 == 2) {
            var_98 = num(var_94);
            g.procs = (int)var_98;
            if (g.procs < 1)
                bail("invalid number of processes: ", var_94);
            if ((size_t)g.procs != var_98 || (((g.procs)<<1)+3) < 1)
                bail("too many processes: ", var_94);




            new_opts();
        }
        else if (var_94 == 3)
            g.sufx = var_94;
        else if (var_94 == 4)
            g.zopts.numiterations = num(var_94);
        else if (var_94 == 5)
            g.zopts.blocksplittingmax = num(var_94);
        var_94 = 0;
        return 0;
    }


    return 1;
}


static void fn_94(int var_96)
{
    (void)var_96;
                                  ;
    if (g.outd != -1 && g.outf != NULL)
        unlink(g.outf);
              ;
    _exit(1);
}




int fn_96(int var_98, char **argv)
{
    int var_98;
    int noop;
    unsigned long done;
    char *opts, *p;


    g.outf = NULL;
    g.first = 1;
    g.hname = NULL;


    p = strrchr(argv[0], '/');
    p = p == NULL ? argv[0] : p + 1;
    g.prog = *p ? p : "pigz";


    signal(SIGINT, cut_short);

    yarn_prefix = g.prog;
    yarn_abort = cut_short;







    defaults();


    opts = getenv("GZIP");
    if (opts != NULL) {
        while (*opts) {
            while (*opts == ' ' || *opts == '\t')
                opts++;
            p = opts;
            while (*p && *p != ' ' && *p != '\t')
                p++;
            var_98 = *p;
            *p = 0;
            if (option(opts))
                bail("cannot provide files in GZIP environment variable", "");
            opts = p + (var_98 ? 1 : 0);
        }
        option(NULL);
    }


    opts = getenv("PIGZ");
    if (opts != NULL) {
        while (*opts) {
            while (*opts == ' ' || *opts == '\t')
                opts++;
            p = opts;
            while (*p && *p != ' ' && *p != '\t')
                p++;
            var_98 = *p;
            *p = 0;
            if (option(opts))
                bail("cannot provide files in PIGZ environment variable", "");
            opts = p + (var_98 ? 1 : 0);
        }
        option(NULL);
    }


    if (strcmp(g.prog, "unpigz") == 0 || strcmp(g.prog, "gunzip") == 0) {
        if (!g.decode)
            g.headis >>= 2;
        g.decode = 1;
    }
    if ((var_98 = strlen(g.prog)) > 2 && strcmp(g.prog + var_98 - 3, "cat") == 0) {
        if (!g.decode)
            g.headis >>= 2;
        g.decode = 1;
        g.pipeout = 1;
    }


    if (var_98 < 2 && isatty(g.decode ? 0 : 1))
        help();


    done = noop = 0;
    for (var_98 = 1; var_98 < var_98; var_98++)
        if (noop == 0 && strcmp(argv[var_98], "--") == 0) {
            noop = 1;
            option(NULL);
        }
        else if (noop || option(argv[var_98])) {
            if (done == 1 && g.pipeout && !g.decode && !g.list && g.form > 1)
                complain("warning: output will be concatenated zip files -- "
                         "will not be able to extract");
            process(strcmp(argv[var_98], "-") ? argv[var_98] : NULL);
            done++;
        }
    option(NULL);


    if (done == 0)
        process(NULL);


    new_opts();
              ;
    return 0;
}
