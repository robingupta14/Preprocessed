







static OPJ_BOOL fn_214(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager);




static OPJ_BOOL fn_216(opj_j2k_t *p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_216(opj_j2k_t * p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_216(opj_j2k_t * p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);





static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager);





static OPJ_BOOL fn_214(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager);





static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_214(opj_j2k_t * p_j2k,
                                       opj_stream_private_t *p_stream,
                                       opj_event_mgr_t * p_manager);




static OPJ_BOOL fn_216(opj_j2k_t * p_j2k,
                                      opj_stream_private_t *p_stream,
                                      opj_event_mgr_t * p_manager);



static OPJ_BOOL fn_216(opj_j2k_t * p_j2k,
                                      opj_stream_private_t *p_stream,
                                      opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_262(opj_j2k_t *p_j2k,
                                   opj_stream_private_t *p_stream,
                                   opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_220(opj_j2k_t * p_j2k,
                             opj_procedure_list_t * p_procedure_list,
                             opj_stream_private_t *p_stream,
                             opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_188(opj_j2k_t *p_j2k,
                                     opj_stream_private_t *p_stream,
                                     opj_event_mgr_t * p_manager);





static OPJ_BOOL fn_221(opj_j2k_t * p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);




static OPJ_BOOL fn_262(opj_j2k_t * p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);

static const struct struct_158 * fn_221(
    OPJ_UINT32 var_221);






static void fn_224(opj_tcp_t *p_tcp);






static void fn_224(opj_tcp_t *p_tcp);






static void fn_224(opj_cp_t *p_cp);

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234, OPJ_UINT32 var_234, OPJ_UINT32 var_234);

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234,
        OPJ_UINT32 var_234,
        OPJ_BYTE * p_data,
        OPJ_UINT32 * var_234,
        opj_event_mgr_t * p_manager);

static OPJ_UINT32 fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234,
        OPJ_UINT32 var_234);

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_252,
        OPJ_BYTE * p_header_data,
        OPJ_UINT32 * var_234,
        opj_event_mgr_t * p_manager);

static OPJ_UINT32 fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234,
        OPJ_UINT32 var_234);

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234, OPJ_UINT32 var_234, OPJ_UINT32 var_234);

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
                                        OPJ_UINT32 var_234,
                                        OPJ_UINT32 var_234,
                                        OPJ_BYTE * p_data,
                                        OPJ_UINT32 * var_234,
                                        opj_event_mgr_t * p_manager);




static void fn_96(opj_j2k_t * p_j2k, OPJ_UINT32 var_96);

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
                                       OPJ_UINT32 var_252,
                                       OPJ_BYTE * p_header_data,
                                       OPJ_UINT32 * var_234,
                                       opj_event_mgr_t * p_manager);






static void fn_234(opj_j2k_t *p_j2k);






static void fn_234(opj_j2k_t *p_j2k);




static OPJ_BOOL fn_244(opj_j2k_t *p_j2k,
                                     opj_stream_private_t *p_stream,
                                     opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_260(opj_j2k_t * p_j2k,
                                       OPJ_UINT32 var_263,
                                       opj_stream_private_t *p_stream,
                                       opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_228(opj_tcd_t * p_tcd, OPJ_BYTE * p_data,
        opj_image_t* p_output_image);

static void fn_260(opj_image_t * l_image,
                                    opj_tcd_tilecomp_t * l_tilec,
                                    opj_image_comp_t * l_img_comp,
                                    OPJ_UINT32* l_size_comp,
                                    OPJ_UINT32* var_260,
                                    OPJ_UINT32* var_260,
                                    OPJ_UINT32* l_offset_x,
                                    OPJ_UINT32* l_offset_y,
                                    OPJ_UINT32* l_image_width,
                                    OPJ_UINT32* l_stride,
                                    OPJ_UINT32* l_tile_offset);

static void fn_260(opj_tcd_t * p_tcd, OPJ_BYTE * p_data);

static OPJ_BOOL fn_260(opj_j2k_t * p_j2k,
                                        opj_stream_private_t *p_stream,
                                        opj_event_mgr_t * p_manager);





static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        OPJ_BYTE * p_data,
        OPJ_UINT32 * p_data_written,
        OPJ_UINT32 var_262,
        opj_stream_private_t *p_stream,
        struct struct_262 * p_manager);

static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        OPJ_BYTE * p_data,
        OPJ_UINT32 * p_data_written,
        OPJ_UINT32 var_262,
        opj_stream_private_t *p_stream,
        struct struct_262 * p_manager);

static OPJ_BOOL fn_191(opj_j2k_t *p_j2k,
                                       opj_stream_private_t *p_stream,
                                       opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_244(opj_j2k_t *p_j2k);

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);







static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                 opj_stream_private_t *p_stream,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);







static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                    OPJ_UINT32 var_234, OPJ_UINT32 var_234);

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  OPJ_UINT32 var_234,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static void fn_177(opj_j2k_t *p_j2k,
                                        OPJ_UINT32 var_234,
                                        OPJ_BYTE * p_data,
                                        OPJ_UINT32 * p_data_written,
                                        opj_event_mgr_t * p_manager);






static OPJ_UINT32 fn_177(opj_j2k_t *p_j2k);

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                    OPJ_UINT32 var_234, OPJ_UINT32 var_234);

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                  OPJ_UINT32 var_234,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static void fn_178(opj_j2k_t *p_j2k,
                                        OPJ_UINT32 var_234,
                                        OPJ_BYTE * p_data,
                                        OPJ_UINT32 * p_data_written,
                                        opj_event_mgr_t * p_manager);




static OPJ_UINT32 fn_178(opj_j2k_t *p_j2k);

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);







static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static void fn_179(opj_j2k_t *p_j2k,
                                        OPJ_BYTE * p_data,
                                        OPJ_UINT32 * p_data_written,
                                        opj_event_mgr_t * p_manager);



static OPJ_UINT32 fn_179(opj_j2k_t *p_j2k);

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);




static OPJ_UINT32 fn_180(opj_j2k_t *p_j2k);






static OPJ_UINT32 fn_180(opj_j2k_t *p_j2k);

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_262(opj_j2k_t *p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_182(
    opj_j2k_t *p_j2k,
    OPJ_BYTE * p_header_data,
    OPJ_UINT32 var_234,
    opj_event_mgr_t * p_manager);







static OPJ_BOOL fn_183(opj_cp_t *p_cp, opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_184(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);







static OPJ_BOOL fn_184(opj_tcp_t *p_tcp,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_184(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_184(opj_j2k_t *p_j2k,
                                  OPJ_BYTE * p_data,
                                  OPJ_UINT32 * p_data_written,
                                  const opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_184(OPJ_BYTE * p_header_data,
                                       OPJ_UINT32 var_234,
                                       OPJ_UINT32* var_234,
                                       OPJ_UINT32* p_tot_len,
                                       OPJ_UINT32* p_current_part,
                                       OPJ_UINT32* p_num_parts,
                                       opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_184(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_185(opj_j2k_t *p_j2k,
                                  opj_tcd_t * p_tile_coder,
                                  OPJ_BYTE * p_data,
                                  OPJ_UINT32 * p_data_written,
                                  OPJ_UINT32 var_262,
                                  const opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_185(opj_j2k_t *p_j2k,
                                 opj_stream_private_t *p_stream,
                                 opj_event_mgr_t * p_manager);

static void fn_96(opj_j2k_t * p_j2k, OPJ_UINT32 var_96)
{
    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                    p_j2k->m_current_tile_number, 1);
    ++p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current;

    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                    var_96, 4);
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
}

static OPJ_BOOL fn_188(opj_j2k_t *p_j2k,
                                  OPJ_UINT32 var_234,
                                  OPJ_UINT32 var_234,
                                  OPJ_UINT32 var_188,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_188(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_188(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_262(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_212(opj_codestream_index_t *cstr_index,
                                     OPJ_UINT32 var_212, OPJ_OFF_T var_212, OPJ_UINT32 var_212) ;

static OPJ_BOOL fn_212(OPJ_UINT32 var_212,
                                     opj_codestream_index_t *cstr_index, OPJ_UINT32 var_212, OPJ_OFF_T var_212,
                                     OPJ_UINT32 var_212);

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
                                 opj_stream_private_t *p_stream,
                                 OPJ_UINT32 *output_marker,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_194(opj_j2k_t *p_j2k,
        opj_mct_data_t * p_mct_record,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_194(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_195(opj_j2k_t *p_j2k,
        opj_simple_mcc_decorrelation_data_t * p_mcc_record,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_196(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_197(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_197(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_197(opj_tcp_t * p_tcp, opj_image_t * p_image,
                                OPJ_UINT32 var_197);

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);
static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159);

static OPJ_BOOL fn_262(opj_j2k_t *p_j2k,
                                     opj_stream_private_t *p_stream,
                                     opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_197(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_197(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
                                      opj_stream_private_t *p_stream,
                                      opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
                                      opj_stream_private_t *p_stream,
                                      opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
                                      opj_stream_private_t *p_stream,
                                      opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager);

static OPJ_BOOL fn_161(const opj_poc_t *p_pocs,
                                      OPJ_UINT32 var_172,
                                      OPJ_UINT32 var_173,
                                      OPJ_UINT32 var_243,
                                      OPJ_UINT32 var_141,
                                      opj_event_mgr_t * p_manager);

static OPJ_UINT32 fn_173(opj_cp_t *cp, OPJ_UINT32 var_262,
                                     OPJ_UINT32 var_212);

static OPJ_BOOL fn_174(opj_j2k_t *p_j2k,
                                     opj_cp_t *cp,
                                     OPJ_UINT32 * p_nb_tiles,
                                     opj_image_t *image,
                                     opj_event_mgr_t * p_manager);

static void fn_239(opj_j2k_t* p_j2k, FILE* out_stream);

static void fn_237(opj_j2k_t* p_j2k, FILE* out_stream);

static opj_codestream_index_t* fn_234(void);

static OPJ_FLOAT32 fn_188(opj_tcp_t * p_tcp);

static OPJ_FLOAT32 fn_188(opj_tcp_t * p_tcp);

static int fn_202(opj_poc_t *POC, int var_202);

static void fn_202(opj_cparameters_t *parameters,
        opj_image_t *image, opj_event_mgr_t *p_manager);

static OPJ_BOOL fn_202(opj_image_t *image, OPJ_UINT16 var_202,
        opj_event_mgr_t *p_manager);

static OPJ_BOOL fn_224(opj_stream_private_t
        *p_stream, OPJ_UINT32 var_224, OPJ_BOOL* p_correction_needed,
        opj_event_mgr_t * p_manager);






typedef struct struct_157 {
    OPJ_PROG_ORDER enum_prog;
    char str_prog[5];
} j2k_prog_order_t;

static const j2k_prog_order_t j2k_prog_order_list[] = {
    {OPJ_CPRL, "CPRL"},
    {OPJ_LRCP, "LRCP"},
    {OPJ_PCRL, "PCRL"},
    {OPJ_RLCP, "RLCP"},
    {OPJ_RPCL, "RPCL"},
    {(OPJ_PROG_ORDER) - 1, ""}
};




static const OPJ_UINT32 MCT_ELEMENT_SIZE [] = {
    2,
    4,
    4,
    8
};

typedef void (* opj_j2k_mct_function)(const void * p_src_data,
                                      void * p_dest_data, OPJ_UINT32 var_159);

static const opj_j2k_mct_function j2k_mct_read_functions_to_float [] = {
    opj_j2k_read_int16_to_float,
    opj_j2k_read_int32_to_float,
    opj_j2k_read_float32_to_float,
    opj_j2k_read_float64_to_float
};

static const opj_j2k_mct_function j2k_mct_read_functions_to_int32 [] = {
    opj_j2k_read_int16_to_int32,
    opj_j2k_read_int32_to_int32,
    opj_j2k_read_float32_to_int32,
    opj_j2k_read_float64_to_int32
};

static const opj_j2k_mct_function j2k_mct_write_functions_from_float [] = {
    opj_j2k_write_float_to_int16,
    opj_j2k_write_float_to_int32,
    opj_j2k_write_float_to_float,
    opj_j2k_write_float_to_float64
};

typedef struct struct_158 {

    OPJ_UINT32 id;

    OPJ_UINT32 states;

    OPJ_BOOL(*handler)(opj_j2k_t *p_j2k,
                       OPJ_BYTE * p_header_data,
                       OPJ_UINT32 var_234,
                       opj_event_mgr_t * p_manager);
}
opj_dec_memory_marker_handler_t;

static const opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab [] =
{
    {var_228, J2K_STATE_MH | J2K_STATE_TPHSOT, opj_j2k_read_sot},
    {J2K_MS_COD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_cod},
    {J2K_MS_COC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_coc},
    {J2K_MS_RGN, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_rgn},
    {J2K_MS_QCD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcd},
    {J2K_MS_QCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcc},
    {J2K_MS_POC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_poc},
    {J2K_MS_SIZ, J2K_STATE_MHSIZ, opj_j2k_read_siz},
    {J2K_MS_TLM, J2K_STATE_MH, opj_j2k_read_tlm},
    {J2K_MS_PLM, J2K_STATE_MH, opj_j2k_read_plm},
    {J2K_MS_PLT, J2K_STATE_TPH, opj_j2k_read_plt},
    {J2K_MS_PPM, J2K_STATE_MH, opj_j2k_read_ppm},
    {J2K_MS_PPT, J2K_STATE_TPH, opj_j2k_read_ppt},
    {J2K_MS_SOP, 0, 0},
    {J2K_MS_CRG, J2K_STATE_MH, opj_j2k_read_crg},
    {J2K_MS_COM, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_com},
    {J2K_MS_MCT, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mct},
    {J2K_MS_CBD, J2K_STATE_MH, opj_j2k_read_cbd},
    {J2K_MS_MCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mcc},
    {J2K_MS_MCO, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mco},

    {J2K_MS_UNK, J2K_STATE_MH | J2K_STATE_TPH, 0}
};

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
    OPJ_UINT32 i;
    OPJ_UINT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        opj_read_bytes(l_src_data, &l_temp, 2);

        l_src_data += sizeof(OPJ_INT16);

        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
    OPJ_UINT32 i;
    OPJ_UINT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        opj_read_bytes(l_src_data, &l_temp, 4);

        l_src_data += sizeof(OPJ_INT32);

        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
    OPJ_UINT32 i;
    OPJ_FLOAT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        opj_read_float(l_src_data, &l_temp);

        l_src_data += sizeof(OPJ_FLOAT32);

        *(l_dest_data++) = l_temp;
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
    OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
    OPJ_UINT32 i;
    OPJ_FLOAT64 l_temp;

    for (i = 0; i < var_159; ++i) {
        opj_read_double(l_src_data, &l_temp);

        l_src_data += sizeof(OPJ_FLOAT64);

        *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;
    OPJ_UINT32 i;
    OPJ_UINT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        opj_read_bytes(l_src_data, &l_temp, 2);

        l_src_data += sizeof(OPJ_INT16);

        *(l_dest_data++) = (OPJ_INT32) l_temp;
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;
    OPJ_UINT32 i;
    OPJ_UINT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        opj_read_bytes(l_src_data, &l_temp, 4);

        l_src_data += sizeof(OPJ_INT32);

        *(l_dest_data++) = (OPJ_INT32) l_temp;
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;
    OPJ_UINT32 i;
    OPJ_FLOAT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        opj_read_float(l_src_data, &l_temp);

        l_src_data += sizeof(OPJ_FLOAT32);

        *(l_dest_data++) = (OPJ_INT32) l_temp;
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
    OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;
    OPJ_UINT32 i;
    OPJ_FLOAT64 l_temp;

    for (i = 0; i < var_159; ++i) {
        opj_read_double(l_src_data, &l_temp);

        l_src_data += sizeof(OPJ_FLOAT64);

        *(l_dest_data++) = (OPJ_INT32) l_temp;
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
    OPJ_UINT32 i;
    OPJ_UINT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        l_temp = (OPJ_UINT32) * (l_src_data++);

        opj_write_bytes(l_dest_data, l_temp, sizeof(OPJ_INT16));

        l_dest_data += sizeof(OPJ_INT16);
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
    OPJ_UINT32 i;
    OPJ_UINT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        l_temp = (OPJ_UINT32) * (l_src_data++);

        opj_write_bytes(l_dest_data, l_temp, sizeof(OPJ_INT32));

        l_dest_data += sizeof(OPJ_INT32);
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
    OPJ_UINT32 i;
    OPJ_FLOAT32 l_temp;

    for (i = 0; i < var_159; ++i) {
        l_temp = (OPJ_FLOAT32) * (l_src_data++);

        opj_write_float(l_dest_data, l_temp);

        l_dest_data += sizeof(OPJ_FLOAT32);
    }
}

static void fn_159(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 var_159)
{
    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
    OPJ_UINT32 i;
    OPJ_FLOAT64 l_temp;

    for (i = 0; i < var_159; ++i) {
        l_temp = (OPJ_FLOAT64) * (l_src_data++);

        opj_write_double(l_dest_data, l_temp);

        l_dest_data += sizeof(OPJ_FLOAT64);
    }
}

const char *fn_159(OPJ_PROG_ORDER var_161)
{
    const j2k_prog_order_t *po;
    for (po = j2k_prog_order_list; po->enum_prog != -1; po++) {
        if (po->enum_prog == var_161) {
            return po->str_prog;
        }
    }
    return po->str_prog;
}

static OPJ_BOOL fn_161(const opj_poc_t *p_pocs,
                                      OPJ_UINT32 var_172,
                                      OPJ_UINT32 var_173,
                                      OPJ_UINT32 var_173,
                                      OPJ_UINT32 var_173,
                                      opj_event_mgr_t * p_manager)
{
    OPJ_UINT32* packet_array;
    OPJ_UINT32 index, resno, var_252, layno;
    OPJ_UINT32 i;
    OPJ_UINT32 var_173 = 1;
    OPJ_UINT32 var_173 = var_173 * var_173;
    OPJ_UINT32 var_173 = var_173 * var_173;
    OPJ_BOOL var_173 = var_263;
    OPJ_UINT32 var_173 = 0;

    packet_array = (OPJ_UINT32*) opj_calloc(var_173 * var_173,
                                            sizeof(OPJ_UINT32));
    if (packet_array == 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Not enough memory for checking the poc values.\n");
        return var_263;
    }

    if (var_172 == 0) {
        opj_free(packet_array);
        return var_263;
    }

    index = var_173 * p_pocs->resno0;

    for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {
        OPJ_UINT32 var_173 = index + p_pocs->compno0 * var_173;


        for (var_252 = p_pocs->compno0 ; var_252 < p_pocs->compno1 ; ++var_252) {
            OPJ_UINT32 var_173 = var_173 + var_173 * var_173;


            for (layno = var_173; layno < p_pocs->layno1 ; ++layno) {

                packet_array[var_173] = 1;
                var_173 += var_173;
            }

            var_173 += var_173;
        }

        index += var_173;
    }
    ++p_pocs;


    for (i = 1; i < var_172 ; ++i) {
        OPJ_UINT32 var_173 = (p_pocs - 1)->layno1 ;

        var_173 = (p_pocs->layno1 > var_173) ? var_173 : 0;
        index = var_173 * p_pocs->resno0;


        for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {
            OPJ_UINT32 var_173 = index + p_pocs->compno0 * var_173;


            for (var_252 = p_pocs->compno0 ; var_252 < p_pocs->compno1 ; ++var_252) {
                OPJ_UINT32 var_173 = var_173 + var_173 * var_173;


                for (layno = var_173; layno < p_pocs->layno1 ; ++layno) {

                    packet_array[var_173] = 1;
                    var_173 += var_173;
                }

                var_173 += var_173;
            }

            index += var_173;
        }

        ++p_pocs;
    }

    index = 0;
    for (layno = 0; layno < var_173 ; ++layno) {
        for (resno = 0; resno < var_173; ++resno) {
            for (var_252 = 0; var_252 < var_173; ++var_252) {
                var_173 |= (packet_array[index] != 1);

                index += var_173;
            }
        }
    }

    if (var_173) {
        opj_event_msg(p_manager, EVT_ERROR, "Missing packets possible loss of data\n");
    }

    opj_free(packet_array);

    return !var_173;
}



static OPJ_UINT32 fn_173(opj_cp_t *cp, OPJ_UINT32 var_262,
                                     OPJ_UINT32 var_212)
{
    const OPJ_CHAR *prog = 0;
    OPJ_INT32 i;
    OPJ_UINT32 var_174 = 1;
    opj_tcp_t *tcp = 0;
    opj_poc_t * l_current_poc = 0;


    assert(var_212 < (cp->tw * cp->th));
    assert(var_262 < (cp->tcps[var_212].numpocs + 1));


    tcp = &cp->tcps[var_212];
    assert(tcp != 0);

    l_current_poc = &(tcp->pocs[var_262]);
    assert(l_current_poc != 0);


    prog = opj_j2k_convert_progression_order(tcp->prg);
    assert(strlen(prog) > 0);

    if (cp->m_specific_param.m_enc.m_tp_on == 1) {
        for (i = 0; i < 4; ++i) {
            switch (prog[i]) {

            case 'C':
                var_174 *= l_current_poc->compE;
                break;

            case 'R':
                var_174 *= l_current_poc->resE;
                break;

            case 'P':
                var_174 *= l_current_poc->prcE;
                break;

            case 'L':
                var_174 *= l_current_poc->layE;
                break;
            }

            if (cp->m_specific_param.m_enc.m_tp_flag == prog[i]) {
                cp->m_specific_param.m_enc.m_tp_pos = i;
                break;
            }
        }
    } else {
        var_174 = 1;
    }

    return var_174;
}

static OPJ_BOOL fn_174(opj_j2k_t *p_j2k,
                                     opj_cp_t *cp,
                                     OPJ_UINT32 * p_nb_tiles,
                                     opj_image_t *image,
                                     opj_event_mgr_t * p_manager
                                    )
{
    OPJ_UINT32 var_262, var_212;
    OPJ_UINT32 var_258;
    opj_tcp_t *tcp;


    assert(p_nb_tiles != 0);
    assert(cp != 0);
    assert(image != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    (void)p_j2k;
    (void)p_manager;

    var_258 = cp->tw * cp->th;
    * p_nb_tiles = 0;
    tcp = cp->tcps;

           {
        for (var_212 = 0; var_212 < var_258; ++var_212) {
            OPJ_UINT32 var_177 = 0;

            opj_pi_update_encoding_parameters(image, cp, var_212);

            for (var_262 = 0; var_262 <= tcp->numpocs; ++var_262) {
                OPJ_UINT32 var_177 = opj_j2k_get_num_tp(cp, var_262, var_212);

                *p_nb_tiles = *p_nb_tiles + var_177;

                var_177 += var_177;
            }
            tcp->m_nb_tile_parts = var_177;

            ++tcp;
        }
    }

    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager)
{

    OPJ_BYTE * l_start_stream = 0;


    assert(p_stream != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;


    opj_write_bytes(l_start_stream, J2K_MS_SOC, 2);

    if (opj_stream_write_data(p_stream, l_start_stream, 2, p_manager) != 2) {
        return var_263;
    }

    return var_263;
}







static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                 opj_stream_private_t *p_stream,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_BYTE l_data [2];
    OPJ_UINT32 l_marker;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    if (opj_stream_read_data(p_stream, l_data, 2, p_manager) != 2) {
        return var_263;
    }

    opj_read_bytes(l_data, &l_marker, 2);
    if (l_marker != J2K_MS_SOC) {
        return var_263;
    }


    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSIZ;


    p_j2k->cstr_index->main_head_start = opj_stream_tell(p_stream) - 2;

    opj_event_msg(p_manager, EVT_INFO, "Start to read j2k main header (%d).\n",
                  p_j2k->cstr_index->main_head_start);


    if (var_263 == opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_SOC,
                                          p_j2k->cstr_index->main_head_start, 2)) {
        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add mh marker\n");
        return var_263;
    }
    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 i;
    OPJ_UINT32 l_size_len;
    OPJ_BYTE * l_current_ptr;
    opj_image_t * l_image = 0;
    opj_cp_t *cp = 0;
    opj_image_comp_t * l_img_comp = 0;


    assert(p_stream != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_image = p_j2k->m_private_image;
    cp = &(p_j2k->m_cp);
    l_size_len = 40 + 3 * l_image->numcomps;
    l_img_comp = l_image->comps;

    if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {

        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory for the SIZ marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
    }

    l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;


    opj_write_bytes(l_current_ptr, J2K_MS_SIZ, 2);
    l_current_ptr += 2;

    opj_write_bytes(l_current_ptr, l_size_len - 2, 2);
    l_current_ptr += 2;

    opj_write_bytes(l_current_ptr, cp->rsiz, 2);
    l_current_ptr += 2;

    opj_write_bytes(l_current_ptr, l_image->x1, 4);
    l_current_ptr += 4;

    opj_write_bytes(l_current_ptr, l_image->y1, 4);
    l_current_ptr += 4;

    opj_write_bytes(l_current_ptr, l_image->x0, 4);
    l_current_ptr += 4;

    opj_write_bytes(l_current_ptr, l_image->y0, 4);
    l_current_ptr += 4;

    opj_write_bytes(l_current_ptr, cp->tdx, 4);
    l_current_ptr += 4;

    opj_write_bytes(l_current_ptr, cp->tdy, 4);
    l_current_ptr += 4;

    opj_write_bytes(l_current_ptr, cp->tx0, 4);
    l_current_ptr += 4;

    opj_write_bytes(l_current_ptr, cp->ty0, 4);
    l_current_ptr += 4;

    opj_write_bytes(l_current_ptr, l_image->numcomps, 2);
    l_current_ptr += 2;

    for (i = 0; i < l_image->numcomps; ++i) {

        opj_write_bytes(l_current_ptr, l_img_comp->prec - 1 + (l_img_comp->sgnd << 7),
                        1);
        ++l_current_ptr;

        opj_write_bytes(l_current_ptr, l_img_comp->dx, 1);
        ++l_current_ptr;

        opj_write_bytes(l_current_ptr, l_img_comp->dy, 1);
        ++l_current_ptr;

        ++l_img_comp;
    }

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len,
                              p_manager) != l_size_len) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 i;
    OPJ_UINT32 l_nb_comp;
    OPJ_UINT32 l_nb_comp_remain;
    OPJ_UINT32 l_remaining_size;
    OPJ_UINT32 var_258;
    OPJ_UINT32 l_tmp, l_tx1, l_ty1;
    OPJ_UINT32 l_prec0, l_sgnd0;
    opj_image_t *l_image = 0;
    opj_cp_t *l_cp = 0;
    opj_image_comp_t * l_img_comp = 0;
    opj_tcp_t * l_current_tile_param = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_header_data != 0);

    l_image = p_j2k->m_private_image;
    l_cp = &(p_j2k->m_cp);


    if (var_234 < 36) {
        opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker size\n");
        return var_263;
    }

    l_remaining_size = var_234 - 36;
    l_nb_comp = l_remaining_size / 3;
    l_nb_comp_remain = l_remaining_size % 3;
    if (l_nb_comp_remain != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker size\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, &l_tmp,
                   2);
    p_header_data += 2;
    l_cp->rsiz = (OPJ_UINT16) l_tmp;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x1, 4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y1, 4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x0, 4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y0, 4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdx,
                   4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdy,
                   4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tx0,
                   4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->ty0,
                   4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_tmp,
                   2);
    p_header_data += 2;
    if (l_tmp < 16385) {
        l_image->numcomps = (OPJ_UINT16) l_tmp;
    } else {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error with SIZ marker: number of component is illegal -> %d\n", l_tmp);
        return var_263;
    }

    if (l_image->numcomps != l_nb_comp) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n",
                      l_image->numcomps, l_nb_comp);
        return var_263;
    }



    if ((l_image->x0 >= l_image->x1) || (l_image->y0 >= l_image->y1)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error with SIZ marker: negative or zero image size (%" PRId64 " x %" PRId64
                      ")\n", (OPJ_INT64)l_image->x1 - l_image->x0,
                      (OPJ_INT64)l_image->y1 - l_image->y0);
        return var_263;
    }

    if ((l_cp->tdx == 0U) || (l_cp->tdy == 0U)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n", l_cp->tdx,
                      l_cp->tdy);
        return var_263;
    }


    if ((0xFFFFFFFFU / l_image->x1) < l_image->y1) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Prevent buffer overflow (x1: %d, y1: %d)\n", l_image->x1, l_image->y1);
        return var_263;
    }


    l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx);
    l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy);
    if ((l_cp->tx0 > l_image->x0) || (l_cp->ty0 > l_image->y0) ||
            (l_tx1 <= l_image->x0) || (l_ty1 <= l_image->y0)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error with SIZ marker: illegal tile offset\n");
        return var_263;
    }
    if (!p_j2k->dump_state) {
        OPJ_UINT32 siz_w, siz_h;

        siz_w = l_image->x1 - l_image->x0;
        siz_h = l_image->y1 - l_image->y0;

        if (p_j2k->ihdr_w > 0 && p_j2k->ihdr_h > 0
                && (p_j2k->ihdr_w != siz_w || p_j2k->ihdr_h != siz_h)) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n", p_j2k->ihdr_w,
                          p_j2k->ihdr_h, siz_w, siz_h);
            return var_263;
        }
    }

    l_image->comps = (opj_image_comp_t*) opj_calloc(l_image->numcomps,
                     sizeof(opj_image_comp_t));
    if (l_image->comps == 0) {
        l_image->numcomps = 0;
        opj_event_msg(p_manager, EVT_ERROR,
                      "Not enough memory to take in charge SIZ marker\n");
        return var_263;
    }

    l_img_comp = l_image->comps;

    l_prec0 = 0;
    l_sgnd0 = 0;

    for (i = 0; i < l_image->numcomps; ++i) {
        OPJ_UINT32 tmp;
        opj_read_bytes(p_header_data, &tmp, 1);
        ++p_header_data;
        l_img_comp->prec = (tmp & 0x7f) + 1;
        l_img_comp->sgnd = tmp >> 7;

        if (p_j2k->dump_state == 0) {
            if (i == 0) {
                l_prec0 = l_img_comp->prec;
                l_sgnd0 = l_img_comp->sgnd;
            } else if (!l_cp->allow_different_bit_depth_sign
                       && (l_img_comp->prec != l_prec0 || l_img_comp->sgnd != l_sgnd0)) {
                opj_event_msg(p_manager, EVT_WARNING,
                              "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n"
                              "        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n", i, l_prec0, l_sgnd0,
                              i, l_img_comp->prec, l_img_comp->sgnd);
            }

        }
        opj_read_bytes(p_header_data, &tmp, 1);
        ++p_header_data;
        l_img_comp->dx = (OPJ_UINT32)tmp;
        opj_read_bytes(p_header_data, &tmp, 1);
        ++p_header_data;
        l_img_comp->dy = (OPJ_UINT32)tmp;
        if (l_img_comp->dx < 1 || l_img_comp->dx > 255 ||
                l_img_comp->dy < 1 || l_img_comp->dy > 255) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n",
                          i, l_img_comp->dx, l_img_comp->dy);
            return var_263;
        }



        if (l_img_comp->prec > 31) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                          i, l_img_comp->prec);
            return var_263;
        }

        l_img_comp->resno_decoded =
            0;
        l_img_comp->factor =
            l_cp->m_specific_param.m_dec.m_reduce;
        ++l_img_comp;
    }

    if (l_cp->tdx == 0 || l_cp->tdy == 0) {
        return var_263;
    }


    l_cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->x1 - l_cp->tx0),
                                           (OPJ_INT32)l_cp->tdx);
    l_cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->y1 - l_cp->ty0),
                                           (OPJ_INT32)l_cp->tdy);


    if (l_cp->tw == 0 || l_cp->th == 0 || l_cp->tw > 65535 / l_cp->th) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                      l_cp->tw, l_cp->th);
        return var_263;
    }
    var_258 = l_cp->tw * l_cp->th;


    if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {
        p_j2k->m_specific_param.m_decoder.m_start_tile_x =
            (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
        p_j2k->m_specific_param.m_decoder.m_start_tile_y =
            (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
        p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv((
                    OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),
                (OPJ_INT32)l_cp->tdx);
        p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv((
                    OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),
                (OPJ_INT32)l_cp->tdy);
    } else {
        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;
        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;
        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
    }

    l_cp->tcps = (opj_tcp_t*) opj_calloc(var_258, sizeof(opj_tcp_t));
    if (l_cp->tcps == 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Not enough memory to take in charge SIZ marker\n");
        return var_263;
    }

    p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps =
        (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));
    if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps == 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Not enough memory to take in charge SIZ marker\n");
        return var_263;
    }

    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records =
        (opj_mct_data_t*)opj_calloc(OPJ_J2K_MCT_DEFAULT_NB_RECORDS,
                                    sizeof(opj_mct_data_t));

    if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Not enough memory to take in charge SIZ marker\n");
        return var_263;
    }
    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mct_records =
        OPJ_J2K_MCT_DEFAULT_NB_RECORDS;

    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records =
        (opj_simple_mcc_decorrelation_data_t*)
        opj_calloc(OPJ_J2K_MCC_DEFAULT_NB_RECORDS,
                   sizeof(opj_simple_mcc_decorrelation_data_t));

    if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Not enough memory to take in charge SIZ marker\n");
        return var_263;
    }
    p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mcc_records =
        OPJ_J2K_MCC_DEFAULT_NB_RECORDS;


    for (i = 0; i < l_image->numcomps; ++i) {
        if (! l_image->comps[i].sgnd) {
            p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1
                    << (l_image->comps[i].prec - 1);
        }
    }

    l_current_tile_param = l_cp->tcps;
    for (i = 0; i < var_258; ++i) {
        l_current_tile_param->tccps = (opj_tccp_t*) opj_calloc(l_image->numcomps,
                                      sizeof(opj_tccp_t));
        if (l_current_tile_param->tccps == 0) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Not enough memory to take in charge SIZ marker\n");
            return var_263;
        }

        ++l_current_tile_param;
    }

    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MH;
    opj_image_comp_header_update(l_image, l_cp);

    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    OPJ_UINT32 l_comment_size;
    OPJ_UINT32 l_total_com_size;
    const OPJ_CHAR *l_comment;
    OPJ_BYTE * l_current_ptr = 0;


    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    l_comment = p_j2k->m_cp.comment;
    l_comment_size = (OPJ_UINT32)strlen(l_comment);
    l_total_com_size = l_comment_size + 6;

    if (l_total_com_size >
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR,
                          "Not enough memory to write the COM marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
    }

    l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;

    opj_write_bytes(l_current_ptr, J2K_MS_COM, 2);
    l_current_ptr += 2;

    opj_write_bytes(l_current_ptr, l_total_com_size - 2, 2);
    l_current_ptr += 2;

    opj_write_bytes(l_current_ptr, 1,
                    2);
    l_current_ptr += 2;

    memcpy(l_current_ptr, l_comment, l_comment_size);

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size,
                              p_manager) != l_total_com_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{

    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_header_data != 0);

    (void)p_j2k;
    (void)p_header_data;
    (void)var_234;
    (void)p_manager;

    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager)
{
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    OPJ_UINT32 l_code_size, l_remaining_size;
    OPJ_BYTE * l_current_data = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];
    l_code_size = 9 + opj_j2k_get_SPCod_SPCoc_size(p_j2k,
                  p_j2k->m_current_tile_number, 0);
    l_remaining_size = l_code_size;

    if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write COD marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
    }

    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;

    opj_write_bytes(l_current_data, J2K_MS_COD, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_code_size - 2, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_tcp->csty, 1);
    ++l_current_data;

    opj_write_bytes(l_current_data, (OPJ_UINT32)l_tcp->prg, 1);
    ++l_current_data;

    opj_write_bytes(l_current_data, l_tcp->numlayers, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_tcp->mct, 1);
    ++l_current_data;

    l_remaining_size -= 9;

    if (! opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, 0,
                                    l_current_data, &l_remaining_size, p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Error writing COD marker\n");
        return var_263;
    }

    if (l_remaining_size != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error writing COD marker\n");
        return var_263;
    }

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size,
                              p_manager) != l_code_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{

    OPJ_UINT32 i;
    OPJ_UINT32 l_tmp;
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    opj_image_t *l_image = 0;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_image = p_j2k->m_private_image;
    l_cp = &(p_j2k->m_cp);


    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
            &l_cp->tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;


    if (l_tcp->cod) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "COD marker already read. No more than one COD marker per tile.\n");
        return var_263;
    }
    l_tcp->cod = 1;


    if (var_234 < 5) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading COD marker\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, &l_tcp->csty, 1);
    ++p_header_data;

    if ((l_tcp->csty & ~(OPJ_UINT32)(J2K_CP_CSTY_PRT | J2K_CP_CSTY_SOP |
                                     J2K_CP_CSTY_EPH)) != 0U) {
        opj_event_msg(p_manager, EVT_ERROR, "Unknown Scod value in COD marker\n");
        return var_263;
    }
    opj_read_bytes(p_header_data, &l_tmp, 1);
    ++p_header_data;
    l_tcp->prg = (OPJ_PROG_ORDER) l_tmp;

    if (l_tcp->prg > OPJ_CPRL) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Unknown progression order in COD marker\n");
        l_tcp->prg = OPJ_PROG_UNKNOWN;
    }
    opj_read_bytes(p_header_data, &l_tcp->numlayers, 2);
    p_header_data += 2;

    if ((l_tcp->numlayers < 1U) || (l_tcp->numlayers > 65535U)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Invalid number of layers in COD marker : %d not in range [1-65535]\n",
                      l_tcp->numlayers);
        return var_263;
    }


    if (l_cp->m_specific_param.m_dec.m_layer) {
        l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;
    } else {
        l_tcp->num_layers_to_decode = l_tcp->numlayers;
    }

    opj_read_bytes(p_header_data, &l_tcp->mct, 1);
    ++p_header_data;

    var_234 -= 5;
    for (i = 0; i < l_image->numcomps; ++i) {
        l_tcp->tccps[i].csty = l_tcp->csty & J2K_CCP_CSTY_PRT;
    }

    if (! opj_j2k_read_SPCod_SPCoc(p_j2k, 0, p_header_data, &var_234,
                                   p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading COD marker\n");
        return var_263;
    }

    if (var_234 != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading COD marker\n");
        return var_263;
    }


    opj_j2k_copy_tile_component_parameters(p_j2k);

    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                  OPJ_UINT32 var_234,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 l_coc_size, l_remaining_size;
    OPJ_UINT32 l_comp_room;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_comp_room = (p_j2k->m_private_image->numcomps <= 256) ? 1 : 2;

    l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,
                 p_j2k->m_current_tile_number, var_234);

    if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data;





        new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                   p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write COC marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;
    }

    opj_j2k_write_coc_in_memory(p_j2k, var_234,
                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &l_remaining_size,
                                p_manager);

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size,
                              p_manager) != l_coc_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_177(opj_j2k_t *p_j2k,
                                    OPJ_UINT32 var_234, OPJ_UINT32 var_234)
{
    opj_cp_t *l_cp = NULL;
    opj_tcp_t *l_tcp = NULL;


    assert(p_j2k != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];

    if (l_tcp->tccps[var_234].csty != l_tcp->tccps[var_234].csty) {
        return var_263;
    }


    return opj_j2k_compare_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number,
                                       var_234, var_234);
}

static void fn_177(opj_j2k_t *p_j2k,
                                        OPJ_UINT32 var_234,
                                        OPJ_BYTE * p_data,
                                        OPJ_UINT32 * p_data_written,
                                        opj_event_mgr_t * p_manager
                                       )
{
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    OPJ_UINT32 l_coc_size, l_remaining_size;
    OPJ_BYTE * l_current_data = 0;
    opj_image_t *l_image = 0;
    OPJ_UINT32 l_comp_room;


    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];
    l_image = p_j2k->m_private_image;
    l_comp_room = (l_image->numcomps <= 256) ? 1 : 2;

    l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,
                 p_j2k->m_current_tile_number, var_234);
    l_remaining_size = l_coc_size;

    l_current_data = p_data;

    opj_write_bytes(l_current_data, J2K_MS_COC,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_coc_size - 2,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, var_234, l_comp_room);
    l_current_data += l_comp_room;

    opj_write_bytes(l_current_data, l_tcp->tccps[var_234].csty,
                    1);
    ++l_current_data;

    l_remaining_size -= (5 + l_comp_room);
    opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, 0,
                              l_current_data, &l_remaining_size, p_manager);
    * p_data_written = l_coc_size;
}

static OPJ_UINT32 fn_177(opj_j2k_t *p_j2k)
{
    OPJ_UINT32 i, j;
    OPJ_UINT32 l_nb_comp;
    OPJ_UINT32 var_258;
    OPJ_UINT32 var_180 = 0;



    var_258 = p_j2k->m_cp.tw * p_j2k->m_cp.th ;
    l_nb_comp = p_j2k->m_private_image->numcomps;

    for (i = 0; i < var_258; ++i) {
        for (j = 0; j < l_nb_comp; ++j) {
            var_180 = opj_uint_max(var_180, opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j));
        }
    }

    return 6 + var_180;
}

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    opj_cp_t *l_cp = NULL;
    opj_tcp_t *l_tcp = NULL;
    opj_image_t *l_image = NULL;
    OPJ_UINT32 l_comp_room;
    OPJ_UINT32 l_comp_no;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)
            ?
            &l_cp->tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;
    l_image = p_j2k->m_private_image;

    l_comp_room = l_image->numcomps <= 256 ? 1 : 2;


    if (var_234 < l_comp_room + 1) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading COC marker\n");
        return var_263;
    }
    var_234 -= l_comp_room + 1;

    opj_read_bytes(p_header_data, &l_comp_no,
                   l_comp_room);
    p_header_data += l_comp_room;
    if (l_comp_no >= l_image->numcomps) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error reading COC marker (bad number of components)\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, &l_tcp->tccps[l_comp_no].csty,
                   1);
    ++p_header_data ;

    if (! opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, &var_234,
                                   p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading COC marker\n");
        return var_263;
    }

    if (var_234 != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading COC marker\n");
        return var_263;
    }
    return var_263;
}

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    OPJ_UINT32 l_qcd_size, l_remaining_size;
    OPJ_BYTE * l_current_data = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_qcd_size = 4 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,
                 0);
    l_remaining_size = l_qcd_size;

    if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write QCD marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
    }

    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;

    opj_write_bytes(l_current_data, J2K_MS_QCD, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_qcd_size - 2, 2);
    l_current_data += 2;

    l_remaining_size -= 4;

    if (! opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, 0,
                                  l_current_data, &l_remaining_size, p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Error writing QCD marker\n");
        return var_263;
    }

    if (l_remaining_size != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error writing QCD marker\n");
        return var_263;
    }

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size,
                              p_manager) != l_qcd_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{

    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (! opj_j2k_read_SQcd_SQcc(p_j2k, 0, p_header_data, &var_234,
                                 p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading QCD marker\n");
        return var_263;
    }

    if (var_234 != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading QCD marker\n");
        return var_263;
    }


    opj_j2k_copy_tile_quantization_parameters(p_j2k);

    return var_263;
}

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                  OPJ_UINT32 var_234,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    OPJ_UINT32 l_qcc_size, l_remaining_size;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_qcc_size = 5 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,
                 var_234);
    l_qcc_size += p_j2k->m_private_image->numcomps <= 256 ? 0 : 1;
    l_remaining_size = l_qcc_size;

    if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write QCC marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;
    }

    opj_j2k_write_qcc_in_memory(p_j2k, var_234,
                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &l_remaining_size,
                                p_manager);

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size,
                              p_manager) != l_qcc_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                    OPJ_UINT32 var_234, OPJ_UINT32 var_234)
{
    return opj_j2k_compare_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number,
                                     var_234, var_234);
}

static void fn_178(opj_j2k_t *p_j2k,
                                        OPJ_UINT32 var_234,
                                        OPJ_BYTE * p_data,
                                        OPJ_UINT32 * p_data_written,
                                        opj_event_mgr_t * p_manager
                                       )
{
    OPJ_UINT32 l_qcc_size, l_remaining_size;
    OPJ_BYTE * l_current_data = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_qcc_size = 6 + opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number,
                 var_234);
    l_remaining_size = l_qcc_size;

    l_current_data = p_data;

    opj_write_bytes(l_current_data, J2K_MS_QCC, 2);
    l_current_data += 2;

    if (p_j2k->m_private_image->numcomps <= 256) {
        --l_qcc_size;

        opj_write_bytes(l_current_data, l_qcc_size - 2, 2);
        l_current_data += 2;

        opj_write_bytes(l_current_data, var_234, 1);
        ++l_current_data;


        l_remaining_size -= 6;
    } else {
        opj_write_bytes(l_current_data, l_qcc_size - 2, 2);
        l_current_data += 2;

        opj_write_bytes(l_current_data, var_234, 2);
        l_current_data += 2;

        l_remaining_size -= 6;
    }

    opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, var_234,
                            l_current_data, &l_remaining_size, p_manager);

    *p_data_written = l_qcc_size;
}

static OPJ_UINT32 fn_178(opj_j2k_t *p_j2k)
{
    return opj_j2k_get_max_coc_size(p_j2k);
}

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 l_num_comp, l_comp_no;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_num_comp = p_j2k->m_private_image->numcomps;

    if (l_num_comp <= 256) {
        if (var_234 < 1) {
            opj_event_msg(p_manager, EVT_ERROR, "Error reading QCC marker\n");
            return var_263;
        }
        opj_read_bytes(p_header_data, &l_comp_no, 1);
        ++p_header_data;
        --var_234;
    } else {
        if (var_234 < 2) {
            opj_event_msg(p_manager, EVT_ERROR, "Error reading QCC marker\n");
            return var_263;
        }
        opj_read_bytes(p_header_data, &l_comp_no, 2);
        p_header_data += 2;
        var_234 -= 2;
    }

    if (l_comp_no >= p_j2k->m_private_image->numcomps) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Invalid component number: %d, regarding the number of components %d\n",
                      l_comp_no, p_j2k->m_private_image->numcomps);
        return var_263;
    }

    if (! opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, &var_234,
                                 p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading QCC marker\n");
        return var_263;
    }

    if (var_234 != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading QCC marker\n");
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_178(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    OPJ_UINT32 l_nb_comp;
    OPJ_UINT32 l_nb_poc;
    OPJ_UINT32 l_poc_size;
    OPJ_UINT32 var_179 = 0;
    opj_tcp_t *l_tcp = 0;
    OPJ_UINT32 l_poc_room;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];
    l_nb_comp = p_j2k->m_private_image->numcomps;
    l_nb_poc = 1 + l_tcp->numpocs;

    if (l_nb_comp <= 256) {
        l_poc_room = 1;
    } else {
        l_poc_room = 2;
    }
    l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;

    if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write POC marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
    }

    opj_j2k_write_poc_in_memory(p_j2k,
                                p_j2k->m_specific_param.m_encoder.m_header_tile_data, &var_179,
                                p_manager);

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size,
                              p_manager) != l_poc_size) {
        return var_263;
    }

    return var_263;
}

static void fn_179(opj_j2k_t *p_j2k,
                                        OPJ_BYTE * p_data,
                                        OPJ_UINT32 * p_data_written,
                                        opj_event_mgr_t * p_manager
                                       )
{
    OPJ_UINT32 i;
    OPJ_BYTE * l_current_data = 0;
    OPJ_UINT32 l_nb_comp;
    OPJ_UINT32 l_nb_poc;
    OPJ_UINT32 l_poc_size;
    opj_image_t *l_image = 0;
    opj_tcp_t *l_tcp = 0;
    opj_tccp_t *l_tccp = 0;
    opj_poc_t *l_current_poc = 0;
    OPJ_UINT32 l_poc_room;


    assert(p_j2k != 0);
    assert(p_manager != 0);

    (void)p_manager;

    l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];
    l_tccp = &l_tcp->tccps[0];
    l_image = p_j2k->m_private_image;
    l_nb_comp = l_image->numcomps;
    l_nb_poc = 1 + l_tcp->numpocs;

    if (l_nb_comp <= 256) {
        l_poc_room = 1;
    } else {
        l_poc_room = 2;
    }

    l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;

    l_current_data = p_data;

    opj_write_bytes(l_current_data, J2K_MS_POC,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_poc_size - 2,
                    2);
    l_current_data += 2;

    l_current_poc = l_tcp->pocs;
    for (i = 0; i < l_nb_poc; ++i) {
        opj_write_bytes(l_current_data, l_current_poc->resno0,
                        1);
        ++l_current_data;

        opj_write_bytes(l_current_data, l_current_poc->compno0,
                        l_poc_room);
        l_current_data += l_poc_room;

        opj_write_bytes(l_current_data, l_current_poc->layno1,
                        2);
        l_current_data += 2;

        opj_write_bytes(l_current_data, l_current_poc->resno1,
                        1);
        ++l_current_data;

        opj_write_bytes(l_current_data, l_current_poc->compno1,
                        l_poc_room);
        l_current_data += l_poc_room;

        opj_write_bytes(l_current_data, (OPJ_UINT32)l_current_poc->prg,
                        1);
        ++l_current_data;


        l_current_poc->layno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)
                                l_current_poc->layno1, (OPJ_INT32)l_tcp->numlayers);
        l_current_poc->resno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)
                                l_current_poc->resno1, (OPJ_INT32)l_tccp->numresolutions);
        l_current_poc->compno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)
                                 l_current_poc->compno1, (OPJ_INT32)l_nb_comp);

        ++l_current_poc;
    }

    *p_data_written = l_poc_size;
}

static OPJ_UINT32 fn_179(opj_j2k_t *p_j2k)
{
    opj_tcp_t * l_tcp = 0;
    OPJ_UINT32 var_258 = 0;
    OPJ_UINT32 var_180 = 0;
    OPJ_UINT32 i;

    l_tcp = p_j2k->m_cp.tcps;
    var_258 = p_j2k->m_cp.th * p_j2k->m_cp.tw;

    for (i = 0; i < var_258; ++i) {
        var_180 = opj_uint_max(var_180, l_tcp->numpocs);
        ++l_tcp;
    }

    ++var_180;

    return 4 + 9 * var_180;
}

static OPJ_UINT32 fn_180(opj_j2k_t *p_j2k)
{
    OPJ_UINT32 i;
    OPJ_UINT32 var_258;
    OPJ_UINT32 var_180 = 0;
    opj_tcp_t * l_tcp = 0;

    l_tcp = p_j2k->m_cp.tcps;
    var_258 = p_j2k->m_cp.tw * p_j2k->m_cp.th ;

    for (i = 0; i < var_258; ++i) {
        var_180 = opj_uint_max(var_180, l_tcp->m_nb_tile_parts);

        ++l_tcp;
    }

    return 12 * var_180;
}

static OPJ_UINT32 fn_180(opj_j2k_t *p_j2k)
{
    OPJ_UINT32 var_181 = 0;
    OPJ_UINT32 l_nb_comps;
    OPJ_UINT32 l_coc_bytes, l_qcc_bytes;

    l_nb_comps = p_j2k->m_private_image->numcomps - 1;
    var_181 += opj_j2k_get_max_toc_size(p_j2k);

    if (!(OPJ_IS_CINEMA(p_j2k->m_cp.rsiz))) {
        l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
        var_181 += l_nb_comps * l_coc_bytes;

        l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
        var_181 += l_nb_comps * l_qcc_bytes;
    }

    var_181 += opj_j2k_get_max_poc_size(p_j2k);



    return var_181;
}

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 i, l_nb_comp, l_tmp;
    opj_image_t * l_image = 0;
    OPJ_UINT32 l_old_poc_nb, l_current_poc_nb, l_current_poc_remaining;
    OPJ_UINT32 l_chunk_size, l_comp_room;

    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    opj_poc_t *l_current_poc = 0;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_image = p_j2k->m_private_image;
    l_nb_comp = l_image->numcomps;
    if (l_nb_comp <= 256) {
        l_comp_room = 1;
    } else {
        l_comp_room = 2;
    }
    l_chunk_size = 5 + 2 * l_comp_room;
    l_current_poc_nb = var_234 / l_chunk_size;
    l_current_poc_remaining = var_234 % l_chunk_size;

    if ((l_current_poc_nb <= 0) || (l_current_poc_remaining != 0)) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading POC marker\n");
        return var_263;
    }

    l_cp = &(p_j2k->m_cp);
    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
            &l_cp->tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;
    l_old_poc_nb = l_tcp->POC ? l_tcp->numpocs + 1 : 0;
    l_current_poc_nb += l_old_poc_nb;

    if (l_current_poc_nb >= 32) {
        opj_event_msg(p_manager, EVT_ERROR, "Too many POCs %d\n", l_current_poc_nb);
        return var_263;
    }
    assert(l_current_poc_nb < 32);


    l_tcp->POC = 1;

    l_current_poc = &l_tcp->pocs[l_old_poc_nb];
    for (i = l_old_poc_nb; i < l_current_poc_nb; ++i) {
        opj_read_bytes(p_header_data, &(l_current_poc->resno0),
                       1);
        ++p_header_data;
        opj_read_bytes(p_header_data, &(l_current_poc->compno0),
                       l_comp_room);
        p_header_data += l_comp_room;
        opj_read_bytes(p_header_data, &(l_current_poc->layno1),
                       2);

        l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);
        p_header_data += 2;
        opj_read_bytes(p_header_data, &(l_current_poc->resno1),
                       1);
        ++p_header_data;
        opj_read_bytes(p_header_data, &(l_current_poc->compno1),
                       l_comp_room);
        p_header_data += l_comp_room;
        opj_read_bytes(p_header_data, &l_tmp,
                       1);
        ++p_header_data;
        l_current_poc->prg = (OPJ_PROG_ORDER) l_tmp;

        l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);
        ++l_current_poc;
    }

    l_tcp->numpocs = l_current_poc_nb - 1;
    return var_263;
}

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 l_nb_comp;

    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    (void)p_header_data;

    l_nb_comp = p_j2k->m_private_image->numcomps;

    if (var_234 != l_nb_comp * 4) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading CRG marker\n");
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 l_Ztlm, l_Stlm, l_ST, l_SP, l_tot_num_tp_remaining, l_quotient,
               l_Ptlm_size;

    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    (void)p_j2k;

    if (var_234 < 2) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading TLM marker\n");
        return var_263;
    }
    var_234 -= 2;

    opj_read_bytes(p_header_data, &l_Ztlm,
                   1);
    ++p_header_data;
    opj_read_bytes(p_header_data, &l_Stlm,
                   1);
    ++p_header_data;

    l_ST = ((l_Stlm >> 4) & 0x3);
    l_SP = (l_Stlm >> 6) & 0x1;

    l_Ptlm_size = (l_SP + 1) * 2;
    l_quotient = l_Ptlm_size + l_ST;

    l_tot_num_tp_remaining = var_234 % l_quotient;

    if (l_tot_num_tp_remaining != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading TLM marker\n");
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{

    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    (void)p_j2k;
    (void)p_header_data;

    if (var_234 < 1) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading PLM marker\n");
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_181(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 l_Zplt, l_tmp, var_182 = 0, i;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    (void)p_j2k;

    if (var_234 < 1) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading PLT marker\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, &l_Zplt, 1);
    ++p_header_data;
    --var_234;

    for (i = 0; i < var_234; ++i) {
        opj_read_bytes(p_header_data, &l_tmp, 1);
        ++p_header_data;

        var_182 |= (l_tmp & 0x7f);
        if (l_tmp & 0x80) {
            var_182 <<= 7;
        } else {

            var_182 = 0;
        }
    }

    if (var_182 != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading PLT marker\n");
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_182(
    opj_j2k_t *p_j2k,
    OPJ_BYTE * p_header_data,
    OPJ_UINT32 var_234,
    opj_event_mgr_t * p_manager)
{
    opj_cp_t *l_cp = 0;
    OPJ_UINT32 l_Z_ppm;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);


    if (var_234 < 2) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading PPM marker\n");
        return var_263;
    }

    l_cp = &(p_j2k->m_cp);
    l_cp->ppm = 1;

    opj_read_bytes(p_header_data, &l_Z_ppm, 1);
    ++p_header_data;
    --var_234;


    if (l_cp->ppm_markers == NULL) {
        OPJ_UINT32 var_184 = l_Z_ppm + 1U;
        assert(l_cp->ppm_markers_count == 0U);

        l_cp->ppm_markers = (opj_ppx *) opj_calloc(var_184, sizeof(opj_ppx));
        if (l_cp->ppm_markers == NULL) {
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPM marker\n");
            return var_263;
        }
        l_cp->ppm_markers_count = var_184;
    } else if (l_cp->ppm_markers_count <= l_Z_ppm) {
        OPJ_UINT32 var_184 = l_Z_ppm + 1U;
        opj_ppx *new_ppm_markers;
        new_ppm_markers = (opj_ppx *) opj_realloc(l_cp->ppm_markers,
                          var_184 * sizeof(opj_ppx));
        if (new_ppm_markers == NULL) {

            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPM marker\n");
            return var_263;
        }
        l_cp->ppm_markers = new_ppm_markers;
        memset(l_cp->ppm_markers + l_cp->ppm_markers_count, 0,
               (var_184 - l_cp->ppm_markers_count) * sizeof(opj_ppx));
        l_cp->ppm_markers_count = var_184;
    }

    if (l_cp->ppm_markers[l_Z_ppm].m_data != NULL) {

        opj_event_msg(p_manager, EVT_ERROR, "Zppm %u already read\n", l_Z_ppm);
        return var_263;
    }

    l_cp->ppm_markers[l_Z_ppm].m_data = (OPJ_BYTE *) opj_malloc(var_234);
    if (l_cp->ppm_markers[l_Z_ppm].m_data == NULL) {

        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPM marker\n");
        return var_263;
    }
    l_cp->ppm_markers[l_Z_ppm].m_data_size = var_234;
    memcpy(l_cp->ppm_markers[l_Z_ppm].m_data, p_header_data, var_234);

    return var_263;
}







static OPJ_BOOL fn_183(opj_cp_t *p_cp, opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 i, l_ppm_data_size, l_N_ppm_remaining;


    assert(p_cp != 0);
    assert(p_manager != 0);
    assert(p_cp->ppm_buffer == NULL);

    if (p_cp->ppm == 0U) {
        return var_263;
    }

    l_ppm_data_size = 0U;
    l_N_ppm_remaining = 0U;
    for (i = 0U; i < p_cp->ppm_markers_count; ++i) {
        if (p_cp->ppm_markers[i].m_data !=
                NULL) {
            OPJ_UINT32 l_N_ppm;
            OPJ_UINT32 var_248 = p_cp->ppm_markers[i].m_data_size;
            const OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;

            if (l_N_ppm_remaining >= var_248) {
                l_N_ppm_remaining -= var_248;
                var_248 = 0U;
            } else {
                l_data += l_N_ppm_remaining;
                var_248 -= l_N_ppm_remaining;
                l_N_ppm_remaining = 0U;
            }

            if (var_248 > 0U) {
                do {

                    if (var_248 < 4U) {

                        opj_event_msg(p_manager, EVT_ERROR, "Not enough bytes to read Nppm\n");
                        return var_263;
                    }
                    opj_read_bytes(l_data, &l_N_ppm, 4);
                    l_data += 4;
                    var_248 -= 4;
                    l_ppm_data_size +=
                        l_N_ppm;

                    if (var_248 >= l_N_ppm) {
                        var_248 -= l_N_ppm;
                        l_data += l_N_ppm;
                    } else {
                        l_N_ppm_remaining = l_N_ppm - var_248;
                        var_248 = 0U;
                    }
                } while (var_248 > 0U);
            }
        }
    }

    if (l_N_ppm_remaining != 0U) {

        opj_event_msg(p_manager, EVT_ERROR, "Corrupted PPM markers\n");
        return var_263;
    }

    p_cp->ppm_buffer = (OPJ_BYTE *) opj_malloc(l_ppm_data_size);
    if (p_cp->ppm_buffer == 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPM marker\n");
        return var_263;
    }
    p_cp->ppm_len = l_ppm_data_size;
    l_ppm_data_size = 0U;
    l_N_ppm_remaining = 0U;
    for (i = 0U; i < p_cp->ppm_markers_count; ++i) {
        if (p_cp->ppm_markers[i].m_data !=
                NULL) {
            OPJ_UINT32 l_N_ppm;
            OPJ_UINT32 var_248 = p_cp->ppm_markers[i].m_data_size;
            const OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;

            if (l_N_ppm_remaining >= var_248) {
                memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, var_248);
                l_ppm_data_size += var_248;
                l_N_ppm_remaining -= var_248;
                var_248 = 0U;
            } else {
                memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm_remaining);
                l_ppm_data_size += l_N_ppm_remaining;
                l_data += l_N_ppm_remaining;
                var_248 -= l_N_ppm_remaining;
                l_N_ppm_remaining = 0U;
            }

            if (var_248 > 0U) {
                do {

                    if (var_248 < 4U) {

                        opj_event_msg(p_manager, EVT_ERROR, "Not enough bytes to read Nppm\n");
                        return var_263;
                    }
                    opj_read_bytes(l_data, &l_N_ppm, 4);
                    l_data += 4;
                    var_248 -= 4;

                    if (var_248 >= l_N_ppm) {
                        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm);
                        l_ppm_data_size += l_N_ppm;
                        var_248 -= l_N_ppm;
                        l_data += l_N_ppm;
                    } else {
                        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, var_248);
                        l_ppm_data_size += var_248;
                        l_N_ppm_remaining = l_N_ppm - var_248;
                        var_248 = 0U;
                    }
                } while (var_248 > 0U);
            }
            opj_free(p_cp->ppm_markers[i].m_data);
            p_cp->ppm_markers[i].m_data = NULL;
            p_cp->ppm_markers[i].m_data_size = 0U;
        }
    }

    p_cp->ppm_data = p_cp->ppm_buffer;
    p_cp->ppm_data_size = p_cp->ppm_len;

    p_cp->ppm_markers_count = 0U;
    opj_free(p_cp->ppm_markers);
    p_cp->ppm_markers = NULL;

    return var_263;
}

static OPJ_BOOL fn_184(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    OPJ_UINT32 l_Z_ppt;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);


    if (var_234 < 2) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading PPT marker\n");
        return var_263;
    }

    l_cp = &(p_j2k->m_cp);
    if (l_cp->ppm) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n");
        return var_263;
    }

    l_tcp = &(l_cp->tcps[p_j2k->m_current_tile_number]);
    l_tcp->ppt = 1;

    opj_read_bytes(p_header_data, &l_Z_ppt, 1);
    ++p_header_data;
    --var_234;


    if (l_tcp->ppt_markers == NULL) {
        OPJ_UINT32 var_184 = l_Z_ppt + 1U;
        assert(l_tcp->ppt_markers_count == 0U);

        l_tcp->ppt_markers = (opj_ppx *) opj_calloc(var_184, sizeof(opj_ppx));
        if (l_tcp->ppt_markers == NULL) {
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPT marker\n");
            return var_263;
        }
        l_tcp->ppt_markers_count = var_184;
    } else if (l_tcp->ppt_markers_count <= l_Z_ppt) {
        OPJ_UINT32 var_184 = l_Z_ppt + 1U;
        opj_ppx *new_ppt_markers;
        new_ppt_markers = (opj_ppx *) opj_realloc(l_tcp->ppt_markers,
                          var_184 * sizeof(opj_ppx));
        if (new_ppt_markers == NULL) {

            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPT marker\n");
            return var_263;
        }
        l_tcp->ppt_markers = new_ppt_markers;
        memset(l_tcp->ppt_markers + l_tcp->ppt_markers_count, 0,
               (var_184 - l_tcp->ppt_markers_count) * sizeof(opj_ppx));
        l_tcp->ppt_markers_count = var_184;
    }

    if (l_tcp->ppt_markers[l_Z_ppt].m_data != NULL) {

        opj_event_msg(p_manager, EVT_ERROR, "Zppt %u already read\n", l_Z_ppt);
        return var_263;
    }

    l_tcp->ppt_markers[l_Z_ppt].m_data = (OPJ_BYTE *) opj_malloc(var_234);
    if (l_tcp->ppt_markers[l_Z_ppt].m_data == NULL) {

        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPT marker\n");
        return var_263;
    }
    l_tcp->ppt_markers[l_Z_ppt].m_data_size = var_234;
    memcpy(l_tcp->ppt_markers[l_Z_ppt].m_data, p_header_data, var_234);
    return var_263;
}







static OPJ_BOOL fn_184(opj_tcp_t *p_tcp, opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 i, l_ppt_data_size;

    assert(p_tcp != 0);
    assert(p_manager != 0);
    assert(p_tcp->ppt_buffer == NULL);

    if (p_tcp->ppt == 0U) {
        return var_263;
    }

    l_ppt_data_size = 0U;
    for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {
        l_ppt_data_size +=
            p_tcp->ppt_markers[i].m_data_size;
    }

    p_tcp->ppt_buffer = (OPJ_BYTE *) opj_malloc(l_ppt_data_size);
    if (p_tcp->ppt_buffer == 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPT marker\n");
        return var_263;
    }
    p_tcp->ppt_len = l_ppt_data_size;
    l_ppt_data_size = 0U;
    for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {
        if (p_tcp->ppt_markers[i].m_data !=
                NULL) {
            memcpy(p_tcp->ppt_buffer + l_ppt_data_size, p_tcp->ppt_markers[i].m_data,
                   p_tcp->ppt_markers[i].m_data_size);
            l_ppt_data_size +=
                p_tcp->ppt_markers[i].m_data_size;

            opj_free(p_tcp->ppt_markers[i].m_data);
            p_tcp->ppt_markers[i].m_data = NULL;
            p_tcp->ppt_markers[i].m_data_size = 0U;
        }
    }

    p_tcp->ppt_markers_count = 0U;
    opj_free(p_tcp->ppt_markers);
    p_tcp->ppt_markers = NULL;

    p_tcp->ppt_data = p_tcp->ppt_buffer;
    p_tcp->ppt_data_size = p_tcp->ppt_len;
    return var_263;
}

static OPJ_BOOL fn_184(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    OPJ_BYTE * l_current_data = 0;
    OPJ_UINT32 l_tlm_size;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_tlm_size = 6 + (5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts);

    if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write TLM marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
    }

    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;



    p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);

    opj_write_bytes(l_current_data, J2K_MS_TLM,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_tlm_size - 2,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, 0,
                    1);
    ++l_current_data;

    opj_write_bytes(l_current_data, 0x50,
                    1);
    ++l_current_data;


    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size,
                              p_manager) != l_tlm_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_184(opj_j2k_t *p_j2k,
                                  OPJ_BYTE * p_data,
                                  OPJ_UINT32 * p_data_written,
                                  const opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{

    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    (void)p_stream;
    (void)p_manager;

    opj_write_bytes(p_data, var_228,
                    2);
    p_data += 2;

    opj_write_bytes(p_data, 10,
                    2);
    p_data += 2;

    opj_write_bytes(p_data, p_j2k->m_current_tile_number,
                    2);
    p_data += 2;


    p_data += 4;

    opj_write_bytes(p_data,
                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
                    1);
    ++p_data;

    opj_write_bytes(p_data,
                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,
                    1);
    ++p_data;

    * p_data_written = 12;

    return var_263;
}

static OPJ_BOOL fn_184(OPJ_BYTE * p_header_data,
                                       OPJ_UINT32 var_234,
                                       OPJ_UINT32* var_234,
                                       OPJ_UINT32* p_tot_len,
                                       OPJ_UINT32* p_current_part,
                                       OPJ_UINT32* p_num_parts,
                                       opj_event_mgr_t * p_manager)
{

    assert(p_header_data != 0);
    assert(p_manager != 0);


    if (var_234 != 8) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading SOT marker\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, var_234, 2);
    p_header_data += 2;
    opj_read_bytes(p_header_data, p_tot_len, 4);
    p_header_data += 4;
    opj_read_bytes(p_header_data, p_current_part, 1);
    ++p_header_data;
    opj_read_bytes(p_header_data, p_num_parts, 1);
    ++p_header_data;
    return var_263;
}

static OPJ_BOOL fn_184(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager)
{
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    OPJ_UINT32 l_tot_len, var_224 = 0;
    OPJ_UINT32 l_current_part;
    OPJ_UINT32 l_tile_x, l_tile_y;



    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (! opj_j2k_get_sot_values(p_header_data, var_234,
                                 &(p_j2k->m_current_tile_number), &l_tot_len, &l_current_part, &var_224,
                                 p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading SOT marker\n");
        return var_263;
    }

    l_cp = &(p_j2k->m_cp);


    if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {
        opj_event_msg(p_manager, EVT_ERROR, "Invalid tile number %d\n",
                      p_j2k->m_current_tile_number);
        return var_263;
    }

    l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];
    l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;
    l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;

    if (l_tcp->m_current_tile_part_number + 1 != (OPJ_INT32)l_current_part) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Invalid tile part index for tile number %d. "
                      "Got %d, expected %d\n",
                      p_j2k->m_current_tile_number,
                      l_current_part,
                      l_tcp->m_current_tile_part_number + 1);
        return var_263;
    }
    ++ l_tcp->m_current_tile_part_number;

    if ((l_tot_len != 0) && (l_tot_len < 14)) {
        if (l_tot_len ==
                12) {
            opj_event_msg(p_manager, EVT_WARNING, "Empty SOT marker detected: Psot=%d.\n",
                          l_tot_len);
        } else {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Psot value is not correct regards to the JPEG2000 norm: %d.\n", l_tot_len);
            return var_263;
        }
    }

    if (!l_tot_len) {
        opj_event_msg(p_manager, EVT_INFO,
                      "Psot value of the current tile-part is equal to zero, "
                      "we assuming it is the last tile-part of the codestream.\n");
        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
    }

    if (l_tcp->m_nb_tile_parts != 0 && l_current_part >= l_tcp->m_nb_tile_parts) {

        opj_event_msg(p_manager, EVT_ERROR,
                      "In SOT marker, TPSot (%d) is not valid regards to the previous "
                      "number of tile-part (%d), giving up\n", l_current_part,
                      l_tcp->m_nb_tile_parts);
        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
        return var_263;
    }

    if (var_224 !=
            0) {
        var_224 += p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction;


        if (l_tcp->m_nb_tile_parts) {
            if (l_current_part >= l_tcp->m_nb_tile_parts) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "In SOT marker, TPSot (%d) is not valid regards to the current "
                              "number of tile-part (%d), giving up\n", l_current_part,
                              l_tcp->m_nb_tile_parts);
                p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
                return var_263;
            }
        }
        if (l_current_part >= var_224) {

            opj_event_msg(p_manager, EVT_ERROR,
                          "In SOT marker, TPSot (%d) is not valid regards to the current "
                          "number of tile-part (header) (%d), giving up\n", l_current_part, var_224);
            p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
            return var_263;
        }
        l_tcp->m_nb_tile_parts = var_224;
    }


    if (l_tcp->m_nb_tile_parts) {
        if (l_tcp->m_nb_tile_parts == (l_current_part + 1)) {
            p_j2k->m_specific_param.m_decoder.m_can_decode =
                1;
        }
    }

    if (!p_j2k->m_specific_param.m_decoder.m_last_tile_part) {

        p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len -
                12;
    } else {

        p_j2k->m_specific_param.m_decoder.m_sot_length = 0;
    }

    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPH;


    if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
        p_j2k->m_specific_param.m_decoder.m_skip_data =
            (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x)
            || (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x)
            || (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y)
            || (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y);
    } else {
        assert(p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec >= 0);
        p_j2k->m_specific_param.m_decoder.m_skip_data =
            (p_j2k->m_current_tile_number != (OPJ_UINT32)
             p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);
    }


    if (p_j2k->cstr_index) {
        assert(p_j2k->cstr_index->tile_index != 0);
        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tileno =
            p_j2k->m_current_tile_number;
        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno =
            l_current_part;

        if (var_224 != 0) {
            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].nb_tps =
                var_224;
            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps =
                var_224;

            if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {
                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =
                    (opj_tp_index_t*)opj_calloc(var_224, sizeof(opj_tp_index_t));
                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {
                    opj_event_msg(p_manager, EVT_ERROR,
                                  "Not enough memory to read SOT marker. Tile index allocation failed\n");
                    return var_263;
                }
            } else {
                opj_tp_index_t *new_tp_index = (opj_tp_index_t *) opj_realloc(
                                                   p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,
                                                   var_224 * sizeof(opj_tp_index_t));
                if (! new_tp_index) {
                    opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);
                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;
                    opj_event_msg(p_manager, EVT_ERROR,
                                  "Not enough memory to read SOT marker. Tile index allocation failed\n");
                    return var_263;
                }
                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =
                    new_tp_index;
            }
        } else {
                                                                                           {

                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {
                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 10;
                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =
                        (opj_tp_index_t*)opj_calloc(
                            p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps,
                            sizeof(opj_tp_index_t));
                    if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {
                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;
                        opj_event_msg(p_manager, EVT_ERROR,
                                      "Not enough memory to read SOT marker. Tile index allocation failed\n");
                        return var_263;
                    }
                }

                if (l_current_part >=
                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps) {
                    opj_tp_index_t *new_tp_index;
                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps =
                        l_current_part + 1;
                    new_tp_index = (opj_tp_index_t *) opj_realloc(
                                       p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,
                                       p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps *
                                       sizeof(opj_tp_index_t));
                    if (! new_tp_index) {
                        opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);
                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;
                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;
                        opj_event_msg(p_manager, EVT_ERROR,
                                      "Not enough memory to read SOT marker. Tile index allocation failed\n");
                        return var_263;
                    }
                    p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =
                        new_tp_index;
                }
            }

        }

    }

    return var_263;
}

static OPJ_BOOL fn_185(opj_j2k_t *p_j2k,
                                  opj_tcd_t * p_tile_coder,
                                  OPJ_BYTE * p_data,
                                  OPJ_UINT32 * p_data_written,
                                  OPJ_UINT32 var_262,
                                  const opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    opj_codestream_info_t *l_cstr_info = 0;
    OPJ_UINT32 l_remaining_data;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    (void)p_stream;

    opj_write_bytes(p_data, J2K_MS_SOD,
                    2);
    p_data += 2;


    l_remaining_data = var_262 - 4;


    p_tile_coder->tp_num =
        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;
    p_tile_coder->cur_tp_num =
        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;

    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {
        p_tile_coder->tcd_image->tiles->packno = 0;
        if (l_cstr_info) {
            l_cstr_info->packno = 0;
        }
    }

    *p_data_written = 0;

    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,
                              p_data_written, l_remaining_data, l_cstr_info,
                              p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Cannot encode tile\n");
        return var_263;
    }

    *p_data_written += 2;

    return var_263;
}

static OPJ_BOOL fn_185(opj_j2k_t *p_j2k,
                                 opj_stream_private_t *p_stream,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_SIZE_T l_current_read_size;
    opj_codestream_index_t * l_cstr_index = 0;
    OPJ_BYTE ** l_current_data = 0;
    opj_tcp_t * l_tcp = 0;
    OPJ_UINT32 * l_tile_len = 0;
    OPJ_BOOL var_188 = var_263;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);

    if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {




        p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32)(
                    opj_stream_get_number_byte_left(p_stream) - 2);
    } else {

        if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2) {
            p_j2k->m_specific_param.m_decoder.m_sot_length -= 2;
        } else {

        }
    }

    l_current_data = &(l_tcp->m_data);
    l_tile_len = &l_tcp->m_data_size;


    if (p_j2k->m_specific_param.m_decoder.m_sot_length) {


        if ((OPJ_OFF_T)p_j2k->m_specific_param.m_decoder.m_sot_length >
                opj_stream_get_number_byte_left(p_stream)) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Tile part length size inconsistent with stream length\n");
            return var_263;
        }
        if (p_j2k->m_specific_param.m_decoder.m_sot_length >
                UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "p_j2k->m_specific_param.m_decoder.m_sot_length > "
                          "UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA");
            return var_263;
        }



        if (! *l_current_data) {



            *l_current_data = (OPJ_BYTE*) opj_malloc(
                                  p_j2k->m_specific_param.m_decoder.m_sot_length + OPJ_COMMON_CBLK_DATA_EXTRA);
        } else {
            OPJ_BYTE *l_new_current_data;
            if (*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA -
                    p_j2k->m_specific_param.m_decoder.m_sot_length) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA - "
                              "p_j2k->m_specific_param.m_decoder.m_sot_length");
                return var_263;
            }

            l_new_current_data = (OPJ_BYTE *) opj_realloc(*l_current_data,
                                 *l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length +
                                 OPJ_COMMON_CBLK_DATA_EXTRA);
            if (! l_new_current_data) {
                opj_free(*l_current_data);




            }
            *l_current_data = l_new_current_data;
        }

        if (*l_current_data == 0) {
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode tile\n");
            return var_263;
        }
    } else {
        var_188 = var_263;
    }


    l_cstr_index = p_j2k->cstr_index;
    if (l_cstr_index) {
        OPJ_OFF_T var_188 = opj_stream_tell(p_stream) - 2;

        OPJ_UINT32 var_212 =
            l_cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno;
        l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[var_212].end_header
            =
                var_188;
        l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[var_212].end_pos
            =
                var_188 + p_j2k->m_specific_param.m_decoder.m_sot_length + 2;

        if (var_263 == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,
                                              l_cstr_index,
                                              J2K_MS_SOD,
                                              var_188,
                                              p_j2k->m_specific_param.m_decoder.m_sot_length + 2)) {
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add tl marker\n");
            return var_263;
        }


    }


    if (!var_188) {
        l_current_read_size = opj_stream_read_data(
                                  p_stream,
                                  *l_current_data + *l_tile_len,
                                  p_j2k->m_specific_param.m_decoder.m_sot_length,
                                  p_manager);
    } else {
        l_current_read_size = 0;
    }

    if (l_current_read_size != p_j2k->m_specific_param.m_decoder.m_sot_length) {
        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
    } else {
        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;
    }

    *l_tile_len += (OPJ_UINT32)l_current_read_size;

    return var_263;
}

static OPJ_BOOL fn_188(opj_j2k_t *p_j2k,
                                  OPJ_UINT32 var_234,
                                  OPJ_UINT32 var_234,
                                  OPJ_UINT32 var_188,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    OPJ_BYTE * l_current_data = 0;
    OPJ_UINT32 l_rgn_size;
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    opj_tccp_t *l_tccp = 0;
    OPJ_UINT32 l_comp_room;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[var_234];
    l_tccp = &l_tcp->tccps[var_234];

    if (var_188 <= 256) {
        l_comp_room = 1;
    } else {
        l_comp_room = 2;
    }

    l_rgn_size = 6 + l_comp_room;

    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;

    opj_write_bytes(l_current_data, J2K_MS_RGN,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_rgn_size - 2,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, var_234,
                    l_comp_room);
    l_current_data += l_comp_room;

    opj_write_bytes(l_current_data, 0,
                    1);
    ++l_current_data;

    opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,
                    1);
    ++l_current_data;

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_rgn_size,
                              p_manager) != l_rgn_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_188(opj_j2k_t *p_j2k,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{

    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                    J2K_MS_EOC, 2);

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, 2, p_manager) != 2) {
        return var_263;
    }

    if (! opj_stream_flush(p_stream, p_manager)) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_188(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 l_nb_comp;
    opj_image_t * l_image = 0;

    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    OPJ_UINT32 l_comp_room, l_comp_no, l_roi_sty;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_image = p_j2k->m_private_image;
    l_nb_comp = l_image->numcomps;

    if (l_nb_comp <= 256) {
        l_comp_room = 1;
    } else {
        l_comp_room = 2;
    }

    if (var_234 != 2 + l_comp_room) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading RGN marker\n");
        return var_263;
    }

    l_cp = &(p_j2k->m_cp);
    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
            &l_cp->tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;

    opj_read_bytes(p_header_data, &l_comp_no, l_comp_room);
    p_header_data += l_comp_room;
    opj_read_bytes(p_header_data, &l_roi_sty,
                   1);
    ++p_header_data;

    if (l_comp_no >= l_nb_comp) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "bad component number in RGN (%d when there are only %d)\n",
                      l_comp_no, l_nb_comp);
        return var_263;
    }

    opj_read_bytes(p_header_data,
                   (OPJ_UINT32 *)(&(l_tcp->tccps[l_comp_no].roishift)), 1);
    ++p_header_data;

    return var_263;

}

static OPJ_FLOAT32 fn_188(opj_tcp_t * p_tcp)
{
    return (OPJ_FLOAT32)((p_tcp->m_nb_tile_parts - 1) * 14);
}

static OPJ_FLOAT32 fn_188(opj_tcp_t * p_tcp)
{
    (void)p_tcp;
    return 0;
}

static OPJ_BOOL fn_188(opj_j2k_t *p_j2k,
                                     opj_stream_private_t *p_stream,
                                     opj_event_mgr_t * p_manager)
{
    opj_cp_t * l_cp = 0;
    opj_image_t * l_image = 0;
    opj_tcp_t * l_tcp = 0;
    opj_image_comp_t * l_img_comp = 0;

    OPJ_UINT32 i, j, var_260;
    OPJ_INT32 l_x0, l_y0, l_x1, l_y1;
    OPJ_FLOAT32 * l_rates = 0;
    OPJ_FLOAT32 l_sot_remove;
    OPJ_UINT32 l_bits_empty, l_size_pixel;
    OPJ_UINT32 var_261 = 0;
    OPJ_UINT32 l_last_res;
    OPJ_FLOAT32(* l_tp_stride_func)(opj_tcp_t *) = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    (void)p_manager;

    l_cp = &(p_j2k->m_cp);
    l_image = p_j2k->m_private_image;
    l_tcp = l_cp->tcps;

    l_bits_empty = 8 * l_image->comps->dx * l_image->comps->dy;
    l_size_pixel = l_image->numcomps * l_image->comps->prec;
    l_sot_remove = (OPJ_FLOAT32) opj_stream_tell(p_stream) / (OPJ_FLOAT32)(
                       l_cp->th * l_cp->tw);

    if (l_cp->m_specific_param.m_enc.m_tp_on) {
        l_tp_stride_func = opj_j2k_get_tp_stride;
    } else {
        l_tp_stride_func = opj_j2k_get_default_stride;
    }

    for (i = 0; i < l_cp->th; ++i) {
        for (j = 0; j < l_cp->tw; ++j) {
            OPJ_FLOAT32 var_221 = (OPJ_FLOAT32)(*l_tp_stride_func)(l_tcp) /
                                   (OPJ_FLOAT32)l_tcp->numlayers;


            l_x0 = opj_int_max((OPJ_INT32)(l_cp->tx0 + j * l_cp->tdx),
                               (OPJ_INT32)l_image->x0);
            l_y0 = opj_int_max((OPJ_INT32)(l_cp->ty0 + i * l_cp->tdy),
                               (OPJ_INT32)l_image->y0);
            l_x1 = opj_int_min((OPJ_INT32)(l_cp->tx0 + (j + 1) * l_cp->tdx),
                               (OPJ_INT32)l_image->x1);
            l_y1 = opj_int_min((OPJ_INT32)(l_cp->ty0 + (i + 1) * l_cp->tdy),
                               (OPJ_INT32)l_image->y1);

            l_rates = l_tcp->rates;


            if (*l_rates > 0.0f) {
                *l_rates = (((OPJ_FLOAT32)(l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) *
                                           (OPJ_UINT32)(l_y1 - l_y0)))
                            /
                            ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)
                           )
                           -
                           var_221;
            }

            ++l_rates;

            for (var_260 = 1; var_260 < l_tcp->numlayers; ++var_260) {
                if (*l_rates > 0.0f) {
                    *l_rates = (((OPJ_FLOAT32)(l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) *
                                               (OPJ_UINT32)(l_y1 - l_y0)))
                                /
                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)
                               )
                               -
                               var_221;
                }

                ++l_rates;
            }

            ++l_tcp;

        }
    }

    l_tcp = l_cp->tcps;

    for (i = 0; i < l_cp->th; ++i) {
        for (j = 0; j < l_cp->tw; ++j) {
            l_rates = l_tcp->rates;

            if (*l_rates > 0.0f) {
                *l_rates -= l_sot_remove;

                if (*l_rates < 30.0f) {
                    *l_rates = 30.0f;
                }
            }

            ++l_rates;

            l_last_res = l_tcp->numlayers - 1;

            for (var_260 = 1; var_260 < l_last_res; ++var_260) {

                if (*l_rates > 0.0f) {
                    *l_rates -= l_sot_remove;

                    if (*l_rates < * (l_rates - 1) + 10.0f) {
                        *l_rates = (*(l_rates - 1)) + 20.0f;
                    }
                }

                ++l_rates;
            }

            if (*l_rates > 0.0f) {
                *l_rates -= (l_sot_remove + 2.f);

                if (*l_rates < * (l_rates - 1) + 10.0f) {
                    *l_rates = (*(l_rates - 1)) + 20.0f;
                }
            }

            ++l_tcp;
        }
    }

    l_img_comp = l_image->comps;
    var_261 = 0;

    for (i = 0; i < l_image->numcomps; ++i) {
        var_261 += (opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx)
                        *
                        opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy)
                        *
                        l_img_comp->prec
                       );

        ++l_img_comp;
    }

    var_261 = (OPJ_UINT32)(var_261 * 0.1625);

    var_261 += opj_j2k_get_specific_header_sizes(p_j2k);

    p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = var_261;
    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data =
        (OPJ_BYTE *) opj_malloc(p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);
    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == 0) {
        return var_263;
    }

    if (OPJ_IS_CINEMA(l_cp->rsiz)) {
        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer =
            (OPJ_BYTE *) opj_malloc(5 *
                                    p_j2k->m_specific_param.m_encoder.m_total_tile_parts);
        if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
            return var_263;
        }

        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current =
            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
    }

    return var_263;
}

static OPJ_BOOL fn_191(opj_j2k_t *p_j2k,
                                       struct struct_262 *p_stream,
                                       struct struct_262 * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    (void)p_manager;

    p_j2k->cstr_index->main_head_end = opj_stream_tell(p_stream);

    return var_263;
}

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
        struct struct_262 *p_stream,
        struct struct_262 * p_manager)
{
    OPJ_UINT32 i;
    opj_simple_mcc_decorrelation_data_t * l_mcc_record;
    opj_mct_data_t * l_mct_record;
    opj_tcp_t * l_tcp;


    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    if (! opj_j2k_write_cbd(p_j2k, p_stream, p_manager)) {
        return var_263;
    }

    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);
    l_mct_record = l_tcp->m_mct_records;

    for (i = 0; i < l_tcp->m_nb_mct_records; ++i) {

        if (! opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager)) {
            return var_263;
        }

        ++l_mct_record;
    }

    l_mcc_record = l_tcp->m_mcc_records;

    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {

        if (! opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager)) {
            return var_263;
        }

        ++l_mcc_record;
    }

    if (! opj_j2k_write_mco(p_j2k, p_stream, p_manager)) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_192(
    opj_j2k_t *p_j2k,
    struct struct_262 *p_stream,
    struct struct_262 * p_manager)
{
    OPJ_UINT32 var_252;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    for (var_252 = 1; var_252 < p_j2k->m_private_image->numcomps; ++var_252) {

        if (! opj_j2k_compare_coc(p_j2k, 0, var_252)) {
            if (! opj_j2k_write_coc(p_j2k, var_252, p_stream, p_manager)) {
                return var_263;
            }
        }
    }

    return var_263;
}

static OPJ_BOOL fn_192(
    opj_j2k_t *p_j2k,
    struct struct_262 *p_stream,
    struct struct_262 * p_manager)
{
    OPJ_UINT32 var_252;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    for (var_252 = 1; var_252 < p_j2k->m_private_image->numcomps; ++var_252) {

        if (! opj_j2k_compare_qcc(p_j2k, 0, var_252)) {
            if (! opj_j2k_write_qcc(p_j2k, var_252, p_stream, p_manager)) {
                return var_263;
            }
        }
    }
    return var_263;
}

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
                                      struct struct_262 *p_stream,
                                      struct struct_262 * p_manager)
{
    OPJ_UINT32 var_252;
    const opj_tccp_t *l_tccp = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_tccp = p_j2k->m_cp.tcps->tccps;

    for (var_252 = 0; var_252 < p_j2k->m_private_image->numcomps; ++var_252) {
        if (l_tccp->roishift) {

            if (! opj_j2k_write_rgn(p_j2k, 0, var_252, p_j2k->m_private_image->numcomps,
                                    p_stream, p_manager)) {
                return var_263;
            }
        }

        ++l_tccp;
    }

    return var_263;
}

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
                                  struct struct_262 *p_stream,
                                  struct struct_262 * p_manager)
{
    opj_codestream_index_t * l_cstr_index = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    (void)p_manager;

    l_cstr_index = p_j2k->cstr_index;
    if (l_cstr_index) {
        l_cstr_index->codestream_size = (OPJ_UINT64)opj_stream_tell(p_stream);




        l_cstr_index->codestream_size -= (OPJ_UINT64)l_cstr_index->main_head_start;

    }

    return var_263;
}

static OPJ_BOOL fn_192(opj_j2k_t *p_j2k,
                                 opj_stream_private_t *p_stream,
                                 OPJ_UINT32 *output_marker,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 l_unknown_marker;
    const opj_dec_memory_marker_handler_t * l_marker_handler;
    OPJ_UINT32 var_194 = 2;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    opj_event_msg(p_manager, EVT_WARNING, "Unknown marker\n");

    for (;;) {

        if (opj_stream_read_data(p_stream,
                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {
            opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
            return var_263;
        }


        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,
                       &l_unknown_marker, 2);

        if (!(l_unknown_marker < 0xff00)) {


            l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);

            if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "Marker is not compliant with its position\n");
                return var_263;
            } else {
                if (l_marker_handler->id != J2K_MS_UNK) {

                    if (l_marker_handler->id != var_228) {
                        OPJ_BOOL var_194 = opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_UNK,
                                                            (OPJ_UINT32) opj_stream_tell(p_stream) - var_194,
                                                            var_194);
                        if (var_194 == var_263) {
                            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add mh marker\n");
                            return var_263;
                        }
                    }
                    break;
                } else {
                    var_194 += 2;
                }
            }
        }
    }

    *output_marker = l_marker_handler->id ;

    return var_263;
}

static OPJ_BOOL fn_194(opj_j2k_t *p_j2k,
        opj_mct_data_t * p_mct_record,
        struct struct_262 *p_stream,
        struct struct_262 * p_manager)
{
    OPJ_UINT32 l_mct_size;
    OPJ_BYTE * l_current_data = 0;
    OPJ_UINT32 l_tmp;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_mct_size = 10 + p_mct_record->m_data_size;

    if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write MCT marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
    }

    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;

    opj_write_bytes(l_current_data, J2K_MS_MCT,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_mct_size - 2,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, 0,
                    2);
    l_current_data += 2;


    l_tmp = (p_mct_record->m_index & 0xff) | (p_mct_record->m_array_type << 8) |
            (p_mct_record->m_element_type << 10);

    opj_write_bytes(l_current_data, l_tmp, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, 0,
                    2);
    l_current_data += 2;

    memcpy(l_current_data, p_mct_record->m_data, p_mct_record->m_data_size);

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size,
                              p_manager) != l_mct_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_194(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 i;
    opj_tcp_t *l_tcp = 0;
    OPJ_UINT32 l_tmp;
    OPJ_UINT32 var_216;
    opj_mct_data_t * l_mct_data;


    assert(p_header_data != 0);
    assert(p_j2k != 0);

    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?
            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;

    if (var_234 < 2) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCT marker\n");
        return var_263;
    }


    opj_read_bytes(p_header_data, &l_tmp, 2);
    p_header_data += 2;
    if (l_tmp != 0) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Cannot take in charge mct data within multiple MCT records\n");
        return var_263;
    }

    if (var_234 <= 6) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCT marker\n");
        return var_263;
    }


    opj_read_bytes(p_header_data, &l_tmp, 2);
    p_header_data += 2;

    var_216 = l_tmp & 0xff;
    l_mct_data = l_tcp->m_mct_records;

    for (i = 0; i < l_tcp->m_nb_mct_records; ++i) {
        if (l_mct_data->m_index == var_216) {
            break;
        }
        ++l_mct_data;
    }


    if (i == l_tcp->m_nb_mct_records) {
        if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {
            opj_mct_data_t *new_mct_records;
            l_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;

            new_mct_records = (opj_mct_data_t *) opj_realloc(l_tcp->m_mct_records,
                              l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));
            if (! new_mct_records) {
                opj_free(l_tcp->m_mct_records);
                l_tcp->m_mct_records = NULL;
                l_tcp->m_nb_max_mct_records = 0;
                l_tcp->m_nb_mct_records = 0;
                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read MCT marker\n");
                return var_263;
            }



            if (new_mct_records != l_tcp->m_mct_records) {
                for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {
                    opj_simple_mcc_decorrelation_data_t* l_mcc_record =
                        &(l_tcp->m_mcc_records[i]);
                    if (l_mcc_record->m_decorrelation_array) {
                        l_mcc_record->m_decorrelation_array =
                            new_mct_records +
                            (l_mcc_record->m_decorrelation_array -
                             l_tcp->m_mct_records);
                    }
                    if (l_mcc_record->m_offset_array) {
                        l_mcc_record->m_offset_array =
                            new_mct_records +
                            (l_mcc_record->m_offset_array -
                             l_tcp->m_mct_records);
                    }
                }
            }

            l_tcp->m_mct_records = new_mct_records;
            l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
            memset(l_mct_data, 0, (l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) *
                   sizeof(opj_mct_data_t));
        }

        l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
        ++l_tcp->m_nb_mct_records;
    }

    if (l_mct_data->m_data) {
        opj_free(l_mct_data->m_data);
        l_mct_data->m_data = 0;
        l_mct_data->m_data_size = 0;
    }

    l_mct_data->m_index = var_216;
    l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE)((l_tmp >> 8) & 3);
    l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE)((l_tmp >> 10) & 3);

    opj_read_bytes(p_header_data, &l_tmp, 2);
    p_header_data += 2;
    if (l_tmp != 0) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Cannot take in charge multiple MCT markers\n");
        return var_263;
    }

    var_234 -= 6;

    l_mct_data->m_data = (OPJ_BYTE*)opj_malloc(var_234);
    if (! l_mct_data->m_data) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCT marker\n");
        return var_263;
    }
    memcpy(l_mct_data->m_data, p_header_data, var_234);

    l_mct_data->m_data_size = var_234;

    return var_263;
}

static OPJ_BOOL fn_195(opj_j2k_t *p_j2k,
        struct struct_195 * p_mcc_record,
        struct struct_262 *p_stream,
        struct struct_262 * p_manager)
{
    OPJ_UINT32 i;
    OPJ_UINT32 l_mcc_size;
    OPJ_BYTE * l_current_data = 0;
    OPJ_UINT32 l_nb_bytes_for_comp;
    OPJ_UINT32 l_mask;
    OPJ_UINT32 l_tmcc;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    if (p_mcc_record->m_nb_comps > 255) {
        l_nb_bytes_for_comp = 2;
        l_mask = 0x8000;
    } else {
        l_nb_bytes_for_comp = 1;
        l_mask = 0;
    }

    l_mcc_size = p_mcc_record->m_nb_comps * 2 * l_nb_bytes_for_comp + 19;
    if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write MCC marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
    }

    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;

    opj_write_bytes(l_current_data, J2K_MS_MCC,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_mcc_size - 2,
                    2);
    l_current_data += 2;


    opj_write_bytes(l_current_data, 0,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, p_mcc_record->m_index,
                    1);
    ++l_current_data;


    opj_write_bytes(l_current_data, 0,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, 1,
                    2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, 0x1,
                    1);
    ++l_current_data;

    opj_write_bytes(l_current_data, p_mcc_record->m_nb_comps | l_mask,
                    2);
    l_current_data += 2;

    for (i = 0; i < p_mcc_record->m_nb_comps; ++i) {
        opj_write_bytes(l_current_data, i,
                        l_nb_bytes_for_comp);
        l_current_data += l_nb_bytes_for_comp;
    }

    opj_write_bytes(l_current_data, p_mcc_record->m_nb_comps | l_mask,
                    2);
    l_current_data += 2;

    for (i = 0; i < p_mcc_record->m_nb_comps; ++i) {
        opj_write_bytes(l_current_data, i,
                        l_nb_bytes_for_comp);
        l_current_data += l_nb_bytes_for_comp;
    }

    l_tmcc = ((!p_mcc_record->m_is_irreversible) & 1U) << 16;

    if (p_mcc_record->m_decorrelation_array) {
        l_tmcc |= p_mcc_record->m_decorrelation_array->m_index;
    }

    if (p_mcc_record->m_offset_array) {
        l_tmcc |= ((p_mcc_record->m_offset_array->m_index) << 8);
    }

    opj_write_bytes(l_current_data, l_tmcc,
                    3);
    l_current_data += 3;

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size,
                              p_manager) != l_mcc_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_196(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 i, j;
    OPJ_UINT32 l_tmp;
    OPJ_UINT32 var_216;
    opj_tcp_t * l_tcp;
    opj_simple_mcc_decorrelation_data_t * l_mcc_record;
    opj_mct_data_t * l_mct_data;
    OPJ_UINT32 l_nb_collections;
    OPJ_UINT32 l_nb_comps;
    OPJ_UINT32 l_nb_bytes_by_comp;
    OPJ_BOOL var_197 = var_263;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?
            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;

    if (var_234 < 2) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
        return var_263;
    }


    opj_read_bytes(p_header_data, &l_tmp, 2);
    p_header_data += 2;
    if (l_tmp != 0) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Cannot take in charge multiple data spanning\n");
        return var_263;
    }

    if (var_234 < 7) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, &var_216,
                   1);
    ++p_header_data;

    l_mcc_record = l_tcp->m_mcc_records;

    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {
        if (l_mcc_record->m_index == var_216) {
            break;
        }
        ++l_mcc_record;
    }


    if (i == l_tcp->m_nb_mcc_records) {
        if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {
            opj_simple_mcc_decorrelation_data_t *new_mcc_records;
            l_tcp->m_nb_max_mcc_records += OPJ_J2K_MCC_DEFAULT_NB_RECORDS;

            new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(
                                  l_tcp->m_mcc_records, l_tcp->m_nb_max_mcc_records * sizeof(
                                      opj_simple_mcc_decorrelation_data_t));
            if (! new_mcc_records) {
                opj_free(l_tcp->m_mcc_records);
                l_tcp->m_mcc_records = NULL;
                l_tcp->m_nb_max_mcc_records = 0;
                l_tcp->m_nb_mcc_records = 0;
                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read MCC marker\n");
                return var_263;
            }
            l_tcp->m_mcc_records = new_mcc_records;
            l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
            memset(l_mcc_record, 0, (l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records)
                   * sizeof(opj_simple_mcc_decorrelation_data_t));
        }
        l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
        var_197 = var_263;
    }
    l_mcc_record->m_index = var_216;


    opj_read_bytes(p_header_data, &l_tmp, 2);
    p_header_data += 2;
    if (l_tmp != 0) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Cannot take in charge multiple data spanning\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, &l_nb_collections,
                   2);
    p_header_data += 2;

    if (l_nb_collections > 1) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Cannot take in charge multiple collections\n");
        return var_263;
    }

    var_234 -= 7;

    for (i = 0; i < l_nb_collections; ++i) {
        if (var_234 < 3) {
            opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
            return var_263;
        }

        opj_read_bytes(p_header_data, &l_tmp,
                       1);
        ++p_header_data;

        if (l_tmp != 1) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "Cannot take in charge collections other than array decorrelation\n");
            return var_263;
        }

        opj_read_bytes(p_header_data, &l_nb_comps, 2);

        p_header_data += 2;
        var_234 -= 3;

        l_nb_bytes_by_comp = 1 + (l_nb_comps >> 15);
        l_mcc_record->m_nb_comps = l_nb_comps & 0x7fff;

        if (var_234 < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2)) {
            opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
            return var_263;
        }

        var_234 -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2);

        for (j = 0; j < l_mcc_record->m_nb_comps; ++j) {
            opj_read_bytes(p_header_data, &l_tmp,
                           l_nb_bytes_by_comp);
            p_header_data += l_nb_bytes_by_comp;

            if (l_tmp != j) {
                opj_event_msg(p_manager, EVT_WARNING,
                              "Cannot take in charge collections with indix shuffle\n");
                return var_263;
            }
        }

        opj_read_bytes(p_header_data, &l_nb_comps, 2);
        p_header_data += 2;

        l_nb_bytes_by_comp = 1 + (l_nb_comps >> 15);
        l_nb_comps &= 0x7fff;

        if (l_nb_comps != l_mcc_record->m_nb_comps) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "Cannot take in charge collections without same number of indixes\n");
            return var_263;
        }

        if (var_234 < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3)) {
            opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
            return var_263;
        }

        var_234 -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3);

        for (j = 0; j < l_mcc_record->m_nb_comps; ++j) {
            opj_read_bytes(p_header_data, &l_tmp,
                           l_nb_bytes_by_comp);
            p_header_data += l_nb_bytes_by_comp;

            if (l_tmp != j) {
                opj_event_msg(p_manager, EVT_WARNING,
                              "Cannot take in charge collections with indix shuffle\n");
                return var_263;
            }
        }

        opj_read_bytes(p_header_data, &l_tmp, 3);
        p_header_data += 3;

        l_mcc_record->m_is_irreversible = !((l_tmp >> 16) & 1);
        l_mcc_record->m_decorrelation_array = 0;
        l_mcc_record->m_offset_array = 0;

        var_216 = l_tmp & 0xff;
        if (var_216 != 0) {
            l_mct_data = l_tcp->m_mct_records;
            for (j = 0; j < l_tcp->m_nb_mct_records; ++j) {
                if (l_mct_data->m_index == var_216) {
                    l_mcc_record->m_decorrelation_array = l_mct_data;
                    break;
                }
                ++l_mct_data;
            }

            if (l_mcc_record->m_decorrelation_array == 0) {
                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
                return var_263;
            }
        }

        var_216 = (l_tmp >> 8) & 0xff;
        if (var_216 != 0) {
            l_mct_data = l_tcp->m_mct_records;
            for (j = 0; j < l_tcp->m_nb_mct_records; ++j) {
                if (l_mct_data->m_index == var_216) {
                    l_mcc_record->m_offset_array = l_mct_data;
                    break;
                }
                ++l_mct_data;
            }

            if (l_mcc_record->m_offset_array == 0) {
                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
                return var_263;
            }
        }
    }

    if (var_234 != 0) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
        return var_263;
    }

    if (var_197) {
        ++l_tcp->m_nb_mcc_records;
    }

    return var_263;
}

static OPJ_BOOL fn_197(opj_j2k_t *p_j2k,
                                  struct struct_262 *p_stream,
                                  struct struct_262 * p_manager
                                 )
{
    OPJ_BYTE * l_current_data = 0;
    OPJ_UINT32 l_mco_size;
    opj_tcp_t * l_tcp = 0;
    opj_simple_mcc_decorrelation_data_t * l_mcc_record;
    OPJ_UINT32 i;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);

    l_mco_size = 5 + l_tcp->m_nb_mcc_records;
    if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {

        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write MCO marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
    }
    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;


    opj_write_bytes(l_current_data, J2K_MS_MCO, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_mco_size - 2, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_tcp->m_nb_mcc_records,
                    1);
    ++l_current_data;

    l_mcc_record = l_tcp->m_mcc_records;
    for (i = 0; i < l_tcp->m_nb_mcc_records; ++i) {
        opj_write_bytes(l_current_data, l_mcc_record->m_index,
                        1);
        ++l_current_data;
        ++l_mcc_record;
    }

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size,
                              p_manager) != l_mco_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_197(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 l_tmp, i;
    OPJ_UINT32 l_nb_stages;
    opj_tcp_t * l_tcp;
    opj_tccp_t * l_tccp;
    opj_image_t * l_image;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_image = p_j2k->m_private_image;
    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?
            &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;

    if (var_234 < 1) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCO marker\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, &l_nb_stages,
                   1);
    ++p_header_data;

    if (l_nb_stages > 1) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Cannot take in charge multiple transformation stages.\n");
        return var_263;
    }

    if (var_234 != l_nb_stages + 1) {
        opj_event_msg(p_manager, EVT_WARNING, "Error reading MCO marker\n");
        return var_263;
    }

    l_tccp = l_tcp->tccps;

    for (i = 0; i < l_image->numcomps; ++i) {
        l_tccp->m_dc_level_shift = 0;
        ++l_tccp;
    }

    if (l_tcp->m_mct_decoding_matrix) {
        opj_free(l_tcp->m_mct_decoding_matrix);
        l_tcp->m_mct_decoding_matrix = 0;
    }

    for (i = 0; i < l_nb_stages; ++i) {
        opj_read_bytes(p_header_data, &l_tmp, 1);
        ++p_header_data;

        if (! opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp)) {
            return var_263;
        }
    }

    return var_263;
}

static OPJ_BOOL fn_197(opj_tcp_t * p_tcp, opj_image_t * p_image,
                                OPJ_UINT32 var_197)
{
    OPJ_UINT32 i;
    opj_simple_mcc_decorrelation_data_t * l_mcc_record;
    opj_mct_data_t * l_deco_array, * l_offset_array;
    OPJ_UINT32 var_248, l_mct_size, l_offset_size;
    OPJ_UINT32 l_nb_elem;
    OPJ_UINT32 * l_offset_data, * l_current_offset_data;
    opj_tccp_t * l_tccp;


    assert(p_tcp != 0);

    l_mcc_record = p_tcp->m_mcc_records;

    for (i = 0; i < p_tcp->m_nb_mcc_records; ++i) {
        if (l_mcc_record->m_index == var_197) {
            break;
        }
    }

    if (i == p_tcp->m_nb_mcc_records) {

        return var_263;
    }

    if (l_mcc_record->m_nb_comps != p_image->numcomps) {

        return var_263;
    }

    l_deco_array = l_mcc_record->m_decorrelation_array;

    if (l_deco_array) {
        var_248 = MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps
                      * p_image->numcomps;
        if (l_deco_array->m_data_size != var_248) {
            return var_263;
        }

        l_nb_elem = p_image->numcomps * p_image->numcomps;
        l_mct_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_FLOAT32);
        p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);

        if (! p_tcp->m_mct_decoding_matrix) {
            return var_263;
        }

        j2k_mct_read_functions_to_float[l_deco_array->m_element_type](
            l_deco_array->m_data, p_tcp->m_mct_decoding_matrix, l_nb_elem);
    }

    l_offset_array = l_mcc_record->m_offset_array;

    if (l_offset_array) {
        var_248 = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] *
                      p_image->numcomps;
        if (l_offset_array->m_data_size != var_248) {
            return var_263;
        }

        l_nb_elem = p_image->numcomps;
        l_offset_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_UINT32);
        l_offset_data = (OPJ_UINT32*)opj_malloc(l_offset_size);

        if (! l_offset_data) {
            return var_263;
        }

        j2k_mct_read_functions_to_int32[l_offset_array->m_element_type](
            l_offset_array->m_data, l_offset_data, l_nb_elem);

        l_tccp = p_tcp->tccps;
        l_current_offset_data = l_offset_data;

        for (i = 0; i < p_image->numcomps; ++i) {
            l_tccp->m_dc_level_shift = (OPJ_INT32) * (l_current_offset_data++);
            ++l_tccp;
        }

        opj_free(l_offset_data);
    }

    return var_263;
}

static OPJ_BOOL fn_197(opj_j2k_t *p_j2k,
                                  struct struct_262 *p_stream,
                                  struct struct_262 * p_manager)
{
    OPJ_UINT32 i;
    OPJ_UINT32 l_cbd_size;
    OPJ_BYTE * l_current_data = 0;
    opj_image_t *l_image = 0;
    opj_image_comp_t * l_comp = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_image = p_j2k->m_private_image;
    l_cbd_size = 6 + p_j2k->m_private_image->numcomps;

    if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
        OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(
                                             p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size);
        if (! new_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write CBD marker\n");
            return var_263;
        }
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
    }

    l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;

    opj_write_bytes(l_current_data, J2K_MS_CBD, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_cbd_size - 2, 2);
    l_current_data += 2;

    opj_write_bytes(l_current_data, l_image->numcomps, 2);
    l_current_data += 2;

    l_comp = l_image->comps;

    for (i = 0; i < l_image->numcomps; ++i) {
        opj_write_bytes(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1),
                        1);
        ++l_current_data;

        ++l_comp;
    }

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size,
                              p_manager) != l_cbd_size) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_197(opj_j2k_t *p_j2k,
                                 OPJ_BYTE * p_header_data,
                                 OPJ_UINT32 var_234,
                                 opj_event_mgr_t * p_manager
                                )
{
    OPJ_UINT32 l_nb_comp, l_num_comp;
    OPJ_UINT32 l_comp_def;
    OPJ_UINT32 i;
    opj_image_comp_t * l_comp = 0;


    assert(p_header_data != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    l_num_comp = p_j2k->m_private_image->numcomps;

    if (var_234 != (p_j2k->m_private_image->numcomps + 2)) {
        opj_event_msg(p_manager, EVT_ERROR, "Crror reading CBD marker\n");
        return var_263;
    }

    opj_read_bytes(p_header_data, &l_nb_comp,
                   2);
    p_header_data += 2;

    if (l_nb_comp != l_num_comp) {
        opj_event_msg(p_manager, EVT_ERROR, "Crror reading CBD marker\n");
        return var_263;
    }

    l_comp = p_j2k->m_private_image->comps;
    for (i = 0; i < l_num_comp; ++i) {
        opj_read_bytes(p_header_data, &l_comp_def,
                       1);
        ++p_header_data;
        l_comp->sgnd = (l_comp_def >> 7) & 1;
        l_comp->prec = (l_comp_def & 0x7f) + 1;

        if (l_comp->prec > 31) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                          i, l_comp->prec);
            return var_263;
        }
        ++l_comp;
    }

    return var_263;
}





void fn_197(opj_j2k_t *j2k, opj_dparameters_t *parameters)
{
    if (j2k && parameters) {
        j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;
        j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;

        j2k->dump_state = (parameters->flags & OPJ_DPARAMETERS_DUMP_FLAG);





    }
}

OPJ_BOOL fn_198(opj_j2k_t *j2k, OPJ_UINT32 var_201)
{
    if (opj_has_thread_support()) {
        opj_thread_pool_destroy(j2k->m_tp);
        j2k->m_tp = NULL;
        if (var_201 <= (OPJ_UINT32)INT_MAX) {
            j2k->m_tp = opj_thread_pool_create((int)var_201);
        }
        if (j2k->m_tp == NULL) {
            j2k->m_tp = opj_thread_pool_create(0);
            return var_263;
        }
        return var_263;
    }
    return var_263;
}

static int fn_200()
{
    const char* var_201 = getenv("OPJ_NUM_THREADS");
    if (var_201 == NULL || !opj_has_thread_support()) {
        return 0;
    }
    if (strcmp(var_201, "ALL_CPUS") == 0) {
        return opj_get_num_cpus();
    }
    return atoi(var_201);
}





opj_j2k_t* fn_201(void)
{
    opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
    if (!l_j2k) {
        return NULL;
    }


    l_j2k->m_is_decoder = 0;
    l_j2k->m_cp.m_is_decoder = 0;

    l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *) opj_malloc(
                OPJ_J2K_DEFAULT_HEADER_SIZE);
    if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
        opj_j2k_destroy(l_j2k);
        return NULL;
    }

    l_j2k->m_specific_param.m_encoder.m_header_tile_data_size =
        OPJ_J2K_DEFAULT_HEADER_SIZE;


    l_j2k->m_validation_list = opj_procedure_list_create();
    if (! l_j2k->m_validation_list) {
        opj_j2k_destroy(l_j2k);
        return NULL;
    }


    l_j2k->m_procedure_list = opj_procedure_list_create();
    if (! l_j2k->m_procedure_list) {
        opj_j2k_destroy(l_j2k);
        return NULL;
    }

    l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());
    if (!l_j2k->m_tp) {
        l_j2k->m_tp = opj_thread_pool_create(0);
    }
    if (!l_j2k->m_tp) {
        opj_j2k_destroy(l_j2k);
        return NULL;
    }

    return l_j2k;
}

static int fn_202(opj_poc_t *POC, int var_202)
{
    POC[0].tile = 1;
    POC[0].resno0 = 0;
    POC[0].compno0 = 0;
    POC[0].layno1 = 1;
    POC[0].resno1 = (OPJ_UINT32)(var_202 - 1);
    POC[0].compno1 = 3;
    POC[0].prg1 = OPJ_CPRL;
    POC[1].tile = 1;
    POC[1].resno0 = (OPJ_UINT32)(var_202 - 1);
    POC[1].compno0 = 0;
    POC[1].layno1 = 1;
    POC[1].resno1 = (OPJ_UINT32)var_202;
    POC[1].compno1 = 3;
    POC[1].prg1 = OPJ_CPRL;
    return 2;
}

static void fn_202(opj_cparameters_t *parameters,
        opj_image_t *image, opj_event_mgr_t *p_manager)
{

    int i;


    parameters->tile_size_on = var_263;
    parameters->cp_tdx = 1;
    parameters->cp_tdy = 1;


    parameters->tp_flag = 'C';
    parameters->tp_on = 1;


    parameters->cp_tx0 = 0;
    parameters->cp_ty0 = 0;
    parameters->image_offset_x0 = 0;
    parameters->image_offset_y0 = 0;


    parameters->cblockw_init = 32;
    parameters->cblockh_init = 32;


    parameters->mode = 0;


    parameters->roi_compno = -1;


    parameters->subsampling_dx = 1;
    parameters->subsampling_dy = 1;


    parameters->irreversible = 1;


    if (parameters->tcp_numlayers > 1) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
                      "1 single quality layer"
                      "-> Number of layers forced to 1 (rather than %d)\n"
                      "-> Rate of the last layer (%3.1f) will be used",
                      parameters->tcp_numlayers,
                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);
        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
        parameters->tcp_numlayers = 1;
    }


    switch (parameters->rsiz) {
    case OPJ_PROFILE_CINEMA_2K:
        if (parameters->numresolution > 6) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "JPEG 2000 Profile-3 (2k dc profile) requires:\n"
                          "Number of decomposition levels <= 5\n"
                          "-> Number of decomposition levels forced to 5 (rather than %d)\n",
                          parameters->numresolution + 1);
            parameters->numresolution = 6;
        }
        break;
    case OPJ_PROFILE_CINEMA_4K:
        if (parameters->numresolution < 2) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "JPEG 2000 Profile-4 (4k dc profile) requires:\n"
                          "Number of decomposition levels >= 1 && <= 6\n"
                          "-> Number of decomposition levels forced to 1 (rather than %d)\n",
                          parameters->numresolution + 1);
            parameters->numresolution = 1;
        } else if (parameters->numresolution > 7) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "JPEG 2000 Profile-4 (4k dc profile) requires:\n"
                          "Number of decomposition levels >= 1 && <= 6\n"
                          "-> Number of decomposition levels forced to 6 (rather than %d)\n",
                          parameters->numresolution + 1);
            parameters->numresolution = 7;
        }
        break;
    default :
        break;
    }


    parameters->csty |= 0x01;
    if (parameters->numresolution == 1) {
        parameters->res_spec = 1;
        parameters->prcw_init[0] = 128;
        parameters->prch_init[0] = 128;
    } else {
        parameters->res_spec = parameters->numresolution - 1;
        for (i = 0; i < parameters->res_spec; i++) {
            parameters->prcw_init[i] = 256;
            parameters->prch_init[i] = 256;
        }
    }


    parameters->prog_order = OPJ_CPRL;


    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {
        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,
                              parameters->numresolution);
    } else {
        parameters->numpocs = 0;
    }


    parameters->cp_disto_alloc = 1;
    if (parameters->max_cs_size <= 0) {

        parameters->max_cs_size = OPJ_CINEMA_24_CS;
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
                      "Maximum 1302083 compressed bytes @ 24fps\n"
                      "As no rate has been given, this limit will be used.\n");
    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
                      "Maximum 1302083 compressed bytes @ 24fps\n"
                      "-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n");
        parameters->max_cs_size = OPJ_CINEMA_24_CS;
    }

    if (parameters->max_comp_size <= 0) {

        parameters->max_comp_size = OPJ_CINEMA_24_COMP;
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
                      "Maximum 1041666 compressed bytes @ 24fps\n"
                      "As no rate has been given, this limit will be used.\n");
    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
                      "Maximum 1041666 compressed bytes @ 24fps\n"
                      "-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n");
        parameters->max_comp_size = OPJ_CINEMA_24_COMP;
    }

    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *
                               image->comps[0].h * image->comps[0].prec) /
                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *
                                       image->comps[0].dy);

}

static OPJ_BOOL fn_202(opj_image_t *image, OPJ_UINT16 var_202,
        opj_event_mgr_t *p_manager)
{
    OPJ_UINT32 i;


    if (image->numcomps != 3) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 Profile-3 (2k dc profile) requires:\n"
                      "3 components"
                      "-> Number of components of input image (%d) is not compliant\n"
                      "-> Non-profile-3 codestream will be generated\n",
                      image->numcomps);
        return var_263;
    }


    for (i = 0; i < image->numcomps; i++) {
        if ((image->comps[i].bpp != 12) | (image->comps[i].sgnd)) {
            char signed_str[] = "signed";
            char unsigned_str[] = "unsigned";
            char *tmp_str = image->comps[i].sgnd ? signed_str : unsigned_str;
            opj_event_msg(p_manager, EVT_WARNING,
                          "JPEG 2000 Profile-3 (2k dc profile) requires:\n"
                          "Precision of each component shall be 12 bits unsigned"
                          "-> At least component %d of input image (%d bits, %s) is not compliant\n"
                          "-> Non-profile-3 codestream will be generated\n",
                          i, image->comps[i].bpp, tmp_str);
            return var_263;
        }
    }


    switch (var_202) {
    case OPJ_PROFILE_CINEMA_2K:
        if (((image->comps[0].w > 2048) | (image->comps[0].h > 1080))) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "JPEG 2000 Profile-3 (2k dc profile) requires:\n"
                          "width <= 2048 and height <= 1080\n"
                          "-> Input image size %d x %d is not compliant\n"
                          "-> Non-profile-3 codestream will be generated\n",
                          image->comps[0].w, image->comps[0].h);
            return var_263;
        }
        break;
    case OPJ_PROFILE_CINEMA_4K:
        if (((image->comps[0].w > 4096) | (image->comps[0].h > 2160))) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "JPEG 2000 Profile-4 (4k dc profile) requires:\n"
                          "width <= 4096 and height <= 2160\n"
                          "-> Image size %d x %d is not compliant\n"
                          "-> Non-profile-4 codestream will be generated\n",
                          image->comps[0].w, image->comps[0].h);
            return var_263;
        }
        break;
    default :
        break;
    }

    return var_263;
}

OPJ_BOOL fn_202(opj_j2k_t *p_j2k,
                               opj_cparameters_t *parameters,
                               opj_image_t *image,
                               opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 i, j, var_212, numpocs_tile;
    opj_cp_t *cp = 0;

    if (!p_j2k || !parameters || ! image) {
        return var_263;
    }

    if ((parameters->numresolution <= 0) ||
            (parameters->numresolution > OPJ_J2K_MAXRLVLS)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Invalid number of resolutions : %d not in range [1,%d]\n",
                      parameters->numresolution, OPJ_J2K_MAXRLVLS);
        return var_263;
    }


    cp = &(p_j2k->m_cp);


    cp->tw = 1;
    cp->th = 1;


    if (parameters->rsiz ==
            OPJ_PROFILE_NONE) {
        OPJ_BOOL var_204 = var_263;
        switch (parameters->cp_cinema) {
        case OPJ_CINEMA2K_24:
            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;
            parameters->max_cs_size = OPJ_CINEMA_24_CS;
            parameters->max_comp_size = OPJ_CINEMA_24_COMP;
            var_204 = var_263;
            break;
        case OPJ_CINEMA2K_48:
            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;
            parameters->max_cs_size = OPJ_CINEMA_48_CS;
            parameters->max_comp_size = OPJ_CINEMA_48_COMP;
            var_204 = var_263;
            break;
        case OPJ_CINEMA4K_24:
            parameters->rsiz = OPJ_PROFILE_CINEMA_4K;
            parameters->max_cs_size = OPJ_CINEMA_24_CS;
            parameters->max_comp_size = OPJ_CINEMA_24_COMP;
            var_204 = var_263;
            break;
        case OPJ_OFF:
        default:
            break;
        }
        switch (parameters->cp_rsiz) {
        case OPJ_CINEMA2K:
            parameters->rsiz = OPJ_PROFILE_CINEMA_2K;
            var_204 = var_263;
            break;
        case OPJ_CINEMA4K:
            parameters->rsiz = OPJ_PROFILE_CINEMA_4K;
            var_204 = var_263;
            break;
        case OPJ_MCT:
            parameters->rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;
            var_204 = var_263;
        case OPJ_STD_RSIZ:
        default:
            break;
        }
        if (var_204) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "Deprecated fields cp_cinema or cp_rsiz are used\n"
                          "Please consider using only the rsiz field\n"
                          "See openjpeg.h documentation for more details\n");
        }
    }


    if (parameters->tcp_numlayers == 0) {
        parameters->tcp_numlayers = 1;
        parameters->cp_disto_alloc = 1;
        parameters->tcp_rates[0] = 0;
    }


    if (parameters->max_cs_size <= 0) {
        if (parameters->tcp_rates[parameters->tcp_numlayers - 1] > 0) {
            OPJ_FLOAT32 temp_size;
            temp_size = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *
                                      image->comps[0].h * image->comps[0].prec) /
                        (parameters->tcp_rates[parameters->tcp_numlayers - 1] * 8 *
                         (OPJ_FLOAT32)image->comps[0].dx * (OPJ_FLOAT32)image->comps[0].dy);
            parameters->max_cs_size = (int) floor(temp_size);
        } else {
            parameters->max_cs_size = 0;
        }
    } else {
        OPJ_FLOAT32 temp_rate;
        OPJ_BOOL var_205 = var_263;
        temp_rate = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *
                                  image->comps[0].h * image->comps[0].prec) /
                    (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *
                                  image->comps[0].dy);
        for (i = 0; i < (OPJ_UINT32) parameters->tcp_numlayers; i++) {
            if (parameters->tcp_rates[i] < temp_rate) {
                parameters->tcp_rates[i] = temp_rate;
                var_205 = var_263;
            }
        }
        if (var_205) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "The desired maximum codestream size has limited\n"
                          "at least one of the desired quality layers\n");
        }
    }



    if (OPJ_IS_CINEMA(parameters->rsiz)) {
        if ((parameters->rsiz == OPJ_PROFILE_CINEMA_S2K)
                || (parameters->rsiz == OPJ_PROFILE_CINEMA_S4K)) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
            parameters->rsiz = OPJ_PROFILE_NONE;
        } else {
            opj_j2k_set_cinema_parameters(parameters, image, p_manager);
            if (!opj_j2k_is_cinema_compliant(image, parameters->rsiz, p_manager)) {
                parameters->rsiz = OPJ_PROFILE_NONE;
            }
        }
    } else if (OPJ_IS_STORAGE(parameters->rsiz)) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 Long Term Storage profile not yet supported\n");
        parameters->rsiz = OPJ_PROFILE_NONE;
    } else if (OPJ_IS_BROADCAST(parameters->rsiz)) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 Broadcast profiles not yet supported\n");
        parameters->rsiz = OPJ_PROFILE_NONE;
    } else if (OPJ_IS_IMF(parameters->rsiz)) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "JPEG 2000 IMF profiles not yet supported\n");
        parameters->rsiz = OPJ_PROFILE_NONE;
    } else if (OPJ_IS_PART2(parameters->rsiz)) {
        if (parameters->rsiz == ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_NONE))) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "JPEG 2000 Part-2 profile defined\n"
                          "but no Part-2 extension enabled.\n"
                          "Profile set to NONE.\n");
            parameters->rsiz = OPJ_PROFILE_NONE;
        } else if (parameters->rsiz != ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_MCT))) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "Unsupported Part-2 extension enabled\n"
                          "Profile set to NONE.\n");
            parameters->rsiz = OPJ_PROFILE_NONE;
        }
    }




    cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32)
            parameters->max_comp_size;
    cp->rsiz = parameters->rsiz;
    cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32)
            parameters->cp_disto_alloc & 1u;
    cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32)
            parameters->cp_fixed_alloc & 1u;
    cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32)
            parameters->cp_fixed_quality & 1u;


    if (parameters->cp_fixed_alloc && parameters->cp_matrice) {
        size_t var_206 = (size_t)parameters->tcp_numlayers *
                            (size_t)parameters->numresolution * 3 * sizeof(OPJ_INT32);
        cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *) opj_malloc(var_206);
        if (!cp->m_specific_param.m_enc.m_matrice) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Not enough memory to allocate copy of user encoding parameters matrix \n");
            return var_263;
        }
        memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice,
               var_206);
    }


    cp->tdx = (OPJ_UINT32)parameters->cp_tdx;
    cp->tdy = (OPJ_UINT32)parameters->cp_tdy;


    cp->tx0 = (OPJ_UINT32)parameters->cp_tx0;
    cp->ty0 = (OPJ_UINT32)parameters->cp_ty0;


    if (parameters->cp_comment) {
        cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1U);
        if (!cp->comment) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Not enough memory to allocate copy of comment string\n");
            return var_263;
        }
        strcpy(cp->comment, parameters->cp_comment);
    } else {

        const char comment[] = "Created by OpenJPEG version ";
        const size_t var_207 = strlen(comment);
        const char *version = opj_version();

        cp->comment = (char*)opj_malloc(var_207 + strlen(version) + 1);
        if (!cp->comment) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Not enough memory to allocate comment string\n");
            return var_263;
        }
        sprintf(cp->comment, "%s%s", comment, version);


    }





    if (parameters->tile_size_on) {
        cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->x1 - cp->tx0),
                                             (OPJ_INT32)cp->tdx);
        cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->y1 - cp->ty0),
                                             (OPJ_INT32)cp->tdy);
    } else {
        cp->tdx = image->x1 - cp->tx0;
        cp->tdy = image->y1 - cp->ty0;
    }

    if (parameters->tp_on) {
        cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE)parameters->tp_flag;
        cp->m_specific_param.m_enc.m_tp_on = 1;
    }

    cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
    if (!cp->tcps) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Not enough memory to allocate tile coding parameters\n");
        return var_263;
    }
    if (parameters->numpocs) {

        opj_j2k_check_poc_val(parameters->POC, parameters->numpocs,
                              (OPJ_UINT32)parameters->numresolution, image->numcomps,
                              (OPJ_UINT32)parameters->tcp_numlayers, p_manager);

    }

    for (var_212 = 0; var_212 < cp->tw * cp->th; var_212++) {
        opj_tcp_t *tcp = &cp->tcps[var_212];
        tcp->numlayers = (OPJ_UINT32)parameters->tcp_numlayers;

        for (j = 0; j < tcp->numlayers; j++) {
            if (OPJ_IS_CINEMA(cp->rsiz)) {
                if (cp->m_specific_param.m_enc.m_fixed_quality) {
                    tcp->distoratio[j] = parameters->tcp_distoratio[j];
                }
                tcp->rates[j] = parameters->tcp_rates[j];
            } else {
                if (cp->m_specific_param.m_enc.m_fixed_quality) {
                    tcp->distoratio[j] = parameters->tcp_distoratio[j];
                } else {
                    tcp->rates[j] = parameters->tcp_rates[j];
                }
            }
        }

        tcp->csty = (OPJ_UINT32)parameters->csty;
        tcp->prg = parameters->prog_order;
        tcp->mct = (OPJ_UINT32)parameters->tcp_mct;

        numpocs_tile = 0;
        tcp->POC = 0;

        if (parameters->numpocs) {

            tcp->POC = 1;
            for (i = 0; i < parameters->numpocs; i++) {
                if (var_212 + 1 == parameters->POC[i].tile) {
                    opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];

                    tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
                    tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
                    tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
                    tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
                    tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
                    tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
                    tcp_poc->tile = parameters->POC[numpocs_tile].tile;

                    numpocs_tile++;
                }
            }

            tcp->numpocs = numpocs_tile - 1 ;
        } else {
            tcp->numpocs = 0;
        }

        tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
        if (!tcp->tccps) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Not enough memory to allocate tile component coding parameters\n");
            return var_263;
        }
        if (parameters->mct_data) {

            OPJ_UINT32 var_208 = image->numcomps * image->numcomps * (OPJ_UINT32)sizeof(
                                      OPJ_FLOAT32);
            OPJ_FLOAT32 * lTmpBuf = (OPJ_FLOAT32*)opj_malloc(var_208);
            OPJ_INT32 * l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *) parameters->mct_data +
                                                   var_208);

            if (!lTmpBuf) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "Not enough memory to allocate temp buffer\n");
                return var_263;
            }

            tcp->mct = 2;
            tcp->m_mct_coding_matrix = (OPJ_FLOAT32*)opj_malloc(var_208);
            if (! tcp->m_mct_coding_matrix) {
                opj_free(lTmpBuf);
                lTmpBuf = NULL;
                opj_event_msg(p_manager, EVT_ERROR,
                              "Not enough memory to allocate encoder MCT coding matrix \n");
                return var_263;
            }
            memcpy(tcp->m_mct_coding_matrix, parameters->mct_data, var_208);
            memcpy(lTmpBuf, parameters->mct_data, var_208);

            tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(var_208);
            if (! tcp->m_mct_decoding_matrix) {
                opj_free(lTmpBuf);
                lTmpBuf = NULL;
                opj_event_msg(p_manager, EVT_ERROR,
                              "Not enough memory to allocate encoder MCT decoding matrix \n");
                return var_263;
            }
            if (opj_matrix_inversion_f(lTmpBuf, (tcp->m_mct_decoding_matrix),
                                       image->numcomps) == var_263) {
                opj_free(lTmpBuf);
                lTmpBuf = NULL;
                opj_event_msg(p_manager, EVT_ERROR,
                              "Failed to inverse encoder MCT decoding matrix \n");
                return var_263;
            }

            tcp->mct_norms = (OPJ_FLOAT64*)
                             opj_malloc(image->numcomps * sizeof(OPJ_FLOAT64));
            if (! tcp->mct_norms) {
                opj_free(lTmpBuf);
                lTmpBuf = NULL;
                opj_event_msg(p_manager, EVT_ERROR,
                              "Not enough memory to allocate encoder MCT norms \n");
                return var_263;
            }
            opj_calculate_norms(tcp->mct_norms, image->numcomps,
                                tcp->m_mct_decoding_matrix);
            opj_free(lTmpBuf);

            for (i = 0; i < image->numcomps; i++) {
                opj_tccp_t *tccp = &tcp->tccps[i];
                tccp->m_dc_level_shift = l_dc_shift[i];
            }

            if (opj_j2k_setup_mct_encoding(tcp, image) == var_263) {

                opj_event_msg(p_manager, EVT_ERROR, "Failed to setup j2k mct encoding\n");
                return var_263;
            }
        } else {
            if (tcp->mct == 1 && image->numcomps >= 3) {
                if ((image->comps[0].dx != image->comps[1].dx) ||
                        (image->comps[0].dx != image->comps[2].dx) ||
                        (image->comps[0].dy != image->comps[1].dy) ||
                        (image->comps[0].dy != image->comps[2].dy)) {
                    opj_event_msg(p_manager, EVT_WARNING,
                                  "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
                    tcp->mct = 0;
                }
            }
            for (i = 0; i < image->numcomps; i++) {
                opj_tccp_t *tccp = &tcp->tccps[i];
                opj_image_comp_t * l_comp = &(image->comps[i]);

                if (! l_comp->sgnd) {
                    tccp->m_dc_level_shift = 1 << (l_comp->prec - 1);
                }
            }
        }

        for (i = 0; i < image->numcomps; i++) {
            opj_tccp_t *tccp = &tcp->tccps[i];

            tccp->csty = parameters->csty &
                         0x01;
            tccp->numresolutions = (OPJ_UINT32)parameters->numresolution;
            tccp->cblkw = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockw_init);
            tccp->cblkh = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockh_init);
            tccp->cblksty = (OPJ_UINT32)parameters->mode;
            tccp->qmfbid = parameters->irreversible ? 0 : 1;
            tccp->qntsty = parameters->irreversible ? J2K_CCP_QNTSTY_SEQNT :
                           J2K_CCP_QNTSTY_NOQNT;
            tccp->numgbits = 2;

            if ((OPJ_INT32)i == parameters->roi_compno) {
                tccp->roishift = parameters->roi_shift;
            } else {
                tccp->roishift = 0;
            }

            if (parameters->csty & J2K_CCP_CSTY_PRT) {
                OPJ_INT32 var_212 = 0, it_res;
                assert(tccp->numresolutions > 0);
                for (it_res = (OPJ_INT32)tccp->numresolutions - 1; it_res >= 0; it_res--) {
                    if (var_212 < parameters->res_spec) {

                        if (parameters->prcw_init[var_212] < 1) {
                            tccp->prcw[it_res] = 1;
                        } else {
                            tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prcw_init[var_212]);
                        }

                        if (parameters->prch_init[var_212] < 1) {
                            tccp->prch[it_res] = 1;
                        } else {
                            tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prch_init[var_212]);
                        }

                    } else {
                        OPJ_INT32 var_212 = parameters->res_spec;
                        OPJ_INT32 var_212 = 0;
                        OPJ_INT32 var_212 = 0;

                        assert(var_212 > 0);
                        var_212 = parameters->prcw_init[var_212 - 1] >> (var_212 - (var_212 - 1));
                        var_212 = parameters->prch_init[var_212 - 1] >> (var_212 - (var_212 - 1));


                        if (var_212 < 1) {
                            tccp->prcw[it_res] = 1;
                        } else {
                            tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(var_212);
                        }

                        if (var_212 < 1) {
                            tccp->prch[it_res] = 1;
                        } else {
                            tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(var_212);
                        }
                    }
                    var_212++;

                }
            } else {
                for (j = 0; j < tccp->numresolutions; j++) {
                    tccp->prcw[j] = 15;
                    tccp->prch[j] = 15;
                }
            }

            opj_dwt_calc_explicit_stepsizes(tccp, image->comps[i].prec);
        }
    }

    if (parameters->mct_data) {
        opj_free(parameters->mct_data);
        parameters->mct_data = 0;
    }
    return var_263;
}

static OPJ_BOOL fn_212(opj_codestream_index_t *cstr_index,
                                     OPJ_UINT32 var_212, OPJ_OFF_T var_212, OPJ_UINT32 var_212)
{
    assert(cstr_index != 0);


    if ((cstr_index->marknum + 1) > cstr_index->maxmarknum) {
        opj_marker_info_t *new_marker;
        cstr_index->maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32)
                                              cstr_index->maxmarknum);
        new_marker = (opj_marker_info_t *) opj_realloc(cstr_index->marker,
                     cstr_index->maxmarknum * sizeof(opj_marker_info_t));
        if (! new_marker) {
            opj_free(cstr_index->marker);
            cstr_index->marker = NULL;
            cstr_index->maxmarknum = 0;
            cstr_index->marknum = 0;

            return var_263;
        }
        cstr_index->marker = new_marker;
    }


    cstr_index->marker[cstr_index->marknum].type = (OPJ_UINT16)var_212;
    cstr_index->marker[cstr_index->marknum].pos = (OPJ_INT32)var_212;
    cstr_index->marker[cstr_index->marknum].len = (OPJ_INT32)var_212;
    cstr_index->marknum++;
    return var_263;
}

static OPJ_BOOL fn_212(OPJ_UINT32 var_212,
                                     opj_codestream_index_t *cstr_index, OPJ_UINT32 var_212, OPJ_OFF_T var_212,
                                     OPJ_UINT32 var_212)
{
    assert(cstr_index != 0);
    assert(cstr_index->tile_index != 0);


    if ((cstr_index->tile_index[var_212].marknum + 1) >
            cstr_index->tile_index[var_212].maxmarknum) {
        opj_marker_info_t *new_marker;
        cstr_index->tile_index[var_212].maxmarknum = (OPJ_UINT32)(100 +
                (OPJ_FLOAT32) cstr_index->tile_index[var_212].maxmarknum);
        new_marker = (opj_marker_info_t *) opj_realloc(
                         cstr_index->tile_index[var_212].marker,
                         cstr_index->tile_index[var_212].maxmarknum * sizeof(opj_marker_info_t));
        if (! new_marker) {
            opj_free(cstr_index->tile_index[var_212].marker);
            cstr_index->tile_index[var_212].marker = NULL;
            cstr_index->tile_index[var_212].maxmarknum = 0;
            cstr_index->tile_index[var_212].marknum = 0;

            return var_263;
        }
        cstr_index->tile_index[var_212].marker = new_marker;
    }


    cstr_index->tile_index[var_212].marker[cstr_index->tile_index[var_212].marknum].type
        = (OPJ_UINT16)var_212;
    cstr_index->tile_index[var_212].marker[cstr_index->tile_index[var_212].marknum].pos
        = (OPJ_INT32)var_212;
    cstr_index->tile_index[var_212].marker[cstr_index->tile_index[var_212].marknum].len
        = (OPJ_INT32)var_212;
    cstr_index->tile_index[var_212].marknum++;

    if (var_212 == var_228) {
        OPJ_UINT32 var_212 = cstr_index->tile_index[var_212].current_tpsno;

        if (cstr_index->tile_index[var_212].tp_index) {
            cstr_index->tile_index[var_212].tp_index[var_212].start_pos = var_212;
        }

    }
    return var_263;
}







OPJ_BOOL fn_212(opj_j2k_t *p_j2k,
                                opj_stream_private_t *p_stream,
                                opj_event_mgr_t * p_manager
                               )
{
    (void)p_j2k;
    (void)p_stream;
    (void)p_manager;
    return var_263;
}

OPJ_BOOL fn_213(opj_stream_private_t *p_stream,
                             opj_j2k_t* p_j2k,
                             opj_image_t** p_image,
                             opj_event_mgr_t* p_manager)
{

    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);


    p_j2k->m_private_image = opj_image_create0();
    if (! p_j2k->m_private_image) {
        return var_263;
    }


    if (! opj_j2k_setup_decoding_validation(p_j2k, p_manager)) {
        opj_image_destroy(p_j2k->m_private_image);
        p_j2k->m_private_image = NULL;
        return var_263;
    }


    if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager)) {
        opj_image_destroy(p_j2k->m_private_image);
        p_j2k->m_private_image = NULL;
        return var_263;
    }


    if (! opj_j2k_setup_header_reading(p_j2k, p_manager)) {
        opj_image_destroy(p_j2k->m_private_image);
        p_j2k->m_private_image = NULL;
        return var_263;
    }


    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {
        opj_image_destroy(p_j2k->m_private_image);
        p_j2k->m_private_image = NULL;
        return var_263;
    }

    *p_image = opj_image_create0();
    if (!(*p_image)) {
        return var_263;
    }


    opj_copy_image_header(p_j2k->m_private_image, *p_image);


    if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_214(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_read_header_procedure, p_manager)) {
        return var_263;
    }


    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_copy_default_tcp_and_create_tcd, p_manager)) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_214(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,
                                           (opj_procedure)opj_j2k_build_decoder, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,
                                           (opj_procedure)opj_j2k_decoding_validation, p_manager)) {
        return var_263;
    }


    return var_263;
}

static OPJ_BOOL fn_214(opj_j2k_t * p_j2k,
                                       opj_stream_private_t *p_stream,
                                       opj_event_mgr_t * p_manager)
{
    OPJ_BOOL var_216 = var_263;
    OPJ_UINT32 i, j;


    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    (void)p_stream;
    (void)p_manager;

    if ((p_j2k->m_cp.rsiz & 0x8200) == 0x8200) {
        OPJ_UINT32 var_258 = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;

        for (i = 0; i < var_258; ++i) {
            if (l_tcp->mct == 2) {
                opj_tccp_t * l_tccp = l_tcp->tccps;
                var_216 &= (l_tcp->m_mct_coding_matrix != 0);

                for (j = 0; j < p_j2k->m_private_image->numcomps; ++j) {
                    var_216 &= !(l_tccp->qmfbid & 1);
                    ++l_tccp;
                }
            }
            ++l_tcp;
        }
    }

    return var_216;
}

OPJ_BOOL fn_215(opj_tcp_t * p_tcp, opj_image_t * p_image)
{
    OPJ_UINT32 i;
    OPJ_UINT32 var_216 = 1;
    opj_mct_data_t * l_mct_deco_data = 0, * l_mct_offset_data = 0;
    opj_simple_mcc_decorrelation_data_t * l_mcc_data;
    OPJ_UINT32 l_mct_size, l_nb_elem;
    OPJ_FLOAT32 * l_data, * l_current_data;
    opj_tccp_t * l_tccp;


    assert(p_tcp != 0);

    if (p_tcp->mct != 2) {
        return var_263;
    }

    if (p_tcp->m_mct_decoding_matrix) {
        if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
            opj_mct_data_t *new_mct_records;
            p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;

            new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records,
                              p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));
            if (! new_mct_records) {
                opj_free(p_tcp->m_mct_records);
                p_tcp->m_mct_records = NULL;
                p_tcp->m_nb_max_mct_records = 0;
                p_tcp->m_nb_mct_records = 0;

                return var_263;
            }
            p_tcp->m_mct_records = new_mct_records;
            l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;

            memset(l_mct_deco_data, 0,
                   (p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(
                       opj_mct_data_t));
        }
        l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;

        if (l_mct_deco_data->m_data) {
            opj_free(l_mct_deco_data->m_data);
            l_mct_deco_data->m_data = 0;
        }

        l_mct_deco_data->m_index = var_216++;
        l_mct_deco_data->m_array_type = MCT_TYPE_DECORRELATION;
        l_mct_deco_data->m_element_type = MCT_TYPE_FLOAT;
        l_nb_elem = p_image->numcomps * p_image->numcomps;
        l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
        l_mct_deco_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size);

        if (! l_mct_deco_data->m_data) {
            return var_263;
        }

        j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type](
            p_tcp->m_mct_decoding_matrix, l_mct_deco_data->m_data, l_nb_elem);

        l_mct_deco_data->m_data_size = l_mct_size;
        ++p_tcp->m_nb_mct_records;
    }

    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
        opj_mct_data_t *new_mct_records;
        p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;
        new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records,
                          p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));
        if (! new_mct_records) {
            opj_free(p_tcp->m_mct_records);
            p_tcp->m_mct_records = NULL;
            p_tcp->m_nb_max_mct_records = 0;
            p_tcp->m_nb_mct_records = 0;

            return var_263;
        }
        p_tcp->m_mct_records = new_mct_records;
        l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;

        memset(l_mct_offset_data, 0,
               (p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(
                   opj_mct_data_t));

        if (l_mct_deco_data) {
            l_mct_deco_data = l_mct_offset_data - 1;
        }
    }

    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;

    if (l_mct_offset_data->m_data) {
        opj_free(l_mct_offset_data->m_data);
        l_mct_offset_data->m_data = 0;
    }

    l_mct_offset_data->m_index = var_216++;
    l_mct_offset_data->m_array_type = MCT_TYPE_OFFSET;
    l_mct_offset_data->m_element_type = MCT_TYPE_FLOAT;
    l_nb_elem = p_image->numcomps;
    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
    l_mct_offset_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size);

    if (! l_mct_offset_data->m_data) {
        return var_263;
    }

    l_data = (OPJ_FLOAT32*)opj_malloc(l_nb_elem * sizeof(OPJ_FLOAT32));
    if (! l_data) {
        opj_free(l_mct_offset_data->m_data);
        l_mct_offset_data->m_data = 0;
        return var_263;
    }

    l_tccp = p_tcp->tccps;
    l_current_data = l_data;

    for (i = 0; i < l_nb_elem; ++i) {
        *(l_current_data++) = (OPJ_FLOAT32)(l_tccp->m_dc_level_shift);
        ++l_tccp;
    }

    j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type](l_data,
            l_mct_offset_data->m_data, l_nb_elem);

    opj_free(l_data);

    l_mct_offset_data->m_data_size = l_mct_size;

    ++p_tcp->m_nb_mct_records;

    if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {
        opj_simple_mcc_decorrelation_data_t *new_mcc_records;
        p_tcp->m_nb_max_mcc_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;
        new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(
                              p_tcp->m_mcc_records, p_tcp->m_nb_max_mcc_records * sizeof(
                                  opj_simple_mcc_decorrelation_data_t));
        if (! new_mcc_records) {
            opj_free(p_tcp->m_mcc_records);
            p_tcp->m_mcc_records = NULL;
            p_tcp->m_nb_max_mcc_records = 0;
            p_tcp->m_nb_mcc_records = 0;

            return var_263;
        }
        p_tcp->m_mcc_records = new_mcc_records;
        l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
        memset(l_mcc_data, 0, (p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) *
               sizeof(opj_simple_mcc_decorrelation_data_t));

    }

    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
    l_mcc_data->m_decorrelation_array = l_mct_deco_data;
    l_mcc_data->m_is_irreversible = 1;
    l_mcc_data->m_nb_comps = p_image->numcomps;
    l_mcc_data->m_index = var_216++;
    l_mcc_data->m_offset_array = l_mct_offset_data;
    ++p_tcp->m_nb_mcc_records;

    return var_263;
}

static OPJ_BOOL fn_216(opj_j2k_t * p_j2k,
                                      opj_stream_private_t *p_stream,
                                      opj_event_mgr_t * p_manager)
{


    (void)p_j2k;
    (void)p_stream;
    (void)p_manager;
    return var_263;
}

static OPJ_BOOL fn_216(opj_j2k_t * p_j2k,
                                      opj_stream_private_t *p_stream,
                                      opj_event_mgr_t * p_manager)
{


    (void)p_j2k;
    (void)p_stream;
    (void)p_manager;
    return var_263;
}

static OPJ_BOOL fn_216(opj_j2k_t * p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager)
{
    OPJ_BOOL var_216 = var_263;


    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    (void)p_stream;



    var_216 &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);



    var_216 &= (p_j2k->m_procedure_list != 0);

    var_216 &= (p_j2k->m_validation_list != 0);




    if ((p_j2k->m_cp.tcps->tccps->numresolutions <= 0) ||
            (p_j2k->m_cp.tcps->tccps->numresolutions > 32)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Number of resolutions is too high in comparison to the size of tiles\n");
        return var_263;
    }

    if ((p_j2k->m_cp.tdx) < (OPJ_UINT32)(1 <<
                                         (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Number of resolutions is too high in comparison to the size of tiles\n");
        return var_263;
    }

    if ((p_j2k->m_cp.tdy) < (OPJ_UINT32)(1 <<
                                         (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Number of resolutions is too high in comparison to the size of tiles\n");
        return var_263;
    }


    return var_216;
}

static OPJ_BOOL fn_216(opj_j2k_t *p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager
                                           )
{
    OPJ_BOOL var_216 = var_263;


    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    (void)p_stream;
    (void)p_manager;






    var_216 &= (p_j2k->m_specific_param.m_decoder.m_state == 0x0000);




    var_216 &= (p_j2k->m_procedure_list != 0);

    var_216 &= (p_j2k->m_validation_list != 0);


    return var_216;
}

static OPJ_BOOL fn_216(opj_j2k_t *p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 var_228;
    OPJ_UINT32 l_marker_size;
    const opj_dec_memory_marker_handler_t * l_marker_handler = 0;
    OPJ_BOOL var_220 = 0;
    OPJ_BOOL var_220 = 0;
    OPJ_BOOL var_220 = 0;


    assert(p_stream != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);


    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSOC;


    if (! opj_j2k_read_soc(p_j2k, p_stream, p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Expected a SOC marker \n");
        return var_263;
    }


    if (opj_stream_read_data(p_stream,
                             p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {
        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
        return var_263;
    }


    opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,
                   &var_228, 2);


    while (var_228 != var_228) {


        if (var_228 < 0xff00) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "A marker ID was expected (0xff--) instead of %.8x\n", var_228);
            return var_263;
        }


        l_marker_handler = opj_j2k_get_marker_handler(var_228);


        if (l_marker_handler->id == J2K_MS_UNK) {
            if (! opj_j2k_read_unk(p_j2k, p_stream, &var_228, p_manager)) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "Unknow marker have been detected and generated error.\n");
                return var_263;
            }

            if (var_228 == var_228) {
                break;
            } else {
                l_marker_handler = opj_j2k_get_marker_handler(var_228);
            }
        }

        if (l_marker_handler->id == J2K_MS_SIZ) {

            var_220 = 1;
        }
        if (l_marker_handler->id == J2K_MS_COD) {

            var_220 = 1;
        }
        if (l_marker_handler->id == J2K_MS_QCD) {

            var_220 = 1;
        }


        if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Marker is not compliant with its position\n");
            return var_263;
        }


        if (opj_stream_read_data(p_stream,
                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {
            opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
            return var_263;
        }


        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data, &l_marker_size,
                       2);
        if (l_marker_size < 2) {
            opj_event_msg(p_manager, EVT_ERROR, "Invalid marker size\n");
            return var_263;
        }
        l_marker_size -= 2;


        if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
            OPJ_BYTE *new_header_data = (OPJ_BYTE *) opj_realloc(
                                            p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);
            if (! new_header_data) {
                opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
                p_j2k->m_specific_param.m_decoder.m_header_data = NULL;
                p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;
                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read header\n");
                return var_263;
            }
            p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
            p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
        }


        if (opj_stream_read_data(p_stream,
                                 p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size,
                                 p_manager) != l_marker_size) {
            opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
            return var_263;
        }


        if (!(*(l_marker_handler->handler))(p_j2k,
                                            p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size, p_manager)) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Marker handler function failed to read the marker segment\n");
            return var_263;
        }


        if (var_263 == opj_j2k_add_mhmarker(
                    p_j2k->cstr_index,
                    l_marker_handler->id,
                    (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,
                    l_marker_size + 4)) {
            opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add mh marker\n");
            return var_263;
        }


        if (opj_stream_read_data(p_stream,
                                 p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {
            opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
            return var_263;
        }


        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,
                       &var_228, 2);
    }

    if (var_220 == 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "required SIZ marker not found in main header\n");
        return var_263;
    }
    if (var_220 == 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "required COD marker not found in main header\n");
        return var_263;
    }
    if (var_220 == 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "required QCD marker not found in main header\n");
        return var_263;
    }

    if (! opj_j2k_merge_ppm(&(p_j2k->m_cp), p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Failed to merge PPM data\n");
        return var_263;
    }

    opj_event_msg(p_manager, EVT_INFO, "Main header has been correctly decoded.\n");


    p_j2k->cstr_index->main_head_end = (OPJ_UINT32) opj_stream_tell(p_stream) - 2;


    p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;

    return var_263;
}

static OPJ_BOOL fn_220(opj_j2k_t * p_j2k,
                             opj_procedure_list_t * p_procedure_list,
                             opj_stream_private_t *p_stream,
                             opj_event_mgr_t * p_manager)
{
    OPJ_BOOL(** l_procedure)(opj_j2k_t *, opj_stream_private_t *,
                             opj_event_mgr_t *) = 0;
    OPJ_BOOL var_221 = var_263;
    OPJ_UINT32 l_nb_proc, i;


    assert(p_procedure_list != 0);
    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
    l_procedure = (OPJ_BOOL(**)(opj_j2k_t *, opj_stream_private_t *,
                                opj_event_mgr_t *)) opj_procedure_list_get_first_procedure(p_procedure_list);

    for (i = 0; i < l_nb_proc; ++i) {
        var_221 = var_221 && ((*l_procedure)(p_j2k, p_stream, p_manager));
        ++l_procedure;
    }


    opj_procedure_list_clear(p_procedure_list);
    return var_221;
}


static OPJ_BOOL fn_221(opj_j2k_t * p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager
                                                       )
{
    opj_tcp_t * l_tcp = 0;
    opj_tcp_t * l_default_tcp = 0;
    OPJ_UINT32 var_258;
    OPJ_UINT32 i, j;
    opj_tccp_t *l_current_tccp = 0;
    OPJ_UINT32 l_tccp_size;
    OPJ_UINT32 l_mct_size;
    opj_image_t * l_image;
    OPJ_UINT32 l_mcc_records_size, l_mct_records_size;
    opj_mct_data_t * l_src_mct_rec, *l_dest_mct_rec;
    opj_simple_mcc_decorrelation_data_t * l_src_mcc_rec, *l_dest_mcc_rec;
    OPJ_UINT32 var_221;


    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    (void)p_stream;

    l_image = p_j2k->m_private_image;
    var_258 = p_j2k->m_cp.th * p_j2k->m_cp.tw;
    l_tcp = p_j2k->m_cp.tcps;
    l_tccp_size = l_image->numcomps * (OPJ_UINT32)sizeof(opj_tccp_t);
    l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
    l_mct_size = l_image->numcomps * l_image->numcomps * (OPJ_UINT32)sizeof(
                     OPJ_FLOAT32);


    for (i = 0; i < var_258; ++i) {

        l_current_tccp = l_tcp->tccps;

        memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t));

        l_tcp->cod = 0;
        l_tcp->ppt = 0;
        l_tcp->ppt_data = 0;
        l_tcp->m_current_tile_part_number = -1;

        l_tcp->m_mct_decoding_matrix = 0;
        l_tcp->m_nb_max_mct_records = 0;
        l_tcp->m_mct_records = 0;
        l_tcp->m_nb_max_mcc_records = 0;
        l_tcp->m_mcc_records = 0;

        l_tcp->tccps = l_current_tccp;


        if (l_default_tcp->m_mct_decoding_matrix) {
            l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);
            if (! l_tcp->m_mct_decoding_matrix) {
                return var_263;
            }
            memcpy(l_tcp->m_mct_decoding_matrix, l_default_tcp->m_mct_decoding_matrix,
                   l_mct_size);
        }


        l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32)sizeof(
                                 opj_mct_data_t);
        l_tcp->m_mct_records = (opj_mct_data_t*)opj_malloc(l_mct_records_size);
        if (! l_tcp->m_mct_records) {
            return var_263;
        }
        memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records, l_mct_records_size);


        l_src_mct_rec = l_default_tcp->m_mct_records;
        l_dest_mct_rec = l_tcp->m_mct_records;

        for (j = 0; j < l_default_tcp->m_nb_mct_records; ++j) {

            if (l_src_mct_rec->m_data) {

                l_dest_mct_rec->m_data = (OPJ_BYTE*) opj_malloc(l_src_mct_rec->m_data_size);
                if (! l_dest_mct_rec->m_data) {
                    return var_263;
                }
                memcpy(l_dest_mct_rec->m_data, l_src_mct_rec->m_data,
                       l_src_mct_rec->m_data_size);
            }

            ++l_src_mct_rec;
            ++l_dest_mct_rec;

            l_tcp->m_nb_max_mct_records += 1;
        }


        l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32)sizeof(
                                 opj_simple_mcc_decorrelation_data_t);
        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t*) opj_malloc(
                                   l_mcc_records_size);
        if (! l_tcp->m_mcc_records) {
            return var_263;
        }
        memcpy(l_tcp->m_mcc_records, l_default_tcp->m_mcc_records, l_mcc_records_size);
        l_tcp->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;


        l_src_mcc_rec = l_default_tcp->m_mcc_records;
        l_dest_mcc_rec = l_tcp->m_mcc_records;

        for (j = 0; j < l_default_tcp->m_nb_max_mcc_records; ++j) {

            if (l_src_mcc_rec->m_decorrelation_array) {
                var_221 = (OPJ_UINT32)(l_src_mcc_rec->m_decorrelation_array -
                                        l_default_tcp->m_mct_records);
                l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + var_221;
            }

            if (l_src_mcc_rec->m_offset_array) {
                var_221 = (OPJ_UINT32)(l_src_mcc_rec->m_offset_array -
                                        l_default_tcp->m_mct_records);
                l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + var_221;
            }

            ++l_src_mcc_rec;
            ++l_dest_mcc_rec;
        }


        memcpy(l_current_tccp, l_default_tcp->tccps, l_tccp_size);


        ++l_tcp;
    }


    p_j2k->m_tcd = (opj_tcd_t*)opj_tcd_create(var_263);
    if (! p_j2k->m_tcd) {
        return var_263;
    }

    if (!opj_tcd_init(p_j2k->m_tcd, l_image, &(p_j2k->m_cp), p_j2k->m_tp)) {
        opj_tcd_destroy(p_j2k->m_tcd);
        p_j2k->m_tcd = 0;
        opj_event_msg(p_manager, EVT_ERROR, "Cannot decode tile, memory error\n");
        return var_263;
    }

    return var_263;
}

static const opj_dec_memory_marker_handler_t * fn_221(
    OPJ_UINT32 var_221)
{
    const opj_dec_memory_marker_handler_t *e;
    for (e = j2k_memory_marker_handler_tab; e->id != 0; ++e) {
        if (e->id == var_221) {
            break;
        }
    }
    return e;
}

void fn_221(opj_j2k_t *p_j2k)
{
    if (p_j2k == 0) {
        return;
    }

    if (p_j2k->m_is_decoder) {

        if (p_j2k->m_specific_param.m_decoder.m_default_tcp != 0) {
            opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);
            opj_free(p_j2k->m_specific_param.m_decoder.m_default_tcp);
            p_j2k->m_specific_param.m_decoder.m_default_tcp = 0;
        }

        if (p_j2k->m_specific_param.m_decoder.m_header_data != 0) {
            opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
            p_j2k->m_specific_param.m_decoder.m_header_data = 0;
            p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;
        }
    } else {

        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
            p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 0;
        }

        if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 0;
            p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 0;
        }

        if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
            opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
            p_j2k->m_specific_param.m_encoder.m_header_tile_data = 0;
            p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
        }
    }

    opj_tcd_destroy(p_j2k->m_tcd);

    opj_j2k_cp_destroy(&(p_j2k->m_cp));
    memset(&(p_j2k->m_cp), 0, sizeof(opj_cp_t));

    opj_procedure_list_destroy(p_j2k->m_procedure_list);
    p_j2k->m_procedure_list = 0;

    opj_procedure_list_destroy(p_j2k->m_validation_list);
    p_j2k->m_procedure_list = 0;

    j2k_destroy_cstr_index(p_j2k->cstr_index);
    p_j2k->cstr_index = NULL;

    opj_image_destroy(p_j2k->m_private_image);
    p_j2k->m_private_image = NULL;

    opj_image_destroy(p_j2k->m_output_image);
    p_j2k->m_output_image = NULL;

    opj_thread_pool_destroy(p_j2k->m_tp);
    p_j2k->m_tp = NULL;

    opj_free(p_j2k);
}

void fn_222(opj_codestream_index_t *p_cstr_ind)
{
    if (p_cstr_ind) {

        if (p_cstr_ind->marker) {
            opj_free(p_cstr_ind->marker);
            p_cstr_ind->marker = NULL;
        }

        if (p_cstr_ind->tile_index) {
            OPJ_UINT32 var_244 = 0;

            for (var_244 = 0; var_244 < p_cstr_ind->nb_of_tiles; var_244++) {

                if (p_cstr_ind->tile_index[var_244].packet_index) {
                    opj_free(p_cstr_ind->tile_index[var_244].packet_index);
                    p_cstr_ind->tile_index[var_244].packet_index = NULL;
                }

                if (p_cstr_ind->tile_index[var_244].tp_index) {
                    opj_free(p_cstr_ind->tile_index[var_244].tp_index);
                    p_cstr_ind->tile_index[var_244].tp_index = NULL;
                }

                if (p_cstr_ind->tile_index[var_244].marker) {
                    opj_free(p_cstr_ind->tile_index[var_244].marker);
                    p_cstr_ind->tile_index[var_244].marker = NULL;

                }
            }

            opj_free(p_cstr_ind->tile_index);
            p_cstr_ind->tile_index = NULL;
        }

        opj_free(p_cstr_ind);
    }
}

static void fn_224(opj_tcp_t *p_tcp)
{
    if (p_tcp == 0) {
        return;
    }

    if (p_tcp->ppt_markers != 0) {
        OPJ_UINT32 i;
        for (i = 0U; i < p_tcp->ppt_markers_count; ++i) {
            if (p_tcp->ppt_markers[i].m_data != NULL) {
                opj_free(p_tcp->ppt_markers[i].m_data);
            }
        }
        p_tcp->ppt_markers_count = 0U;
        opj_free(p_tcp->ppt_markers);
        p_tcp->ppt_markers = NULL;
    }

    if (p_tcp->ppt_buffer != 0) {
        opj_free(p_tcp->ppt_buffer);
        p_tcp->ppt_buffer = 0;
    }

    if (p_tcp->tccps != 0) {
        opj_free(p_tcp->tccps);
        p_tcp->tccps = 0;
    }

    if (p_tcp->m_mct_coding_matrix != 0) {
        opj_free(p_tcp->m_mct_coding_matrix);
        p_tcp->m_mct_coding_matrix = 0;
    }

    if (p_tcp->m_mct_decoding_matrix != 0) {
        opj_free(p_tcp->m_mct_decoding_matrix);
        p_tcp->m_mct_decoding_matrix = 0;
    }

    if (p_tcp->m_mcc_records) {
        opj_free(p_tcp->m_mcc_records);
        p_tcp->m_mcc_records = 0;
        p_tcp->m_nb_max_mcc_records = 0;
        p_tcp->m_nb_mcc_records = 0;
    }

    if (p_tcp->m_mct_records) {
        opj_mct_data_t * l_mct_data = p_tcp->m_mct_records;
        OPJ_UINT32 i;

        for (i = 0; i < p_tcp->m_nb_mct_records; ++i) {
            if (l_mct_data->m_data) {
                opj_free(l_mct_data->m_data);
                l_mct_data->m_data = 0;
            }

            ++l_mct_data;
        }

        opj_free(p_tcp->m_mct_records);
        p_tcp->m_mct_records = 0;
    }

    if (p_tcp->mct_norms != 0) {
        opj_free(p_tcp->mct_norms);
        p_tcp->mct_norms = 0;
    }

    opj_j2k_tcp_data_destroy(p_tcp);

}

static void fn_224(opj_tcp_t *p_tcp)
{
    if (p_tcp->m_data) {
        opj_free(p_tcp->m_data);
        p_tcp->m_data = NULL;
        p_tcp->m_data_size = 0;
    }
}

static void fn_224(opj_cp_t *p_cp)
{
    OPJ_UINT32 var_258;
    opj_tcp_t * l_current_tile = 0;

    if (p_cp == 0) {
        return;
    }
    if (p_cp->tcps != 0) {
        OPJ_UINT32 i;
        l_current_tile = p_cp->tcps;
        var_258 = p_cp->th * p_cp->tw;

        for (i = 0U; i < var_258; ++i) {
            opj_j2k_tcp_destroy(l_current_tile);
            ++l_current_tile;
        }
        opj_free(p_cp->tcps);
        p_cp->tcps = 0;
    }
    if (p_cp->ppm_markers != 0) {
        OPJ_UINT32 i;
        for (i = 0U; i < p_cp->ppm_markers_count; ++i) {
            if (p_cp->ppm_markers[i].m_data != NULL) {
                opj_free(p_cp->ppm_markers[i].m_data);
            }
        }
        p_cp->ppm_markers_count = 0U;
        opj_free(p_cp->ppm_markers);
        p_cp->ppm_markers = NULL;
    }
    opj_free(p_cp->ppm_buffer);
    p_cp->ppm_buffer = 0;
    p_cp->ppm_data =
        NULL;
    opj_free(p_cp->comment);
    p_cp->comment = 0;
    if (! p_cp->m_is_decoder) {
        opj_free(p_cp->m_specific_param.m_enc.m_matrice);
        p_cp->m_specific_param.m_enc.m_matrice = 0;
    }
}

static OPJ_BOOL fn_224(opj_stream_private_t
        *p_stream, OPJ_UINT32 var_224, OPJ_BOOL* p_correction_needed,
        opj_event_mgr_t * p_manager)
{
    OPJ_BYTE l_header_data[10];
    OPJ_OFF_T l_stream_pos_backup;
    OPJ_UINT32 var_228;
    OPJ_UINT32 l_marker_size;
    OPJ_UINT32 l_tile_no, l_tot_len, l_current_part, var_224;


    *p_correction_needed = var_263;

    if (!opj_stream_has_seek(p_stream)) {

        return var_263;
    }

    l_stream_pos_backup = opj_stream_tell(p_stream);
    if (l_stream_pos_backup == -1) {

        return var_263;
    }

    for (;;) {

        if (opj_stream_read_data(p_stream, l_header_data, 2, p_manager) != 2) {

            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {
                return var_263;
            }
            return var_263;
        }


        opj_read_bytes(l_header_data, &var_228, 2);

        if (var_228 != var_228) {

            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {
                return var_263;
            }
            return var_263;
        }


        if (opj_stream_read_data(p_stream, l_header_data, 2, p_manager) != 2) {
            opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
            return var_263;
        }


        opj_read_bytes(l_header_data, &l_marker_size, 2);


        if (l_marker_size != 10) {
            opj_event_msg(p_manager, EVT_ERROR, "Inconsistent marker size\n");
            return var_263;
        }
        l_marker_size -= 2;

        if (opj_stream_read_data(p_stream, l_header_data, l_marker_size,
                                 p_manager) != l_marker_size) {
            opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
            return var_263;
        }

        if (! opj_j2k_get_sot_values(l_header_data, l_marker_size, &l_tile_no,
                                     &l_tot_len, &l_current_part, &var_224, p_manager)) {
            return var_263;
        }

        if (l_tile_no == var_224) {

            break;
        }

        if ((l_tot_len == 0U) || (l_tot_len < 14U)) {


            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {
                return var_263;
            }
            return var_263;
        }
        l_tot_len -= 12U;

        if (opj_stream_skip(p_stream, (OPJ_OFF_T)(l_tot_len),
                            p_manager) != (OPJ_OFF_T)(l_tot_len)) {

            if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {
                return var_263;
            }
            return var_263;
        }
    }


    if (l_current_part == var_224) {
        *p_correction_needed = var_263;
    }

    if (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {
        return var_263;
    }
    return var_263;
}

OPJ_BOOL fn_224(opj_j2k_t * p_j2k,
                                  OPJ_UINT32 * var_263,
                                  OPJ_UINT32 * var_263,
                                  OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,
                                  OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,
                                  OPJ_UINT32 * p_nb_comps,
                                  OPJ_BOOL * p_go_on,
                                  opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 var_228 = var_228;
    OPJ_UINT32 l_marker_size;
    const opj_dec_memory_marker_handler_t * l_marker_handler = 0;
    opj_tcp_t * l_tcp = NULL;


    assert(p_stream != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);


    if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC) {
        var_228 = J2K_MS_EOC;
    }

    else if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) {
        return var_263;
    }


    while ((!p_j2k->m_specific_param.m_decoder.m_can_decode) &&
            (var_228 != J2K_MS_EOC)) {


        while (var_228 != J2K_MS_SOD) {

            if (opj_stream_get_number_byte_left(p_stream) == 0) {
                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
                break;
            }


            if (opj_stream_read_data(p_stream,
                                     p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {
                opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
                return var_263;
            }


            opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data, &l_marker_size,
                           2);


            if (l_marker_size < 2) {
                opj_event_msg(p_manager, EVT_ERROR, "Inconsistent marker size\n");
                return var_263;
            }


            if (var_228 == 0x8080 &&
                    opj_stream_get_number_byte_left(p_stream) == 0) {
                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
                break;
            }


            if (p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_TPH) {
                p_j2k->m_specific_param.m_decoder.m_sot_length -= (l_marker_size + 2);
            }
            l_marker_size -= 2;


            l_marker_handler = opj_j2k_get_marker_handler(var_228);


            if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "Marker is not compliant with its position\n");
                return var_263;
            }



            if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
                OPJ_BYTE *new_header_data = NULL;


                if ((OPJ_OFF_T)l_marker_size > opj_stream_get_number_byte_left(p_stream)) {
                    opj_event_msg(p_manager, EVT_ERROR,
                                  "Marker size inconsistent with stream length\n");
                    return var_263;
                }
                new_header_data = (OPJ_BYTE *) opj_realloc(
                                      p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);
                if (! new_header_data) {
                    opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
                    p_j2k->m_specific_param.m_decoder.m_header_data = NULL;
                    p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;
                    opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read header\n");
                    return var_263;
                }
                p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
                p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
            }


            if (opj_stream_read_data(p_stream,
                                     p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size,
                                     p_manager) != l_marker_size) {
                opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
                return var_263;
            }

            if (!l_marker_handler->handler) {

                opj_event_msg(p_manager, EVT_ERROR, "Not sure how that happened.\n");
                return var_263;
            }

            if (!(*(l_marker_handler->handler))(p_j2k,
                                                p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size, p_manager)) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "Fail to read the current marker segment (%#x)\n", var_228);
                return var_263;
            }


            if (var_263 == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,
                                                  p_j2k->cstr_index,
                                                  l_marker_handler->id,
                                                  (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,
                                                  l_marker_size + 4)) {
                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add tl marker\n");
                return var_263;
            }


            if (l_marker_handler->id == var_228) {
                OPJ_UINT32 var_227 = (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4
                                     ;
                if (var_227 > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {
                    p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = var_227;
                }
            }

            if (p_j2k->m_specific_param.m_decoder.m_skip_data) {

                if (opj_stream_skip(p_stream, p_j2k->m_specific_param.m_decoder.m_sot_length,
                                    p_manager) != p_j2k->m_specific_param.m_decoder.m_sot_length) {
                    opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
                    return var_263;
                }
                var_228 = J2K_MS_SOD;
            } else {

                if (opj_stream_read_data(p_stream,
                                         p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {
                    opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
                    return var_263;
                }

                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,
                               &var_228, 2);
            }
        }
        if (opj_stream_get_number_byte_left(p_stream) == 0
                && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {
            break;
        }


        if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {

            if (! opj_j2k_read_sod(p_j2k, p_stream, p_manager)) {
                return var_263;
            }
            if (p_j2k->m_specific_param.m_decoder.m_can_decode &&
                    !p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {

                OPJ_BOOL l_correction_needed;

                p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;
                if (!opj_j2k_need_nb_tile_parts_correction(p_stream,
                        p_j2k->m_current_tile_number, &l_correction_needed, p_manager)) {
                    opj_event_msg(p_manager, EVT_ERROR,
                                  "opj_j2k_apply_nb_tile_parts_correction error\n");
                    return var_263;
                }
                if (l_correction_needed) {
                    OPJ_UINT32 var_258 = p_j2k->m_cp.tw * p_j2k->m_cp.th;
                    OPJ_UINT32 l_tile_no;

                    p_j2k->m_specific_param.m_decoder.m_can_decode = 0;
                    p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = 1;

                    for (l_tile_no = 0U; l_tile_no < var_258; ++l_tile_no) {
                        if (p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts != 0U) {
                            p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts += 1;
                        }
                    }
                    opj_event_msg(p_manager, EVT_WARNING,
                                  "Non conformant codestream TPsot==TNsot.\n");
                }
            }
            if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {

                if (opj_stream_read_data(p_stream,
                                         p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {
                    opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
                    return var_263;
                }


                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,
                               &var_228, 2);
            }
        } else {

            p_j2k->m_specific_param.m_decoder.m_skip_data = 0;
            p_j2k->m_specific_param.m_decoder.m_can_decode = 0;
            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;


            if (opj_stream_read_data(p_stream,
                                     p_j2k->m_specific_param.m_decoder.m_header_data, 2, p_manager) != 2) {
                opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
                return var_263;
            }


            opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,
                           &var_228, 2);
        }
    }


    if (var_228 == J2K_MS_EOC) {
        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;
    }


    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
        OPJ_UINT32 var_258 = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;

        while ((p_j2k->m_current_tile_number < var_258) && (l_tcp->m_data == 0)) {
            ++p_j2k->m_current_tile_number;
            ++l_tcp;
        }

        if (p_j2k->m_current_tile_number == var_258) {
            *p_go_on = var_263;
            return var_263;
        }
    }

    if (! opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number,
                            p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Failed to merge PPT data\n");
        return var_263;
    }

    if (! opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,
                                   p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, "Cannot decode tile, memory error\n");
        return var_263;
    }

    opj_event_msg(p_manager, EVT_INFO, "Header of tile %d / %d has been read.\n",
                  p_j2k->m_current_tile_number + 1, (p_j2k->m_cp.th * p_j2k->m_cp.tw));

    *var_263 = p_j2k->m_current_tile_number;
    *p_go_on = var_263;
    *var_263 = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);
    if (*var_263 == UINT_MAX) {
        return var_263;
    }
    *p_tile_x0 = p_j2k->m_tcd->tcd_image->tiles->x0;
    *p_tile_y0 = p_j2k->m_tcd->tcd_image->tiles->y0;
    *p_tile_x1 = p_j2k->m_tcd->tcd_image->tiles->x1;
    *p_tile_y1 = p_j2k->m_tcd->tcd_image->tiles->y1;
    *p_nb_comps = p_j2k->m_tcd->tcd_image->tiles->numcomps;

    p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_DATA;

    return var_263;
}

OPJ_BOOL fn_227(opj_j2k_t * p_j2k,
                             OPJ_UINT32 var_263,
                             OPJ_BYTE * p_data,
                             OPJ_UINT32 var_263,
                             opj_stream_private_t *p_stream,
                             opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 var_228;
    OPJ_BYTE l_data [2];
    opj_tcp_t * l_tcp;


    assert(p_stream != 0);
    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (!(p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_DATA)
            || (var_263 != p_j2k->m_current_tile_number)) {
        return var_263;
    }

    l_tcp = &(p_j2k->m_cp.tcps[var_263]);
    if (! l_tcp->m_data) {
        opj_j2k_tcp_destroy(l_tcp);
        return var_263;
    }

    if (! opj_tcd_decode_tile(p_j2k->m_tcd,
                              l_tcp->m_data,
                              l_tcp->m_data_size,
                              var_263,
                              p_j2k->cstr_index, p_manager)) {
        opj_j2k_tcp_destroy(l_tcp);
        p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_ERR;
        opj_event_msg(p_manager, EVT_ERROR, "Failed to decode.\n");
        return var_263;
    }




    if (p_data != NULL) {
        if (! opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, var_263)) {
            return var_263;
        }





        opj_j2k_tcp_data_destroy(l_tcp);
    }

    p_j2k->m_specific_param.m_decoder.m_can_decode = 0;
    p_j2k->m_specific_param.m_decoder.m_state &= (~(OPJ_UINT32)J2K_STATE_DATA);

    if (opj_stream_get_number_byte_left(p_stream) == 0
            && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {
        return var_263;
    }

    if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_EOC) {
        if (opj_stream_read_data(p_stream, l_data, 2, p_manager) != 2) {
            opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
            return var_263;
        }

        opj_read_bytes(l_data, &var_228, 2);

        if (var_228 == J2K_MS_EOC) {
            p_j2k->m_current_tile_number = 0;
            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;
        } else if (var_228 != var_228) {
            if (opj_stream_get_number_byte_left(p_stream) == 0) {
                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
                opj_event_msg(p_manager, EVT_WARNING, "Stream does not end with EOC\n");
                return var_263;
            }
            opj_event_msg(p_manager, EVT_ERROR, "Stream too short, expected SOT\n");
            return var_263;
        }
    }

    return var_263;
}

static OPJ_BOOL fn_228(opj_tcd_t * p_tcd, OPJ_BYTE * p_data,
        opj_image_t* p_output_image)
{
    OPJ_UINT32 i, j, var_260 = 0;
    OPJ_UINT32 l_width_src, l_height_src;
    OPJ_UINT32 l_width_dest, l_height_dest;
    OPJ_INT32 l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src;
    OPJ_SIZE_T l_start_offset_src, l_line_offset_src, l_end_offset_src ;
    OPJ_UINT32 l_start_x_dest, l_start_y_dest;
    OPJ_UINT32 l_x0_dest, l_y0_dest, l_x1_dest, l_y1_dest;
    OPJ_SIZE_T l_start_offset_dest, l_line_offset_dest;

    opj_image_comp_t * l_img_comp_src = 0;
    opj_image_comp_t * l_img_comp_dest = 0;

    opj_tcd_tilecomp_t * l_tilec = 0;
    opj_image_t * l_image_src = 0;
    OPJ_UINT32 l_size_comp, l_remaining;
    OPJ_INT32 * l_dest_ptr;
    opj_tcd_resolution_t* l_res = 0;

    l_tilec = p_tcd->tcd_image->tiles->comps;
    l_image_src = p_tcd->image;
    l_img_comp_src = l_image_src->comps;

    l_img_comp_dest = p_output_image->comps;

    for (i = 0; i < l_image_src->numcomps; i++) {


        if (!l_img_comp_dest->data) {
            OPJ_SIZE_T var_260 = l_img_comp_dest->w;
            OPJ_SIZE_T var_260 = l_img_comp_dest->h;

            if ((var_260 == 0U) || (var_260 > (SIZE_MAX / var_260)) ||
                    var_260 * var_260 > SIZE_MAX / sizeof(OPJ_INT32)) {

                return var_263;
            }
            l_img_comp_dest->data = (OPJ_INT32*) opj_image_data_alloc(var_260 * var_260 *
                                    sizeof(OPJ_INT32));
            if (! l_img_comp_dest->data) {
                return var_263;
            }

            memset(l_img_comp_dest->data, 0, var_260 * var_260 * sizeof(OPJ_INT32));
        }


        l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;



        l_size_comp = l_img_comp_src->prec >> 3;
        l_remaining = l_img_comp_src->prec & 7;
        l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;

        if (l_remaining) {
            ++l_size_comp;
        }

        if (l_size_comp == 3) {
            l_size_comp = 4;
        }

        l_width_src = (OPJ_UINT32)(l_res->x1 - l_res->x0);
        l_height_src = (OPJ_UINT32)(l_res->y1 - l_res->y0);


        l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);
        l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);
        l_x1_dest = l_x0_dest +
                    l_img_comp_dest->w;
        l_y1_dest = l_y0_dest + l_img_comp_dest->h;

        assert(l_res->x0 >= 0);
        assert(l_res->x1 >= 0);
        if (l_x0_dest < (OPJ_UINT32)l_res->x0) {
            l_start_x_dest = (OPJ_UINT32)l_res->x0 - l_x0_dest;
            l_offset_x0_src = 0;

            if (l_x1_dest >= (OPJ_UINT32)l_res->x1) {
                l_width_dest = l_width_src;
                l_offset_x1_src = 0;
            } else {
                l_width_dest = l_x1_dest - (OPJ_UINT32)l_res->x0 ;
                l_offset_x1_src = (OPJ_INT32)(l_width_src - l_width_dest);
            }
        } else {
            l_start_x_dest = 0U;
            l_offset_x0_src = (OPJ_INT32)l_x0_dest - l_res->x0;

            if (l_x1_dest >= (OPJ_UINT32)l_res->x1) {
                l_width_dest = l_width_src - (OPJ_UINT32)l_offset_x0_src;
                l_offset_x1_src = 0;
            } else {
                l_width_dest = l_img_comp_dest->w ;
                l_offset_x1_src = l_res->x1 - (OPJ_INT32)l_x1_dest;
            }
        }

        if (l_y0_dest < (OPJ_UINT32)l_res->y0) {
            l_start_y_dest = (OPJ_UINT32)l_res->y0 - l_y0_dest;
            l_offset_y0_src = 0;

            if (l_y1_dest >= (OPJ_UINT32)l_res->y1) {
                l_height_dest = l_height_src;
                l_offset_y1_src = 0;
            } else {
                l_height_dest = l_y1_dest - (OPJ_UINT32)l_res->y0 ;
                l_offset_y1_src = (OPJ_INT32)(l_height_src - l_height_dest);
            }
        } else {
            l_start_y_dest = 0U;
            l_offset_y0_src = (OPJ_INT32)l_y0_dest - l_res->y0;

            if (l_y1_dest >= (OPJ_UINT32)l_res->y1) {
                l_height_dest = l_height_src - (OPJ_UINT32)l_offset_y0_src;
                l_offset_y1_src = 0;
            } else {
                l_height_dest = l_img_comp_dest->h ;
                l_offset_y1_src = l_res->y1 - (OPJ_INT32)l_y1_dest;
            }
        }

        if ((l_offset_x0_src < 0) || (l_offset_y0_src < 0) || (l_offset_x1_src < 0) ||
                (l_offset_y1_src < 0)) {
            return var_263;
        }

        if ((OPJ_INT32)l_width_dest < 0 || (OPJ_INT32)l_height_dest < 0) {
            return var_263;
        }



        l_start_offset_src = (OPJ_SIZE_T)l_offset_x0_src + (OPJ_SIZE_T)l_offset_y0_src
                             * (OPJ_SIZE_T)l_width_src;
        l_line_offset_src = (OPJ_SIZE_T)l_offset_x1_src + (OPJ_SIZE_T)l_offset_x0_src;
        l_end_offset_src = (OPJ_SIZE_T)l_offset_y1_src * (OPJ_SIZE_T)l_width_src -
                             (OPJ_SIZE_T)l_offset_x0_src;


        l_start_offset_dest = (OPJ_SIZE_T)l_start_x_dest + (OPJ_SIZE_T)l_start_y_dest
                              * (OPJ_SIZE_T)l_img_comp_dest->w;
        l_line_offset_dest = (OPJ_SIZE_T)l_img_comp_dest->w - (OPJ_SIZE_T)l_width_dest;


        l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;

        switch (l_size_comp) {
        case 1: {
            OPJ_CHAR * l_src_ptr = (OPJ_CHAR*) p_data;
            l_src_ptr += l_start_offset_src;

            if (l_img_comp_src->sgnd) {
                for (j = 0 ; j < l_height_dest ; ++j) {
                    for (var_260 = 0 ; var_260 < l_width_dest ; ++var_260) {
                        *(l_dest_ptr++) = (OPJ_INT32)(*
                                                      (l_src_ptr++));
                    }

                    l_dest_ptr +=
                        l_line_offset_dest;
                    l_src_ptr += l_line_offset_src ;
                }
            } else {
                for (j = 0 ; j < l_height_dest ; ++j) {
                    for (var_260 = 0 ; var_260 < l_width_dest ; ++var_260) {
                        *(l_dest_ptr++) = (OPJ_INT32)((*(l_src_ptr++)) & 0xff);
                    }

                    l_dest_ptr += l_line_offset_dest;
                    l_src_ptr += l_line_offset_src;
                }
            }

            l_src_ptr +=
                l_end_offset_src;
            p_data = (OPJ_BYTE*)
                     l_src_ptr;
        }
        break;
        case 2: {
            OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_data;
            l_src_ptr += l_start_offset_src;

            if (l_img_comp_src->sgnd) {
                for (j = 0; j < l_height_dest; ++j) {
                    for (var_260 = 0; var_260 < l_width_dest; ++var_260) {
                        OPJ_INT16 val;
                        memcpy(&val, l_src_ptr, sizeof(val));
                        l_src_ptr ++;
                        *(l_dest_ptr++) = val;
                    }

                    l_dest_ptr += l_line_offset_dest;
                    l_src_ptr += l_line_offset_src ;
                }
            } else {
                for (j = 0; j < l_height_dest; ++j) {
                    for (var_260 = 0; var_260 < l_width_dest; ++var_260) {
                        OPJ_INT16 val;
                        memcpy(&val, l_src_ptr, sizeof(val));
                        l_src_ptr ++;
                        *(l_dest_ptr++) = val & 0xffff;
                    }

                    l_dest_ptr += l_line_offset_dest;
                    l_src_ptr += l_line_offset_src ;
                }
            }

            l_src_ptr += l_end_offset_src;
            p_data = (OPJ_BYTE*) l_src_ptr;
        }
        break;
        case 4: {
            OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_data;
            l_src_ptr += l_start_offset_src;

            for (j = 0; j < l_height_dest; ++j) {
                memcpy(l_dest_ptr, l_src_ptr, l_width_dest * sizeof(OPJ_INT32));
                l_dest_ptr += l_width_dest + l_line_offset_dest;
                l_src_ptr += l_width_dest + l_line_offset_src ;
            }

            l_src_ptr += l_end_offset_src;
            p_data = (OPJ_BYTE*) l_src_ptr;
        }
        break;
        }

        ++l_img_comp_dest;
        ++l_img_comp_src;
        ++l_tilec;
    }

    return var_263;
}

OPJ_BOOL fn_228(opj_j2k_t *p_j2k,
                                 opj_image_t* p_image,
                                 OPJ_INT32 var_233, OPJ_INT32 var_233,
                                 OPJ_INT32 var_233, OPJ_INT32 var_233,
                                 opj_event_mgr_t * p_manager)
{
    opj_cp_t * l_cp = &(p_j2k->m_cp);
    opj_image_t * l_image = p_j2k->m_private_image;

    OPJ_UINT32 it_comp;
    OPJ_INT32 l_comp_x1, l_comp_y1;
    opj_image_comp_t* l_img_comp = NULL;


    if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Need to decode the main header before begin to decode the remaining codestream");
        return var_263;
    }

    if (!var_233 && !var_233 && !var_233 && !var_233) {
        opj_event_msg(p_manager, EVT_INFO,
                      "No decoded area parameters, set the decoded area to the whole image\n");

        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;
        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;
        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;

        return var_263;
    }





    if (var_233 < 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Left position of the decoded area (region_x0=%d) should be >= 0.\n",
                      var_233);
        return var_263;
    } else if ((OPJ_UINT32)var_233 > l_image->x1) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
                      var_233, l_image->x1);
        return var_263;
    } else if ((OPJ_UINT32)var_233 < l_image->x0) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
                      var_233, l_image->x0);
        p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;
        p_image->x0 = l_image->x0;
    } else {
        p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32)var_233 -
                l_cp->tx0) / l_cp->tdx;
        p_image->x0 = (OPJ_UINT32)var_233;
    }


    if (var_233 < 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Up position of the decoded area (region_y0=%d) should be >= 0.\n",
                      var_233);
        return var_263;
    } else if ((OPJ_UINT32)var_233 > l_image->y1) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\n",
                      var_233, l_image->y1);
        return var_263;
    } else if ((OPJ_UINT32)var_233 < l_image->y0) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\n",
                      var_233, l_image->y0);
        p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;
        p_image->y0 = l_image->y0;
    } else {
        p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32)var_233 -
                l_cp->ty0) / l_cp->tdy;
        p_image->y0 = (OPJ_UINT32)var_233;
    }


    if (var_233 <= 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Right position of the decoded area (region_x1=%d) should be > 0.\n",
                      var_233);
        return var_263;
    } else if ((OPJ_UINT32)var_233 < l_image->x0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n",
                      var_233, l_image->x0);
        return var_263;
    } else if ((OPJ_UINT32)var_233 > l_image->x1) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
                      var_233, l_image->x1);
        p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
        p_image->x1 = l_image->x1;
    } else {
        p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv(
                    var_233 - (OPJ_INT32)l_cp->tx0, (OPJ_INT32)l_cp->tdx);
        p_image->x1 = (OPJ_UINT32)var_233;
    }


    if (var_233 <= 0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Bottom position of the decoded area (region_y1=%d) should be > 0.\n",
                      var_233);
        return var_263;
    } else if ((OPJ_UINT32)var_233 < l_image->y0) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n",
                      var_233, l_image->y0);
        return var_263;
    }
    if ((OPJ_UINT32)var_233 > l_image->y1) {
        opj_event_msg(p_manager, EVT_WARNING,
                      "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n",
                      var_233, l_image->y1);
        p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
        p_image->y1 = l_image->y1;
    } else {
        p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv(
                    var_233 - (OPJ_INT32)l_cp->ty0, (OPJ_INT32)l_cp->tdy);
        p_image->y1 = (OPJ_UINT32)var_233;
    }


    p_j2k->m_specific_param.m_decoder.m_discard_tiles = 1;

    l_img_comp = p_image->comps;
    for (it_comp = 0; it_comp < p_image->numcomps; ++it_comp) {
        OPJ_INT32 l_h, l_w;

        l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,
                         (OPJ_INT32)l_img_comp->dx);
        l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,
                         (OPJ_INT32)l_img_comp->dy);
        l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);
        l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);

        l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)
              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);
        if (l_w < 0) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Size x of the decoded component image is incorrect (comp[%d].w=%d).\n",
                          it_comp, l_w);
            return var_263;
        }
        l_img_comp->w = (OPJ_UINT32)l_w;

        l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)
              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);
        if (l_h < 0) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n",
                          it_comp, l_h);
            return var_263;
        }
        l_img_comp->h = (OPJ_UINT32)l_h;

        l_img_comp++;
    }

    opj_event_msg(p_manager, EVT_INFO, "Setting decoding area to %d,%d,%d,%d\n",
                  p_image->x0, p_image->y0, p_image->x1, p_image->y1);

    return var_263;
}

opj_j2k_t* fn_233(void)
{
    opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
    if (!l_j2k) {
        return 0;
    }

    l_j2k->m_is_decoder = 1;
    l_j2k->m_cp.m_is_decoder = 1;


    l_j2k->m_cp.allow_different_bit_depth_sign = 1;





    l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t*) opj_calloc(1,
            sizeof(opj_tcp_t));
    if (!l_j2k->m_specific_param.m_decoder.m_default_tcp) {
        opj_j2k_destroy(l_j2k);
        return 0;
    }

    l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *) opj_calloc(1,
            OPJ_J2K_DEFAULT_HEADER_SIZE);
    if (! l_j2k->m_specific_param.m_decoder.m_header_data) {
        opj_j2k_destroy(l_j2k);
        return 0;
    }

    l_j2k->m_specific_param.m_decoder.m_header_data_size =
        OPJ_J2K_DEFAULT_HEADER_SIZE;

    l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1 ;

    l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = 0 ;


    l_j2k->cstr_index = opj_j2k_create_cstr_index();
    if (!l_j2k->cstr_index) {
        opj_j2k_destroy(l_j2k);
        return 0;
    }


    l_j2k->m_validation_list = opj_procedure_list_create();
    if (! l_j2k->m_validation_list) {
        opj_j2k_destroy(l_j2k);
        return 0;
    }


    l_j2k->m_procedure_list = opj_procedure_list_create();
    if (! l_j2k->m_procedure_list) {
        opj_j2k_destroy(l_j2k);
        return 0;
    }

    l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());
    if (!l_j2k->m_tp) {
        l_j2k->m_tp = opj_thread_pool_create(0);
    }
    if (!l_j2k->m_tp) {
        opj_j2k_destroy(l_j2k);
        return NULL;
    }

    return l_j2k;
}

static opj_codestream_index_t* fn_234(void)
{
    opj_codestream_index_t* cstr_index = (opj_codestream_index_t*)
                                         opj_calloc(1, sizeof(opj_codestream_index_t));
    if (!cstr_index) {
        return NULL;
    }

    cstr_index->maxmarknum = 100;
    cstr_index->marknum = 0;
    cstr_index->marker = (opj_marker_info_t*)
                         opj_calloc(cstr_index->maxmarknum, sizeof(opj_marker_info_t));
    if (!cstr_index-> marker) {
        opj_free(cstr_index);
        return NULL;
    }

    cstr_index->tile_index = NULL;

    return cstr_index;
}

static OPJ_UINT32 fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234,
        OPJ_UINT32 var_234)
{
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    opj_tccp_t *l_tccp = 0;


    assert(p_j2k != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[var_234];
    l_tccp = &l_tcp->tccps[var_234];


    assert(var_234 < (l_cp->tw * l_cp->th));
    assert(var_234 < p_j2k->m_private_image->numcomps);

    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {
        return 5 + l_tccp->numresolutions;
    } else {
        return 5;
    }
}

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234, OPJ_UINT32 var_234, OPJ_UINT32 var_234)
{
    OPJ_UINT32 i;
    opj_cp_t *l_cp = NULL;
    opj_tcp_t *l_tcp = NULL;
    opj_tccp_t *l_tccp0 = NULL;
    opj_tccp_t *l_tccp1 = NULL;


    assert(p_j2k != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[var_234];
    l_tccp0 = &l_tcp->tccps[var_234];
    l_tccp1 = &l_tcp->tccps[var_234];

    if (l_tccp0->numresolutions != l_tccp1->numresolutions) {
        return var_263;
    }
    if (l_tccp0->cblkw != l_tccp1->cblkw) {
        return var_263;
    }
    if (l_tccp0->cblkh != l_tccp1->cblkh) {
        return var_263;
    }
    if (l_tccp0->cblksty != l_tccp1->cblksty) {
        return var_263;
    }
    if (l_tccp0->qmfbid != l_tccp1->qmfbid) {
        return var_263;
    }
    if ((l_tccp0->csty & J2K_CCP_CSTY_PRT) != (l_tccp1->csty & J2K_CCP_CSTY_PRT)) {
        return var_263;
    }

    for (i = 0U; i < l_tccp0->numresolutions; ++i) {
        if (l_tccp0->prcw[i] != l_tccp1->prcw[i]) {
            return var_263;
        }
        if (l_tccp0->prch[i] != l_tccp1->prch[i]) {
            return var_263;
        }
    }
    return var_263;
}

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234,
        OPJ_UINT32 var_234,
        OPJ_BYTE * p_data,
        OPJ_UINT32 * var_234,
        struct struct_262 * p_manager)
{
    OPJ_UINT32 i;
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    opj_tccp_t *l_tccp = 0;


    assert(p_j2k != 0);
    assert(var_234 != 0);
    assert(p_manager != 0);
    assert(p_data != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[var_234];
    l_tccp = &l_tcp->tccps[var_234];


    assert(var_234 < (l_cp->tw * l_cp->th));
    assert(var_234 < (p_j2k->m_private_image->numcomps));

    if (*var_234 < 5) {
        opj_event_msg(p_manager, EVT_ERROR, "Error writing SPCod SPCoc element\n");
        return var_263;
    }

    opj_write_bytes(p_data, l_tccp->numresolutions - 1, 1);
    ++p_data;

    opj_write_bytes(p_data, l_tccp->cblkw - 2, 1);
    ++p_data;

    opj_write_bytes(p_data, l_tccp->cblkh - 2, 1);
    ++p_data;

    opj_write_bytes(p_data, l_tccp->cblksty,
                    1);
    ++p_data;

    opj_write_bytes(p_data, l_tccp->qmfbid,
                    1);
    ++p_data;

    *var_234 = *var_234 - 5;

    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {

        if (*var_234 < l_tccp->numresolutions) {
            opj_event_msg(p_manager, EVT_ERROR, "Error writing SPCod SPCoc element\n");
            return var_263;
        }

        for (i = 0; i < l_tccp->numresolutions; ++i) {
            opj_write_bytes(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4),
                            1);
            ++p_data;
        }

        *var_234 = *var_234 - l_tccp->numresolutions;
    }

    return var_263;
}

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_252,
        OPJ_BYTE * p_header_data,
        OPJ_UINT32 * var_234,
        opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 i, l_tmp;
    opj_cp_t *l_cp = NULL;
    opj_tcp_t *l_tcp = NULL;
    opj_tccp_t *l_tccp = NULL;
    OPJ_BYTE * l_current_ptr = NULL;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_header_data != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
            &l_cp->tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;


    assert(var_252 < p_j2k->m_private_image->numcomps);

    l_tccp = &l_tcp->tccps[var_252];
    l_current_ptr = p_header_data;


    if (*var_234 < 5) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading SPCod SPCoc element\n");
        return var_263;
    }

    opj_read_bytes(l_current_ptr, &l_tccp->numresolutions,
                   1);
    ++l_tccp->numresolutions;
    if (l_tccp->numresolutions > OPJ_J2K_MAXRLVLS) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
                      l_tccp->numresolutions, OPJ_J2K_MAXRLVLS);
        return var_263;
    }
    ++l_current_ptr;


    if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error decoding component %d.\nThe number of resolutions to remove is higher than the number "
                      "of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                      var_252);
        p_j2k->m_specific_param.m_decoder.m_state |=
            0x8000;
        return var_263;
    }

    opj_read_bytes(l_current_ptr, &l_tccp->cblkw, 1);
    ++l_current_ptr;
    l_tccp->cblkw += 2;

    opj_read_bytes(l_current_ptr, &l_tccp->cblkh, 1);
    ++l_current_ptr;
    l_tccp->cblkh += 2;

    if ((l_tccp->cblkw > 10) || (l_tccp->cblkh > 10) ||
            ((l_tccp->cblkw + l_tccp->cblkh) > 12)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
        return var_263;
    }


    opj_read_bytes(l_current_ptr, &l_tccp->cblksty, 1);
    ++l_current_ptr;
    if (l_tccp->cblksty & 0xC0U) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error reading SPCod SPCoc element, Invalid code-block style found\n");
        return var_263;
    }

    opj_read_bytes(l_current_ptr, &l_tccp->qmfbid, 1);
    ++l_current_ptr;

    *var_234 = *var_234 - 5;


    if (l_tccp->csty & J2K_CCP_CSTY_PRT) {
        if (*var_234 < l_tccp->numresolutions) {
            opj_event_msg(p_manager, EVT_ERROR, "Error reading SPCod SPCoc element\n");
            return var_263;
        }

        for (i = 0; i < l_tccp->numresolutions; ++i) {
            opj_read_bytes(l_current_ptr, &l_tmp, 1);
            ++l_current_ptr;

            if ((i != 0) && (((l_tmp & 0xf) == 0) || ((l_tmp >> 4) == 0))) {
                opj_event_msg(p_manager, EVT_ERROR, "Invalid precinct size\n");
                return var_263;
            }
            l_tccp->prcw[i] = l_tmp & 0xf;
            l_tccp->prch[i] = l_tmp >> 4;
        }

        *var_234 = *var_234 - l_tccp->numresolutions;
    } else {

        for (i = 0; i < l_tccp->numresolutions; ++i) {
            l_tccp->prcw[i] = 15;
            l_tccp->prch[i] = 15;
        }
    }

    return var_263;
}

static void fn_234(opj_j2k_t *p_j2k)
{

    OPJ_UINT32 i;
    opj_cp_t *l_cp = NULL;
    opj_tcp_t *l_tcp = NULL;
    opj_tccp_t *l_ref_tccp = NULL, *l_copied_tccp = NULL;
    OPJ_UINT32 l_prc_size;


    assert(p_j2k != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)
            ?
            &l_cp->tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;

    l_ref_tccp = &l_tcp->tccps[0];
    l_copied_tccp = l_ref_tccp + 1;
    l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32)sizeof(OPJ_UINT32);

    for (i = 1; i < p_j2k->m_private_image->numcomps; ++i) {
        l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
        l_copied_tccp->cblkw = l_ref_tccp->cblkw;
        l_copied_tccp->cblkh = l_ref_tccp->cblkh;
        l_copied_tccp->cblksty = l_ref_tccp->cblksty;
        l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
        memcpy(l_copied_tccp->prcw, l_ref_tccp->prcw, l_prc_size);
        memcpy(l_copied_tccp->prch, l_ref_tccp->prch, l_prc_size);
        ++l_copied_tccp;
    }
}

static OPJ_UINT32 fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234,
        OPJ_UINT32 var_234)
{
    OPJ_UINT32 l_num_bands;

    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    opj_tccp_t *l_tccp = 0;


    assert(p_j2k != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[var_234];
    l_tccp = &l_tcp->tccps[var_234];


    assert(var_234 < l_cp->tw * l_cp->th);
    assert(var_234 < p_j2k->m_private_image->numcomps);

    l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :
                  (l_tccp->numresolutions * 3 - 2);

    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
        return 1 + l_num_bands;
    } else {
        return 1 + 2 * l_num_bands;
    }
}

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_234, OPJ_UINT32 var_234, OPJ_UINT32 var_234)
{
    opj_cp_t *l_cp = NULL;
    opj_tcp_t *l_tcp = NULL;
    opj_tccp_t *l_tccp0 = NULL;
    opj_tccp_t *l_tccp1 = NULL;
    OPJ_UINT32 l_band_no, l_num_bands;


    assert(p_j2k != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[var_234];
    l_tccp0 = &l_tcp->tccps[var_234];
    l_tccp1 = &l_tcp->tccps[var_234];

    if (l_tccp0->qntsty != l_tccp1->qntsty) {
        return var_263;
    }
    if (l_tccp0->numgbits != l_tccp1->numgbits) {
        return var_263;
    }
    if (l_tccp0->qntsty == J2K_CCP_QNTSTY_SIQNT) {
        l_num_bands = 1U;
    } else {
        l_num_bands = l_tccp0->numresolutions * 3U - 2U;
        if (l_num_bands != (l_tccp1->numresolutions * 3U - 2U)) {
            return var_263;
        }
    }

    for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {
        if (l_tccp0->stepsizes[l_band_no].expn != l_tccp1->stepsizes[l_band_no].expn) {
            return var_263;
        }
    }
    if (l_tccp0->qntsty != J2K_CCP_QNTSTY_NOQNT) {
        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {
            if (l_tccp0->stepsizes[l_band_no].mant != l_tccp1->stepsizes[l_band_no].mant) {
                return var_263;
            }
        }
    }
    return var_263;
}


static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
                                        OPJ_UINT32 var_234,
                                        OPJ_UINT32 var_234,
                                        OPJ_BYTE * p_data,
                                        OPJ_UINT32 * var_234,
                                        struct struct_262 * p_manager)
{
    OPJ_UINT32 l_header_size;
    OPJ_UINT32 l_band_no, l_num_bands;
    OPJ_UINT32 l_expn, l_mant;

    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    opj_tccp_t *l_tccp = 0;


    assert(p_j2k != 0);
    assert(var_234 != 0);
    assert(p_manager != 0);
    assert(p_data != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = &l_cp->tcps[var_234];
    l_tccp = &l_tcp->tccps[var_234];


    assert(var_234 < l_cp->tw * l_cp->th);
    assert(var_234 < p_j2k->m_private_image->numcomps);

    l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :
                  (l_tccp->numresolutions * 3 - 2);

    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
        l_header_size = 1 + l_num_bands;

        if (*var_234 < l_header_size) {
            opj_event_msg(p_manager, EVT_ERROR, "Error writing SQcd SQcc element\n");
            return var_263;
        }

        opj_write_bytes(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5),
                        1);
        ++p_data;

        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {
            l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;
            opj_write_bytes(p_data, l_expn << 3, 1);
            ++p_data;
        }
    } else {
        l_header_size = 1 + 2 * l_num_bands;

        if (*var_234 < l_header_size) {
            opj_event_msg(p_manager, EVT_ERROR, "Error writing SQcd SQcc element\n");
            return var_263;
        }

        opj_write_bytes(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5),
                        1);
        ++p_data;

        for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {
            l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;
            l_mant = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].mant;

            opj_write_bytes(p_data, (l_expn << 11) + l_mant, 2);
            p_data += 2;
        }
    }

    *var_234 = *var_234 - l_header_size;

    return var_263;
}

static OPJ_BOOL fn_234(opj_j2k_t *p_j2k,
                                       OPJ_UINT32 var_234,
                                       OPJ_BYTE* p_header_data,
                                       OPJ_UINT32 * var_234,
                                       opj_event_mgr_t * p_manager
                                      )
{

    OPJ_UINT32 l_band_no;
    opj_cp_t *l_cp = 0;
    opj_tcp_t *l_tcp = 0;
    opj_tccp_t *l_tccp = 0;
    OPJ_BYTE * l_current_ptr = 0;
    OPJ_UINT32 l_tmp, l_num_band;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_header_data != 0);

    l_cp = &(p_j2k->m_cp);

    l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH)
            ?
            &l_cp->tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;


    assert(var_234 < p_j2k->m_private_image->numcomps);

    l_tccp = &l_tcp->tccps[var_234];
    l_current_ptr = p_header_data;

    if (*var_234 < 1) {
        opj_event_msg(p_manager, EVT_ERROR, "Error reading SQcd or SQcc element\n");
        return var_263;
    }
    *var_234 -= 1;

    opj_read_bytes(l_current_ptr, &l_tmp, 1);
    ++l_current_ptr;

    l_tccp->qntsty = l_tmp & 0x1f;
    l_tccp->numgbits = l_tmp >> 5;
    if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
        l_num_band = 1;
    } else {
        l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?
                     (*var_234) :
                     (*var_234) / 2;

        if (l_num_band > OPJ_J2K_MAXBANDS) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "While reading CCP_QNTSTY element inside QCD or QCC marker segment, "
                          "number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to "
                          "OPJ_J2K_MAXBANDS (%d) and skip the rest. \n", l_num_band, OPJ_J2K_MAXBANDS,
                          OPJ_J2K_MAXBANDS);

        }
    }

    if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
        for (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {
            opj_read_bytes(l_current_ptr, &l_tmp, 1);
            ++l_current_ptr;
            if (l_band_no < OPJ_J2K_MAXBANDS) {
                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);
                l_tccp->stepsizes[l_band_no].mant = 0;
            }
        }
        *var_234 = *var_234 - l_num_band;
    } else {
        for (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {
            opj_read_bytes(l_current_ptr, &l_tmp, 2);
            l_current_ptr += 2;
            if (l_band_no < OPJ_J2K_MAXBANDS) {
                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);
                l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;
            }
        }
        *var_234 = *var_234 - 2 * l_num_band;
    }


    if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
        for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {
            l_tccp->stepsizes[l_band_no].expn =
                ((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0)
                ?
                (OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;
            l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
        }
    }

    return var_263;
}

static void fn_234(opj_j2k_t *p_j2k)
{
    OPJ_UINT32 i;
    opj_cp_t *l_cp = NULL;
    opj_tcp_t *l_tcp = NULL;
    opj_tccp_t *l_ref_tccp = NULL;
    opj_tccp_t *l_copied_tccp = NULL;
    OPJ_UINT32 l_size;


    assert(p_j2k != 0);

    l_cp = &(p_j2k->m_cp);
    l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?
            &l_cp->tcps[p_j2k->m_current_tile_number] :
            p_j2k->m_specific_param.m_decoder.m_default_tcp;

    l_ref_tccp = &l_tcp->tccps[0];
    l_copied_tccp = l_ref_tccp + 1;
    l_size = OPJ_J2K_MAXBANDS * sizeof(opj_stepsize_t);

    for (i = 1; i < p_j2k->m_private_image->numcomps; ++i) {
        l_copied_tccp->qntsty = l_ref_tccp->qntsty;
        l_copied_tccp->numgbits = l_ref_tccp->numgbits;
        memcpy(l_copied_tccp->stepsizes, l_ref_tccp->stepsizes, l_size);
        ++l_copied_tccp;
    }
}

static void fn_234(opj_tcp_t * l_default_tile,
                                   OPJ_INT32 var_243, FILE* out_stream)
{
    if (l_default_tile) {
        OPJ_INT32 var_252;

        fprintf(out_stream, "\t default tile {\n");
        fprintf(out_stream, "\t\t csty=%#x\n", l_default_tile->csty);
        fprintf(out_stream, "\t\t prg=%#x\n", l_default_tile->prg);
        fprintf(out_stream, "\t\t numlayers=%d\n", l_default_tile->numlayers);
        fprintf(out_stream, "\t\t mct=%x\n", l_default_tile->mct);

        for (var_252 = 0; var_252 < var_243; var_252++) {
            opj_tccp_t *l_tccp = &(l_default_tile->tccps[var_252]);
            OPJ_UINT32 resno;
            OPJ_INT32 bandno, numbands;


            fprintf(out_stream, "\t\t comp %d {\n", var_252);
            fprintf(out_stream, "\t\t\t csty=%#x\n", l_tccp->csty);
            fprintf(out_stream, "\t\t\t numresolutions=%d\n", l_tccp->numresolutions);
            fprintf(out_stream, "\t\t\t cblkw=2^%d\n", l_tccp->cblkw);
            fprintf(out_stream, "\t\t\t cblkh=2^%d\n", l_tccp->cblkh);
            fprintf(out_stream, "\t\t\t cblksty=%#x\n", l_tccp->cblksty);
            fprintf(out_stream, "\t\t\t qmfbid=%d\n", l_tccp->qmfbid);

            fprintf(out_stream, "\t\t\t preccintsize (w,h)=");
            for (resno = 0; resno < l_tccp->numresolutions; resno++) {
                fprintf(out_stream, "(%d,%d) ", l_tccp->prcw[resno], l_tccp->prch[resno]);
            }
            fprintf(out_stream, "\n");


            fprintf(out_stream, "\t\t\t qntsty=%d\n", l_tccp->qntsty);
            fprintf(out_stream, "\t\t\t numgbits=%d\n", l_tccp->numgbits);
            fprintf(out_stream, "\t\t\t stepsizes (m,e)=");
            numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :
                       (OPJ_INT32)l_tccp->numresolutions * 3 - 2;
            for (bandno = 0; bandno < numbands; bandno++) {
                fprintf(out_stream, "(%d,%d) ", l_tccp->stepsizes[bandno].mant,
                        l_tccp->stepsizes[bandno].expn);
            }
            fprintf(out_stream, "\n");


            fprintf(out_stream, "\t\t\t roishift=%d\n", l_tccp->roishift);

            fprintf(out_stream, "\t\t }\n");
        }
        fprintf(out_stream, "\t }\n");
    }
}

void fn_235(opj_j2k_t* p_j2k, OPJ_INT32 var_237, FILE* out_stream)
{

    if ((var_237 & OPJ_JP2_INFO) || (var_237 & OPJ_JP2_IND)) {
        fprintf(out_stream, "Wrong flag\n");
        return;
    }


    if (var_237 & OPJ_IMG_INFO) {
        if (p_j2k->m_private_image) {
            j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);
        }
    }


    if (var_237 & OPJ_J2K_MH_INFO) {
        if (p_j2k->m_private_image) {
            opj_j2k_dump_MH_info(p_j2k, out_stream);
        }
    }

    if (var_237 & OPJ_J2K_TCH_INFO) {
        OPJ_UINT32 var_258 = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        OPJ_UINT32 i;
        opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;
        if (p_j2k->m_private_image) {
            for (i = 0; i < var_258; ++i) {
                opj_j2k_dump_tile_info(l_tcp, (OPJ_INT32)p_j2k->m_private_image->numcomps,
                                       out_stream);
                ++l_tcp;
            }
        }
    }


    if (var_237 & OPJ_J2K_TH_INFO) {

    }


    if (var_237 & OPJ_J2K_MH_IND) {
        opj_j2k_dump_MH_index(p_j2k, out_stream);
    }


    if (var_237 & OPJ_J2K_TH_IND) {

    }

}

static void fn_237(opj_j2k_t* p_j2k, FILE* out_stream)
{
    opj_codestream_index_t* cstr_index = p_j2k->cstr_index;
    OPJ_UINT32 it_marker, var_244, it_tile_part;

    fprintf(out_stream, "Codestream index from main header: {\n");

    fprintf(out_stream, "\t Main header start position=%" PRIi64 "\n"
            "\t Main header end position=%" PRIi64 "\n",
            cstr_index->main_head_start, cstr_index->main_head_end);

    fprintf(out_stream, "\t Marker list: {\n");

    if (cstr_index->marker) {
        for (it_marker = 0; it_marker < cstr_index->marknum ; it_marker++) {
            fprintf(out_stream, "\t\t type=%#x, pos=%" PRIi64 ", len=%d\n",
                    cstr_index->marker[it_marker].type,
                    cstr_index->marker[it_marker].pos,
                    cstr_index->marker[it_marker].len);
        }
    }

    fprintf(out_stream, "\t }\n");

    if (cstr_index->tile_index) {


        OPJ_UINT32 var_238 = 0;
        for (var_244 = 0; var_244 < cstr_index->nb_of_tiles ; var_244++) {
            var_238 += cstr_index->tile_index[var_244].nb_tps;
        }

        if (var_238) {
            fprintf(out_stream, "\t Tile index: {\n");

            for (var_244 = 0; var_244 < cstr_index->nb_of_tiles ; var_244++) {
                OPJ_UINT32 var_239 = cstr_index->tile_index[var_244].nb_tps;

                fprintf(out_stream, "\t\t nb of tile-part in tile [%d]=%d\n", var_244,
                        var_239);

                if (cstr_index->tile_index[var_244].tp_index) {
                    for (it_tile_part = 0; it_tile_part < var_239; it_tile_part++) {
                        fprintf(out_stream, "\t\t\t tile-part[%d]: star_pos=%" PRIi64 ", end_header=%"
                                PRIi64 ", end_pos=%" PRIi64 ".\n",
                                it_tile_part,
                                cstr_index->tile_index[var_244].tp_index[it_tile_part].start_pos,
                                cstr_index->tile_index[var_244].tp_index[it_tile_part].end_header,
                                cstr_index->tile_index[var_244].tp_index[it_tile_part].end_pos);
                    }
                }

                if (cstr_index->tile_index[var_244].marker) {
                    for (it_marker = 0; it_marker < cstr_index->tile_index[var_244].marknum ;
                            it_marker++) {
                        fprintf(out_stream, "\t\t type=%#x, pos=%" PRIi64 ", len=%d\n",
                                cstr_index->tile_index[var_244].marker[it_marker].type,
                                cstr_index->tile_index[var_244].marker[it_marker].pos,
                                cstr_index->tile_index[var_244].marker[it_marker].len);
                    }
                }
            }
            fprintf(out_stream, "\t }\n");
        }
    }

    fprintf(out_stream, "}\n");

}


static void fn_239(opj_j2k_t* p_j2k, FILE* out_stream)
{

    fprintf(out_stream, "Codestream info from main header: {\n");

    fprintf(out_stream, "\t tx0=%d, ty0=%d\n", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);
    fprintf(out_stream, "\t tdx=%d, tdy=%d\n", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);
    fprintf(out_stream, "\t tw=%d, th=%d\n", p_j2k->m_cp.tw, p_j2k->m_cp.th);
    opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp,
                           (OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);
    fprintf(out_stream, "}\n");
}

void fn_239(opj_image_t* img_header, OPJ_BOOL var_242,
                           FILE* out_stream)
{
    char tab[2];

    if (var_242) {
        fprintf(stdout, "[DEV] Dump an image_header struct {\n");
        tab[0] = '\0';
    } else {
        fprintf(out_stream, "Image info {\n");
        tab[0] = '\t';
        tab[1] = '\0';
    }

    fprintf(out_stream, "%s x0=%d, y0=%d\n", tab, img_header->x0, img_header->y0);
    fprintf(out_stream, "%s x1=%d, y1=%d\n", tab, img_header->x1,
            img_header->y1);
    fprintf(out_stream, "%s numcomps=%d\n", tab, img_header->numcomps);

    if (img_header->comps) {
        OPJ_UINT32 var_252;
        for (var_252 = 0; var_252 < img_header->numcomps; var_252++) {
            fprintf(out_stream, "%s\t component %d {\n", tab, var_252);
            j2k_dump_image_comp_header(&(img_header->comps[var_252]), var_242,
                                       out_stream);
            fprintf(out_stream, "%s}\n", tab);
        }
    }

    fprintf(out_stream, "}\n");
}

void fn_241(opj_image_comp_t* comp_header,
                                OPJ_BOOL var_242, FILE* out_stream)
{
    char tab[3];

    if (var_242) {
        fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
        tab[0] = '\0';
    } else {
        tab[0] = '\t';
        tab[1] = '\t';
        tab[2] = '\0';
    }

    fprintf(out_stream, "%s dx=%d, dy=%d\n", tab, comp_header->dx, comp_header->dy);
    fprintf(out_stream, "%s prec=%d\n", tab, comp_header->prec);
    fprintf(out_stream, "%s sgnd=%d\n", tab, comp_header->sgnd);

    if (var_242) {
        fprintf(out_stream, "}\n");
    }
}

opj_codestream_info_v2_t* fn_242(opj_j2k_t* p_j2k)
{
    OPJ_UINT32 var_252;
    OPJ_UINT32 var_243 = p_j2k->m_private_image->numcomps;
    opj_tcp_t *l_default_tile;
    opj_codestream_info_v2_t* cstr_info = (opj_codestream_info_v2_t*) opj_calloc(1,
                                          sizeof(opj_codestream_info_v2_t));
    if (!cstr_info) {
        return NULL;
    }

    cstr_info->nbcomps = p_j2k->m_private_image->numcomps;

    cstr_info->tx0 = p_j2k->m_cp.tx0;
    cstr_info->ty0 = p_j2k->m_cp.ty0;
    cstr_info->tdx = p_j2k->m_cp.tdx;
    cstr_info->tdy = p_j2k->m_cp.tdy;
    cstr_info->tw = p_j2k->m_cp.tw;
    cstr_info->th = p_j2k->m_cp.th;

    cstr_info->tile_info = NULL;

    l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;

    cstr_info->m_default_tile_info.csty = l_default_tile->csty;
    cstr_info->m_default_tile_info.prg = l_default_tile->prg;
    cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;
    cstr_info->m_default_tile_info.mct = l_default_tile->mct;

    cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t*) opj_calloc(
                cstr_info->nbcomps, sizeof(opj_tccp_info_t));
    if (!cstr_info->m_default_tile_info.tccp_info) {
        opj_destroy_cstr_info(&cstr_info);
        return NULL;
    }

    for (var_252 = 0; var_252 < var_243; var_252++) {
        opj_tccp_t *l_tccp = &(l_default_tile->tccps[var_252]);
        opj_tccp_info_t *l_tccp_info = &
                                       (cstr_info->m_default_tile_info.tccp_info[var_252]);
        OPJ_INT32 bandno, numbands;


        l_tccp_info->csty = l_tccp->csty;
        l_tccp_info->numresolutions = l_tccp->numresolutions;
        l_tccp_info->cblkw = l_tccp->cblkw;
        l_tccp_info->cblkh = l_tccp->cblkh;
        l_tccp_info->cblksty = l_tccp->cblksty;
        l_tccp_info->qmfbid = l_tccp->qmfbid;
        if (l_tccp->numresolutions < OPJ_J2K_MAXRLVLS) {
            memcpy(l_tccp_info->prch, l_tccp->prch, l_tccp->numresolutions);
            memcpy(l_tccp_info->prcw, l_tccp->prcw, l_tccp->numresolutions);
        }


        l_tccp_info->qntsty = l_tccp->qntsty;
        l_tccp_info->numgbits = l_tccp->numgbits;

        numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 :
                   (OPJ_INT32)l_tccp->numresolutions * 3 - 2;
        if (numbands < OPJ_J2K_MAXBANDS) {
            for (bandno = 0; bandno < numbands; bandno++) {
                l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32)
                                                      l_tccp->stepsizes[bandno].mant;
                l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32)
                                                      l_tccp->stepsizes[bandno].expn;
            }
        }


        l_tccp_info->roishift = l_tccp->roishift;
    }

    return cstr_info;
}

opj_codestream_index_t* fn_243(opj_j2k_t* p_j2k)
{
    opj_codestream_index_t* l_cstr_index = (opj_codestream_index_t*)
                                           opj_calloc(1, sizeof(opj_codestream_index_t));
    if (!l_cstr_index) {
        return NULL;
    }

    l_cstr_index->main_head_start = p_j2k->cstr_index->main_head_start;
    l_cstr_index->main_head_end = p_j2k->cstr_index->main_head_end;
    l_cstr_index->codestream_size = p_j2k->cstr_index->codestream_size;

    l_cstr_index->marknum = p_j2k->cstr_index->marknum;
    l_cstr_index->marker = (opj_marker_info_t*)opj_malloc(l_cstr_index->marknum *
                           sizeof(opj_marker_info_t));
    if (!l_cstr_index->marker) {
        opj_free(l_cstr_index);
        return NULL;
    }

    if (p_j2k->cstr_index->marker) {
        memcpy(l_cstr_index->marker, p_j2k->cstr_index->marker,
               l_cstr_index->marknum * sizeof(opj_marker_info_t));
    } else {
        opj_free(l_cstr_index->marker);
        l_cstr_index->marker = NULL;
    }

    l_cstr_index->nb_of_tiles = p_j2k->cstr_index->nb_of_tiles;
    l_cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(
                                   l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));
    if (!l_cstr_index->tile_index) {
        opj_free(l_cstr_index->marker);
        opj_free(l_cstr_index);
        return NULL;
    }

    if (!p_j2k->cstr_index->tile_index) {
        opj_free(l_cstr_index->tile_index);
        l_cstr_index->tile_index = NULL;
    } else {
        OPJ_UINT32 var_244 = 0;
        for (var_244 = 0; var_244 < l_cstr_index->nb_of_tiles; var_244++) {


            l_cstr_index->tile_index[var_244].marknum =
                p_j2k->cstr_index->tile_index[var_244].marknum;

            l_cstr_index->tile_index[var_244].marker =
                (opj_marker_info_t*)opj_malloc(l_cstr_index->tile_index[var_244].marknum *
                                               sizeof(opj_marker_info_t));

            if (!l_cstr_index->tile_index[var_244].marker) {
                OPJ_UINT32 it_tile_free;

                for (it_tile_free = 0; it_tile_free < var_244; it_tile_free++) {
                    opj_free(l_cstr_index->tile_index[it_tile_free].marker);
                }

                opj_free(l_cstr_index->tile_index);
                opj_free(l_cstr_index->marker);
                opj_free(l_cstr_index);
                return NULL;
            }

            if (p_j2k->cstr_index->tile_index[var_244].marker)
                memcpy(l_cstr_index->tile_index[var_244].marker,
                       p_j2k->cstr_index->tile_index[var_244].marker,
                       l_cstr_index->tile_index[var_244].marknum * sizeof(opj_marker_info_t));
            else {
                opj_free(l_cstr_index->tile_index[var_244].marker);
                l_cstr_index->tile_index[var_244].marker = NULL;
            }


            l_cstr_index->tile_index[var_244].nb_tps =
                p_j2k->cstr_index->tile_index[var_244].nb_tps;

            l_cstr_index->tile_index[var_244].tp_index =
                (opj_tp_index_t*)opj_malloc(l_cstr_index->tile_index[var_244].nb_tps * sizeof(
                                                opj_tp_index_t));

            if (!l_cstr_index->tile_index[var_244].tp_index) {
                OPJ_UINT32 it_tile_free;

                for (it_tile_free = 0; it_tile_free < var_244; it_tile_free++) {
                    opj_free(l_cstr_index->tile_index[it_tile_free].marker);
                    opj_free(l_cstr_index->tile_index[it_tile_free].tp_index);
                }

                opj_free(l_cstr_index->tile_index);
                opj_free(l_cstr_index->marker);
                opj_free(l_cstr_index);
                return NULL;
            }

            if (p_j2k->cstr_index->tile_index[var_244].tp_index) {
                memcpy(l_cstr_index->tile_index[var_244].tp_index,
                       p_j2k->cstr_index->tile_index[var_244].tp_index,
                       l_cstr_index->tile_index[var_244].nb_tps * sizeof(opj_tp_index_t));
            } else {
                opj_free(l_cstr_index->tile_index[var_244].tp_index);
                l_cstr_index->tile_index[var_244].tp_index = NULL;
            }


            l_cstr_index->tile_index[var_244].nb_packet = 0;
            l_cstr_index->tile_index[var_244].packet_index = NULL;

        }
    }

    return l_cstr_index;
}

static OPJ_BOOL fn_244(opj_j2k_t *p_j2k)
{
    OPJ_UINT32 var_244 = 0;

    p_j2k->cstr_index->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
    p_j2k->cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(
                                        p_j2k->cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));
    if (!p_j2k->cstr_index->tile_index) {
        return var_263;
    }

    for (var_244 = 0; var_244 < p_j2k->cstr_index->nb_of_tiles; var_244++) {
        p_j2k->cstr_index->tile_index[var_244].maxmarknum = 100;
        p_j2k->cstr_index->tile_index[var_244].marknum = 0;
        p_j2k->cstr_index->tile_index[var_244].marker = (opj_marker_info_t*)
                opj_calloc(p_j2k->cstr_index->tile_index[var_244].maxmarknum,
                           sizeof(opj_marker_info_t));
        if (!p_j2k->cstr_index->tile_index[var_244].marker) {
            return var_263;
        }
    }

    return var_263;
}

static OPJ_BOOL fn_244(opj_j2k_t *p_j2k,
                                     opj_stream_private_t *p_stream,
                                     opj_event_mgr_t * p_manager)
{
    OPJ_BOOL var_248 = var_263;
    OPJ_UINT32 l_current_tile_no;
    OPJ_UINT32 var_248, l_max_data_size;
    OPJ_INT32 l_tile_x0, l_tile_y0, l_tile_x1, l_tile_y1;
    OPJ_UINT32 l_nb_comps;
    OPJ_BYTE * l_current_data;
    OPJ_UINT32 var_246 = 0;



    if (p_j2k->m_cp.tw == 1 && p_j2k->m_cp.th == 1 &&
            p_j2k->m_cp.tx0 == 0 && p_j2k->m_cp.ty0 == 0 &&
            p_j2k->m_output_image->x0 == 0 &&
            p_j2k->m_output_image->y0 == 0 &&
            p_j2k->m_output_image->x1 == p_j2k->m_cp.tdx &&
            p_j2k->m_output_image->y1 == p_j2k->m_cp.tdy &&
            p_j2k->m_output_image->comps[0].factor == 0) {
        OPJ_UINT32 i;
        if (! opj_j2k_read_tile_header(p_j2k,
                                       &l_current_tile_no,
                                       &var_248,
                                       &l_tile_x0, &l_tile_y0,
                                       &l_tile_x1, &l_tile_y1,
                                       &l_nb_comps,
                                       &var_248,
                                       p_stream,
                                       p_manager)) {
            return var_263;
        }

        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, NULL, 0,
                                  p_stream, p_manager)) {
            opj_event_msg(p_manager, EVT_ERROR, "Failed to decode tile 1/1\n");
            return var_263;
        }


        for (i = 0; i < p_j2k->m_output_image->numcomps; i++) {
            opj_image_data_free(p_j2k->m_output_image->comps[i].data);
            p_j2k->m_output_image->comps[i].data =
                p_j2k->m_tcd->tcd_image->tiles->comps[i].data;
            p_j2k->m_output_image->comps[i].resno_decoded =
                p_j2k->m_tcd->image->comps[i].resno_decoded;
            p_j2k->m_tcd->tcd_image->tiles->comps[i].data = NULL;
        }

        return var_263;
    }

    l_current_data = (OPJ_BYTE*)opj_malloc(1000);
    if (! l_current_data) {
        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode tiles\n");
        return var_263;
    }
    l_max_data_size = 1000;

    for (;;) {
        if (! opj_j2k_read_tile_header(p_j2k,
                                       &l_current_tile_no,
                                       &var_248,
                                       &l_tile_x0, &l_tile_y0,
                                       &l_tile_x1, &l_tile_y1,
                                       &l_nb_comps,
                                       &var_248,
                                       p_stream,
                                       p_manager)) {
            opj_free(l_current_data);
            return var_263;
        }

        if (! var_248) {
            break;
        }

        if (var_248 > l_max_data_size) {
            OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,
                                           var_248);
            if (! l_new_current_data) {
                opj_free(l_current_data);
                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode tile %d/%d\n",
                              l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);
                return var_263;
            }
            l_current_data = l_new_current_data;
            l_max_data_size = var_248;
        }

        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, var_248,
                                  p_stream, p_manager)) {
            opj_free(l_current_data);
            opj_event_msg(p_manager, EVT_ERROR, "Failed to decode tile %d/%d\n",
                          l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);
            return var_263;
        }
        opj_event_msg(p_manager, EVT_INFO, "Tile %d/%d has been decoded.\n",
                      l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);

        if (! opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data,
                                        p_j2k->m_output_image)) {
            opj_free(l_current_data);
            return var_263;
        }
        opj_event_msg(p_manager, EVT_INFO,
                      "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1);

        if (opj_stream_get_number_byte_left(p_stream) == 0
                && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC) {
            break;
        }
        if (++var_246 == p_j2k->m_cp.th * p_j2k->m_cp.tw) {
            break;
        }
    }

    opj_free(l_current_data);

    return var_263;
}




static OPJ_BOOL fn_246(opj_j2k_t *p_j2k,
                                       opj_event_mgr_t * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_decode_tiles, p_manager)) {
        return var_263;
    }


    return var_263;
}




static OPJ_BOOL fn_247(opj_j2k_t *p_j2k,
                                        opj_stream_private_t *p_stream,
                                        opj_event_mgr_t * p_manager)
{
    OPJ_BOOL var_248 = var_263;
    OPJ_UINT32 l_current_tile_no;
    OPJ_UINT32 l_tile_no_to_dec;
    OPJ_UINT32 var_248, l_max_data_size;
    OPJ_INT32 l_tile_x0, l_tile_y0, l_tile_x1, l_tile_y1;
    OPJ_UINT32 l_nb_comps;
    OPJ_BYTE * l_current_data;
    OPJ_UINT32 var_258;
    OPJ_UINT32 i;

    l_current_data = (OPJ_BYTE*)opj_malloc(1000);
    if (! l_current_data) {
        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode one tile\n");
        return var_263;
    }
    l_max_data_size = 1000;


    if (!p_j2k->cstr_index->tile_index) {
        if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)) {
            opj_free(l_current_data);
            return var_263;
        }
    }

    l_tile_no_to_dec = (OPJ_UINT32)
                       p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
    if (p_j2k->cstr_index->tile_index)
        if (p_j2k->cstr_index->tile_index->tp_index) {
            if (! p_j2k->cstr_index->tile_index[l_tile_no_to_dec].nb_tps) {


                if (!(opj_stream_read_seek(p_stream,
                                           p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2, p_manager))) {
                    opj_event_msg(p_manager, EVT_ERROR, "Problem with seek function\n");
                    opj_free(l_current_data);
                    return var_263;
                }
            } else {
                if (!(opj_stream_read_seek(p_stream,
                                           p_j2k->cstr_index->tile_index[l_tile_no_to_dec].tp_index[0].start_pos + 2,
                                           p_manager))) {
                    opj_event_msg(p_manager, EVT_ERROR, "Problem with seek function\n");
                    opj_free(l_current_data);
                    return var_263;
                }
            }

            if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC) {
                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;
            }
        }





    var_258 = p_j2k->m_cp.tw * p_j2k->m_cp.th;
    for (i = 0; i < var_258; ++i) {
        p_j2k->m_cp.tcps[i].m_current_tile_part_number = -1;
    }

    for (;;) {
        if (! opj_j2k_read_tile_header(p_j2k,
                                       &l_current_tile_no,
                                       &var_248,
                                       &l_tile_x0, &l_tile_y0,
                                       &l_tile_x1, &l_tile_y1,
                                       &l_nb_comps,
                                       &var_248,
                                       p_stream,
                                       p_manager)) {
            opj_free(l_current_data);
            return var_263;
        }

        if (! var_248) {
            break;
        }

        if (var_248 > l_max_data_size) {
            OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,
                                           var_248);
            if (! l_new_current_data) {
                opj_free(l_current_data);
                l_current_data = NULL;
                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode tile %d/%d\n",
                              l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);
                return var_263;
            }
            l_current_data = l_new_current_data;
            l_max_data_size = var_248;
        }

        if (! opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, var_248,
                                  p_stream, p_manager)) {
            opj_free(l_current_data);
            return var_263;
        }
        opj_event_msg(p_manager, EVT_INFO, "Tile %d/%d has been decoded.\n",
                      l_current_tile_no + 1, p_j2k->m_cp.th * p_j2k->m_cp.tw);

        if (! opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data,
                                        p_j2k->m_output_image)) {
            opj_free(l_current_data);
            return var_263;
        }
        opj_event_msg(p_manager, EVT_INFO,
                      "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1);

        if (l_current_tile_no == l_tile_no_to_dec) {

            if (!(opj_stream_read_seek(p_stream, p_j2k->cstr_index->main_head_end + 2,
                                       p_manager))) {
                opj_event_msg(p_manager, EVT_ERROR, "Problem with seek function\n");
                opj_free(l_current_data);
                return var_263;
            }
            break;
        } else {
            opj_event_msg(p_manager, EVT_WARNING,
                          "Tile read, decoded and updated is not the desired one (%d vs %d).\n",
                          l_current_tile_no + 1, l_tile_no_to_dec + 1);
        }

    }

    opj_free(l_current_data);

    return var_263;
}




static OPJ_BOOL fn_248(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_decode_one_tile, p_manager)) {
        return var_263;
    }


    return var_263;
}

OPJ_BOOL fn_249(opj_j2k_t * p_j2k,
                        opj_stream_private_t * p_stream,
                        opj_image_t * p_image,
                        opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 var_252;

    if (!p_image) {
        return var_263;
    }

    p_j2k->m_output_image = opj_image_create0();
    if (!(p_j2k->m_output_image)) {
        return var_263;
    }
    opj_copy_image_header(p_image, p_j2k->m_output_image);


    if (!opj_j2k_setup_decoding(p_j2k, p_manager)) {
        return var_263;
    }


    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {
        opj_image_destroy(p_j2k->m_private_image);
        p_j2k->m_private_image = NULL;
        return var_263;
    }


    for (var_252 = 0; var_252 < p_image->numcomps; var_252++) {
        p_image->comps[var_252].resno_decoded =
            p_j2k->m_output_image->comps[var_252].resno_decoded;
        p_image->comps[var_252].data = p_j2k->m_output_image->comps[var_252].data;

        p_j2k->m_output_image->comps[var_252].data = NULL;
    }

    return var_263;
}

OPJ_BOOL fn_250(opj_j2k_t *p_j2k,
                          opj_stream_private_t *p_stream,
                          opj_image_t* p_image,
                          opj_event_mgr_t * p_manager,
                          OPJ_UINT32 var_252)
{
    OPJ_UINT32 var_252;
    OPJ_UINT32 l_tile_x, l_tile_y;
    opj_image_comp_t* l_img_comp;

    if (!p_image) {
        opj_event_msg(p_manager, EVT_ERROR, "We need an image previously created.\n");
        return var_263;
    }

    if ( (var_252 >= p_j2k->m_cp.tw * p_j2k->m_cp.th)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Tile index provided by the user is incorrect %d (max = %d) \n", var_252,
                      (p_j2k->m_cp.tw * p_j2k->m_cp.th) - 1);
        return var_263;
    }


    l_tile_x = var_252 % p_j2k->m_cp.tw;
    l_tile_y = var_252 / p_j2k->m_cp.tw;

    p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
    if (p_image->x0 < p_j2k->m_private_image->x0) {
        p_image->x0 = p_j2k->m_private_image->x0;
    }
    p_image->x1 = (l_tile_x + 1) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
    if (p_image->x1 > p_j2k->m_private_image->x1) {
        p_image->x1 = p_j2k->m_private_image->x1;
    }

    p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
    if (p_image->y0 < p_j2k->m_private_image->y0) {
        p_image->y0 = p_j2k->m_private_image->y0;
    }
    p_image->y1 = (l_tile_y + 1) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
    if (p_image->y1 > p_j2k->m_private_image->y1) {
        p_image->y1 = p_j2k->m_private_image->y1;
    }

    l_img_comp = p_image->comps;
    for (var_252 = 0; var_252 < p_image->numcomps; ++var_252) {
        OPJ_INT32 l_comp_x1, l_comp_y1;

        l_img_comp->factor = p_j2k->m_private_image->comps[var_252].factor;

        l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,
                         (OPJ_INT32)l_img_comp->dx);
        l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,
                         (OPJ_INT32)l_img_comp->dy);
        l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);
        l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);

        l_img_comp->w = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_x1,
                                     (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0,
                                             (OPJ_INT32)l_img_comp->factor));
        l_img_comp->h = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_y1,
                                     (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0,
                                             (OPJ_INT32)l_img_comp->factor));

        l_img_comp++;
    }


    if (p_j2k->m_output_image) {
        opj_image_destroy(p_j2k->m_output_image);
    }


    p_j2k->m_output_image = opj_image_create0();
    if (!(p_j2k->m_output_image)) {
        return var_263;
    }
    opj_copy_image_header(p_image, p_j2k->m_output_image);

    p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32)var_252;


    if (!opj_j2k_setup_decoding_tile(p_j2k, p_manager)) {
        return var_263;
    }


    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {
        opj_image_destroy(p_j2k->m_private_image);
        p_j2k->m_private_image = NULL;
        return var_263;
    }


    for (var_252 = 0; var_252 < p_image->numcomps; var_252++) {
        p_image->comps[var_252].resno_decoded =
            p_j2k->m_output_image->comps[var_252].resno_decoded;

        if (p_image->comps[var_252].data) {
            opj_image_data_free(p_image->comps[var_252].data);
        }

        p_image->comps[var_252].data = p_j2k->m_output_image->comps[var_252].data;

        p_j2k->m_output_image->comps[var_252].data = NULL;
    }

    return var_263;
}

OPJ_BOOL fn_252(opj_j2k_t *p_j2k,
        OPJ_UINT32 var_255,
        opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 it_comp;

    p_j2k->m_cp.m_specific_param.m_dec.m_reduce = var_255;

    if (p_j2k->m_private_image) {
        if (p_j2k->m_private_image->comps) {
            if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {
                if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps) {
                    for (it_comp = 0 ; it_comp < p_j2k->m_private_image->numcomps; it_comp++) {
                        OPJ_UINT32 var_255 =
                            p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[it_comp].numresolutions;
                        if (var_255 >= var_255) {
                            opj_event_msg(p_manager, EVT_ERROR,
                                          "Resolution factor is greater than the maximum resolution in the component.\n");
                            return var_263;
                        }
                        p_j2k->m_private_image->comps[it_comp].factor = var_255;
                    }
                    return var_263;
                }
            }
        }
    }

    return var_263;
}

OPJ_BOOL fn_255(opj_j2k_t * p_j2k,
                        opj_stream_private_t *p_stream,
                        opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 i, j;
    OPJ_UINT32 var_258;
    OPJ_UINT32 var_258 = 0, l_current_tile_size;
    OPJ_BYTE * l_current_data = 0;
    OPJ_BOOL var_258 = var_263;
    opj_tcd_t* p_tcd = 0;


    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    p_tcd = p_j2k->m_tcd;

    var_258 = p_j2k->m_cp.th * p_j2k->m_cp.tw;
    if (var_258 == 1) {
        var_258 = var_263;

        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {
            opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;
            if (((size_t)l_img_comp->data & 0xFU) !=
                    0U) {
                var_258 = var_263;
            }
        }

    }
    for (i = 0; i < var_258; ++i) {
        if (! opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager)) {
            if (l_current_data) {
                opj_free(l_current_data);
            }
            return var_263;
        }



        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {
            opj_tcd_tilecomp_t* l_tilec = p_tcd->tcd_image->tiles->comps + j;
            if (var_258) {
                opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;
                l_tilec->data = l_img_comp->data;
                l_tilec->ownsData = var_263;
            } else {
                if (! opj_alloc_tile_component_data(l_tilec)) {
                    opj_event_msg(p_manager, EVT_ERROR, "Error allocating tile component data.");
                    if (l_current_data) {
                        opj_free(l_current_data);
                    }
                    return var_263;
                }
            }
        }
        l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);
        if (!var_258) {
            if (l_current_tile_size > var_258) {
                OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,
                                               l_current_tile_size);
                if (! l_new_current_data) {
                    if (l_current_data) {
                        opj_free(l_current_data);
                    }
                    opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to encode all tiles\n");
                    return var_263;
                }
                l_current_data = l_new_current_data;
                var_258 = l_current_tile_size;
            }




            opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);


            if (! opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data,
                                         l_current_tile_size)) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "Size mismatch between tile data and sent data.");
                opj_free(l_current_data);
                return var_263;
            }
        }

        if (! opj_j2k_post_write_tile(p_j2k, p_stream, p_manager)) {
            if (l_current_data) {
                opj_free(l_current_data);
            }
            return var_263;
        }
    }

    if (l_current_data) {
        opj_free(l_current_data);
    }
    return var_263;
}

OPJ_BOOL fn_258(opj_j2k_t *p_j2k,
                              opj_stream_private_t *p_stream,
                              opj_event_mgr_t * p_manager)
{

    if (! opj_j2k_setup_end_compress(p_j2k, p_manager)) {
        return var_263;
    }

    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {
        return var_263;
    }

    return var_263;
}

OPJ_BOOL fn_259(opj_j2k_t *p_j2k,
                                opj_stream_private_t *p_stream,
                                opj_image_t * p_image,
                                opj_event_mgr_t * p_manager)
{

    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    p_j2k->m_private_image = opj_image_create0();
    if (! p_j2k->m_private_image) {
        opj_event_msg(p_manager, EVT_ERROR, "Failed to allocate image header.");
        return var_263;
    }
    opj_copy_image_header(p_image, p_j2k->m_private_image);


    if (p_image->comps) {
        OPJ_UINT32 it_comp;
        for (it_comp = 0 ; it_comp < p_image->numcomps; it_comp++) {
            if (p_image->comps[it_comp].data) {
                p_j2k->m_private_image->comps[it_comp].data = p_image->comps[it_comp].data;
                p_image->comps[it_comp].data = NULL;

            }
        }
    }


    if (! opj_j2k_setup_encoding_validation(p_j2k, p_manager)) {
        return var_263;
    }


    if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager)) {
        return var_263;
    }


    if (! opj_j2k_setup_header_writing(p_j2k, p_manager)) {
        return var_263;
    }


    if (! opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager)) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_260(opj_j2k_t * p_j2k,
                                       OPJ_UINT32 var_263,
                                       opj_stream_private_t *p_stream,
                                       opj_event_mgr_t * p_manager)
{
    (void)p_stream;
    if (var_263 != p_j2k->m_current_tile_number) {
        opj_event_msg(p_manager, EVT_ERROR, "The given tile index does not match.");
        return var_263;
    }

    opj_event_msg(p_manager, EVT_INFO, "tile number %d / %d\n",
                  p_j2k->m_current_tile_number + 1, p_j2k->m_cp.tw * p_j2k->m_cp.th);

    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = 0;
    p_j2k->m_tcd->cur_totnum_tp = p_j2k->m_cp.tcps[var_263].m_nb_tile_parts;
    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;


    if (! opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,
                                   p_manager)) {
        return var_263;
    }

    return var_263;
}

static void fn_260(opj_image_t * l_image,
                                    opj_tcd_tilecomp_t * l_tilec,
                                    opj_image_comp_t * l_img_comp,
                                    OPJ_UINT32* l_size_comp,
                                    OPJ_UINT32* var_260,
                                    OPJ_UINT32* var_260,
                                    OPJ_UINT32* l_offset_x,
                                    OPJ_UINT32* l_offset_y,
                                    OPJ_UINT32* l_image_width,
                                    OPJ_UINT32* l_stride,
                                    OPJ_UINT32* l_tile_offset)
{
    OPJ_UINT32 l_remaining;
    *l_size_comp = l_img_comp->prec >> 3;
    l_remaining = l_img_comp->prec & 7;
    if (l_remaining) {
        *l_size_comp += 1;
    }

    if (*l_size_comp == 3) {
        *l_size_comp = 4;
    }

    *var_260 = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);
    *var_260 = (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);
    *l_offset_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x0,
                  (OPJ_INT32)l_img_comp->dx);
    *l_offset_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->y0,
                  (OPJ_INT32)l_img_comp->dy);
    *l_image_width = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x1 -
                     (OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);
    *l_stride = *l_image_width - *var_260;
    *l_tile_offset = ((OPJ_UINT32)l_tilec->x0 - *l_offset_x) + ((
                         OPJ_UINT32)l_tilec->y0 - *l_offset_y) * *l_image_width;
}

static void fn_260(opj_tcd_t * p_tcd, OPJ_BYTE * p_data)
{
    OPJ_UINT32 i, j, var_260 = 0;

    for (i = 0; i < p_tcd->image->numcomps; ++i) {
        opj_image_t * l_image = p_tcd->image;
        OPJ_INT32 * l_src_ptr;
        opj_tcd_tilecomp_t * l_tilec = p_tcd->tcd_image->tiles->comps + i;
        opj_image_comp_t * l_img_comp = l_image->comps + i;
        OPJ_UINT32 l_size_comp, var_260, var_260, l_offset_x, l_offset_y,
                   l_image_width, l_stride, l_tile_offset;

        opj_get_tile_dimensions(l_image,
                                l_tilec,
                                l_img_comp,
                                &l_size_comp,
                                &var_260,
                                &var_260,
                                &l_offset_x,
                                &l_offset_y,
                                &l_image_width,
                                &l_stride,
                                &l_tile_offset);

        l_src_ptr = l_img_comp->data + l_tile_offset;

        switch (l_size_comp) {
        case 1: {
            OPJ_CHAR * l_dest_ptr = (OPJ_CHAR*) p_data;
            if (l_img_comp->sgnd) {
                for (j = 0; j < var_260; ++j) {
                    for (var_260 = 0; var_260 < var_260; ++var_260) {
                        *(l_dest_ptr) = (OPJ_CHAR)(*l_src_ptr);
                        ++l_dest_ptr;
                        ++l_src_ptr;
                    }
                    l_src_ptr += l_stride;
                }
            } else {
                for (j = 0; j < var_260; ++j) {
                    for (var_260 = 0; var_260 < var_260; ++var_260) {
                        *(l_dest_ptr) = (OPJ_CHAR)((*l_src_ptr) & 0xff);
                        ++l_dest_ptr;
                        ++l_src_ptr;
                    }
                    l_src_ptr += l_stride;
                }
            }

            p_data = (OPJ_BYTE*) l_dest_ptr;
        }
        break;
        case 2: {
            OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_data;
            if (l_img_comp->sgnd) {
                for (j = 0; j < var_260; ++j) {
                    for (var_260 = 0; var_260 < var_260; ++var_260) {
                        *(l_dest_ptr++) = (OPJ_INT16)(*(l_src_ptr++));
                    }
                    l_src_ptr += l_stride;
                }
            } else {
                for (j = 0; j < var_260; ++j) {
                    for (var_260 = 0; var_260 < var_260; ++var_260) {
                        *(l_dest_ptr++) = (OPJ_INT16)((*(l_src_ptr++)) & 0xffff);
                    }
                    l_src_ptr += l_stride;
                }
            }

            p_data = (OPJ_BYTE*) l_dest_ptr;
        }
        break;
        case 4: {
            OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_data;
            for (j = 0; j < var_260; ++j) {
                for (var_260 = 0; var_260 < var_260; ++var_260) {
                    *(l_dest_ptr++) = *(l_src_ptr++);
                }
                l_src_ptr += l_stride;
            }

            p_data = (OPJ_BYTE*) l_dest_ptr;
        }
        break;
        }
    }
}

static OPJ_BOOL fn_260(opj_j2k_t * p_j2k,
                                        opj_stream_private_t *p_stream,
                                        opj_event_mgr_t * p_manager)
{
    OPJ_UINT32 var_262;
    OPJ_BYTE * l_current_data = 0;
    OPJ_UINT32 var_261 = 0;
    OPJ_UINT32 l_available_data;


    assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);

    var_261 = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;
    l_available_data = var_261;
    l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;

    var_262 = 0;
    if (! opj_j2k_write_first_tile_part(p_j2k, l_current_data, &var_262,
                                        l_available_data, p_stream, p_manager)) {
        return var_263;
    }
    l_current_data += var_262;
    l_available_data -= var_262;

    var_262 = 0;
    if (! opj_j2k_write_all_tile_parts(p_j2k, l_current_data, &var_262,
                                       l_available_data, p_stream, p_manager)) {
        return var_263;
    }

    l_available_data -= var_262;
    var_262 = var_261 - l_available_data;

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,
                              var_262, p_manager) != var_262) {
        return var_263;
    }

    ++p_j2k->m_current_tile_number;

    return var_263;
}

static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);


    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_eoc, p_manager)) {
        return var_263;
    }

    if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {
        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                               (opj_procedure)opj_j2k_write_updated_tlm, p_manager)) {
            return var_263;
        }
    }

    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_epc, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_end_encoding, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_destroy_header_memory, p_manager)) {
        return var_263;
    }
    return var_263;
}

static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,
                                           (opj_procedure)opj_j2k_build_encoder, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,
                                           (opj_procedure)opj_j2k_encoding_validation, p_manager)) {
        return var_263;
    }


    if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,
                                           (opj_procedure)opj_j2k_mct_validation, p_manager)) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        opj_event_mgr_t * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);

    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_init_info, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_soc, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_siz, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_cod, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_qcd, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_all_coc, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_all_qcc, p_manager)) {
        return var_263;
    }

    if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {
        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                               (opj_procedure)opj_j2k_write_tlm, p_manager)) {
            return var_263;
        }

        if (p_j2k->m_cp.rsiz == OPJ_PROFILE_CINEMA_4K) {
            if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                                   (opj_procedure)opj_j2k_write_poc, p_manager)) {
                return var_263;
            }
        }
    }

    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_write_regions, p_manager)) {
        return var_263;
    }

    if (p_j2k->m_cp.comment != 0) {
        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                               (opj_procedure)opj_j2k_write_com, p_manager)) {
            return var_263;
        }
    }


    if (p_j2k->m_cp.rsiz & OPJ_EXTENSION_MCT) {
        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                               (opj_procedure)opj_j2k_write_mct_data_group, p_manager)) {
            return var_263;
        }
    }


    if (p_j2k->cstr_index) {
        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                               (opj_procedure)opj_j2k_get_end_header, p_manager)) {
            return var_263;
        }
    }

    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_create_tcd, p_manager)) {
        return var_263;
    }
    if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,
                                           (opj_procedure)opj_j2k_update_rates, p_manager)) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        OPJ_BYTE * p_data,
        OPJ_UINT32 * p_data_written,
        OPJ_UINT32 var_262,
        opj_stream_private_t *p_stream,
        struct struct_262 * p_manager)
{
    OPJ_UINT32 var_262 = 0;
    OPJ_UINT32 l_current_nb_bytes_written;
    OPJ_BYTE * l_begin_data = 0;

    opj_tcd_t * l_tcd = 0;
    opj_cp_t * l_cp = 0;

    l_tcd = p_j2k->m_tcd;
    l_cp = &(p_j2k->m_cp);

    l_tcd->cur_pino = 0;


    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;




    l_current_nb_bytes_written = 0;
    l_begin_data = p_data;
    if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,
                            p_manager)) {
        return var_263;
    }

    var_262 += l_current_nb_bytes_written;
    p_data += l_current_nb_bytes_written;
    var_262 -= l_current_nb_bytes_written;

    if (!OPJ_IS_CINEMA(l_cp->rsiz)) {

        if (l_cp->tcps[p_j2k->m_current_tile_number].numpocs) {
            l_current_nb_bytes_written = 0;
            opj_j2k_write_poc_in_memory(p_j2k, p_data, &l_current_nb_bytes_written,
                                        p_manager);
            var_262 += l_current_nb_bytes_written;
            p_data += l_current_nb_bytes_written;
            var_262 -= l_current_nb_bytes_written;
        }
    }

    l_current_nb_bytes_written = 0;
    if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,
                            var_262, p_stream, p_manager)) {
        return var_263;
    }

    var_262 += l_current_nb_bytes_written;
    * p_data_written = var_262;


    opj_write_bytes(l_begin_data + 6, var_262,
                    4);

    if (OPJ_IS_CINEMA(l_cp->rsiz)) {
        opj_j2k_update_tlm(p_j2k, var_262);
    }

    return var_263;
}

static OPJ_BOOL fn_261(opj_j2k_t *p_j2k,
        OPJ_BYTE * p_data,
        OPJ_UINT32 * p_data_written,
        OPJ_UINT32 var_262,
        opj_stream_private_t *p_stream,
        struct struct_262 * p_manager
                                            )
{
    OPJ_UINT32 var_262 = 0;
    OPJ_UINT32 var_262 = 0;
    OPJ_UINT32 l_current_nb_bytes_written;
    OPJ_UINT32 l_part_tile_size;
    OPJ_UINT32 tot_num_tp;
    OPJ_UINT32 var_262;

    OPJ_BYTE * l_begin_data;
    opj_tcp_t *l_tcp = 0;
    opj_tcd_t * l_tcd = 0;
    opj_cp_t * l_cp = 0;

    l_tcd = p_j2k->m_tcd;
    l_cp = &(p_j2k->m_cp);
    l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;


    tot_num_tp = opj_j2k_get_num_tp(l_cp, 0, p_j2k->m_current_tile_number);


    ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
    for (var_262 = 1; var_262 < tot_num_tp ; ++var_262) {
        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = var_262;
        l_current_nb_bytes_written = 0;
        l_part_tile_size = 0;
        l_begin_data = p_data;

        if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,
                                p_manager)) {
            return var_263;
        }

        var_262 += l_current_nb_bytes_written;
        p_data += l_current_nb_bytes_written;
        var_262 -= l_current_nb_bytes_written;
        l_part_tile_size += l_current_nb_bytes_written;

        l_current_nb_bytes_written = 0;
        if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,
                                var_262, p_stream, p_manager)) {
            return var_263;
        }

        p_data += l_current_nb_bytes_written;
        var_262 += l_current_nb_bytes_written;
        var_262 -= l_current_nb_bytes_written;
        l_part_tile_size += l_current_nb_bytes_written;


        opj_write_bytes(l_begin_data + 6, l_part_tile_size,
                        4);

        if (OPJ_IS_CINEMA(l_cp->rsiz)) {
            opj_j2k_update_tlm(p_j2k, l_part_tile_size);
        }

        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
    }

    for (var_262 = 1; var_262 <= l_tcp->numpocs; ++var_262) {
        l_tcd->cur_pino = var_262;


        tot_num_tp = opj_j2k_get_num_tp(l_cp, var_262, p_j2k->m_current_tile_number);
        for (var_262 = 0; var_262 < tot_num_tp ; ++var_262) {
            p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = var_262;
            l_current_nb_bytes_written = 0;
            l_part_tile_size = 0;
            l_begin_data = p_data;

            if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,
                                    p_manager)) {
                return var_263;
            }

            var_262 += l_current_nb_bytes_written;
            p_data += l_current_nb_bytes_written;
            var_262 -= l_current_nb_bytes_written;
            l_part_tile_size += l_current_nb_bytes_written;

            l_current_nb_bytes_written = 0;

            if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,
                                    var_262, p_stream, p_manager)) {
                return var_263;
            }

            var_262 += l_current_nb_bytes_written;
            p_data += l_current_nb_bytes_written;
            var_262 -= l_current_nb_bytes_written;
            l_part_tile_size += l_current_nb_bytes_written;


            opj_write_bytes(l_begin_data + 6, l_part_tile_size,
                            4);

            if (OPJ_IS_CINEMA(l_cp->rsiz)) {
                opj_j2k_update_tlm(p_j2k, l_part_tile_size);
            }

            ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
        }
    }

    *p_data_written = var_262;

    return var_263;
}

static OPJ_BOOL fn_262(opj_j2k_t *p_j2k,
        struct struct_262 *p_stream,
        struct struct_262 * p_manager)
{
    OPJ_UINT32 l_tlm_size;
    OPJ_OFF_T l_tlm_position, l_current_position;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    l_tlm_size = 5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
    l_tlm_position = 6 + p_j2k->m_specific_param.m_encoder.m_tlm_start;
    l_current_position = opj_stream_tell(p_stream);

    if (! opj_stream_seek(p_stream, l_tlm_position, p_manager)) {
        return var_263;
    }

    if (opj_stream_write_data(p_stream,
                              p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer, l_tlm_size,
                              p_manager) != l_tlm_size) {
        return var_263;
    }

    if (! opj_stream_seek(p_stream, l_current_position, p_manager)) {
        return var_263;
    }

    return var_263;
}

static OPJ_BOOL fn_262(opj_j2k_t *p_j2k,
                                     struct struct_262 *p_stream,
                                     struct struct_262 * p_manager)
{

    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    (void)p_stream;
    (void)p_manager;

    opj_tcd_destroy(p_j2k->m_tcd);
    p_j2k->m_tcd = 0;

    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
        opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 0;
        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 0;
    }

    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
        opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 0;
    }

    p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = 0;

    return var_263;
}




static OPJ_BOOL fn_262(opj_j2k_t * p_j2k,
        opj_stream_private_t *p_stream,
        opj_event_mgr_t * p_manager
                                             )
{

    assert(p_j2k != 0);
    assert(p_stream != 0);
    assert(p_manager != 0);

    (void)p_stream;
    (void)p_manager;

    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
        p_j2k->m_specific_param.m_encoder.m_header_tile_data = 0;
    }

    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;

    return var_263;
}

static OPJ_BOOL fn_262(opj_j2k_t *p_j2k,
                                  struct struct_262 *p_stream,
                                  struct struct_262 * p_manager)
{
    opj_codestream_info_t * l_cstr_info = 0;


    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);
    (void)l_cstr_info;

    (void)p_stream;

    return opj_j2k_calculate_tp(p_j2k, &(p_j2k->m_cp),
                                &p_j2k->m_specific_param.m_encoder.m_total_tile_parts, p_j2k->m_private_image,
                                p_manager);
}

static OPJ_BOOL fn_262(opj_j2k_t *p_j2k,
                                   opj_stream_private_t *p_stream,
                                   opj_event_mgr_t * p_manager
                                  )
{

    assert(p_j2k != 0);
    assert(p_manager != 0);
    assert(p_stream != 0);

    (void)p_stream;

    p_j2k->m_tcd = opj_tcd_create(var_263);

    if (! p_j2k->m_tcd) {
        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to create Tile Coder\n");
        return var_263;
    }

    if (!opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, &p_j2k->m_cp,
                      p_j2k->m_tp)) {
        opj_tcd_destroy(p_j2k->m_tcd);
        p_j2k->m_tcd = 0;
        return var_263;
    }

    return var_263;
}

OPJ_BOOL fn_262(opj_j2k_t * p_j2k,
                            OPJ_UINT32 var_263,
                            OPJ_BYTE * p_data,
                            OPJ_UINT32 var_263,
                            opj_stream_private_t *p_stream,
                            opj_event_mgr_t * p_manager)
{
    if (! opj_j2k_pre_write_tile(p_j2k, var_263, p_stream, p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR,
                      "Error while opj_j2k_pre_write_tile with tile index = %d\n", var_263);
        return var_263;
    } else {
        OPJ_UINT32 j;

        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {
            opj_tcd_tilecomp_t* l_tilec = p_j2k->m_tcd->tcd_image->tiles->comps + j;

            if (! opj_alloc_tile_component_data(l_tilec)) {
                opj_event_msg(p_manager, EVT_ERROR, "Error allocating tile component data.");
                return var_263;
            }
        }


        if (! opj_tcd_copy_tile_data(p_j2k->m_tcd, p_data, var_263)) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Size mismatch between tile data and sent data.");
            return var_263;
        }
        if (! opj_j2k_post_write_tile(p_j2k, p_stream, p_manager)) {
            opj_event_msg(p_manager, EVT_ERROR,
                          "Error while opj_j2k_post_write_tile with tile index = %d\n", var_263);
            return var_263;
        }
    }

    return var_263;
}
