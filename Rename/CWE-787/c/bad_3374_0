







OnigSyntaxType var_0 = {
  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |
     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |
     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_CONTROL_CHARS |
     ONIG_SYN_OP_ESC_C_CONTROL )
   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )
  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |
      ONIG_SYN_OP2_OPTION_RUBY |
      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |
      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |
      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY |
      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |
      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |
      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |
      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |
      ONIG_SYN_OP2_ESC_H_XDIGIT )
  , ( SYN_GNU_REGEX_BV |
      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |
      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |
      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |
      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |
      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |
      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |
      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )
  , ONIG_OPTION_NONE
  ,
  {
      (OnigCodePoint )'\\'
    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR
    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR
    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR
    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR
    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR
  }
};

OnigSyntaxType* OnigDefaultSyntax = var_1;

extern void fn_2(const char* s var_185) { }




static OnigWarnFunc var_146 = var_146;





static OnigWarnFunc var_10 = var_146;


extern void fn_7(OnigWarnFunc var_10)
{
  var_146 = var_10;
}

extern void fn_9(OnigWarnFunc var_10)
{
  var_10 = var_10;
}

extern void
fn_10(const char* s)
{
  if (var_146 == var_146) return ;

  (*var_146)(s);
}



static int var_48 = 32767;

extern int
fn_12(int var_181)
{
  if (var_181 < 0) return -1;

  var_48 = var_181;
  return 0;
}

static unsigned int var_182 = var_19;

extern unsigned int
fn_16(void)
{
  return var_182;
}

extern int
fn_17(unsigned int var_19)
{
  if (var_19 == 0)
    var_182 = var_19;
  else
    var_182 = var_19;
  return 0;
}


static void
fn_19(BBuf* bbuf)
{
  if (IS_NOT_NULL(bbuf)) {
    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);
    xfree(bbuf);
  }
}

static int
fn_20(BBuf** rto, BBuf* var_180)
{
  int var_184;
  BBuf *var_180;

  *rto = var_180 = (BBuf* )xmalloc(sizeof(BBuf));
  CHECK_NULL_RETURN_MEMERR(var_180);
  var_184 = BBUF_INIT(var_180, var_180->alloc);
  if (var_184 != 0) return var_184;
  var_180->used = var_180->used;
  xmemcpy(var_180->p, var_180->p, var_180->used);
  return 0;
}

static void
fn_24(BitSetRef var_180, int var_180, int var_180)
{
  int i;
  for (i = var_180; i <= var_180 && i < SINGLE_BYTE_SIZE; i++) {
    BITSET_SET_BIT(var_180, i);
  }
}

static void
fn_26(BitSetRef var_180)
{
  int i;
  for (i = 0; i < (int )BITSET_SIZE; i++) { var_180[i] = ~(var_180[i]); }
}

static void
fn_27(BitSetRef var_180, BitSetRef var_180)
{
  int i;
  for (i = 0; i < (int )BITSET_SIZE; i++) { var_180[i] = ~(var_180[i]); }
}

static void
fn_28(BitSetRef var_106, BitSetRef var_180)
{
  int i;
  for (i = 0; i < (int )BITSET_SIZE; i++) { var_106[i] &= var_180[i]; }
}

static void
fn_30(BitSetRef var_106, BitSetRef var_180)
{
  int i;
  for (i = 0; i < (int )BITSET_SIZE; i++) { var_106[i] |= var_180[i]; }
}

static void
fn_31(BitSetRef var_106, BitSetRef var_180)
{
  int i;
  for (i = 0; i < (int )BITSET_SIZE; i++) { var_106[i] = var_180[i]; }
}

extern int
fn_32(const UChar* s1, const UChar* s2, int var_175)
{
  int x;

  while (var_175-- > 0) {
    x = *s2++ - *s1++;
    if (x) return x;
  }
  return 0;
}

extern void
fn_34(UChar* var_106, const UChar* src, const UChar* end)
{
  int var_181 = end - src;
  if (var_181 > 0) {
    xmemcpy(var_106, src, var_181);
    var_106[var_181] = (UChar )0;
  }
}

static UChar*
fn_36(UChar* var_106, UChar* dest_end, const UChar* src, const UChar* src_end,
       int var_77)
{
  UChar* var_184;

  if (var_106)
    var_184 = (UChar* )xrealloc(var_106, var_77 + 1);
  else
    var_184 = (UChar* )xmalloc(var_77 + 1);

  CHECK_NULL_RETURN(var_184);
  onig_strcpy(var_184 + (dest_end - var_106), src, src_end);
  return var_184;
}


static UChar*
fn_38(UChar* var_106, UChar* dest_end,
   const UChar* src, const UChar* src_end, int var_77)
{
  UChar* var_184;

  var_184 = (UChar* )xmalloc(var_77 + 1);
  CHECK_NULL_RETURN(var_184);
  onig_strcpy(var_184, var_106, dest_end);
  onig_strcpy(var_184 + (dest_end - var_106), src, src_end);
  return var_184;
}

extern int
fn_39(regex_t* reg, const UChar* name,
      const UChar* name_end, int** nums)
{
  return ONIG_NO_SUPPORT_CONFIG;
}

extern int
fn_40(regex_t* reg, const UChar* name,
       const UChar* name_end, OnigRegion* region)
{
  return ONIG_NO_SUPPORT_CONFIG;
}

extern int
fn_41(regex_t* reg,
  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)
{
  return ONIG_NO_SUPPORT_CONFIG;
}

extern int
fn_42(regex_t* reg)
{
  return 0;
}


extern int
fn_43(regex_t* reg)
{
  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))
    return 0;

  return 1;
}




static void
fn_44(ScanEnv* env)
{
  int i;

  BIT_STATUS_CLEAR(env->capture_history);
  BIT_STATUS_CLEAR(env->bt_mem_start);
  BIT_STATUS_CLEAR(env->bt_mem_end);
  BIT_STATUS_CLEAR(env->backrefed_mem);
  env->error = (UChar* )NULL;
  env->error_end = (UChar* )NULL;
  env->num_call = 0;
  env->num_mem = 0;



  env->mem_alloc = 0;
  env->mem_nodes_dynamic = (Node** )NULL;

  for (i = 0; i < SCANENV_MEMNODES_SIZE; i++)
    env->mem_nodes_static[i] = var_181;







  env->parse_depth = 0;
}

static int
fn_46(ScanEnv* env)
{
  int i, need, alloc;
  Node** var_184;

  need = env->num_mem + 1;
  if (need > var_48 && var_48 != 0)
    return ONIGERR_TOO_MANY_CAPTURES;

  if (need >= SCANENV_MEMNODES_SIZE) {
    if (env->mem_alloc <= need) {
      if (IS_NULL(env->mem_nodes_dynamic)) {
        alloc = 16;
        var_184 = (Node** )xmalloc(sizeof(Node*) * alloc);
        xmemcpy(var_184, env->mem_nodes_static,
                sizeof(Node*) * SCANENV_MEMNODES_SIZE);
      }
      else {
        alloc = env->mem_alloc * 2;
        var_184 = (Node** )xrealloc(env->mem_nodes_dynamic, sizeof(Node*) * alloc);
      }
      CHECK_NULL_RETURN_MEMERR(var_184);

      for (i = env->num_mem + 1; i < alloc; i++)
        var_184[i] = var_181;

      env->mem_nodes_dynamic = var_184;
      env->mem_alloc = alloc;
    }
  }

  env->num_mem++;
  return env->num_mem;
}

static int
fn_48(ScanEnv* env, int var_181, Node* node)
{
  if (env->num_mem >= var_181)
    SCANENV_MEM_NODES(env)[var_181] = node;
  else
    return ONIGERR_PARSER_BUG;
  return 0;
}

extern void
fn_49(Node* node)
{
 start:
  if (IS_NULL(node)) return ;





  switch (NTYPE(node)) {
  case NT_STR:
    if (NSTR(node)->capa != 0 &&
 IS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {
      xfree(NSTR(node)->s);
    }
    break;

  case NT_LIST:
  case NT_ALT:
    onig_node_free(NCAR(node));
    {
      Node* next_node = NCDR(node);

      xfree(node);
      node = next_node;
      goto start;
    }
    break;

  case NT_CCLASS:
    {
      CClassNode* cc = NCCLASS(node);

      if (IS_NCCLASS_SHARE(cc)) return ;
      if (cc->mbuf)
        bbuf_free(cc->mbuf);
    }
    break;

  case NT_QTFR:
    if (NQTFR(node)->target)
      onig_node_free(NQTFR(node)->target);
    break;

  case NT_ENCLOSE:
    if (NENCLOSE(node)->target)
      onig_node_free(NENCLOSE(node)->target);
    break;

  case NT_BREF:
    if (IS_NOT_NULL(NBREF(node)->back_dynamic))
      xfree(NBREF(node)->back_dynamic);
    break;

  case NT_ANCHOR:
    if (NANCHOR(node)->target)
      onig_node_free(NANCHOR(node)->target);
    break;
  }

  xfree(node);
}

static Node*
fn_50(void)
{
  Node* node;

  node = (Node* )xmalloc(sizeof(Node));




  return node;
}


static void
fn_51(CClassNode* cc)
{
  BITSET_CLEAR(cc->bs);

  cc->flags = 0;
  cc->mbuf = NULL;
}

static Node*
fn_52(void)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_CCLASS);
  initialize_cclass(NCCLASS(node));
  return node;
}

static Node*
fn_53(int var_164, int var_155)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_CTYPE);
  NCTYPE(node)->ctype = var_164;
  NCTYPE(node)->not = var_155;
  return node;
}

static Node*
fn_56(void)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_CANY);
  return node;
}

static Node*
fn_57(Node* left, Node* right)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_LIST);
  NCAR(node) = left;
  NCDR(node) = right;
  return node;
}

extern Node*
fn_58(Node* left, Node* right)
{
  return node_new_list(left, right);
}

extern Node*
fn_59(Node* list, Node* x)
{
  Node *var_175;

  var_175 = onig_node_new_list(x, NULL);
  if (IS_NULL(var_175)) return var_181;

  if (IS_NOT_NULL(list)) {
    while (IS_NOT_NULL(NCDR(list)))
      list = NCDR(list);

    NCDR(list) = var_175;
  }

  return var_175;
}

extern Node*
fn_60(Node* left, Node* right)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_ALT);
  NCAR(node) = left;
  NCDR(node) = right;
  return node;
}

extern Node*
fn_61(int var_164)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_ANCHOR);
  NANCHOR(node)->type = var_164;
  NANCHOR(node)->target = NULL;
  NANCHOR(node)->char_len = -1;
  return node;
}

static Node*
fn_62(int var_65, int* backrefs, int var_65,



   ScanEnv* env)
{
  int i;
  Node* node = node_new();

  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_BREF);
  NBREF(node)->state = 0;
  NBREF(node)->back_num = var_65;
  NBREF(node)->back_dynamic = (int* )NULL;
  if (var_65 != 0)
    NBREF(node)->state |= NST_NAME_REF;

  for (i = 0; i < var_65; i++) {
    if (backrefs[i] <= env->num_mem &&
        IS_NULL(SCANENV_MEM_NODES(env)[backrefs[i]])) {
      NBREF(node)->state |= NST_RECURSION;
      break;
    }
  }

  if (var_65 <= NODE_BACKREFS_SIZE) {
    for (i = 0; i < var_65; i++)
      NBREF(node)->back_static[i] = backrefs[i];
  }
  else {
    int* var_184 = (int* )xmalloc(sizeof(int) * var_65);
    if (IS_NULL(var_184)) {
      onig_node_free(node);
      return NULL;
    }
    NBREF(node)->back_dynamic = var_184;
    for (i = 0; i < var_65; i++)
      var_184[i] = backrefs[i];
  }
  return node;
}

static Node*
fn_65(int var_69, int var_69, int var_69)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_QTFR);
  NQTFR(node)->state = 0;
  NQTFR(node)->target = NULL;
  NQTFR(node)->lower = var_69;
  NQTFR(node)->upper = var_69;
  NQTFR(node)->greedy = 1;
  NQTFR(node)->target_empty_info = NQ_TARGET_ISNOT_EMPTY;
  NQTFR(node)->head_exact = var_181;
  NQTFR(node)->next_head_exact = var_181;
  NQTFR(node)->is_refered = 0;
  if (var_69 != 0)
    NQTFR(node)->state |= NST_BY_NUMBER;





  return node;
}

static Node*
fn_69(int var_164)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_ENCLOSE);
  NENCLOSE(node)->type = var_164;
  NENCLOSE(node)->state = 0;
  NENCLOSE(node)->regnum = 0;
  NENCLOSE(node)->option = 0;
  NENCLOSE(node)->target = NULL;
  NENCLOSE(node)->call_addr = -1;
  NENCLOSE(node)->opt_count = 0;
  return node;
}

extern Node*
fn_70(int var_164)
{
  return node_new_enclose(var_164);
}

static Node*
fn_71(OnigOptionType var_174, int var_74)
{
  Node* node = node_new_enclose(ENCLOSE_MEMORY);
  CHECK_NULL_RETURN(node);
  if (var_74 != 0)
    SET_ENCLOSE_STATUS(node, NST_NAMED_GROUP);




  return node;
}

static Node*
fn_74(OnigOptionType var_174)
{
  Node* node = node_new_enclose(ENCLOSE_OPTION);
  CHECK_NULL_RETURN(node);
  NENCLOSE(node)->option = var_174;
  return node;
}

extern int
fn_75(Node* node, const UChar* s, const UChar* end)
{
  int var_77 = end - s;

  if (var_77 > 0) {
    int var_181 = NSTR(node)->end - NSTR(node)->s;

    if (NSTR(node)->capa > 0 || (var_181 + var_77 > NODE_STR_BUF_SIZE - 1)) {
      UChar* var_184;
      int var_77 = var_181 + var_77 + NODE_STR_MARGIN;

      if (var_77 <= NSTR(node)->capa) {
        onig_strcpy(NSTR(node)->s + var_181, s, end);
      }
      else {
        if (NSTR(node)->s == NSTR(node)->buf)
          var_184 = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,
                                      s, end, var_77);
        else
          var_184 = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, var_77);

        CHECK_NULL_RETURN_MEMERR(var_184);
        NSTR(node)->s = var_184;
        NSTR(node)->capa = var_77;
      }
    }
    else {
      onig_strcpy(NSTR(node)->s + var_181, s, end);
    }
    NSTR(node)->end = NSTR(node)->s + var_181 + var_77;
  }

  return 0;
}

extern int
fn_77(Node* node, const UChar* s, const UChar* end)
{
  onig_node_str_clear(node);
  return onig_node_str_cat(node, s, end);
}

static int
fn_78(Node* node, UChar var_173)
{
  UChar s[1];

  s[0] = var_173;
  return onig_node_str_cat(node, s, s + 1);
}

extern void
fn_80(Node* node, int var_82)
{
  SET_NTYPE(node, NT_STR);
  NSTR(node)->flag = var_82;
  NSTR(node)->capa = 0;
  NSTR(node)->s = NSTR(node)->buf;
  NSTR(node)->end = NSTR(node)->buf;
}

extern void
fn_82(Node* node)
{
  if (NSTR(node)->capa != 0 &&
      IS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {
    xfree(NSTR(node)->s);
  }

  NSTR(node)->capa = 0;
  NSTR(node)->flag = 0;
  NSTR(node)->s = NSTR(node)->buf;
  NSTR(node)->end = NSTR(node)->buf;
}

static Node*
fn_83(const UChar* s, const UChar* end)
{
  Node* node = node_new();
  CHECK_NULL_RETURN(node);

  SET_NTYPE(node, NT_STR);
  NSTR(node)->capa = 0;
  NSTR(node)->flag = 0;
  NSTR(node)->s = NSTR(node)->buf;
  NSTR(node)->end = NSTR(node)->buf;
  if (onig_node_str_cat(node, s, end)) {
    onig_node_free(node);
    return NULL;
  }
  return node;
}

extern Node*
fn_84(const UChar* s, const UChar* end)
{
  return node_new_str(s, end);
}

static Node*
fn_85(UChar* s, UChar* end)
{
  Node* node = node_new_str(s, end);
  NSTRING_SET_RAW(node);
  return node;
}

static Node*
fn_86(void)
{
  return node_new_str(NULL, NULL);
}

static Node*
fn_87(UChar var_173)
{
  UChar var_184[1];

  var_184[0] = var_173;
  return node_new_str_raw(var_184, var_184 + 1);
}

static Node*
fn_88(StrNode* sn, OnigEncoding var_173)
{
  const UChar *var_184;
  Node* var_175 = var_181;

  if (sn->end > sn->s) {
    var_184 = onigenc_get_prev_char_head(var_173, sn->s, sn->end);
    if (var_184 && var_184 > sn->s) {
      var_175 = node_new_str(var_184, sn->end);
      if ((sn->flag & NSTR_RAW) != 0)
        NSTRING_SET_RAW(var_175);

      sn->end = (UChar* )var_184;
    }
  }
  return var_175;
}

static int
fn_90(StrNode* sn, OnigEncoding var_173)
{
  if (sn->end > sn->s) {
    return ((enclen(var_173, sn->s) < sn->end - sn->s) ? 1 : 0);
  }
  return 0;
}

extern int
fn_91(UChar** src, const UChar* end, OnigEncoding var_173)
{
  unsigned int var_181, val;
  OnigCodePoint var_173;
  UChar* var_184 = *src;
  UChar* var_173;

  var_181 = 0;
  while (!(var_184 < end ? 0 : 1)) {
    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if (ONIGENC_IS_CODE_DIGIT(var_173, var_173)) {
      val = (unsigned int )DIGITVAL(var_173);
      if ((INT_MAX_LIMIT - val) / 10UL < var_181)
        return -1;

      var_181 = var_181 * 10 + val;
    }
    else {
      var_184 = var_173;
      break;
    }
  }
  *src = var_184;
  return var_181;
}

static int
fn_93(UChar** src, UChar* end, int var_96,
     OnigEncoding var_173)
{
  OnigCodePoint var_173;
  unsigned int var_181, val;
  UChar* var_184 = *src;
  UChar* var_173;

  var_181 = 0;
  while (! (var_184 < end ? 0 : 1) && var_96-- != 0) {
    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if (ONIGENC_IS_CODE_XDIGIT(var_173, var_173)) {
      val = (unsigned int )XDIGITVAL(var_173,var_173);
      if ((INT_MAX_LIMIT - val) / 16UL < var_181)
        return -1;

      var_181 = (var_181 << 4) + XDIGITVAL(var_173,var_173);
    }
    else {
      var_184 = var_173;
      break;
    }
  }
  *src = var_184;
  return var_181;
}

static int
fn_95(UChar** src, UChar* end, int var_96,
      OnigEncoding var_173)
{
  OnigCodePoint var_173;
  unsigned int var_181, val;
  UChar* var_184 = *src;
  UChar* var_173;

  var_181 = 0;
  while (!(var_184 < end ? 0 : 1) && var_96-- != 0) {
    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if (ONIGENC_IS_CODE_DIGIT(var_173, var_173) && var_173 < '8') {
      val = ODIGITVAL(var_173);
      if ((INT_MAX_LIMIT - val) / 8UL < var_181)
        return -1;

      var_181 = (var_181 << 3) + val;
    }
    else {
      var_184 = var_173;
      break;
    }
  }
  *src = var_184;
  return var_181;
}

static int
fn_96(BBuf** pbuf)
{

  int var_184;
  OnigCodePoint var_175;
  BBuf* bbuf;

  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));
  CHECK_NULL_RETURN_MEMERR(*pbuf);
  var_184 = BBUF_INIT(*pbuf, (SIZE_CODE_POINT * 5));
  if (var_184) return var_184;

  var_175 = 0;
  BBUF_WRITE(bbuf, 0, &(var_175), SIZE_CODE_POINT);
  return 0;
}

static int
fn_97(BBuf** pbuf, OnigCodePoint var_180, OnigCodePoint var_180)
{
  int var_184, inc_n, pos;
  int low, high, bound, x;
  OnigCodePoint var_175, *data;
  BBuf* bbuf;

  if (var_180 > var_180) {
    var_175 = var_180; var_180 = var_180; var_180 = var_175;
  }

  if (IS_NULL(*pbuf)) {
    var_184 = new_code_range(pbuf);
    if (var_184) return var_184;
    bbuf = *pbuf;
    var_175 = 0;
  }
  else {
    bbuf = *pbuf;
    GET_CODE_POINT(var_175, bbuf->p);
  }
  data = (OnigCodePoint* )(bbuf->p);
  data++;

  for (low = 0, bound = var_175; low < bound; ) {
    x = (low + bound) >> 1;
    if (var_180 > data[x*2 + 1])
      low = x + 1;
    else
      bound = x;
  }

  high = (var_180 == ~((OnigCodePoint )0)) ? var_175 : low;
  for (bound = var_175; high < bound; ) {
    x = (high + bound) >> 1;
    if (var_180 + 1 >= data[x*2])
      high = x + 1;
    else
      bound = x;
  }

  inc_n = low + 1 - high;
  if (var_175 + inc_n > ONIG_MAX_MULTI_BYTE_RANGES_NUM)
    return ONIGERR_TOO_MANY_MULTI_BYTE_RANGES;

  if (inc_n != 1) {
    if (var_180 > data[low*2])
      var_180 = data[low*2];
    if (var_180 < data[(high - 1)*2 + 1])
      var_180 = data[(high - 1)*2 + 1];
  }

  if (inc_n != 0 && (OnigCodePoint )high < var_175) {
    int var_101 = SIZE_CODE_POINT * (1 + high * 2);
    int var_101 = SIZE_CODE_POINT * (1 + (low + 1) * 2);
    int var_101 = (var_175 - high) * 2 * SIZE_CODE_POINT;

    if (inc_n > 0) {
      BBUF_MOVE_RIGHT(bbuf, var_101, var_101, var_101);
    }
    else {
      BBUF_MOVE_LEFT_REDUCE(bbuf, var_101, var_101);
    }
  }

  pos = SIZE_CODE_POINT * (1 + low * 2);
  BBUF_ENSURE_SIZE(bbuf, pos + SIZE_CODE_POINT * 2);
  BBUF_WRITE(bbuf, pos, &(var_180), SIZE_CODE_POINT);
  BBUF_WRITE(bbuf, pos + SIZE_CODE_POINT, &(var_180), SIZE_CODE_POINT);
  var_175 += inc_n;
  BBUF_WRITE(bbuf, 0, &(var_175), SIZE_CODE_POINT);

  return 0;
}

static int
fn_101(BBuf** pbuf, ScanEnv* env, OnigCodePoint var_180, OnigCodePoint var_180)
{
  if (var_180 > var_180) {
    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))
      return 0;
    else
      return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;
  }

  return add_code_range_to_buf(pbuf, var_180, var_180);
}

static int
fn_102(OnigEncoding var_173, BBuf* bbuf, BBuf** pbuf)
{
  int var_184, i, var_175;
  OnigCodePoint pre, var_180, *data, var_180 = 0;

  *pbuf = (BBuf* )NULL;
  if (IS_NULL(bbuf)) {
  set_all:
    return add_code_range_to_buf(pbuf, (OnigCodePoint )(ONIGENC_MBC_MINLEN(var_173) > 1 ? 0 : 0x80), ~((OnigCodePoint )0));
  }

  data = (OnigCodePoint* )(bbuf->p);
  GET_CODE_POINT(var_175, data);
  data++;
  if (var_175 <= 0) goto set_all;

  var_184 = 0;
  pre = (OnigCodePoint )(ONIGENC_MBC_MINLEN(var_173) > 1 ? 0 : 0x80);
  for (i = 0; i < var_175; i++) {
    var_180 = data[i*2];
    var_180 = data[i*2+1];
    if (pre <= var_180 - 1) {
      var_184 = add_code_range_to_buf(pbuf, pre, var_180 - 1);
      if (var_184 != 0) return var_184;
    }
    if (var_180 == ~((OnigCodePoint )0)) break;
    pre = var_180 + 1;
  }
  if (var_180 < ~((OnigCodePoint )0)) {
    var_184 = add_code_range_to_buf(pbuf, var_180 + 1, ~((OnigCodePoint )0));
  }
  return var_184;
}

static int
fn_103(OnigEncoding var_173, BBuf* bbuf1, int var_106,
                  BBuf* bbuf2, int var_106, BBuf** pbuf)
{
  int var_184;
  OnigCodePoint i, n1, *data1;
  OnigCodePoint var_180, var_180;

  *pbuf = (BBuf* )NULL;
  if (IS_NULL(bbuf1) && IS_NULL(bbuf2)) {
    if (var_106 != 0 || var_106 != 0)
      return add_code_range_to_buf(pbuf, (OnigCodePoint )(ONIGENC_MBC_MINLEN(var_173) > 1 ? 0 : 0x80), ~((OnigCodePoint )0));
    return 0;
  }

  var_184 = 0;
  if (IS_NULL(bbuf2))
    do { BBuf *tbuf; int tnot; tnot = var_106; var_106 = var_106; var_106 = tnot; tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; } while 0;

  if (IS_NULL(bbuf1)) {
    if (var_106 != 0) {
      return add_code_range_to_buf(pbuf, (OnigCodePoint )(ONIGENC_MBC_MINLEN(var_173) > 1 ? 0 : 0x80), ~((OnigCodePoint )0));
    }
    else {
      if (var_106 == 0) {
        return bbuf_clone(pbuf, bbuf2);
      }
      else {
        return not_code_range_buf(var_173, bbuf2, pbuf);
      }
    }
  }

  if (var_106 != 0)
    do { BBuf *tbuf; int tnot; tnot = var_106; var_106 = var_106; var_106 = tnot; tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; } while 0;

  data1 = (OnigCodePoint* )(bbuf1->p);
  GET_CODE_POINT(n1, data1);
  data1++;

  if (var_106 == 0 && var_106 == 0) {
    var_184 = bbuf_clone(pbuf, bbuf2);
  }
  else if (var_106 == 0) {
    var_184 = not_code_range_buf(var_173, bbuf2, pbuf);
  }
  if (var_184 != 0) return var_184;

  for (i = 0; i < n1; i++) {
    var_180 = data1[i*2];
    var_180 = data1[i*2+1];
    var_184 = add_code_range_to_buf(pbuf, var_180, var_180);
    if (var_184 != 0) return var_184;
  }
  return 0;
}

static int
and_code_range1(BBuf** pbuf, OnigCodePoint from1, OnigCodePoint to1,
         OnigCodePoint* data, int var_175)
{
  int i, var_184;
  OnigCodePoint from2, to2;

  for (i = 0; i < var_175; i++) {
    from2 = data[i*2];
    to2 = data[i*2+1];
    if (from2 < from1) {
      if (to2 < from1) continue;
      else {
        from1 = to2 + 1;
      }
    }
    else if (from2 <= to1) {
      if (to2 < to1) {
        if (from1 <= from2 - 1) {
          var_184 = add_code_range_to_buf(pbuf, from1, from2-1);
          if (var_184 != 0) return var_184;
        }
        from1 = to2 + 1;
      }
      else {
        to1 = from2 - 1;
      }
    }
    else {
      from1 = from2;
    }
    if (from1 > to1) break;
  }
  if (from1 <= to1) {
    var_184 = add_code_range_to_buf(pbuf, from1, to1);
    if (var_184 != 0) return var_184;
  }
  return 0;
}

static int
and_code_range_buf(BBuf* bbuf1, int var_106, BBuf* bbuf2, int var_106, BBuf** pbuf)
{
  int var_184;
  OnigCodePoint i, j, n1, n2, *data1, *data2;
  OnigCodePoint var_180, var_180, from1, to1, from2, to2;

  *pbuf = (BBuf* )NULL;
  if (IS_NULL(bbuf1)) {
    if (var_106 != 0 && IS_NOT_NULL(bbuf2))
      return bbuf_clone(pbuf, bbuf2);
    return 0;
  }
  else if (IS_NULL(bbuf2)) {
    if (var_106 != 0)
      return bbuf_clone(pbuf, bbuf1);
    return 0;
  }

  if (var_106 != 0)
    do { BBuf *tbuf; int tnot; tnot = var_106; var_106 = var_106; var_106 = tnot; tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; } while 0;

  data1 = (OnigCodePoint* )(bbuf1->p);
  data2 = (OnigCodePoint* )(bbuf2->p);
  GET_CODE_POINT(n1, data1);
  GET_CODE_POINT(n2, data2);
  data1++;
  data2++;

  if (var_106 == 0 && var_106 == 0) {
    for (i = 0; i < n1; i++) {
      from1 = data1[i*2];
      to1 = data1[i*2+1];
      for (j = 0; j < n2; j++) {
        from2 = data2[j*2];
        to2 = data2[j*2+1];
        if (from2 > to1) break;
        if (to2 < from1) continue;
        var_180 = MAX(from1, from2);
        var_180 = MIN(to1, to2);
        var_184 = add_code_range_to_buf(pbuf, var_180, var_180);
        if (var_184 != 0) return var_184;
      }
    }
  }
  else if (var_106 == 0) {
    for (i = 0; i < n1; i++) {
      from1 = data1[i*2];
      to1 = data1[i*2+1];
      var_184 = and_code_range1(pbuf, from1, to1, data2, n2);
      if (var_184 != 0) return var_184;
    }
  }

  return 0;
}

static int
and_cclass(CClassNode* var_106, CClassNode* cc, OnigEncoding var_173)
{
  int var_184, var_106, var_106;
  BBuf *buf1, *buf2, *pbuf;
  BitSetRef bsr1, bsr2;
  BitSet bs1, bs2;

  var_106 = IS_NCCLASS_NOT(var_106);
  bsr1 = var_106->bs;
  buf1 = var_106->mbuf;
  var_106 = IS_NCCLASS_NOT(cc);
  bsr2 = cc->bs;
  buf2 = cc->mbuf;

  if (var_106 != 0) {
    bitset_invert_to(bsr1, bs1);
    bsr1 = bs1;
  }
  if (var_106 != 0) {
    bitset_invert_to(bsr2, bs2);
    bsr2 = bs2;
  }
  bitset_and(bsr1, bsr2);
  if (bsr1 != var_106->bs) {
    bitset_copy(var_106->bs, bsr1);
    bsr1 = var_106->bs;
  }
  if (var_106 != 0) {
    bitset_invert(var_106->bs);
  }

  if (! ONIGENC_IS_SINGLEBYTE(var_173)) {
    if (var_106 != 0 && var_106 != 0) {
      var_184 = or_code_range_buf(var_173, buf1, 0, buf2, 0, &pbuf);
    }
    else {
      var_184 = and_code_range_buf(buf1, var_106, buf2, var_106, &pbuf);
      if (var_184 == 0 && var_106 != 0) {
        BBuf *tbuf;
        var_184 = not_code_range_buf(var_173, pbuf, &tbuf);
        if (var_184 != 0) {
          bbuf_free(pbuf);
          return var_184;
        }
        bbuf_free(pbuf);
        pbuf = tbuf;
      }
    }
    if (var_184 != 0) return var_184;

    var_106->mbuf = pbuf;
    bbuf_free(buf1);
    return var_184;
  }
  return 0;
}

static int
or_cclass(CClassNode* var_106, CClassNode* cc, OnigEncoding var_173)
{
  int var_184, var_106, var_106;
  BBuf *buf1, *buf2, *pbuf;
  BitSetRef bsr1, bsr2;
  BitSet bs1, bs2;

  var_106 = IS_NCCLASS_NOT(var_106);
  bsr1 = var_106->bs;
  buf1 = var_106->mbuf;
  var_106 = IS_NCCLASS_NOT(cc);
  bsr2 = cc->bs;
  buf2 = cc->mbuf;

  if (var_106 != 0) {
    bitset_invert_to(bsr1, bs1);
    bsr1 = bs1;
  }
  if (var_106 != 0) {
    bitset_invert_to(bsr2, bs2);
    bsr2 = bs2;
  }
  bitset_or(bsr1, bsr2);
  if (bsr1 != var_106->bs) {
    bitset_copy(var_106->bs, bsr1);
    bsr1 = var_106->bs;
  }
  if (var_106 != 0) {
    bitset_invert(var_106->bs);
  }

  if (! ONIGENC_IS_SINGLEBYTE(var_173)) {
    if (var_106 != 0 && var_106 != 0) {
      var_184 = and_code_range_buf(buf1, 0, buf2, 0, &pbuf);
    }
    else {
      var_184 = or_code_range_buf(var_173, buf1, var_106, buf2, var_106, &pbuf);
      if (var_184 == 0 && var_106 != 0) {
        BBuf *tbuf;
        var_184 = not_code_range_buf(var_173, pbuf, &tbuf);
        if (var_184 != 0) {
          bbuf_free(pbuf);
          return var_184;
        }
        bbuf_free(pbuf);
        pbuf = tbuf;
      }
    }
    if (var_184 != 0) return var_184;

    var_106->mbuf = pbuf;
    bbuf_free(buf1);
    return var_184;
  }
  else
    return 0;
}

static OnigCodePoint
conv_backslash_value(OnigCodePoint var_173, ScanEnv* env)
{
  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_CONTROL_CHARS)) {
    switch (var_173) {
    case 'n': return '\n';
    case 't': return '\t';
    case 'r': return '\r';
    case 'f': return '\f';
    case 'a': return '\007';
    case 'b': return '\010';
    case 'e': return '\033';
    case 'v':
      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_V_VTAB))
 return '\v';
      break;

    default:
      break;
    }
  }
  return var_173;
}

static int
is_invalid_quantifier_target(Node* node)
{
  switch (NTYPE(node)) {
  case NT_ANCHOR:
    return 1;
    break;

  case NT_ENCLOSE:


    break;

  case NT_LIST:
    do {
      if (! is_invalid_quantifier_target(NCAR(node))) return 0;
    } while (IS_NOT_NULL(node = NCDR(node)));
    return 0;
    break;

  case NT_ALT:
    do {
      if (is_invalid_quantifier_target(NCAR(node))) return 1;
    } while (IS_NOT_NULL(node = NCDR(node)));
    break;

  default:
    break;
  }
  return 0;
}


static int
popular_quantifier_num(QtfrNode* q)
{
  if (q->greedy) {
    if (q->lower == 0) {
      if (q->upper == 1) return 0;
      else if (IS_REPEAT_INFINITE(q->upper)) return 1;
    }
    else if (q->lower == 1) {
      if (IS_REPEAT_INFINITE(q->upper)) return 2;
    }
  }
  else {
    if (q->lower == 0) {
      if (q->upper == 1) return 3;
      else if (IS_REPEAT_INFINITE(q->upper)) return 4;
    }
    else if (q->lower == 1) {
      if (IS_REPEAT_INFINITE(q->upper)) return 5;
    }
  }
  return -1;
}


enum ReduceType {
  RQ_ASIS = 0,
  RQ_DEL = 1,
  RQ_A,
  RQ_AQ,
  RQ_QQ,
  RQ_P_QQ,
  RQ_PQ_Q
};

static enum enumtype_106 ReduceTypeTable[6][6] = {
  {RQ_DEL, RQ_A, RQ_A, RQ_QQ, RQ_AQ, RQ_ASIS},
  {RQ_DEL, RQ_DEL, RQ_DEL, RQ_P_QQ, RQ_P_QQ, RQ_DEL},
  {RQ_A, RQ_A, RQ_DEL, RQ_ASIS, RQ_P_QQ, RQ_DEL},
  {RQ_DEL, RQ_AQ, RQ_AQ, RQ_DEL, RQ_AQ, RQ_AQ},
  {RQ_DEL, RQ_DEL, RQ_DEL, RQ_DEL, RQ_DEL, RQ_DEL},
  {RQ_ASIS, RQ_PQ_Q, RQ_DEL, RQ_AQ, RQ_AQ, RQ_DEL}
};

extern void
fn_107(Node* pnode, Node* cnode)
{
  int pnum, cnum;
  QtfrNode *var_184, *var_173;

  var_184 = NQTFR(pnode);
  var_173 = NQTFR(cnode);
  pnum = popular_quantifier_num(var_184);
  cnum = popular_quantifier_num(var_173);
  if (pnum < 0 || cnum < 0) return ;

  switch(ReduceTypeTable[cnum][pnum]) {
  case RQ_DEL:
    *pnode = *cnode;
    break;
  case RQ_A:
    var_184->target = var_173->target;
    var_184->lower = 0; var_184->upper = REPEAT_INFINITE; var_184->greedy = 1;
    break;
  case RQ_AQ:
    var_184->target = var_173->target;
    var_184->lower = 0; var_184->upper = REPEAT_INFINITE; var_184->greedy = 0;
    break;
  case RQ_QQ:
    var_184->target = var_173->target;
    var_184->lower = 0; var_184->upper = 1; var_184->greedy = 0;
    break;
  case RQ_P_QQ:
    var_184->target = cnode;
    var_184->lower = 0; var_184->upper = 1; var_184->greedy = 0;
    var_173->lower = 1; var_173->upper = REPEAT_INFINITE; var_173->greedy = 1;
    return ;
    break;
  case RQ_PQ_Q:
    var_184->target = cnode;
    var_184->lower = 0; var_184->upper = 1; var_184->greedy = 1;
    var_173->lower = 1; var_173->upper = REPEAT_INFINITE; var_173->greedy = 0;
    return ;
    break;
  case RQ_ASIS:
    var_184->target = cnode;
    return ;
    break;
  }

  var_173->target = var_181;
  onig_node_free(cnode);
}


enum enumtype_182 {
  enum_109 = 0,
  enum_110 = 1,
  enum_111,
  enum_112,
  enum_113,
  enum_114,
  enum_115,
  enum_116,
  enum_117,
  enum_118,
  enum_119,
  enum_120,
  enum_121,
  enum_122,
  enum_123,
  enum_124,
  enum_125,
  enum_126,
  enum_127,

  enum_128,
  enum_129,
  enum_130,
  enum_131,
  enum_132
};

typedef struct {
  enum enumtype_182 type;
  int escaped;
  int base;
  UChar* backp;
  union {
    UChar* s;
    int c;
    OnigCodePoint code;
    int anchor;
    int subtype;
    struct {
      int lower;
      int upper;
      int greedy;
      int possessive;
    } repeat;
    struct {
      int num;
      int ref1;
      int* refs;
      int by_name;




    } backref;
    struct {
      UChar* name;
      UChar* name_end;
      int gnum;
    } call;
    struct {
      int ctype;
      int not;
    } prop;
  } u;
} OnigToken;


static int
fn_133(UChar** src, UChar* end, OnigToken* tok, ScanEnv* env)
{
  int low, up, syn_allow, var_136 = 0;
  int var_184 = 0;
  OnigCodePoint var_173;
  OnigEncoding var_173 = env->enc;
  UChar* var_184 = *src;
  UChar* var_173;

  syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL);

  if ((var_184 < end ? 0 : 1)) {
    if (syn_allow)
      return 1;
    else
      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;
  }

  if (! syn_allow) {
    var_173 = (var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0);
    if (var_173 == ')' || var_173 == '(' || var_173 == '|') {
      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;
    }
  }

  low = onig_scan_unsigned_number(&var_184, end, env->enc);
  if (low < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
  if (low > ONIG_MAX_REPEAT_NUM)
    return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;

  if (var_184 == *src) {
    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) {

      low = 0;
      var_136 = 1;
    }
    else
      goto invalid;
  }

  if ((var_184 < end ? 0 : 1)) goto invalid;
  do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
  if (var_173 == ',') {
    UChar* var_181 = var_184;
    up = onig_scan_unsigned_number(&var_184, end, env->enc);
    if (up < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
    if (up > ONIG_MAX_REPEAT_NUM)
      return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;

    if (var_184 == var_181) {
      if (var_136 != 0)
        goto invalid;
      up = REPEAT_INFINITE;
    }
  }
  else {
    if (var_136 != 0)
      goto invalid;

    var_184 = var_173;
    up = low;
    var_184 = 2;
  }

  if ((var_184 < end ? 0 : 1)) goto invalid;
  do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) {
    if (var_173 != MC_ESC(env->syntax)) goto invalid;
    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
  }
  if (var_173 != '}') goto invalid;

  if (!IS_REPEAT_INFINITE(up) && low > up) {
    return ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE;
  }

  tok->type = TK_INTERVAL;
  tok->u.repeat.lower = low;
  tok->u.repeat.upper = up;
  *src = var_184;
  return var_184;

 invalid:
  if (syn_allow) {

    return 1;
  }
  else
    return ONIGERR_INVALID_REPEAT_RANGE_PATTERN;
}


static int
fn_136(UChar** src, UChar* end, ScanEnv* env, OnigCodePoint* val)
{
  int var_169;
  OnigCodePoint var_173;
  OnigEncoding var_173 = env->enc;
  UChar* var_184 = *src;

  if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_AT_ESCAPE;

  do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
  switch (var_173) {
  case 'M':
    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {
      if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_AT_META;
      do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      if (var_173 != '-') return ONIGERR_META_CODE_SYNTAX;
      if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_AT_META;
      do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      if (var_173 == MC_ESC(env->syntax)) {
        var_169 = fetch_escaped_value(&var_184, end, env, &var_173);
        if (var_169 < 0) return var_169;
      }
      var_173 = ((var_173 & 0xff) | 0x80);
    }
    else
      goto backslash;
    break;

  case 'C':
    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {
      if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_AT_CONTROL;
      do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      if (var_173 != '-') return ONIGERR_CONTROL_CODE_SYNTAX;
      goto control;
    }
    else
      goto backslash;

  case 'c':
    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {
    control:
      if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_AT_CONTROL;
      do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      if (var_173 == '?') {
        var_173 = 177;
      }
      else {
        if (var_173 == MC_ESC(env->syntax)) {
          var_169 = fetch_escaped_value(&var_184, end, env, &var_173);
          if (var_169 < 0) return var_169;
        }
        var_173 &= 0x9f;
      }
      break;
    }


  default:
    {
    backslash:
      var_173 = conv_backslash_value(var_173, env);
    }
    break;
  }

  *src = var_184;
  *val = var_173;
  return 0;
}

static int fn_150(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env);

static OnigCodePoint
fn_139(OnigCodePoint var_155)
{
  switch (var_155) {
  case '<': return (OnigCodePoint )'>'; break;
  case '\'': return (OnigCodePoint )'\''; break;
  default:
    break;
  }

  return (OnigCodePoint )0;
}

static int
fn_141(OnigCodePoint var_144, UChar** src, UChar* end,
    UChar** rname_end, ScanEnv* env, int* rback_num, int var_143)
{
  int var_184, is_num, sign;
  OnigCodePoint end_code;
  OnigCodePoint var_173 = 0;
  UChar *name_end;
  OnigEncoding var_173 = env->enc;
  UChar *pnum_head;
  UChar *var_184 = *src;
  UChar* var_173;

  *rback_num = 0;

  end_code = get_name_end_code_point(var_144);

  *rname_end = name_end = end;
  var_184 = 0;
  pnum_head = *src;
  is_num = 0;
  sign = 1;

  if ((var_184 < end ? 0 : 1)) {
    return ONIGERR_EMPTY_GROUP_NAME;
  }
  else {
    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if (var_173 == end_code)
      return ONIGERR_EMPTY_GROUP_NAME;

    if (ONIGENC_IS_CODE_DIGIT(var_173, var_173)) {
      is_num = 1;
    }
    else if (var_173 == '-') {
      is_num = 2;
      sign = -1;
      pnum_head = var_184;
    }
    else {
      var_184 = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;
    }
  }

  while (!(var_184 < end ? 0 : 1)) {
    name_end = var_184;

    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if (var_173 == end_code || var_173 == ')') break;
    if (! ONIGENC_IS_CODE_DIGIT(var_173, var_173))
      var_184 = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;
  }
  if (var_184 == 0 && var_173 != end_code) {
    var_184 = ONIGERR_INVALID_GROUP_NAME;
    name_end = end;
  }

  if (var_184 == 0) {
    *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, var_173);
    if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;
    else if (*rback_num == 0) {
      var_184 = ONIGERR_INVALID_GROUP_NAME;
      goto err;
    }
    *rback_num *= sign;

    *rname_end = name_end;
    *src = var_184;
    return 0;
  }
  else {
  err:
    onig_scan_env_set_error_string(env, var_184, *src, name_end);
    return var_184;
  }
}


static void
fn_144(ScanEnv* env, UChar *var_173)
{
  if (var_146 == var_146) return ;

  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&
      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {
    UChar buf[256];
    onig_snprintf_with_pattern(buf, 256, env->enc,
  env->pattern, env->pattern_end,
                (UChar* )"character class has '%s' without escape", var_173);
    (*var_146)((char* )buf);
  }
}

static void
fn_145(ScanEnv* env, UChar* var_173)
{
  if (var_146 == var_146) return ;

  if (IS_SYNTAX_BV((env)->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {
    UChar buf[256];
    onig_snprintf_with_pattern(buf, 256, (env)->enc,
  (env)->pattern, (env)->pattern_end,
  (UChar* )"regular expression has '%s' without escape", var_173);
    (*var_146)((char* )buf);
  }
}

static UChar*
fn_146(OnigCodePoint s[], int var_175, UChar* var_180, UChar* var_180,
    UChar **next, OnigEncoding var_173)
{
  int i;
  OnigCodePoint x;
  UChar *q;
  UChar *var_184 = var_180;

  while (var_184 < var_180) {
    x = ONIGENC_MBC_TO_CODE(var_173, var_184, var_180);
    q = var_184 + enclen(var_173, var_184);
    if (x == s[0]) {
      for (i = 1; i < var_175 && q < var_180; i++) {
        x = ONIGENC_MBC_TO_CODE(var_173, q, var_180);
        if (x != s[i]) break;
        q += enclen(var_173, q);
      }
      if (i >= var_175) {
        if (IS_NOT_NULL(next))
          *next = q;
        return var_184;
      }
    }
    var_184 = q;
  }
  return NULL_UCHARP;
}

static int
fn_147(OnigCodePoint s[], int var_175, UChar* var_180, UChar* var_180,
   OnigCodePoint var_149, OnigEncoding var_173, OnigSyntaxType* syn)
{
  int i, in_esc;
  OnigCodePoint x;
  UChar *q;
  UChar *var_184 = var_180;

  in_esc = 0;
  while (var_184 < var_180) {
    if (in_esc) {
      in_esc = 0;
      var_184 += enclen(var_173, var_184);
    }
    else {
      x = ONIGENC_MBC_TO_CODE(var_173, var_184, var_180);
      q = var_184 + enclen(var_173, var_184);
      if (x == s[0]) {
        for (i = 1; i < var_175 && q < var_180; i++) {
          x = ONIGENC_MBC_TO_CODE(var_173, q, var_180);
          if (x != s[i]) break;
          q += enclen(var_173, q);
        }
        if (i >= var_175) return 1;
        var_184 += enclen(var_173, var_184);
      }
      else {
        x = ONIGENC_MBC_TO_CODE(var_173, var_184, var_180);
        if (x == var_149) return 0;
        else if (x == MC_ESC(syn)) in_esc = 1;
        var_184 = q;
      }
    }
  }
  return 0;
}

static int
fn_149(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)
{
  int var_181;
  OnigCodePoint var_173, c2;
  OnigSyntaxType* syn = env->syntax;
  OnigEncoding var_173 = env->enc;
  UChar* var_181;
  UChar* var_184 = *src;
  UChar* var_173;

  if ((var_184 < end ? 0 : 1)) {
    tok->type = TK_EOT;
    return tok->type;
  }

  do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
  tok->type = TK_CHAR;
  tok->base = 0;
  tok->u.c = var_173;
  tok->escaped = 0;

  if (var_173 == ']') {
    tok->type = TK_CC_CLOSE;
  }
  else if (var_173 == '-') {
    tok->type = TK_CC_RANGE;
  }
  else if (var_173 == MC_ESC(syn)) {
    if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))
      goto end;

    if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_AT_ESCAPE;

    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    tok->escaped = 1;
    tok->u.c = var_173;
    switch (var_173) {
    case 'w':
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
      tok->u.prop.not = 0;
      break;
    case 'W':
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
      tok->u.prop.not = 1;
      break;
    case 'd':
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
      tok->u.prop.not = 0;
      break;
    case 'D':
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
      tok->u.prop.not = 1;
      break;
    case 's':
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
      tok->u.prop.not = 0;
      break;
    case 'S':
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
      tok->u.prop.not = 1;
      break;
    case 'h':
      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
      tok->u.prop.not = 0;
      break;
    case 'H':
      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
      tok->u.prop.not = 1;
      break;

    case 'p':
    case 'P':
      if ((var_184 < end ? 0 : 1)) break;

      c2 = (var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0);
      if (c2 == '{' &&
   IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {
 do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
 tok->type = TK_CHAR_PROPERTY;
 tok->u.prop.not = (var_173 == 'P' ? 1 : 0);

 if (!(var_184 < end ? 0 : 1) && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {
   do { c2 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
   if (c2 == '^') {
     tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);
   }
   else
     var_184 = var_173;
 }
      }
      break;

    case 'x':
      if ((var_184 < end ? 0 : 1)) break;

      var_181 = var_184;
      if (((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {
        do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
        var_181 = scan_unsigned_hexadecimal_number(&var_184, end, 8, var_173);
        if (var_181 < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;
        if (!(var_184 < end ? 0 : 1)) {
          c2 = (var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0);
          if (ONIGENC_IS_CODE_XDIGIT(var_173, c2))
            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;
        }

        if (var_184 > var_181 + enclen(var_173, var_181) && !(var_184 < end ? 0 : 1) && (((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'}'))) {
          do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
          tok->type = TK_CODE_POINT;
          tok->base = 16;
          tok->u.code = (OnigCodePoint )var_181;
        }
        else {

          var_184 = var_181;
        }
      }
      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {
        var_181 = scan_unsigned_hexadecimal_number(&var_184, end, 2, var_173);
        if (var_181 < 0) return ONIGERR_TOO_BIG_NUMBER;
        if (var_184 == var_181) {
          var_181 = 0;
        }
        tok->type = TK_RAW_BYTE;
        tok->base = 16;
        tok->u.c = var_181;
      }
      break;

    case 'u':
      if ((var_184 < end ? 0 : 1)) break;

      var_181 = var_184;
      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {
        var_181 = scan_unsigned_hexadecimal_number(&var_184, end, 4, var_173);
        if (var_181 < 0) return ONIGERR_TOO_BIG_NUMBER;
        if (var_184 == var_181) {
          var_181 = 0;
        }
        tok->type = TK_CODE_POINT;
        tok->base = 16;
        tok->u.code = (OnigCodePoint )var_181;
      }
      break;

    case '0':
    case '1': case '2': case '3': case '4': case '5': case '6': case '7':
      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {
        var_184 = var_173;
        var_181 = var_184;
        var_181 = scan_unsigned_octal_number(&var_184, end, 3, var_173);
        if (var_181 < 0) return ONIGERR_TOO_BIG_NUMBER;
        if (var_184 == var_181) {
          var_181 = 0;
        }
        tok->type = TK_RAW_BYTE;
        tok->base = 8;
        tok->u.c = var_181;
      }
      break;

    default:
      var_184 = var_173;
      var_181 = fetch_escaped_value(&var_184, end, env, &c2);
      if (var_181 < 0) return var_181;
      if (tok->u.c != c2) {
        tok->u.code = c2;
        tok->type = TK_CODE_POINT;
      }
      break;
    }
  }
  else if (var_173 == '[') {
    if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )':'))) {
      OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };
      tok->backp = var_184;
      do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      if (str_exist_check_with_esc(send, 2, var_184, end,
                                   (OnigCodePoint )']', var_173, syn)) {
        tok->type = TK_POSIX_BRACKET_OPEN;
      }
      else {
        var_184 = var_173;
        goto cc_in_cc;
      }
    }
    else {
    cc_in_cc:
      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {
        tok->type = TK_CC_CC_OPEN;
      }
      else {
        CC_ESC_WARN(env, (UChar* )"[");
      }
    }
  }
  else if (var_173 == '&') {
    if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&
        !(var_184 < end ? 0 : 1) && (((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'&'))) {
      do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      tok->type = TK_CC_AND;
    }
  }

 end:
  *src = var_184;
  return tok->type;
}

static int
fn_150(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)
{
  int var_184, var_181;
  OnigCodePoint var_173;
  OnigEncoding var_173 = env->enc;
  OnigSyntaxType* syn = env->syntax;
  UChar* var_181;
  UChar* var_184 = *src;
  UChar* var_173;

 start:
  if ((var_184 < end ? 0 : 1)) {
    tok->type = TK_EOT;
    return tok->type;
  }

  tok->type = TK_STRING;
  tok->base = 0;
  tok->backp = var_184;

  do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
  if (IS_MC_ESC_CODE(var_173, syn)) {
    if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_AT_ESCAPE;

    tok->backp = var_184;
    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;

    tok->u.c = var_173;
    tok->escaped = 1;
    switch (var_173) {
    case '*':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;
      tok->type = TK_OP_REPEAT;
      tok->u.repeat.lower = 0;
      tok->u.repeat.upper = REPEAT_INFINITE;
      goto greedy_check;
      break;

    case '+':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;
      tok->type = TK_OP_REPEAT;
      tok->u.repeat.lower = 1;
      tok->u.repeat.upper = REPEAT_INFINITE;
      goto greedy_check;
      break;

    case '?':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;
      tok->type = TK_OP_REPEAT;
      tok->u.repeat.lower = 0;
      tok->u.repeat.upper = 1;
    greedy_check:
      if (!(var_184 < end ? 0 : 1) && ((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'?') &&
   IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {
        do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
        tok->u.repeat.greedy = 0;
        tok->u.repeat.possessive = 0;
      }
      else {
      possessive_check:
        if (!(var_184 < end ? 0 : 1) && ((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'+') &&
            ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&
              tok->type != TK_INTERVAL) ||
             (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&
              tok->type == TK_INTERVAL))) {
          do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
          tok->u.repeat.greedy = 1;
          tok->u.repeat.possessive = 1;
        }
        else {
          tok->u.repeat.greedy = 1;
          tok->u.repeat.possessive = 0;
        }
      }
      break;

    case '{':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;
      var_184 = fetch_range_quantifier(&var_184, end, tok, env);
      if (var_184 < 0) return var_184;
      if (var_184 == 0) goto greedy_check;
      else if (var_184 == 2) {
        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))
          goto possessive_check;

        goto greedy_check;
      }

      break;

    case '|':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;
      tok->type = TK_ALT;
      break;

    case '(':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;
      tok->type = TK_SUBEXP_OPEN;
      break;

    case ')':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;
      tok->type = TK_SUBEXP_CLOSE;
      break;

    case 'w':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
      tok->u.prop.not = 0;
      break;

    case 'W':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
      tok->u.prop.not = 1;
      break;

    case 'b':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;
      tok->type = TK_ANCHOR;
      tok->u.anchor = ANCHOR_WORD_BOUND;
      break;

    case 'B':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;
      tok->type = TK_ANCHOR;
      tok->u.anchor = ANCHOR_NOT_WORD_BOUND;
      break;

    case 's':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
      tok->u.prop.not = 0;
      break;

    case 'S':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
      tok->u.prop.not = 1;
      break;

    case 'd':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
      tok->u.prop.not = 0;
      break;

    case 'D':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
      tok->u.prop.not = 1;
      break;

    case 'h':
      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
      tok->u.prop.not = 0;
      break;

    case 'H':
      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;
      tok->type = TK_CHAR_TYPE;
      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
      tok->u.prop.not = 1;
      break;

    case 'A':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;
    begin_buf:
      tok->type = TK_ANCHOR;
      tok->u.subtype = ANCHOR_BEGIN_BUF;
      break;

    case 'Z':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;
      tok->type = TK_ANCHOR;
      tok->u.subtype = ANCHOR_SEMI_END_BUF;
      break;

    case 'z':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;
    end_buf:
      tok->type = TK_ANCHOR;
      tok->u.subtype = ANCHOR_END_BUF;
      break;

    case 'G':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;
      tok->type = TK_ANCHOR;
      tok->u.subtype = ANCHOR_BEGIN_POSITION;
      break;

    case '`':
      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;
      goto begin_buf;
      break;

    case '\'':
      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;
      goto end_buf;
      break;

    case 'x':
      if ((var_184 < end ? 0 : 1)) break;

      var_181 = var_184;
      if (((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {
        do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
        var_181 = scan_unsigned_hexadecimal_number(&var_184, end, 8, var_173);
        if (var_181 < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;
        if (!(var_184 < end ? 0 : 1)) {
          if (ONIGENC_IS_CODE_XDIGIT(var_173, (var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0)))
            return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;
        }

        if ((var_184 > var_181 + enclen(var_173, var_181)) && !(var_184 < end ? 0 : 1) && ((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'}')) {
          do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
          tok->type = TK_CODE_POINT;
          tok->u.code = (OnigCodePoint )var_181;
        }
        else {

          var_184 = var_181;
        }
      }
      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {
        var_181 = scan_unsigned_hexadecimal_number(&var_184, end, 2, var_173);
        if (var_181 < 0) return ONIGERR_TOO_BIG_NUMBER;
        if (var_184 == var_181) {
          var_181 = 0;
        }
        tok->type = TK_RAW_BYTE;
        tok->base = 16;
        tok->u.c = var_181;
      }
      break;

    case 'u':
      if ((var_184 < end ? 0 : 1)) break;

      var_181 = var_184;
      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {
        var_181 = scan_unsigned_hexadecimal_number(&var_184, end, 4, var_173);
        if (var_181 < 0) return ONIGERR_TOO_BIG_NUMBER;
        if (var_184 == var_181) {
          var_181 = 0;
        }
        tok->type = TK_CODE_POINT;
        tok->base = 16;
        tok->u.code = (OnigCodePoint )var_181;
      }
      break;

    case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      var_184 = var_173;
      var_181 = var_184;
      var_181 = onig_scan_unsigned_number(&var_184, end, var_173);
      if (var_181 < 0 || var_181 > ONIG_MAX_BACKREF_NUM) {
        goto skip_backref;
      }

      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&
          (var_181 <= env->num_mem || var_181 <= 9)) {
        if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {
          if (var_181 > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[var_181]))
            return ONIGERR_INVALID_BACKREF;
        }

        tok->type = TK_BACKREF;
        tok->u.backref.num = 1;
        tok->u.backref.ref1 = var_181;
        tok->u.backref.by_name = 0;



        break;
      }

    skip_backref:
      if (var_173 == '8' || var_173 == '9') {

        var_184 = var_181; do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
        break;
      }

      var_184 = var_181;

    case '0':
      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {
        var_181 = var_184;
        var_181 = scan_unsigned_octal_number(&var_184, end, (var_173 == '0' ? 2:3), var_173);
        if (var_181 < 0) return ONIGERR_TOO_BIG_NUMBER;
        if (var_184 == var_181) {
          var_181 = 0;
        }
        tok->type = TK_RAW_BYTE;
        tok->base = 8;
        tok->u.c = var_181;
      }
      else if (var_173 != '0') {
        do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      }
      break;

    case 'Q':
      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {
        tok->type = TK_QUOTE_OPEN;
      }
      break;

    case 'p':
    case 'P':
      if (!(var_184 < end ? 0 : 1) && ((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'{') &&
          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {
        do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
        tok->type = TK_CHAR_PROPERTY;
        tok->u.prop.not = (var_173 == 'P' ? 1 : 0);

        if (!(var_184 < end ? 0 : 1) &&
            IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {
          do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
          if (var_173 == '^') {
            tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);
          }
          else
            var_184 = var_173;
        }
      }
      break;

    default:
      {
        OnigCodePoint c2;

        var_184 = var_173;
        var_181 = fetch_escaped_value(&var_184, end, env, &c2);
        if (var_181 < 0) return var_181;

        if (tok->u.c != c2) {
          tok->type = TK_CODE_POINT;
          tok->u.code = c2;
        }
        else {
          var_184 = tok->backp + enclen(var_173, tok->backp);
 }
      }
      break;
    }
  }
  else {
    tok->u.c = var_173;
    tok->escaped = 0;

    switch (var_173) {
    case '.':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;



      tok->type = TK_ANYCHAR;
      break;

    case '*':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;



      tok->type = TK_OP_REPEAT;
      tok->u.repeat.lower = 0;
      tok->u.repeat.upper = REPEAT_INFINITE;
      goto greedy_check;
      break;

    case '+':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;



      tok->type = TK_OP_REPEAT;
      tok->u.repeat.lower = 1;
      tok->u.repeat.upper = REPEAT_INFINITE;
      goto greedy_check;
      break;

    case '?':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;



      tok->type = TK_OP_REPEAT;
      tok->u.repeat.lower = 0;
      tok->u.repeat.upper = 1;
      goto greedy_check;
      break;

    case '{':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;
      var_184 = fetch_range_quantifier(&var_184, end, tok, env);
      if (var_184 < 0) return var_184;
      if (var_184 == 0) goto greedy_check;
      else if (var_184 == 2) {
        if (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))
          goto possessive_check;

        goto greedy_check;
      }

      break;

    case '|':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;
      tok->type = TK_ALT;
      break;

    case '(':
      if (!(var_184 < end ? 0 : 1) && ((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'?') &&
          IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {
        do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
        if (!(var_184 < end ? 0 : 1) && ((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'#')) {
          do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
          while 1 {
            if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_IN_GROUP;
            do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
            if (var_173 == MC_ESC(syn)) {
              if (!(var_184 < end ? 0 : 1)) do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
            }
            else {
              if (var_173 == ')') break;
            }
          }
          goto start;
        }
        var_184 = var_173;
      }

      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;
      tok->type = TK_SUBEXP_OPEN;
      break;

    case ')':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;
      tok->type = TK_SUBEXP_CLOSE;
      break;

    case '^':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;
      tok->type = TK_ANCHOR;
      tok->u.subtype = (IS_SINGLELINE(env->option)
   ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);
      break;

    case '$':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;
      tok->type = TK_ANCHOR;
      tok->u.subtype = (IS_SINGLELINE(env->option)
   ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);
      break;

    case '[':
      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;
      tok->type = TK_CC_OPEN;
      break;

    case ']':
      if (*src > env->pattern)
        CLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )"]");
      break;

    case '#':
      if (IS_EXTEND(env->option)) {
        while (!(var_184 < end ? 0 : 1)) {
          do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
          if (ONIGENC_IS_CODE_NEWLINE(var_173, var_173))
            break;
        }
        goto start;
        break;
      }
      break;

    case ' ': case '\t': case '\n': case '\r': case '\f':
      if (IS_EXTEND(env->option))
        goto start;
      break;

    default:

      break;
    }
  }




  *src = var_184;
  return tok->type;
}

static int
fn_150(CClassNode* cc, int var_169 var_185, int var_155,
    OnigEncoding var_173 var_185,
                         OnigCodePoint var_154, const OnigCodePoint mbr[])
{
  int i, var_184;
  OnigCodePoint j;

  int var_175 = ONIGENC_CODE_RANGE_NUM(mbr);

  if (var_155 == 0) {
    for (i = 0; i < var_175; i++) {
      for (j = ONIGENC_CODE_RANGE_FROM(mbr, i);
           j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {
        if (j >= var_154) {
          if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {
            var_184 = add_code_range_to_buf(&(cc->mbuf), j,
                                      ONIGENC_CODE_RANGE_TO(mbr, i));
            if (var_184 != 0) return var_184;
            i++;
          }

          goto sb_end;
        }
        BITSET_SET_BIT(cc->bs, j);
      }
    }

  sb_end:
    for ( ; i < var_175; i++) {
      var_184 = add_code_range_to_buf(&(cc->mbuf),
                                ONIGENC_CODE_RANGE_FROM(mbr, i),
                                ONIGENC_CODE_RANGE_TO(mbr, i));
      if (var_184 != 0) return var_184;
    }
  }
  else {
    OnigCodePoint var_181 = 0;

    for (i = 0; i < var_175; i++) {
      for (j = var_181;
    j < ONIGENC_CODE_RANGE_FROM(mbr, i); j++) {
        if (j >= var_154) {
          goto sb_end2;
        }
        BITSET_SET_BIT(cc->bs, j);
      }
      var_181 = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;
    }
    for (j = var_181; j < var_154; j++) {
      BITSET_SET_BIT(cc->bs, j);
    }

  sb_end2:
    var_181 = var_154;

    for (i = 0; i < var_175; i++) {
      if (var_181 < ONIGENC_CODE_RANGE_FROM(mbr, i)) {
        var_184 = add_code_range_to_buf(&(cc->mbuf), var_181,
                                  ONIGENC_CODE_RANGE_FROM(mbr, i) - 1);
        if (var_184 != 0) return var_184;
      }
      var_181 = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;
    }
    if (var_181 < 0x7fffffff) {
      var_184 = add_code_range_to_buf(&(cc->mbuf), var_181, 0x7fffffff);
      if (var_184 != 0) return var_184;
    }
  }

  return 0;
}

static int
fn_153(CClassNode* cc, int var_169, int var_155, ScanEnv* env)
{
  int var_173, var_184;
  const OnigCodePoint *ranges;
  OnigCodePoint var_154;
  OnigEncoding var_173 = env->enc;

  var_184 = ONIGENC_GET_CTYPE_CODE_RANGE(var_173, var_169, &var_154, &ranges);
  if (var_184 == 0) {
    return add_ctype_to_cc_by_range(cc, var_169, var_155, env->enc, var_154, ranges);
  }
  else if (var_184 != ONIG_NO_SUPPORT_CONFIG) {
    return var_184;
  }

  var_184 = 0;
  switch (var_169) {
  case ONIGENC_CTYPE_ALPHA:
  case ONIGENC_CTYPE_BLANK:
  case ONIGENC_CTYPE_CNTRL:
  case ONIGENC_CTYPE_DIGIT:
  case ONIGENC_CTYPE_LOWER:
  case ONIGENC_CTYPE_PUNCT:
  case ONIGENC_CTYPE_SPACE:
  case ONIGENC_CTYPE_UPPER:
  case ONIGENC_CTYPE_XDIGIT:
  case ONIGENC_CTYPE_ASCII:
  case ONIGENC_CTYPE_ALNUM:
    if (var_155 != 0) {
      for (var_173 = 0; var_173 < SINGLE_BYTE_SIZE; var_173++) {
        if (! ONIGENC_IS_CODE_CTYPE(var_173, (OnigCodePoint )var_173, var_169))
          BITSET_SET_BIT(cc->bs, var_173);
      }
      do { if (! ONIGENC_IS_SINGLEBYTE(var_173)) { var_184 = add_code_range_to_buf(&(cc->mbuf), (OnigCodePoint )(ONIGENC_MBC_MINLEN(var_173) > 1 ? 0 : 0x80), ~((OnigCodePoint )0)); if (var_184) return var_184; }} while 0;
    }
    else {
      for (var_173 = 0; var_173 < SINGLE_BYTE_SIZE; var_173++) {
        if (ONIGENC_IS_CODE_CTYPE(var_173, (OnigCodePoint )var_173, var_169))
          BITSET_SET_BIT(cc->bs, var_173);
      }
    }
    break;

  case ONIGENC_CTYPE_GRAPH:
  case ONIGENC_CTYPE_PRINT:
    if (var_155 != 0) {
      for (var_173 = 0; var_173 < SINGLE_BYTE_SIZE; var_173++) {
        if (! ONIGENC_IS_CODE_CTYPE(var_173, (OnigCodePoint )var_173, var_169))
          BITSET_SET_BIT(cc->bs, var_173);
      }
    }
    else {
      for (var_173 = 0; var_173 < SINGLE_BYTE_SIZE; var_173++) {
        if (ONIGENC_IS_CODE_CTYPE(var_173, (OnigCodePoint )var_173, var_169))
          BITSET_SET_BIT(cc->bs, var_173);
      }
      do { if (! ONIGENC_IS_SINGLEBYTE(var_173)) { var_184 = add_code_range_to_buf(&(cc->mbuf), (OnigCodePoint )(ONIGENC_MBC_MINLEN(var_173) > 1 ? 0 : 0x80), ~((OnigCodePoint )0)); if (var_184) return var_184; }} while 0;
    }
    break;

  case ONIGENC_CTYPE_WORD:
    if (var_155 == 0) {
      for (var_173 = 0; var_173 < SINGLE_BYTE_SIZE; var_173++) {
        if (IS_CODE_SB_WORD(var_173, var_173)) BITSET_SET_BIT(cc->bs, var_173);
      }
      do { if (! ONIGENC_IS_SINGLEBYTE(var_173)) { var_184 = add_code_range_to_buf(&(cc->mbuf), (OnigCodePoint )(ONIGENC_MBC_MINLEN(var_173) > 1 ? 0 : 0x80), ~((OnigCodePoint )0)); if (var_184) return var_184; }} while 0;
    }
    else {
      for (var_173 = 0; var_173 < SINGLE_BYTE_SIZE; var_173++) {
        if ((ONIGENC_CODE_TO_MBCLEN(var_173, var_173) > 0)
            && ! ONIGENC_IS_CODE_WORD(var_173, var_173))
          BITSET_SET_BIT(cc->bs, var_173);
      }
    }
    break;

  default:
    return ONIGERR_PARSER_BUG;
    break;
  }

  return var_184;
}

static int
fn_154(CClassNode* cc, UChar** src, UChar* end, ScanEnv* env)
{



  static PosixBracketEntryType PBS[] = {
    { (UChar* )"alnum", ONIGENC_CTYPE_ALNUM, 5 },
    { (UChar* )"alpha", ONIGENC_CTYPE_ALPHA, 5 },
    { (UChar* )"blank", ONIGENC_CTYPE_BLANK, 5 },
    { (UChar* )"cntrl", ONIGENC_CTYPE_CNTRL, 5 },
    { (UChar* )"digit", ONIGENC_CTYPE_DIGIT, 5 },
    { (UChar* )"graph", ONIGENC_CTYPE_GRAPH, 5 },
    { (UChar* )"lower", ONIGENC_CTYPE_LOWER, 5 },
    { (UChar* )"print", ONIGENC_CTYPE_PRINT, 5 },
    { (UChar* )"punct", ONIGENC_CTYPE_PUNCT, 5 },
    { (UChar* )"space", ONIGENC_CTYPE_SPACE, 5 },
    { (UChar* )"upper", ONIGENC_CTYPE_UPPER, 5 },
    { (UChar* )"xdigit", ONIGENC_CTYPE_XDIGIT, 6 },
    { (UChar* )"ascii", ONIGENC_CTYPE_ASCII, 5 },
    { (UChar* )"word", ONIGENC_CTYPE_WORD, 4 },
    { (UChar* )NULL, -1, 0 }
  };

  PosixBracketEntryType *pb;
  int var_155, i, var_184;
  OnigCodePoint var_173;
  OnigEncoding var_173 = env->enc;
  UChar *var_184 = *src;

  if (((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'^')) {
    do { var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    var_155 = 1;
  }
  else
    var_155 = 0;

  if (onigenc_strlen(var_173, var_184, end) < 7)
    goto not_posix_bracket;

  for (pb = PBS; IS_NOT_NULL(pb->name); pb++) {
    if (onigenc_with_ascii_strncmp(var_173, var_184, end, pb->name, pb->len) == 0) {
      var_184 = (UChar* )onigenc_step(var_173, var_184, end, pb->len);
      if (onigenc_with_ascii_strncmp(var_173, var_184, end, (UChar* )":]", 2) != 0)
        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;

      var_184 = add_ctype_to_cc(cc, pb->ctype, var_155, env);
      if (var_184 != 0) return var_184;

      do { var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0; do { var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      *src = var_184;
      return 0;
    }
  }

 not_posix_bracket:
  var_173 = 0;
  i = 0;
  while (!(var_184 < end ? 0 : 1) && ((var_173 = (var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0)) != ':') && var_173 != ']') {
    do { var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if (++i > 20) break;
  }
  if (var_173 == ':' && ! (var_184 < end ? 0 : 1)) {
    do { var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if (! (var_184 < end ? 0 : 1)) {
      do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      if (var_173 == ']')
        return ONIGERR_INVALID_POSIX_BRACKET_TYPE;
    }
  }

  return 1;
}

static int
fetch_char_property_to_ctype(UChar** src, UChar* end, ScanEnv* env)
{
  int var_184;
  OnigCodePoint var_173;
  OnigEncoding var_173 = env->enc;
  UChar *var_181, *var_155, *var_184 = *src;

  var_184 = 0;
  var_155 = var_181 = var_184;

  while (!(var_184 < end ? 0 : 1)) {
    var_181 = var_184;
    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if (var_173 == '}') {
      var_184 = ONIGENC_PROPERTY_NAME_TO_CTYPE(var_173, var_155, var_181);
      if (var_184 < 0) break;

      *src = var_184;
      return var_184;
    }
    else if (var_173 == '(' || var_173 == ')' || var_173 == '{' || var_173 == '|') {
      var_184 = ONIGERR_INVALID_CHAR_PROPERTY_NAME;
      break;
    }
  }

  onig_scan_env_set_error_string(env, var_184, *src, var_181);
  return var_184;
}

static int
parse_char_property(Node** np, OnigToken* tok, UChar** src, UChar* end,
      ScanEnv* env)
{
  int var_184, var_169;
  CClassNode* cc;

  var_169 = fetch_char_property_to_ctype(src, end, env);
  if (var_169 < 0) return var_169;

  *np = node_new_cclass();
  CHECK_NULL_RETURN_MEMERR(*np);
  cc = NCCLASS(*np);
  var_184 = add_ctype_to_cc(cc, var_169, 0, env);
  if (var_184 != 0) return var_184;
  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);

  return 0;
}


enum CCSTATE {
  CCS_VALUE,
  CCS_RANGE,
  CCS_COMPLETE,
  CCS_START
};

enum enumtype_168 {
  enum_156,
  enum_157,
  enum_158
};

static int
fn_159(CClassNode* cc, OnigCodePoint* vs, enum enumtype_168* var_164,
   enum enumtype_168* state, ScanEnv* env)
{
  int var_184;

  if (*state == CCS_RANGE)
    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;

  if (*state == CCS_VALUE && *var_164 != CCV_CLASS) {
    if (*var_164 == CCV_SB)
      BITSET_SET_BIT(cc->bs, (int )(*vs));
    else if (*var_164 == CCV_CODE_POINT) {
      var_184 = add_code_range(&(cc->mbuf), env, *vs, *vs);
      if (var_184 < 0) return var_184;
    }
  }

  *state = CCS_VALUE;
  *var_164 = CCV_CLASS;
  return 0;
}

static int
fn_161(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint var_169,
        int* vs_israw, int var_164,
        enum enumtype_168 var_164, enum enumtype_168* var_164,
        enum enumtype_168* state, ScanEnv* env)
{
  int var_184;

  switch (*state) {
  case CCS_VALUE:
    if (*var_164 == CCV_SB) {
      BITSET_SET_BIT(cc->bs, (int )(*vs));
    }
    else if (*var_164 == CCV_CODE_POINT) {
      var_184 = add_code_range(&(cc->mbuf), env, *vs, *vs);
      if (var_184 < 0) return var_184;
    }
    break;

  case CCS_RANGE:
    if (var_164 == *var_164) {
      if (var_164 == CCV_SB) {
        if (*vs > 0xff || var_169 > 0xff)
          return ONIGERR_INVALID_CODE_POINT_VALUE;

        if (*vs > var_169) {
          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))
            goto ccs_range_end;
          else
            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;
        }
        bitset_set_range(cc->bs, (int )*vs, (int )var_169);
      }
      else {
        var_184 = add_code_range(&(cc->mbuf), env, *vs, var_169);
        if (var_184 < 0) return var_184;
      }
    }
    else {



        if (*vs > var_169) {
          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))
            goto ccs_range_end;
          else
            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;
        }
        bitset_set_range(cc->bs, (int )*vs, (int )(var_169 < 0xff ? var_169 : 0xff));
        var_184 = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, var_169);
        if (var_184 < 0) return var_184;





    }
  ccs_range_end:
    *state = CCS_COMPLETE;
    break;

  case CCS_COMPLETE:
  case CCS_START:
    *state = CCS_VALUE;
    break;

  default:
    break;
  }

  *vs_israw = var_164;
  *vs = var_169;
  *var_164 = var_164;
  return 0;
}

static int
fn_164(OnigCodePoint var_173, UChar* var_180, UChar* end, int var_166,
   ScanEnv* env)
{
  int in_esc;
  OnigCodePoint code;
  OnigEncoding var_173 = env->enc;
  UChar* var_184 = var_180;

  in_esc = 0;
  while (! (var_184 < end ? 0 : 1)) {
    if (var_166 && in_esc) {
      in_esc = 0;
    }
    else {
      do { code = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      if (code == var_173) return 1;
      if (code == MC_ESC(env->syntax)) in_esc = 1;
    }
  }
  return 0;
}

static int
fn_166(Node** np, OnigToken* tok, UChar** src, UChar* end,
   ScanEnv* env)
{
  int var_184, var_173, var_181, fetched, and_start;
  OnigCodePoint var_169, vs;
  UChar *var_184;
  Node* node;
  CClassNode *cc, *prev_cc;
  CClassNode work_cc;

  enum enumtype_168 state;
  enum enumtype_168 val_type, in_type;
  int val_israw, in_israw;

  *np = var_181;
  env->parse_depth++;
  if (env->parse_depth > var_182)
    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;
  prev_cc = (CClassNode* )NULL;
  var_184 = fetch_token_in_cc(tok, src, end, env);
  if (var_184 == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {
    var_173 = 1;
    var_184 = fetch_token_in_cc(tok, src, end, env);
  }
  else {
    var_173 = 0;
  }

  if (var_184 < 0) return var_184;
  if (var_184 == TK_CC_CLOSE) {
    if (! code_exist_check((OnigCodePoint )']',
                           *src, env->pattern_end, 1, env))
      return ONIGERR_EMPTY_CHAR_CLASS;

    CC_ESC_WARN(env, (UChar* )"]");
    var_184 = tok->type = TK_CHAR;
  }

  *np = node = node_new_cclass();
  CHECK_NULL_RETURN_MEMERR(node);
  cc = NCCLASS(node);

  and_start = 0;
  state = CCS_START;
  var_184 = *src;
  while (var_184 != TK_CC_CLOSE) {
    fetched = 0;
    switch (var_184) {
    case TK_CHAR:
    any_char_in:
      var_181 = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);
      if (var_181 > 1) {
        in_type = CCV_CODE_POINT;
      }
      else if (var_181 < 0) {
        var_184 = var_181;
        goto err;
      }
      else {

        in_type = CCV_SB;
      }
      var_169 = (OnigCodePoint )tok->u.c;
      in_israw = 0;
      goto val_entry2;
      break;

    case TK_RAW_BYTE:

      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {
        UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];
        UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;
        UChar* psave = var_184;
        int i, var_169 = tok->base;

        buf[0] = tok->u.c;
        for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {
          var_184 = fetch_token_in_cc(tok, &var_184, end, env);
          if (var_184 < 0) goto err;
          if (var_184 != TK_RAW_BYTE || tok->base != var_169) {
            fetched = 1;
            break;
          }
          buf[i] = tok->u.c;
        }

        if (i < ONIGENC_MBC_MINLEN(env->enc)) {
          var_184 = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;
          goto err;
        }

        var_181 = enclen(env->enc, buf);
        if (i < var_181) {
          var_184 = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;
          goto err;
        }
        else if (i > var_181) {
          var_184 = psave;
          for (i = 1; i < var_181; i++) {
            var_184 = fetch_token_in_cc(tok, &var_184, end, env);
          }
          fetched = 0;
        }

        if (i == 1) {
          var_169 = (OnigCodePoint )buf[0];
          goto raw_single;
        }
        else {
          var_169 = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);
          in_type = CCV_CODE_POINT;
        }
      }
      else {
        var_169 = (OnigCodePoint )tok->u.c;
      raw_single:
        in_type = CCV_SB;
      }
      in_israw = 1;
      goto val_entry2;
      break;

    case TK_CODE_POINT:
      var_169 = tok->u.code;
      in_israw = 1;
    val_entry:
      var_181 = ONIGENC_CODE_TO_MBCLEN(env->enc, var_169);
      if (var_181 < 0) {
        var_184 = var_181;
        goto err;
      }
      in_type = (var_181 == 1 ? CCV_SB : CCV_CODE_POINT);
    val_entry2:
      var_184 = next_state_val(cc, &vs, var_169, &val_israw, in_israw, in_type, &val_type,
    &state, env);
      if (var_184 != 0) goto err;
      break;

    case TK_POSIX_BRACKET_OPEN:
      var_184 = parse_posix_bracket(cc, &var_184, end, env);
      if (var_184 < 0) goto err;
      if (var_184 == 1) {
        CC_ESC_WARN(env, (UChar* )"[");
        var_184 = tok->backp;
        var_169 = (OnigCodePoint )tok->u.c;
        in_israw = 0;
        goto val_entry;
      }
      goto next_class;
      break;

    case TK_CHAR_TYPE:
      var_184 = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);
      if (var_184 != 0) return var_184;

    next_class:
      var_184 = next_state_class(cc, &vs, &val_type, &state, env);
      if (var_184 != 0) goto err;
      break;

    case TK_CHAR_PROPERTY:
      {
        int var_169;

        var_169 = fetch_char_property_to_ctype(&var_184, end, env);
        if (var_169 < 0) return var_169;
        var_184 = add_ctype_to_cc(cc, var_169, tok->u.prop.not, env);
        if (var_184 != 0) return var_184;
        goto next_class;
      }
      break;

    case TK_CC_RANGE:
      if (state == CCS_VALUE) {
        var_184 = fetch_token_in_cc(tok, &var_184, end, env);
        if (var_184 < 0) goto err;
        fetched = 1;
        if (var_184 == TK_CC_CLOSE) {
        range_end_val:
          var_169 = (OnigCodePoint )'-';
          in_israw = 0;
          goto val_entry;
        }
        else if (var_184 == TK_CC_AND) {
          CC_ESC_WARN(env, (UChar* )"-");
          goto range_end_val;
        }
        state = CCS_RANGE;
      }
      else if (state == CCS_START) {

        var_169 = (OnigCodePoint )tok->u.c;
        in_israw = 0;

        var_184 = fetch_token_in_cc(tok, &var_184, end, env);
        if (var_184 < 0) goto err;
        fetched = 1;

        if (var_184 == TK_CC_RANGE || and_start != 0)
          CC_ESC_WARN(env, (UChar* )"-");

        goto val_entry;
      }
      else if (state == CCS_RANGE) {
        CC_ESC_WARN(env, (UChar* )"-");
        goto any_char_in;
      }
      else {
        var_184 = fetch_token_in_cc(tok, &var_184, end, env);
        if (var_184 < 0) goto err;
        fetched = 1;
        if (var_184 == TK_CC_CLOSE) goto range_end_val;
        else if (var_184 == TK_CC_AND) {
          CC_ESC_WARN(env, (UChar* )"-");
          goto range_end_val;
        }

        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {
          CC_ESC_WARN(env, (UChar* )"-");
          goto range_end_val;
        }
        var_184 = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;
        goto err;
      }
      break;

    case TK_CC_CC_OPEN:
      {
        Node *anode;
        CClassNode* acc;

        var_184 = parse_char_class(&anode, tok, &var_184, end, env);
        if (var_184 != 0) {
   onig_node_free(anode);
   goto cc_open_err;
 }
        acc = NCCLASS(anode);
        var_184 = or_cclass(cc, acc, env->enc);

        onig_node_free(anode);
      cc_open_err:
        if (var_184 != 0) goto err;
      }
      break;

    case TK_CC_AND:
      {
        if (state == CCS_VALUE) {
          var_184 = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,
                             &val_type, &state, env);
          if (var_184 != 0) goto err;
        }

        and_start = 1;
        state = CCS_START;

        if (IS_NOT_NULL(prev_cc)) {
          var_184 = and_cclass(prev_cc, cc, env->enc);
          if (var_184 != 0) goto err;
          bbuf_free(cc->mbuf);
        }
        else {
          prev_cc = cc;
          cc = &work_cc;
        }
        initialize_cclass(cc);
      }
      break;

    case TK_EOT:
      var_184 = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;
      goto err;
      break;
    default:
      var_184 = ONIGERR_PARSER_BUG;
      goto err;
      break;
    }

    if (fetched)
      var_184 = tok->type;
    else {
      var_184 = fetch_token_in_cc(tok, &var_184, end, env);
      if (var_184 < 0) goto err;
    }
  }

  if (state == CCS_VALUE) {
    var_184 = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,
         &val_type, &state, env);
    if (var_184 != 0) goto err;
  }

  if (IS_NOT_NULL(prev_cc)) {
    var_184 = and_cclass(prev_cc, cc, env->enc);
    if (var_184 != 0) goto err;
    bbuf_free(cc->mbuf);
    cc = prev_cc;
  }

  if (var_173 != 0)
    NCCLASS_SET_NOT(cc);
  else
    NCCLASS_CLEAR_NOT(cc);
  if (IS_NCCLASS_NOT(cc) &&
      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {
    int is_empty;

    is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);
    if (is_empty != 0)
      do { int i; is_empty = 1; for (i = 0; i < (int )BITSET_SIZE; i++) { if ((cc->bs)[i] != 0) { is_empty = 0; break; } }} while 0;

    if (is_empty == 0) {


      if (ONIGENC_IS_CODE_NEWLINE(env->enc, 0x0a)) {
        if (ONIGENC_CODE_TO_MBCLEN(env->enc, 0x0a) == 1)
          BITSET_SET_BIT(cc->bs, 0x0a);
        else
          add_code_range(&(cc->mbuf), env, 0x0a, 0x0a);
      }
    }
  }
  *src = var_184;
  env->parse_depth--;
  return 0;

 err:
  if (cc != NCCLASS(*np))
    bbuf_free(cc->mbuf);
  return var_184;
}

static int fn_182(Node** top, OnigToken* tok, int var_182,
   UChar** src, UChar* end, ScanEnv* env);

static int
fn_171(Node** np, OnigToken* tok, int var_182, UChar** src, UChar* end,
       ScanEnv* env)
{
  int var_184, var_181;
  Node *target;
  OnigOptionType var_174;
  OnigCodePoint var_173;
  OnigEncoding var_173 = env->enc;





  UChar* var_184 = *src;
  UChar* var_173;

  *np = NULL;
  if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;

  var_174 = env->option;
  if (((var_184 < end ? ONIGENC_MBC_TO_CODE(var_173, var_184, end) : 0) == (OnigCodePoint )'?') &&
      IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {
    do { var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_IN_GROUP;

    do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
    switch (var_173) {
    case ':':
    group:
      var_184 = fetch_token(tok, &var_184, end, env);
      if (var_184 < 0) return var_184;
      var_184 = parse_subexp(np, tok, var_182, &var_184, end, env);
      if (var_184 < 0) return var_184;
      *src = var_184;
      return 1;
      break;

    case '=':
      *np = onig_node_new_anchor(ANCHOR_PREC_READ);
      break;
    case '!':
      *np = onig_node_new_anchor(ANCHOR_PREC_READ_NOT);
      break;
    case '>':
      *np = node_new_enclose(ENCLOSE_STOP_BACKTRACK);
      break;

    case '<':
      if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;
      do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
      if (var_173 == '=')
        *np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND);
      else fn_172 (var_173 == '!')
        *np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND_NOT);

      else {
        return ONIGERR_UNDEFINED_GROUP_OPTION;
      }

      break;

    case '@':
      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY)) {

        *np = node_new_enclose_memory(env->option, 0);
        CHECK_NULL_RETURN_MEMERR(*np);
        var_181 = scan_env_add_mem_entry(env);
        if (var_181 < 0) {
          return var_181;
        }
        else if (var_181 >= (int )BIT_STATUS_BITS_NUM) {
          return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;
        }
        NENCLOSE(*np)->regnum = var_181;
        BIT_STATUS_ON_AT_SIMPLE(env->capture_history, var_181);
      }
      else {
        return ONIGERR_UNDEFINED_GROUP_OPTION;
      }
      break;




    case '-': case 'i': case 'm': case 's': case 'x':
      {
        int var_173 = 0;

        while 1 {
          switch (var_173) {
          case ':':
          case ')':
            break;

          case '-': var_173 = 1; break;
          case 'x': (var_173) ? ((var_174) &= ~(ONIG_OPTION_EXTEND)) : ((var_174) |= (ONIG_OPTION_EXTEND)); break;
          case 'i': (var_173) ? ((var_174) &= ~(ONIG_OPTION_IGNORECASE)) : ((var_174) |= (ONIG_OPTION_IGNORECASE)); break;
          case 's':
            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {
              (var_173) ? ((var_174) &= ~(ONIG_OPTION_MULTILINE)) : ((var_174) |= (ONIG_OPTION_MULTILINE));
            }
            else
              return ONIGERR_UNDEFINED_GROUP_OPTION;
            break;

          case 'm':
            if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {
              ((var_173 == 0 ? 1 : 0)) ? ((var_174) &= ~(ONIG_OPTION_SINGLELINE)) : ((var_174) |= (ONIG_OPTION_SINGLELINE));
            }
            else if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) {
              (var_173) ? ((var_174) &= ~(ONIG_OPTION_MULTILINE)) : ((var_174) |= (ONIG_OPTION_MULTILINE));
            }
            else
              return ONIGERR_UNDEFINED_GROUP_OPTION;
            break;





          default:
            return ONIGERR_UNDEFINED_GROUP_OPTION;
          }

          if (var_173 == ')') {
            *np = node_new_option(var_174);
            CHECK_NULL_RETURN_MEMERR(*np);
            *src = var_184;
            return 2;
          }
          else if (var_173 == ':') {
            OnigOptionType var_181 = env->option;

            env->option = var_174;
            var_184 = fetch_token(tok, &var_184, end, env);
            if (var_184 < 0) return var_184;
            var_184 = parse_subexp(&target, tok, var_182, &var_184, end, env);
            env->option = var_181;
            if (var_184 < 0) {
       onig_node_free(target);
       return var_184;
     }
            *np = node_new_option(var_174);
            CHECK_NULL_RETURN_MEMERR(*np);
            NENCLOSE(*np)->target = target;
            *src = var_184;
            return 0;
          }

          if ((var_184 < end ? 0 : 1)) return ONIGERR_END_PATTERN_IN_GROUP;
          do { var_173 = ONIGENC_MBC_TO_CODE(var_173, var_184, end); var_173 = var_184; var_184 += ONIGENC_MBC_ENC_LEN(var_173, var_184); } while 0;
        }
      }
      break;

    default:
      return ONIGERR_UNDEFINED_GROUP_OPTION;
    }
  }
  else {
    if (ONIG_IS_OPTION_ON(env->var_174, ONIG_OPTION_DONT_CAPTURE_GROUP))
      goto var_181;

    *np = node_new_enclose_memory(env->var_174, 0);
    CHECK_NULL_RETURN_MEMERR(*np);
    var_181 = scan_env_add_mem_entry(env);
    if (var_181 < 0) return var_181;
    NENCLOSE(*np)->regnum = var_181;
  }

  CHECK_NULL_RETURN_MEMERR(*np);
  var_184 = fetch_token(tok, &var_184, end, env);
  if (var_184 < 0) return var_184;
  var_184 = parse_subexp(&target, tok, var_182, &var_184, end, env);
  if (var_184 < 0) {
    onig_node_free(target);
    return var_184;
  }

  if (NTYPE(*np) == NT_ANCHOR)
    NANCHOR(*np)->target = target;
  else {
    NENCLOSE(*np)->target = target;
    if (NENCLOSE(*np)->type == ENCLOSE_MEMORY) {

      var_184 = scan_env_set_mem_node(env, NENCLOSE(*np)->regnum, *np);
      if (var_184 != 0) return var_184;
    }
  }

  *src = var_184;
  return 0;
}

static const char* PopularQStr[] = {
  "?", "*", "+", "??", "*?", "+?"
};

static const char* ReduceQStr[] = {
  "", "", "*", "*?", "??", "+ and ??", "+? and ?"
};

static int
fn_174(Node* qnode, Node* target, int var_181, ScanEnv* env)
{
  QtfrNode* qn;

  qn = NQTFR(qnode);
  if (qn->lower == 1 && qn->upper == 1) {
    return 1;
  }

  switch (NTYPE(target)) {
  case NT_STR:
    if (! var_181) {
      StrNode* sn = NSTR(target);
      if (str_node_can_be_split(sn, env->enc)) {
        Node* var_175 = str_node_split_last_char(sn, env->enc);
        if (IS_NOT_NULL(var_175)) {
          qn->target = var_175;
          return 2;
        }
      }
    }
    break;

  case NT_QTFR:
    {

      QtfrNode* qnt = NQTFR(target);
      int var_177 = popular_quantifier_num(qn);
      int var_177 = popular_quantifier_num(qnt);

      if (var_177 >= 0) {
        if (var_177 >= 0) {
          onig_reduce_nested_quantifier(qnode, target);
          goto q_exit;
        }
        else if (var_177 == 1 || var_177 == 2) {

          if (! IS_REPEAT_INFINITE(qn->upper) && qn->upper > 1 && qn->greedy) {
            qn->upper = (qn->lower == 0 ? 1 : qn->lower);
          }
        }
      }
    }
    break;

  default:
    break;
  }

  qn->target = target;
 q_exit:
  return 0;
}

typedef struct {
  ScanEnv* env;
  CClassNode* cc;
  Node* alt_root;
  Node** ptail;
} IApplyCaseFoldArg;

static int
fn_177(OnigCodePoint var_180, OnigCodePoint var_180[],
    int var_180, void* arg)
{
  IApplyCaseFoldArg* iarg;
  ScanEnv* env;
  CClassNode* cc;
  BitSetRef var_180;

  iarg = (IApplyCaseFoldArg* )arg;
  env = iarg->env;
  cc = iarg->cc;
  var_180 = cc->bs;

  if (var_180 == 1) {
    int var_180 = onig_is_code_in_cc(env->enc, var_180, cc);

    if ((var_180 != 0 && !IS_NCCLASS_NOT(cc)) ||
        (var_180 == 0 && IS_NCCLASS_NOT(cc))) {
      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *var_180 >= SINGLE_BYTE_SIZE) {
        add_code_range(&(cc->mbuf), env, *var_180, *var_180);
      }
      else {
        BITSET_SET_BIT(var_180, *var_180);
      }
    }

  }
  else {
    int var_184, i, var_181;
    UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];
    Node *snode = var_181;

    if (onig_is_code_in_cc(env->enc, var_180, cc)

 && !IS_NCCLASS_NOT(cc)

        ) {
      for (i = 0; i < var_180; i++) {
        var_181 = ONIGENC_CODE_TO_MBC(env->enc, var_180[i], buf);
        if (i == 0) {
          snode = onig_node_new_str(buf, buf + var_181);
          CHECK_NULL_RETURN_MEMERR(snode);



          NSTRING_SET_AMBIG(snode);
        }
        else {
          var_184 = onig_node_str_cat(snode, buf, buf + var_181);
          if (var_184 < 0) {
            onig_node_free(snode);
            return var_184;
          }
        }
      }

      *(iarg->ptail) = onig_node_new_alt(snode, var_181);
      CHECK_NULL_RETURN_MEMERR(*(iarg->ptail));
      iarg->ptail = &(NCDR((*(iarg->ptail))));
    }
  }

  return 0;
}

static int
fn_180(Node** np, OnigToken* tok, int var_182,
   UChar** src, UChar* end, ScanEnv* env)
{
  int var_184, var_181, var_181 = 0;
  Node* qn;
  Node** targetp;

  *np = NULL;
  if (tok->type == (enum enumtype_182 )var_182)
    goto end_of_token;

  switch (tok->type) {
  case TK_ALT:
  case TK_EOT:
  end_of_token:
  *np = node_new_empty();
  return tok->type;
  break;

  case TK_SUBEXP_OPEN:
    var_184 = parse_enclose(np, tok, TK_SUBEXP_CLOSE, src, end, env);
    if (var_184 < 0) return var_184;
    if (var_184 == 1) var_181 = 1;
    else if (var_184 == 2) {
      Node* target;
      OnigOptionType var_181 = env->option;

      env->option = NENCLOSE(*np)->option;
      var_184 = fetch_token(tok, src, end, env);
      if (var_184 < 0) return var_184;
      var_184 = parse_subexp(&target, tok, var_182, src, end, env);
      env->option = var_181;
      if (var_184 < 0) {
        onig_node_free(target);
        return var_184;
      }
      NENCLOSE(*np)->target = target;
      return tok->type;
    }
    break;

  case TK_SUBEXP_CLOSE:
    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))
      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;

    if (tok->escaped) goto tk_raw_byte;
    else goto tk_byte;
    break;

  case TK_STRING:
  tk_byte:
    {
      *np = node_new_str(tok->backp, *src);
      CHECK_NULL_RETURN_MEMERR(*np);

      while 1 {
        var_184 = fetch_token(tok, src, end, env);
        if (var_184 < 0) return var_184;
        if (var_184 != TK_STRING) break;

        var_184 = onig_node_str_cat(*np, tok->backp, *src);
        if (var_184 < 0) return var_184;
      }

    string_end:
      targetp = np;
      goto repeat;
    }
    break;

  case TK_RAW_BYTE:
  tk_raw_byte:
    {
      *np = node_new_str_raw_char((UChar )tok->u.c);
      CHECK_NULL_RETURN_MEMERR(*np);
      var_181 = 1;
      while 1 {
        if (var_181 >= ONIGENC_MBC_MINLEN(env->enc)) {
          if (var_181 == enclen(env->enc, NSTR(*np)->s)) {
            var_184 = fetch_token(tok, src, end, env);
            NSTRING_CLEAR_RAW(*np);
            goto string_end;
          }
        }

        var_184 = fetch_token(tok, src, end, env);
        if (var_184 < 0) return var_184;
        if (var_184 != TK_RAW_BYTE) {

          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;
        }

        var_184 = node_str_cat_char(*np, (UChar )tok->u.c);
        if (var_184 < 0) return var_184;

        var_181++;
      }
    }
    break;

  case TK_CODE_POINT:
    {
      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];
      int var_181 = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);
      if (var_181 < 0) return var_181;



      *np = node_new_str(buf, buf + var_181);

      CHECK_NULL_RETURN_MEMERR(*np);
    }
    break;

  case TK_QUOTE_OPEN:
    {
      OnigCodePoint end_op[2];
      UChar *qstart, *qend, *nextp;

      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);
      end_op[1] = (OnigCodePoint )'E';
      qstart = *src;
      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);
      if (IS_NULL(qend)) {
        nextp = qend = end;
      }
      *np = node_new_str(qstart, qend);
      CHECK_NULL_RETURN_MEMERR(*np);
      *src = nextp;
    }
    break;

  case TK_CHAR_TYPE:
    {
      switch (tok->u.prop.ctype) {
      case ONIGENC_CTYPE_WORD:
        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not);
        CHECK_NULL_RETURN_MEMERR(*np);
        break;

      case ONIGENC_CTYPE_SPACE:
      case ONIGENC_CTYPE_DIGIT:
      case ONIGENC_CTYPE_XDIGIT:
        {
          CClassNode* cc;

          *np = node_new_cclass();
          CHECK_NULL_RETURN_MEMERR(*np);
          cc = NCCLASS(*np);
          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);
          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);
        }
        break;

      default:
        return ONIGERR_PARSER_BUG;
        break;
      }
    }
    break;

  case TK_CHAR_PROPERTY:
    var_184 = parse_char_property(np, tok, src, end, env);
    if (var_184 != 0) return var_184;
    break;

  case TK_CC_OPEN:
    {
      CClassNode* cc;

      var_184 = parse_char_class(np, tok, src, end, env);
      if (var_184 != 0) return var_184;

      cc = NCCLASS(*np);
      if (IS_IGNORECASE(env->option)) {
        IApplyCaseFoldArg iarg;

        iarg.env = env;
        iarg.cc = cc;
        iarg.alt_root = var_181;
        iarg.ptail = &(iarg.alt_root);

        var_184 = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,
                                        i_apply_case_fold, &iarg);
        if (var_184 != 0) {
          onig_node_free(iarg.alt_root);
          return var_184;
        }
        if (IS_NOT_NULL(iarg.alt_root)) {
          Node* work = onig_node_new_alt(*np, iarg.alt_root);
          if (IS_NULL(work)) {
            onig_node_free(iarg.alt_root);
            return ONIGERR_MEMORY;
          }
          *np = work;
        }
      }
    }
    break;

  case TK_ANYCHAR:
    *np = node_new_anychar();
    CHECK_NULL_RETURN_MEMERR(*np);
    break;

  case TK_ANYCHAR_ANYTIME:
    *np = node_new_anychar();
    CHECK_NULL_RETURN_MEMERR(*np);
    qn = node_new_quantifier(0, REPEAT_INFINITE, 0);
    CHECK_NULL_RETURN_MEMERR(qn);
    NQTFR(qn)->target = *np;
    *np = qn;
    break;

  case TK_BACKREF:
    var_181 = tok->u.backref.num;
    *np = node_new_backref(var_181,
                  (var_181 > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),
                  tok->u.backref.by_name,




      env);
    CHECK_NULL_RETURN_MEMERR(*np);
    break;

  case TK_ANCHOR:
    *np = onig_node_new_anchor(tok->u.anchor);
    break;

  case TK_OP_REPEAT:
  case TK_INTERVAL:
    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {
      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))
        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;
      else
        *np = node_new_empty();
    }
    else {
      goto tk_byte;
    }
    break;

  default:
    return ONIGERR_PARSER_BUG;
    break;
  }

  {
    targetp = np;

  re_entry:
    var_184 = fetch_token(tok, src, end, env);
    if (var_184 < 0) return var_184;

  repeat:
    if (var_184 == TK_OP_REPEAT || var_184 == TK_INTERVAL) {
      if (is_invalid_quantifier_target(*targetp))
        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;

      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,
                               (var_184 == TK_INTERVAL ? 1 : 0));
      CHECK_NULL_RETURN_MEMERR(qn);
      NQTFR(qn)->greedy = tok->u.repeat.greedy;
      var_184 = set_quantifier(qn, *targetp, var_181, env);
      if (var_184 < 0) {
        onig_node_free(qn);
        return var_184;
      }

      if (tok->u.repeat.possessive != 0) {
        Node* en;
        en = node_new_enclose(ENCLOSE_STOP_BACKTRACK);
        if (IS_NULL(en)) {
          onig_node_free(qn);
          return ONIGERR_MEMORY;
        }
        NENCLOSE(en)->target = qn;
        qn = en;
      }

      if (var_184 == 0) {
        *targetp = qn;
      }
      else if (var_184 == 1) {
        onig_node_free(qn);
      }
      else if (var_184 == 2) {
        Node *tmp;

        *targetp = node_new_list(*targetp, NULL);
        if (IS_NULL(*targetp)) {
          onig_node_free(qn);
          return ONIGERR_MEMORY;
        }
        tmp = NCDR(*targetp) = node_new_list(qn, NULL);
        if (IS_NULL(tmp)) {
          onig_node_free(qn);
          return ONIGERR_MEMORY;
        }
        targetp = &(NCAR(tmp));
      }
      goto re_entry;
    }
  }

  return var_184;
}

static int
fn_181(Node** top, OnigToken* tok, int var_182,
      UChar** src, UChar* end, ScanEnv* env)
{
  int var_184;
  Node *node, **headp;

  *top = NULL;
  var_184 = parse_exp(&node, tok, var_182, src, end, env);
  if (var_184 < 0) {
    onig_node_free(node);
    return var_184;
  }

  if (var_184 == TK_EOT || var_184 == var_182 || var_184 == TK_ALT) {
    *top = node;
  }
  else {
    *top = node_new_list(node, NULL);
    headp = &(NCDR(*top));
    while (var_184 != TK_EOT && var_184 != var_182 && var_184 != TK_ALT) {
      var_184 = parse_exp(&node, tok, var_182, src, end, env);
      if (var_184 < 0) {
 onig_node_free(node);
 return var_184;
      }

      if (NTYPE(node) == NT_LIST) {
        *headp = node;
        while (IS_NOT_NULL(NCDR(node))) node = NCDR(node);
        headp = &(NCDR(node));
      }
      else {
        *headp = node_new_list(node, NULL);
        headp = &(NCDR(*headp));
      }
    }
  }

  return var_184;
}


static int
fn_182(Node** top, OnigToken* tok, int var_182,
      UChar** src, UChar* end, ScanEnv* env)
{
  int var_184;
  Node *node, **headp;

  *top = NULL;
  env->parse_depth++;
  if (env->parse_depth > var_182)
    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;
  var_184 = parse_branch(&node, tok, var_182, src, end, env);
  if (var_184 < 0) {
    onig_node_free(node);
    return var_184;
  }

  if (var_184 == var_182) {
    *top = node;
  }
  else if (var_184 == TK_ALT) {
    *top = onig_node_new_alt(node, NULL);
    headp = &(NCDR(*top));
    while (var_184 == TK_ALT) {
      var_184 = fetch_token(tok, src, end, env);
      if (var_184 < 0) return var_184;
      var_184 = parse_branch(&node, tok, var_182, src, end, env);
      if (var_184 < 0) {
        onig_node_free(node);
        return var_184;
      }
      *headp = onig_node_new_alt(node, NULL);
      headp = &(NCDR(*headp));
    }

    if (tok->type != (enum enumtype_182 )var_182)
      goto err;
  }
  else {
    onig_node_free(node);
  err:
    if (var_182 == TK_SUBEXP_CLOSE)
      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;
    else
      return ONIGERR_PARSER_BUG;
  }

  env->parse_depth--;
  return var_184;
}

static int
fn_182(Node** top, UChar** src, UChar* end, ScanEnv* env)
{
  int var_184;
  OnigToken tok;

  var_184 = fetch_token(&tok, src, end, env);
  if (var_184 < 0) return var_184;
  var_184 = parse_subexp(top, &tok, TK_EOT, src, end, env);
  if (var_184 < 0) return var_184;
  return 0;
}

extern int
fn_183(Node** root, const UChar* pattern, const UChar* end,
       regex_t* reg, ScanEnv* env)
{
  int var_184;
  UChar* var_184;





  scan_env_clear(env);
  env->option = reg->options;
  env->case_fold_flag = reg->case_fold_flag;
  env->enc = reg->enc;
  env->syntax = reg->syntax;
  env->pattern = (UChar* )pattern;
  env->pattern_end = (UChar* )end;
  env->reg = reg;

  *root = NULL;

  if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, pattern, end))
    return ONIGERR_INVALID_WIDE_CHAR_VALUE;

  var_184 = (UChar* )pattern;
  var_184 = parse_regexp(root, &var_184, (UChar* )end, env);
  reg->num_mem = env->num_mem;
  return var_184;
}

extern void
fn_184(ScanEnv* env, int ecode var_185,
    UChar* arg, UChar* arg_end)
{
  env->error = arg;
  env->error_end = arg_end;
}
