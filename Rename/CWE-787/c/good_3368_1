







static int fn_0(int var_2)
{
 switch(var_2) {
 case IW_IMGTYPE_RGBA:
  return 3;
 case IW_IMGTYPE_GRAYA:
  return 1;
 }
 return 0;
}

static IW_INLINE iw_tmpsample fn_2(iw_tmpsample var_4)
{
 if(var_4<=0.04045) {
  return var_4/12.92;
 }
 else {
  return pow( (var_4+0.055)/(1.055) , 2.4);
 }
}

static IW_INLINE iw_tmpsample fn_4(iw_tmpsample var_6)
{
 if(var_6 < 4.5*0.020) {
  return var_6/4.5;
 }
 else {
  return pow( (var_6+0.099)/1.099 , 1.0/0.45);
 }
}

static IW_INLINE iw_tmpsample fn_6(iw_tmpsample var_47, double var_16)
{
 return pow(var_47,var_16);
}

static iw_tmpsample fn_9(iw_tmpsample var_47, const struct struct_84 *csdescr)
{
 switch(csdescr->cstype) {
 case IW_CSTYPE_SRGB:
  return srgb_to_linear_sample(var_47);
 case IW_CSTYPE_LINEAR:
  return var_47;
 case IW_CSTYPE_GAMMA:
  return gamma_to_linear_sample(var_47,csdescr->gamma);
 case IW_CSTYPE_REC709:
  return rec709_to_linear_sample(var_47);
 }
 return srgb_to_linear_sample(var_47);
}


IW_IMPL(double) fn_11(double var_47, const struct struct_84 *csdescr)
{
 return (double)x_to_linear_sample(var_47,csdescr);
}

static IW_INLINE iw_tmpsample fn_12(iw_tmpsample var_16)
{
 if(var_16 <= 0.0031308) {
  return 12.92*var_16;
 }
 return 1.055*pow(var_16,1.0/2.4) - 0.055;
}

static IW_INLINE iw_tmpsample fn_14(iw_tmpsample var_16)
{



 if(var_16 < 0.020) {
  return 4.5*var_16;
 }
 return 1.099*pow(var_16,0.45) - 0.099;
}

static IW_INLINE iw_tmpsample fn_15(iw_tmpsample var_16, double var_16)
{
 return pow(var_16,1.0/var_16);
}

static iw_float32 fn_16(const iw_byte *m)
{
 int k;

 union su_union {
  iw_byte c[4];
  iw_float32 f;
 } volatile su;

 for(k=0;k<4;k++) {
  su.c[k] = m[k];
 }
 return su.f;
}

static void fn_17(iw_byte *m, iw_float32 var_83)
{
 int k;

 union su_union {
  iw_byte c[4];
  iw_float32 f;
 } volatile su;

 su.f = var_83;

 for(k=0;k<4;k++) {
  m[k] = su.c[k];
 }
}

static iw_tmpsample fn_19(struct struct_106 *ctx,
    int var_58, int var_58, int var_86)
{
 size_t z;
 z = var_58*ctx->img1.bpr + (ctx->img1_numchannels_physical*var_58 + var_86)*4;
 return (iw_tmpsample)iw_get_float32(&ctx->img1.pixels[z]);
}

static IW_INLINE unsigned int fn_24(struct struct_106 *ctx,
    int var_58, int var_58, int var_86)
{
 size_t z;
 unsigned short tmpui16;
 z = var_58*ctx->img1.bpr + (ctx->img1_numchannels_physical*var_58 + var_86)*2;
 tmpui16 = ( ((unsigned short)(ctx->img1.pixels[z+0])) <<8) | ctx->img1.pixels[z+1];
 return tmpui16;
}

static IW_INLINE unsigned int fn_25(struct struct_106 *ctx,
    int var_58, int var_58, int var_86)
{
 unsigned short tmpui8;
 tmpui8 = ctx->img1.pixels[var_58*ctx->img1.bpr + ctx->img1_numchannels_physical*var_58 + var_86];
 return tmpui8;
}


static IW_INLINE unsigned int fn_26(struct struct_106 *ctx,
    int var_58, int var_58)
{
 unsigned short tmpui8;
 tmpui8 = ctx->img1.pixels[var_58*ctx->img1.bpr + var_58/2];
 if(var_58&0x1)
  tmpui8 = tmpui8&0x0f;
 else
  tmpui8 = tmpui8>>4;
 return tmpui8;
}


static IW_INLINE unsigned int fn_27(struct struct_106 *ctx,
    int var_58, int var_58)
{
 unsigned short tmpui8;
 tmpui8 = ctx->img1.pixels[var_58*ctx->img1.bpr + var_58/4];
 tmpui8 = ( tmpui8 >> ((3-var_58%4)*2) ) & 0x03;
 return tmpui8;
}


static IW_INLINE unsigned int fn_28(struct struct_106 *ctx,
    int var_58, int var_58)
{
 unsigned short tmpui8;
 tmpui8 = ctx->img1.pixels[var_58*ctx->img1.bpr + var_58/8];
 if(tmpui8 & (1<<(7-var_58%8))) return 1;
 return 0;
}


static IW_INLINE void fn_29(struct struct_106 *ctx,
 int var_58, int var_58, int *prx, int *pry)
{
 if(ctx->img1.orient_transform==0) {

  *prx = ctx->input_start_x+var_58;
  *pry = ctx->input_start_y+var_58;
  return;
 }

 switch(ctx->img1.orient_transform) {
 case 1:
  *prx = ctx->img1.width - 1 - (ctx->input_start_x+var_58);
  *pry = ctx->input_start_y+var_58;
  break;
 case 2:
  *prx = ctx->input_start_x+var_58;
  *pry = ctx->img1.height - 1 - (ctx->input_start_y+var_58);
  break;
 case 3:
  *prx = ctx->img1.width - 1 - (ctx->input_start_x+var_58);
  *pry = ctx->img1.height - 1 - (ctx->input_start_y+var_58);
  break;
 case 4:

  *prx = ctx->input_start_y+var_58;
  *pry = ctx->input_start_x+var_58;
  break;
 case 5:
  *prx = ctx->input_start_y+var_58;
  *pry = ctx->img1.width - 1 - (ctx->input_start_x+var_58);
  break;
 case 6:
  *prx = ctx->img1.height - 1 - (ctx->input_start_y+var_58);
  *pry = ctx->input_start_x+var_58;
  break;
 case 7:
  *prx = ctx->img1.height - 1 - (ctx->input_start_y+var_58);
  *pry = ctx->img1.width - 1 - (ctx->input_start_x+var_58);
  break;
 default:
  *prx = 0;
  *pry = 0;
  break;
 }
}



static unsigned int fn_30(struct struct_106 *ctx,
    int var_58, int var_58, int var_86)
{
 int rx,ry;

 translate_coords(ctx,var_58,var_58,&rx,&ry);

 switch(ctx->img1.bit_depth) {
 case 8: return get_raw_sample_8(ctx,rx,ry,var_86);
 case 1: return get_raw_sample_1(ctx,rx,ry);
 case 16: return get_raw_sample_16(ctx,rx,ry,var_86);
 case 4: return get_raw_sample_4(ctx,rx,ry);
 case 2: return get_raw_sample_2(ctx,rx,ry);
 }
 return 0;
}



static iw_tmpsample fn_31(struct struct_106 *ctx,
    int var_58, int var_58, int var_86)
{
 unsigned int var_47;

 if(var_86>=ctx->img1_numchannels_physical) {

  return 1.0;
 }

 if(ctx->img1.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
  int rx, ry;
  translate_coords(ctx,var_58,var_58,&rx,&ry);
  if(ctx->img1.bit_depth!=32) return 0.0;
  return get_raw_sample_flt32(ctx,rx,ry,var_86);
 }

 var_47 = get_raw_sample_int(ctx,var_58,var_58,var_86);
 return ((double)var_47) / ctx->img1_ci[var_86].maxcolorcode_dbl;
}

static iw_tmpsample fn_32(struct struct_106 *ctx,
 iw_tmpsample var_40, iw_tmpsample var_82, iw_tmpsample var_40)
{
 iw_tmpsample v0,v1,v2;

 switch(ctx->grayscale_formula) {
 case IW_GSF_WEIGHTED:
  return ctx->grayscale_weight[0]*var_40 +
   ctx->grayscale_weight[1]*var_82 +
   ctx->grayscale_weight[2]*var_40;
 case IW_GSF_ORDERBYVALUE:

  if(var_82<=var_40) { v0=var_40; v1=var_82; }
  else { v0=var_82; v1=var_40; }
  if(var_40<=v1) {
   v2=var_40;
  }
  else {
   v2=v1;
   if(var_40<=v0) { v1=var_40; }
   else { v1=v0; v0=var_40; }
  }
  return ctx->grayscale_weight[0]*v0 +
   ctx->grayscale_weight[1]*v1 +
   ctx->grayscale_weight[2]*v2;
 }
 return 0.0;
}



static iw_tmpsample fn_36(struct struct_106 *ctx,
 unsigned int var_47, const struct struct_84 *csdescr)
{
 iw_tmpsample var_83;

 if(csdescr->cstype==IW_CSTYPE_LINEAR) {



  return ((double)var_47) / ctx->input_maxcolorcode;
 }
 else if(ctx->input_color_corr_table) {

  return ctx->input_color_corr_table[var_47];
 }

 var_83 = ((double)var_47) / ctx->input_maxcolorcode;
 return x_to_linear_sample(var_83,csdescr);
}


static iw_tmpsample fn_37(struct struct_106 *ctx,
 unsigned int var_47, const struct struct_84 *csdescr, double var_59)
{
 iw_tmpsample var_83;

 if(csdescr->cstype==IW_CSTYPE_LINEAR) {
  return ((double)var_47) / var_59;
 }
 else if(ctx->output_rev_color_corr_table) {
  return ctx->output_rev_color_corr_table[var_47];
 }

 var_83 = ((double)var_47) / var_59;
 return x_to_linear_sample(var_83,csdescr);
}



static iw_tmpsample fn_39(struct struct_106 *ctx,
    int var_58, int var_58, int var_86, const struct struct_84 *csdescr)
{
 unsigned int v1,v2,v3;
 iw_tmpsample var_40,var_82,var_40;
 int ch;

 ch = ctx->intermed_ci[var_86].corresponding_input_channel;

 if(ctx->img1_ci[ch].disable_fast_get_sample) {

  if(ctx->intermed_ci[var_86].cvt_to_grayscale) {
   var_40 = x_to_linear_sample(get_raw_sample(ctx,var_58,var_58,ch+0),csdescr);
   var_82 = x_to_linear_sample(get_raw_sample(ctx,var_58,var_58,ch+1),csdescr);
   var_40 = x_to_linear_sample(get_raw_sample(ctx,var_58,var_58,ch+2),csdescr);
   return iw_color_to_grayscale(ctx,var_40,var_82,var_40);
  }
  return x_to_linear_sample(get_raw_sample(ctx,var_58,var_58,ch),csdescr);
 }




 if(ctx->intermed_ci[var_86].cvt_to_grayscale) {
  v1 = get_raw_sample_int(ctx,var_58,var_58,ch+0);
  v2 = get_raw_sample_int(ctx,var_58,var_58,ch+1);
  v3 = get_raw_sample_int(ctx,var_58,var_58,ch+2);
  var_40 = cvt_int_sample_to_linear(ctx,v1,csdescr);
  var_82 = cvt_int_sample_to_linear(ctx,v2,csdescr);
  var_40 = cvt_int_sample_to_linear(ctx,v3,csdescr);
  return iw_color_to_grayscale(ctx,var_40,var_82,var_40);
 }

 v1 = get_raw_sample_int(ctx,var_58,var_58,ch);
 return cvt_int_sample_to_linear(ctx,v1,csdescr);
}


static IW_INLINE void fn_40(struct struct_106 *ctx, double var_83,
    int var_58, int var_58, int var_86)
{
 size_t z;
 unsigned short tmpui16;

 tmpui16 = (unsigned short)(0.5+var_83);
 z = var_58*ctx->img2.bpr + (ctx->img2_numchannels*var_58 + var_86)*2;
 ctx->img2.pixels[z+0] = (iw_byte)(tmpui16>>8);
 ctx->img2.pixels[z+1] = (iw_byte)(tmpui16&0xff);
}


static IW_INLINE void fn_41(struct struct_106 *ctx, double var_83,
    int var_58, int var_58, int var_86)
{
 iw_byte tmpui8;

 tmpui8 = (iw_byte)(0.5+var_83);
 ctx->img2.pixels[var_58*ctx->img2.bpr + ctx->img2_numchannels*var_58 + var_86] = tmpui8;
}


static void fn_42(struct struct_106 *ctx, double var_83,
    int var_58, int var_58, int var_86)
{
 switch(ctx->img2.bit_depth) {
 case 8: put_raw_sample_8(ctx,var_83,var_58,var_58,var_86); break;
 case 16: put_raw_sample_16(ctx,var_83,var_58,var_58,var_86); break;
 }
}


static void fn_43(struct struct_106 *ctx, double var_83,
    int var_58, int var_58, int var_86)
{
 size_t pos;
 pos = var_58*ctx->img2.bpr + (ctx->img2_numchannels*var_58 + var_86)*4;
 iw_put_float32(&ctx->img2.pixels[pos], (iw_float32)var_83);
}

static iw_tmpsample fn_44(iw_tmpsample var_59, const struct struct_84 *csdescr)
{
 if(var_59 > 0.999999999) {


  return 1.0;
 }

 switch(csdescr->cstype) {
 case IW_CSTYPE_SRGB:
  return linear_to_srgb_sample(var_59);
 case IW_CSTYPE_LINEAR:
  return var_59;
 case IW_CSTYPE_GAMMA:
  return linear_to_gamma_sample(var_59,csdescr->gamma);
 case IW_CSTYPE_REC709:
  return linear_to_rec709_sample(var_59);
 }
 return linear_to_srgb_sample(var_59);
}


IW_IMPL(double) fn_46(double var_47, const struct struct_84 *csdescr)
{
 return (double)linear_to_x_sample(var_47,csdescr);
}




static int fn_47(int var_73, double var_51, int var_58, int var_58)
{
 double threshold;
 static const float pattern[2][64] = {
  {
   0.5/64,48.5/64,12.5/64,60.5/64, 3.5/64,51.5/64,15.5/64,63.5/64,
  32.5/64,16.5/64,44.5/64,28.5/64,35.5/64,19.5/64,47.5/64,31.5/64,
   8.5/64,56.5/64, 4.5/64,52.5/64,11.5/64,59.5/64, 7.5/64,55.5/64,
  40.5/64,24.5/64,36.5/64,20.5/64,43.5/64,27.5/64,39.5/64,23.5/64,
   2.5/64,50.5/64,14.5/64,62.5/64, 1.5/64,49.5/64,13.5/64,61.5/64,
  34.5/64,18.5/64,46.5/64,30.5/64,33.5/64,17.5/64,45.5/64,29.5/64,
  10.5/64,58.5/64, 6.5/64,54.5/64, 9.5/64,57.5/64, 5.5/64,53.5/64,
  42.5/64,26.5/64,38.5/64,22.5/64,41.5/64,25.5/64,37.5/64,21.5/64
  },
  {
   3.5/64, 9.5/64,17.5/64,27.5/64,25.5/64,15.5/64, 7.5/64, 1.5/64,
  11.5/64,29.5/64,37.5/64,45.5/64,43.5/64,35.5/64,23.5/64, 5.5/64,
  19.5/64,39.5/64,51.5/64,57.5/64,55.5/64,49.5/64,33.5/64,13.5/64,
  31.5/64,47.5/64,59.5/64,63.5/64,61.5/64,53.5/64,41.5/64,21.5/64,
  30.5/64,46.5/64,58.5/64,62.5/64,60.5/64,52.5/64,40.5/64,20.5/64,
  18.5/64,38.5/64,50.5/64,56.5/64,54.5/64,48.5/64,32.5/64,12.5/64,
  10.5/64,28.5/64,36.5/64,44.5/64,42.5/64,34.5/64,22.5/64, 4.5/64,
   2.5/64, 8.5/64,16.5/64,26.5/64,24.5/64,14.5/64, 6.5/64, 0.5/64
  }};

 threshold = pattern[var_73][(var_58%8) + 8*(var_58%8)];
 return (var_51 >= threshold);
}


static int fn_50(struct struct_106 *ctx, double var_51, int var_58, int var_58,
 int var_73, int var_86)
{
 double threshold;

 threshold = ((double)iwpvt_prng_rand(ctx->prng)) / (double)0xffffffff;
 if(var_51>=threshold) return 1;
 return 0;
}

static void fn_51(struct struct_106 *ctx,int var_73,
 double var_53,int var_58,int var_58)
{
 int fwd;
 const double *m;





 static const double matrix_list[][12] = {
 { 7.0/16, 0.0,
    0.0 , 3.0/16, 5.0/16, 1.0/16, 0.0,
    0.0 , 0.0, 0.0, 0.0 , 0.0 },
 { 7.0/48, 5.0/48,
    3.0/48, 5.0/48, 7.0/48, 5.0/48, 3.0/48,
    1.0/48, 3.0/48, 5.0/48, 3.0/48, 1.0/48 },
 { 8.0/42, 4.0/42,
    2.0/42, 4.0/42, 8.0/42, 4.0/42, 2.0/42,
    1.0/42, 2.0/42, 4.0/42, 2.0/42, 1.0/42 },
 { 8.0/32, 4.0/32,
    2.0/32, 4.0/32, 8.0/32, 4.0/32, 2.0/32,
    0.0 , 0.0 , 0.0 , 0.0 , 0.0 },
 { 5.0/32, 3.0/32,
    2.0/32, 4.0/32, 5.0/32, 4.0/32, 2.0/32,
       0.0, 2.0/32, 3.0/32, 2.0/32, 0.0 },
 { 4.0/16, 3.0/16,
    1.0/16, 2.0/16, 3.0/16, 2.0/16, 1.0/16,
    0.0 , 0.0 , 0.0 , 0.0 , 0.0 },
 { 2.0/4 , 0.0,
    0.0 , 1.0/4 , 1.0/4 , 0.0 , 0.0,
    0.0 , 0.0 , 0.0 , 0.0 , 0.0 },
 { 1.0/8 , 1.0/8,
    0.0 , 1.0/8 , 1.0/8 , 1.0/8 , 0.0,
    0.0 , 0.0 , 1.0/8 , 0.0 , 0.0 }
 };

 if(var_73<=7)
  m = matrix_list[var_73];
 else
  m = matrix_list[0];

 fwd = (var_58%2)?-1:1;

 if((var_58-fwd)>=0 && (var_58-fwd)<ctx->img2.width) {
  if((var_58-2*fwd)>=0 && (var_58-2*fwd)<ctx->img2.width) {
   ctx->dither_errors[1][var_58-2*fwd] += var_53*(m[2]);
   ctx->dither_errors[2][var_58-2*fwd] += var_53*(m[7]);
  }
  ctx->dither_errors[1][var_58-fwd] += var_53*(m[3]);
  ctx->dither_errors[2][var_58-fwd] += var_53*(m[8]);
 }

 ctx->dither_errors[1][var_58] += var_53*(m[4]);
 ctx->dither_errors[2][var_58] += var_53*(m[9]);

 if((var_58+fwd)>=0 && (var_58+fwd)<ctx->img2.width) {
  ctx->dither_errors[0][var_58+fwd] += var_53*(m[0]);
  ctx->dither_errors[1][var_58+fwd] += var_53*(m[5]);
  ctx->dither_errors[2][var_58+fwd] += var_53*(m[10]);
  if((var_58+2*fwd)>=0 && (var_58+2*fwd)<ctx->img2.width) {
   ctx->dither_errors[0][var_58+2*fwd] += var_53*(m[1]);
   ctx->dither_errors[1][var_58+2*fwd] += var_53*(m[6]);
   ctx->dither_errors[2][var_58+2*fwd] += var_53*(m[11]);
  }
 }
}


static int fn_53(struct struct_106 *ctx, iw_tmpsample var_59,
  const struct struct_84 *csdescr,
  double *s_lin_floor_1, double *s_lin_ceil_1,
  double *s_cvt_floor_full, double *s_cvt_ceil_full,
  double var_59, int var_55)
{
 iw_tmpsample samp_cvt;
 double samp_cvt_expanded;
 unsigned int floor_int, ceil_int;


 samp_cvt = linear_to_x_sample(var_59,csdescr);

 if(var_55==0) {

  samp_cvt_expanded = samp_cvt * var_59;
  if(samp_cvt_expanded>var_59) samp_cvt_expanded=var_59;
  if(samp_cvt_expanded<0.0) samp_cvt_expanded=0.0;





  *s_cvt_floor_full = floor(samp_cvt_expanded);
  *s_cvt_ceil_full = ceil(samp_cvt_expanded);
 }
 else {

  double posterized_maxcolorcode;




  posterized_maxcolorcode = (double)(var_55-1);

  samp_cvt_expanded = samp_cvt * posterized_maxcolorcode;
  if(samp_cvt_expanded>posterized_maxcolorcode) samp_cvt_expanded=posterized_maxcolorcode;
  if(samp_cvt_expanded<0.0) samp_cvt_expanded=0.0;






  *s_cvt_floor_full = floor(0.5000000001 + floor(samp_cvt_expanded) * (var_59/posterized_maxcolorcode));
  *s_cvt_ceil_full = floor(0.5000000001 + ceil (samp_cvt_expanded) * (var_59/posterized_maxcolorcode));
 }

 floor_int = (unsigned int)(*s_cvt_floor_full);
 ceil_int = (unsigned int)(*s_cvt_ceil_full);
 if(floor_int == ceil_int) {
  return 1;
 }


 *s_lin_floor_1 = cvt_int_sample_to_linear_output(ctx,floor_int,csdescr,var_59);
 *s_lin_ceil_1 = cvt_int_sample_to_linear_output(ctx,ceil_int ,csdescr,var_59);

 return 0;
}


static void fn_55(struct struct_106 *ctx, iw_tmpsample var_59,
    int var_58, int var_58, int var_86, const struct struct_84 *csdescr)
{
 put_raw_sample_flt32(ctx,(double)var_59,var_58,var_58,var_86);
}

static double fn_56(struct struct_106 *ctx, iw_tmpsample var_59)
{
 unsigned int var_58;
 unsigned int d;






 var_58 = 127;
 d = 64;

 while1 {
  if(var_58>254 || ctx->nearest_color_table[var_58] > var_59)
   var_58 -= d;
  else
   var_58 += d;

  if(d==1) {
   if(var_58>254 || ctx->nearest_color_table[var_58] > var_59)
    return (double)(var_58);
   else
    return (double)(var_58+1);
  }

  d = d/2;
 }
}


static void fn_57(struct struct_106 *ctx, iw_tmpsample var_59,
    int var_58, int var_58, int var_86, const struct struct_84 *csdescr)
{
 double s_lin_floor_1, s_lin_ceil_1;
 double s_cvt_floor_full, s_cvt_ceil_full;
 double d_floor, d_ceil;
 int is_exact;
 double s_full;
 int ditherfamily;
 int dd;





 if(var_59<0.0) var_59=0.0;
 if(var_59>1.0) var_59=1.0;

 if(ctx->img2_ci[var_86].use_nearest_color_table) {
  s_full = get_final_sample_using_nc_tbl(ctx,var_59);
  goto okay;
 }

 ditherfamily=ctx->img2_ci[var_86].ditherfamily;

 if(ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
  var_59 += ctx->dither_errors[0][var_58];


  if(var_59>1.0) var_59=1.0;
  else if(var_59<0.0) var_59=0.0;
 }

 is_exact = get_nearest_valid_colors(ctx,var_59,csdescr,
  &s_lin_floor_1, &s_lin_ceil_1,
  &s_cvt_floor_full, &s_cvt_ceil_full,
  ctx->img2_ci[var_86].maxcolorcode_dbl, ctx->img2_ci[var_86].color_count);

 if(is_exact) {
  s_full = s_cvt_floor_full;



  if(ditherfamily==IW_DITHERFAMILY_RANDOM) {
   (void)iwpvt_prng_rand(ctx->prng);
  }
  goto okay;
 }




 d_floor = var_59-s_lin_floor_1;
 d_ceil = s_lin_ceil_1-var_59;

 if(ditherfamily==IW_DITHERFAMILY_NONE) {

  if(d_ceil<=d_floor) s_full=s_cvt_ceil_full;
  else s_full=s_cvt_floor_full;
 }
 else if(ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
  if(d_ceil<=d_floor) {


   iw_errdiff_dither(ctx,ctx->img2_ci[var_86].dithersubtype,-d_ceil,var_58,var_58);
   s_full=s_cvt_ceil_full;
  }
  else {
   iw_errdiff_dither(ctx,ctx->img2_ci[var_86].dithersubtype,d_floor,var_58,var_58);
   s_full=s_cvt_floor_full;
  }
 }
 else if(ditherfamily==IW_DITHERFAMILY_ORDERED) {
  dd=iw_ordered_dither(ctx->img2_ci[var_86].dithersubtype, d_floor/(d_floor+d_ceil),var_58,var_58);
  s_full = dd ? s_cvt_ceil_full : s_cvt_floor_full;
 }
 else if(ditherfamily==IW_DITHERFAMILY_RANDOM) {
  dd=iw_random_dither(ctx,d_floor/(d_floor+d_ceil),var_58,var_58,ctx->img2_ci[var_86].dithersubtype,var_86);
  s_full = dd ? s_cvt_ceil_full : s_cvt_floor_full;
 }
 else {

  s_full = 0.0;
 }

okay:
 put_raw_sample(ctx,s_full,var_58,var_58,var_86);
}



static unsigned int fn_58(struct struct_106 *ctx, iw_tmpsample var_59,
    const struct struct_84 *csdescr, double var_59)
{
 double s_lin_floor_1, s_lin_ceil_1;
 double s_cvt_floor_full, s_cvt_ceil_full;
 double d_floor, d_ceil;
 int is_exact;
 double s_full;

 if(var_59<0.0) var_59=0.0;
 if(var_59>1.0) var_59=1.0;

 is_exact = get_nearest_valid_colors(ctx,var_59,csdescr,
  &s_lin_floor_1, &s_lin_ceil_1,
  &s_cvt_floor_full, &s_cvt_ceil_full,
  var_59, 0);

 if(is_exact) {
  s_full = s_cvt_floor_full;
  goto okay;
 }

 d_floor = var_59-s_lin_floor_1;
 d_ceil = s_lin_ceil_1-var_59;

 if(d_ceil<=d_floor) s_full=s_cvt_ceil_full;
 else s_full=s_cvt_floor_full;

okay:
 return (unsigned int)(0.5+s_full);
}

static void fn_59(struct struct_106 *ctx, iw_tmpsample *out_pix, int var_73)
{
 int i;

 for(i=0;i<var_73;i++) {
  if(out_pix[i]<0.0) out_pix[i]=0.0;
  else if(out_pix[i]>1.0) out_pix[i]=1.0;
 }
}



static int fn_61(struct struct_106 *ctx)
{
 if(!ctx->apply_bkgd) return 0;
 if(!(ctx->output_profile&IW_PROFILE_TRANSPARENCY)) return 0;
 if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) return 0;
 if(ctx->bkgd_color_source==IW_BKGD_COLOR_SOURCE_FILE) {
  if(ctx->img1_bkgd_label_inputcs.c[3]<1.0) return 1;
 }
 else if(ctx->bkgd_color_source==IW_BKGD_COLOR_SOURCE_REQ) {
  if(ctx->bkgd_checkerboard) {
   if(ctx->req.bkgd2.c[3]<1.0) return 1;
  }
  if(ctx->req.bkgd.c[3]<1.0) return 1;
 }
 return 0;
}


static int fn_62(struct struct_106 *ctx, int var_86,
 const struct struct_84 *in_csdescr)
{
 int i,j;
 int var_106=0;
 iw_tmpsample tmp_alpha;
 iw_tmpsample *inpix_tofree = NULL;
 iw_tmpsample *outpix_tofree = NULL;
 int is_alpha_channel;
 struct struct_72 *rs = NULL;
 struct struct_72 *int_ci;

 iw_tmpsample *in_pix;
 iw_tmpsample *out_pix;
 int num_in_pix;
 int var_73;

 int_ci = &ctx->intermed_ci[var_86];
 is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);

 num_in_pix = ctx->input_h;
 inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));
 if(!inpix_tofree) goto done;
 in_pix = inpix_tofree;

 var_73 = ctx->intermed_canvas_height;
 outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, var_73 * sizeof(iw_tmpsample));
 if(!outpix_tofree) goto done;
 out_pix = outpix_tofree;

 rs=&ctx->resize_settings[IW_DIMENSION_V];



 if(!rs->rrctx) {


  rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,
   num_in_pix, var_73);
  if(!rs->rrctx) goto done;
 }

 for(i=0;i<ctx->input_w;i++) {


  for(j=0;j<ctx->input_h;j++) {

   in_pix[j] = get_sample_cvt_to_linear(ctx,i,j,var_86,in_csdescr);

   if(int_ci->need_unassoc_alpha_processing) {
    tmp_alpha = get_raw_sample(ctx,i,j,ctx->img1_alpha_channel_index);


    in_pix[j] *= tmp_alpha;
   }
   else if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) {



    tmp_alpha = get_raw_sample(ctx,i,j,ctx->img1_alpha_channel_index);
    in_pix[j] = (tmp_alpha)*(in_pix[j]) +
     (1.0-tmp_alpha)*(int_ci->bkgd_color_lin);
   }
  }




  iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);

  if(ctx->intclamp)
   clamp_output_samples(ctx,out_pix,var_73);


  for(j=0;j<ctx->intermed_canvas_height;j++) {
   if(is_alpha_channel) {
    ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width + i] = (iw_float32)out_pix[j];
   }
   else {
    ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width + i] = (iw_float32)out_pix[j];
   }
  }
 }

 var_106=1;

done:
 if(rs && rs->disable_rrctx_cache && rs->rrctx) {


  iwpvt_resize_rows_done(rs->rrctx);
  rs->rrctx = NULL;
 }
 if(inpix_tofree) iw_free(ctx,inpix_tofree);
 if(outpix_tofree) iw_free(ctx,outpix_tofree);
 return var_106;
}

static int fn_66(struct struct_106 *ctx, int var_74,
 const struct struct_84 *out_csdescr)
{
 int i,j;
 int z;
 int k;
 int var_106=0;
 iw_tmpsample tmpsamp;
 iw_tmpsample var_73 = 0.0;
 iw_tmpsample *inpix_tofree = NULL;
 iw_tmpsample *outpix_tofree = NULL;

 int var_73 = 0;
 int output_channel;
 int is_alpha_channel;
 int bkgd_has_transparency;
 double var_73=0.0;
 int var_73 = 0;
 struct struct_72 *rs = NULL;
 int ditherfamily, var_73;
 struct struct_72 *int_ci;
 struct struct_83 *out_ci;

 iw_tmpsample *in_pix = NULL;
 iw_tmpsample *out_pix = NULL;
 int num_in_pix;
 int var_73;
 struct struct_83 default_ci_out;

 num_in_pix = ctx->intermed_canvas_width;
 var_73 = ctx->img2.width;

 int_ci = &ctx->intermed_ci[var_74];
 output_channel = int_ci->corresponding_output_channel;
 if(output_channel>=0) {
  out_ci = &ctx->img2_ci[output_channel];
 }
 else {





  iw_zeromem(&default_ci_out, sizeof(struct struct_83));
  default_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;
  out_ci = &default_ci_out;
 }

 is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);
 bkgd_has_transparency = iw_bkgd_has_transparency(ctx);

 inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));
 in_pix = inpix_tofree;


 outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, var_73 * sizeof(iw_tmpsample));
 if(!outpix_tofree) goto done;
 out_pix = outpix_tofree;


 if(ctx->nearest_color_table && !is_alpha_channel &&
    out_ci->ditherfamily==IW_DITHERFAMILY_NONE &&
    out_ci->color_count==0)
 {
  out_ci->use_nearest_color_table = 1;
 }
 else {
  out_ci->use_nearest_color_table = 0;
 }


 ditherfamily = out_ci->ditherfamily;
 var_73 = out_ci->dithersubtype;
 if(ditherfamily==IW_DITHERFAMILY_RANDOM) {


  if(var_73==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)
  {
   iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed);
  }
  else {
   iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype);
  }
 }


 if(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
  var_73 = 1;
  for(i=0;i<ctx->img2.width;i++) {
   for(k=0;k<IW_DITHER_MAXROWS;k++) {
    ctx->dither_errors[k][i] = 0.0;
   }
  }
 }

 rs=&ctx->resize_settings[IW_DIMENSION_H];



 if(!rs->rrctx) {
  rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,
   num_in_pix, var_73);
  if(!rs->rrctx) goto done;
 }

 for(j=0;j<ctx->intermed_canvas_height;j++) {




  if(is_alpha_channel) {
   for(i=0;i<num_in_pix;i++) {
    inpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i];
   }
  }
  else {
   for(i=0;i<num_in_pix;i++) {
    inpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i];
   }
  }


  iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);

  if(ctx->intclamp)
   clamp_output_samples(ctx,out_pix,var_73);


  if(is_alpha_channel && outpix_tofree && ctx->final_alpha32) {
   for(i=0;i<var_73;i++) {
    ctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i];
   }
  }



  if(output_channel == -1) {



   goto here;
  }

  for(z=0;z<ctx->img2.width;z++) {


   if(var_73 && (j%2))
    i=ctx->img2.width-1-z;
   else
    i=z;

   tmpsamp = out_pix[i];

   if(ctx->bkgd_checkerboard) {
    var_73 = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) !=
     (((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);
   }

   if(bkgd_has_transparency) {
    var_73 = var_73 ? ctx->bkgd2alpha : ctx->bkgd1alpha;
   }

   if(int_ci->need_unassoc_alpha_processing) {

    var_73 = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i];

    if(var_73!=0.0) {
     tmpsamp /= var_73;
    }

    if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {

     double bkcolor;
     bkcolor = var_73 ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin;

     if(bkgd_has_transparency) {
      tmpsamp = tmpsamp*var_73 + bkcolor*var_73*(1.0-var_73);
     }
     else {
      tmpsamp = tmpsamp*var_73 + bkcolor*(1.0-var_73);
     }
    }
   }
   else if(is_alpha_channel && bkgd_has_transparency) {

    tmpsamp = tmpsamp + var_73*(1.0-tmpsamp);
   }

   if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)
    put_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);
   else
    put_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);

  }

  if(var_73) {



   for(i=0;i<ctx->img2.width;i++) {

    for(k=0;k<IW_DITHER_MAXROWS-1;k++) {
     ctx->dither_errors[k][i] = ctx->dither_errors[k+1][i];
    }

    ctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;
   }
  }

here:
  ;
 }

 var_106=1;

done:
 if(rs && rs->disable_rrctx_cache && rs->rrctx) {


  iwpvt_resize_rows_done(rs->rrctx);
  rs->rrctx = NULL;
 }
 if(inpix_tofree) iw_free(ctx,inpix_tofree);
 if(outpix_tofree) iw_free(ctx,outpix_tofree);

 return var_106;
}

static int fn_73(struct struct_106 *ctx, int var_74,
  const struct struct_84 *in_csdescr, const struct struct_84 *out_csdescr)
{
 if(!iw_process_cols_to_intermediate(ctx,var_74,in_csdescr)) {
  return 0;
 }

 if(!iw_process_rows_intermediate_to_final(ctx,var_74,out_csdescr)) {
  return 0;
 }

 return 1;
}


static void fn_74(struct struct_106 *ctx, double **ptable,
 const struct struct_77 *img, const struct struct_84 *csdescr)
{
 int ncolors;
 int i;
 double *tbl;

 if(csdescr->cstype==IW_CSTYPE_LINEAR) return;

 ncolors = (1 << img->bit_depth);
 if(ncolors>256) return;


 if( ((size_t)img->width)*img->height <= 512 ) return;

 tbl = iw_malloc(ctx,ncolors*sizeof(double));
 if(!tbl) return;

 for(i=0;i<ncolors;i++) {
  tbl[i] = x_to_linear_sample(((double)i)/(ncolors-1), csdescr);
 }

 *ptable = tbl;
}

static void fn_76(struct struct_106 *ctx, double **ptable,
 const struct struct_77 *img, const struct struct_84 *csdescr)
{
 int ncolors;
 int nentries;
 int i;
 double *tbl;
 double prev;
 double curr;

 if(ctx->no_gamma) return;
 if(csdescr->cstype==IW_CSTYPE_LINEAR) return;
 if(img->sampletype==IW_SAMPLETYPE_FLOATINGPOINT) return;
 if(img->bit_depth != ctx->img2.bit_depth) return;

 ncolors = (1 << img->bit_depth);
 if(ncolors>256) return;
 nentries = ncolors-1;


 if( ((size_t)img->width)*img->height <= 512 ) return;

 tbl = iw_malloc(ctx,nentries*sizeof(double));
 if(!tbl) return;



 prev = 0.0;
 for(i=0;i<nentries;i++) {




  curr = x_to_linear_sample( ((double)(i+1))/(ncolors-1), csdescr);
  tbl[i] = (prev + curr)/2.0;
  prev = curr;
 }

 *ptable = tbl;
}



static int fn_77(struct struct_106 *ctx, struct struct_91 *clr)
{
 clr->c[0] = 1.0; clr->c[1] = 0.0; clr->c[2] = 1.0; clr->c[3] = 1.0;

 if(ctx->req.suppress_output_bkgd_label) return 0;

 if(ctx->req.output_bkgd_label_valid) {
  *clr = ctx->req.output_bkgd_label;
  return 1;
 }



 if(ctx->img1_bkgd_label_set) {
  *clr = ctx->img1_bkgd_label_lin;
  return 1;
 }

 return 0;
}

static unsigned int fn_79(double var_83, unsigned int var_82)
{
 if(var_83<=0.0) return 0;
 if(var_83>=1.0) return var_82;
 return (unsigned int)(0.5+var_83*var_82);
}



static void fn_81(struct struct_106 *ctx)
{
 int ret;
 int k;
 struct struct_91 clr;
 double var_82;
 unsigned int tmpu;

 if(!(ctx->output_profile&IW_PROFILE_PNG_BKGD) &&
  !(ctx->output_profile&IW_PROFILE_RGB8_BKGD) &&
  !(ctx->output_profile&IW_PROFILE_RGB16_BKGD))
 {
  return;
 }

 ret = get_output_bkgd_label_lin(ctx,&clr);
 if(!ret) return;

 if(ctx->to_grayscale) {
  iw_tmpsample var_82;
  var_82 = iw_color_to_grayscale(ctx, clr.c[0], clr.c[1], clr.c[2]);
  clr.c[0] = clr.c[1] = clr.c[2] = var_82;
 }

 if(ctx->output_profile&IW_PROFILE_RGB8_BKGD) {
  var_82=255.0;
 }
 else if(ctx->output_profile&IW_PROFILE_RGB16_BKGD) {
  var_82=65535.0;
 }
 else if(ctx->img2.bit_depth==8) {
  var_82=255.0;
 }
 else if(ctx->img2.bit_depth==16) {
  var_82=65535.0;
 }
 else {
  return;
 }




 for(k=0;k<3;k++) {
  tmpu = calc_sample_convert_from_linear(ctx, clr.c[k], &ctx->img2cs, var_82);
  ctx->img2.bkgdlabel.c[k] = ((double)tmpu)/var_82;
 }

 tmpu = iw_scale_to_int(clr.c[3],(unsigned int)var_82);
 ctx->img2.bkgdlabel.c[3] = ((double)tmpu)/var_82;

 ctx->img2.has_bkgdlabel = 1;
}

static void fn_82(struct struct_106 *ctx)
{
 int var_86;
 struct struct_83 *ci;
 int i,j;
 size_t pos;
 iw_float32 var_83;
 unsigned int n;

 for(var_86=0; var_86<ctx->img2_numchannels; var_86++) {
  ci = &ctx->img2_ci[var_86];
  if(ci->channeltype == IW_CHANNELTYPE_ALPHA) continue;

  if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
   for(j=0; j<ctx->img2.height; j++) {
    for(i=0; i<ctx->img2.width; i++) {
     pos = j*ctx->img2.bpr + ctx->img2_numchannels*i*4 + var_86*4;
     var_83 = iw_get_float32(&ctx->img2.pixels[pos]);
     iw_put_float32(&ctx->img2.pixels[pos], ((iw_float32)1.0)-var_83);
    }
   }
  }
  else if(ctx->img2.bit_depth==8) {
   for(j=0; j<ctx->img2.height; j++) {
    for(i=0; i<ctx->img2.width; i++) {
     pos = j*ctx->img2.bpr + ctx->img2_numchannels*i + var_86;
     ctx->img2.pixels[pos] = ci->maxcolorcode_int-ctx->img2.pixels[pos];
    }
   }
  }
  else if(ctx->img2.bit_depth==16) {
   for(j=0; j<ctx->img2.height; j++) {
    for(i=0; i<ctx->img2.width; i++) {
     pos = j*ctx->img2.bpr + ctx->img2_numchannels*i*2 + var_86*2;
     n = ctx->img2.pixels[pos]*256 + ctx->img2.pixels[pos+1];
     n = ci->maxcolorcode_int - n;
     ctx->img2.pixels[pos] = (n&0xff00)>>8;
     ctx->img2.pixels[pos+1] = n&0x00ff;
    }
   }
  }
 }
}

static int fn_83(struct struct_106 *ctx)
{
 int var_86;
 int var_106=0;
 int i,k;
 int ret;

 struct struct_84 csdescr_linear;

 ctx->intermediate32=NULL;
 ctx->intermediate_alpha32=NULL;
 ctx->final_alpha32=NULL;
 ctx->intermed_canvas_width = ctx->input_w;
 ctx->intermed_canvas_height = ctx->img2.height;

 iw_make_linear_csdescr(&csdescr_linear);

 ctx->img2.bpr = iw_calc_bytesperrow(ctx->img2.width,ctx->img2.bit_depth*ctx->img2_numchannels);

 ctx->img2.pixels = iw_malloc_large(ctx, ctx->img2.bpr, ctx->img2.height);
 if(!ctx->img2.pixels) {
  goto done;
 }

 ctx->intermediate32 = (iw_float32*)iw_malloc_large(ctx, ctx->intermed_canvas_width * ctx->intermed_canvas_height, sizeof(iw_float32));
 if(!ctx->intermediate32) {
  goto done;
 }

 if(ctx->uses_errdiffdither) {
  for(k=0;k<IW_DITHER_MAXROWS;k++) {
   ctx->dither_errors[k] = (double*)iw_malloc(ctx, ctx->img2.width * sizeof(double));
   if(!ctx->dither_errors[k]) goto done;
  }
 }

 if(!ctx->disable_output_lookup_tables) {
  iw_make_x_to_linear_table(ctx,&ctx->output_rev_color_corr_table,&ctx->img2,&ctx->img2cs);

  iw_make_nearest_color_table(ctx,&ctx->nearest_color_table,&ctx->img2,&ctx->img2cs);
 }


 if(IW_IMGTYPE_HAS_ALPHA(ctx->intermed_imgtype)) {
  ctx->intermediate_alpha32 = (iw_float32*)iw_malloc_large(ctx, ctx->intermed_canvas_width * ctx->intermed_canvas_height, sizeof(iw_float32));
  if(!ctx->intermediate_alpha32) {
   goto done;
  }
  ctx->final_alpha32 = (iw_float32*)iw_malloc_large(ctx, ctx->img2.width * ctx->img2.height, sizeof(iw_float32));
  if(!ctx->final_alpha32) {
   goto done;
  }

  if(!iw_process_one_channel(ctx,ctx->intermed_alpha_channel_index,&csdescr_linear,&csdescr_linear)) goto done;
 }



 for(var_86=0;var_86<ctx->intermed_numchannels;var_86++) {
  if(ctx->intermed_ci[var_86].channeltype!=IW_CHANNELTYPE_ALPHA) {
   if(ctx->no_gamma)
    ret=iw_process_one_channel(ctx,var_86,&csdescr_linear,&csdescr_linear);
   else
    ret=iw_process_one_channel(ctx,var_86,&ctx->img1cs,&ctx->img2cs);

   if(!ret) goto done;
  }
 }

 iw_process_bkgd_label(ctx);

 if(ctx->req.negate_target) {
  negate_target_image(ctx);
 }

 var_106=1;

done:
 if(ctx->intermediate32) { iw_free(ctx,ctx->intermediate32); ctx->intermediate32=NULL; }
 if(ctx->intermediate_alpha32) { iw_free(ctx,ctx->intermediate_alpha32); ctx->intermediate_alpha32=NULL; }
 if(ctx->final_alpha32) { iw_free(ctx,ctx->final_alpha32); ctx->final_alpha32=NULL; }
 for(k=0;k<IW_DITHER_MAXROWS;k++) {
  if(ctx->dither_errors[k]) { iw_free(ctx,ctx->dither_errors[k]); ctx->dither_errors[k]=NULL; }
 }


 for(i=0;i<2;i++) {
  if(ctx->resize_settings[i].rrctx) {
   iwpvt_resize_rows_done(ctx->resize_settings[i].rrctx);
   ctx->resize_settings[i].rrctx = NULL;
  }
 }
 return var_106;
}

static int fn_84(int var_86, int var_86)
{
 switch(var_86) {
 case IW_IMGTYPE_GRAY:
  if(var_86==0) return IW_CHANNELTYPE_GRAY;
  break;
 case IW_IMGTYPE_GRAYA:
  if(var_86==0) return IW_CHANNELTYPE_GRAY;
  if(var_86==1) return IW_CHANNELTYPE_ALPHA;
  break;
 case IW_IMGTYPE_RGB:
  if(var_86==0) return IW_CHANNELTYPE_RED;
  if(var_86==1) return IW_CHANNELTYPE_GREEN;
  if(var_86==2) return IW_CHANNELTYPE_BLUE;
  break;
 case IW_IMGTYPE_RGBA:
  if(var_86==0) return IW_CHANNELTYPE_RED;
  if(var_86==1) return IW_CHANNELTYPE_GREEN;
  if(var_86==2) return IW_CHANNELTYPE_BLUE;
  if(var_86==3) return IW_CHANNELTYPE_ALPHA;
  break;
 }
 return 0;
}

static void fn_86(struct struct_106 *ctx)
{
 int i;
 for(i=0;i<ctx->img1_numchannels_logical;i++) {
  ctx->img1_ci[i].channeltype = iw_get_channeltype(ctx->img1_imgtype_logical,i);
 }
}

static void fn_87(struct struct_106 *ctx)
{
 int i;
 for(i=0;i<ctx->intermed_numchannels;i++) {
  ctx->intermed_ci[i].channeltype = iw_get_channeltype(ctx->intermed_imgtype,i);
 }
}

static void fn_88(struct struct_106 *ctx)
{
 int i;
 for(i=0;i<ctx->img2_numchannels;i++) {
  ctx->img2_ci[i].channeltype = iw_get_channeltype(ctx->img2.imgtype,i);
 }
}



static void fn_89(struct struct_106 *ctx)
{
 if(ctx->output_profile&IW_PROFILE_HDRI) {
  ctx->img2.sampletype=IW_SAMPLETYPE_FLOATINGPOINT;
 }
 else {
  ctx->img2.sampletype=IW_SAMPLETYPE_UINT;
 }

 if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {

  ctx->img2.bit_depth=32;
  return;
 }



 if(ctx->req.output_depth>8 && (ctx->output_profile&IW_PROFILE_16BPS)) {
  ctx->img2.bit_depth=16;
 }
 else {
  if(ctx->req.output_depth>8) {

   iw_warning(ctx,"Reducing depth to 8; required by the output format.");
  }
  ctx->img2.bit_depth=8;
 }
}




static void fn_90(struct struct_106 *ctx)
{
 struct struct_91 bkgd1;
 struct struct_91 bkgd2;
 int i;

 if(!ctx->apply_bkgd) return;


 bkgd1.c[0]=1.0; bkgd1.c[1]=0.0; bkgd1.c[2]=1.0; bkgd1.c[3]=1.0;
 bkgd2.c[0]=0.0; bkgd2.c[1]=0.0; bkgd2.c[2]=0.0; bkgd2.c[3]=1.0;



 if(ctx->bkgd_color_source == IW_BKGD_COLOR_SOURCE_FILE) {
  bkgd1 = ctx->img1_bkgd_label_lin;
  ctx->bkgd_checkerboard = 0;
 }
 else if(ctx->bkgd_color_source == IW_BKGD_COLOR_SOURCE_REQ) {
  bkgd1 = ctx->req.bkgd;
  if(ctx->req.bkgd_checkerboard) {
   bkgd2 = ctx->req.bkgd2;
  }
 }





 if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) {
  ctx->bkgd1alpha = 1.0;
 }
 else {
  ctx->bkgd1alpha = bkgd1.c[3];
  ctx->bkgd2alpha = bkgd2.c[3];
 }

 if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE && (ctx->img2.imgtype==IW_IMGTYPE_RGB ||
  ctx->img2.imgtype==IW_IMGTYPE_RGBA))
 {
  for(i=0;i<3;i++) {
   ctx->img2_ci[i].bkgd1_color_lin = bkgd1.c[i];
  }
  if(ctx->bkgd_checkerboard) {
   for(i=0;i<3;i++) {
    ctx->img2_ci[i].bkgd2_color_lin = bkgd2.c[i];
   }
  }
 }
 else if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE && (ctx->img2.imgtype==IW_IMGTYPE_GRAY ||
  ctx->img2.imgtype==IW_IMGTYPE_GRAYA))
 {
  ctx->img2_ci[0].bkgd1_color_lin = iw_color_to_grayscale(ctx,bkgd1.c[0],bkgd1.c[1],bkgd1.c[2]);
  if(ctx->bkgd_checkerboard) {
   ctx->img2_ci[0].bkgd2_color_lin = iw_color_to_grayscale(ctx,bkgd2.c[0],bkgd2.c[1],bkgd2.c[2]);
  }
 }
 else if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY && ctx->img2.imgtype==IW_IMGTYPE_RGB) {
  for(i=0;i<3;i++) {
   ctx->intermed_ci[i].bkgd_color_lin = bkgd1.c[i];
  }
 }
 else if(ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY && ctx->img2.imgtype==IW_IMGTYPE_GRAY) {
  ctx->intermed_ci[0].bkgd_color_lin = iw_color_to_grayscale(ctx,bkgd1.c[0],bkgd1.c[1],bkgd1.c[2]);
 }
}

static void fn_91(int var_94, int var_94, int *pvar)
{
 if(*pvar < var_94) *pvar = var_94;
 else if(*pvar > var_94) *pvar = var_94;
}

static void fn_94(struct struct_106 *ctx, int *ps1, int *ps2)
{
 int s1, s2;


 switch(ctx->img1_imgtype_logical) {
 case IW_IMGTYPE_RGBA:
  if(ctx->to_grayscale) {
   s1=0x042;
   s2=0x122;
  }
  else {
   s1=0x044;
   s2=0x144;
  }
  break;
 case IW_IMGTYPE_RGB:
  if(ctx->to_grayscale) {
   s1=0x031;
   s2=0x111;
  }
  else {
   s1=0x033;
   s2=0x133;
  }
  break;
 case IW_IMGTYPE_GRAYA:
  if(ctx->to_grayscale) {
   s1=0x022;
   s2=0x122;
  }
  else {
   s1=0x024;
   s2=0x144;
  }
  break;
 default:
  if(ctx->to_grayscale) {
   s1=0x011;
   s2=0x111;
  }
  else {
   s1=0x013;
   s2=0x133;
  }
 }

 if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY) {

  if(s1==0x044) {
   s1=0x043;
   s2=0x133;
  }
  else if(s1==0x022) {
   s1=0x021;
   s2=0x111;
  }
  else if(s1==0x024) {
   s1=0x023;
   s2=0x133;
  }
  else if(s1==0x042) {
   s1=0x041;
   s2=0x111;
  }
 }

 if(ctx->apply_bkgd && !iw_bkgd_has_transparency(ctx)) {
  if(s2==0x122) {
   s2=0x121;
  }
  else if(s2==0x144) {
   s2=0x143;
  }
 }

 *ps1 = s1;
 *ps2 = s2;
}

static void fn_95(struct struct_106 *ctx)
{
 if(!IW_IMGTYPE_HAS_ALPHA(ctx->img1_imgtype_logical)) {


  ctx->apply_bkgd=0;
  return;
 }



 if(ctx->img1_bkgd_label_set &&
  (ctx->req.use_bkgd_label_from_file || !ctx->req.bkgd_valid))
 {




  ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_FILE;
 }
 else if(ctx->req.bkgd_valid) {

  ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_REQ;



  ctx->bkgd_checkerboard = ctx->req.bkgd_checkerboard;
 }
 else {

  ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_NONE;
 }

 if(ctx->bkgd_checkerboard) {
  if(ctx->bkgd_check_size<1) ctx->bkgd_check_size=1;
 }

 if(ctx->req.bkgd_valid) {

  ctx->apply_bkgd=1;
 }

 if(!(ctx->output_profile&IW_PROFILE_TRANSPARENCY)) {
  if(!ctx->req.bkgd_valid && !ctx->apply_bkgd) {
   iw_warning(ctx,"This image may have transparency, which is incompatible with the output format. A background color will be applied.");
  }
  ctx->apply_bkgd=1;
 }

 if(ctx->resize_settings[IW_DIMENSION_H].use_offset ||
  ctx->resize_settings[IW_DIMENSION_V].use_offset)
 {




  if(!ctx->req.bkgd_valid && !ctx->apply_bkgd) {
   iw_warning(ctx,"This image may have transparency, which is incompatible with a channel offset. A background color will be applied.");
  }
  ctx->apply_bkgd=1;

  if(ctx->bkgd_checkerboard && ctx->req.bkgd_checkerboard) {
   iw_warning(ctx,"Checkerboard backgrounds are not supported when using a channel offset.");
   ctx->bkgd_checkerboard=0;
  }
  ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_EARLY;
  return;
 }

 if(!ctx->apply_bkgd) {

  return;
 }

 if(ctx->bkgd_checkerboard) {

  ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_LATE;
  return;
 }

 ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_LATE;
}

static void fn_96(struct struct_106 *ctx, int var_100, int var_100,
 int var_100)
{


 if(var_100==var_100 && !ctx->resize_settings[var_100].use_offset &&
  !ctx->req.out_true_valid &&
  ctx->resize_settings[var_100].translate==0.0)
 {
  iw_set_resize_alg(ctx, var_100, IW_RESIZETYPE_NULL, 1.0, 0.0, 0.0);
  return;
 }


 iw_set_resize_alg(ctx, var_100, IW_RESIZETYPE_CUBIC, 1.0, 0.0, 0.5);
}

static void fn_100(struct struct_106 *ctx)
{
 int i;

 ctx->img1_imgtype_logical = ctx->img1.imgtype;

 if(ctx->resize_settings[IW_DIMENSION_H].edge_policy==IW_EDGE_POLICY_TRANSPARENT ||
  ctx->resize_settings[IW_DIMENSION_V].edge_policy==IW_EDGE_POLICY_TRANSPARENT)
 {

  if(ctx->img1.imgtype==IW_IMGTYPE_GRAY) {
   ctx->img1_imgtype_logical = IW_IMGTYPE_GRAYA;
  }
  else if(ctx->img1.imgtype==IW_IMGTYPE_RGB)
   ctx->img1_imgtype_logical = IW_IMGTYPE_RGBA;
 }

 ctx->img1_numchannels_physical = iw_imgtype_num_channels(ctx->img1.imgtype);
 ctx->img1_numchannels_logical = iw_imgtype_num_channels(ctx->img1_imgtype_logical);
 ctx->img1_alpha_channel_index = iw_imgtype_alpha_channel_index(ctx->img1_imgtype_logical);

 iw_set_input_channeltypes(ctx);

 ctx->img2.imgtype = ctx->img1_imgtype_logical;
 ctx->img2_numchannels = ctx->img1_numchannels_logical;
 ctx->intermed_numchannels = ctx->img1_numchannels_logical;

 for(i=0;i<ctx->img1_numchannels_logical;i++) {
  ctx->intermed_ci[i].channeltype = ctx->img1_ci[i].channeltype;
  ctx->intermed_ci[i].corresponding_input_channel = i;
  ctx->img2_ci[i].channeltype = ctx->img1_ci[i].channeltype;
  if(i>=ctx->img1_numchannels_physical) {



   ctx->img1_ci[i].disable_fast_get_sample = 1;
  }
 }
}


static void fn_101(struct struct_106 *ctx)
{
 switch(ctx->grayscale_formula) {
 case IW_GSF_STANDARD:
  ctx->grayscale_formula = IW_GSF_WEIGHTED;
  iw_set_grayscale_weights(ctx,0.212655,0.715158,0.072187);
  break;
 case IW_GSF_COMPATIBLE:
  ctx->grayscale_formula = IW_GSF_WEIGHTED;
  iw_set_grayscale_weights(ctx,0.299,0.587,0.114);
  break;
 }
}



static int fn_102(struct struct_106 *ctx, int var_105, int var_105)
{
 int i,j;
 int output_maxcolorcode_int;
 int strategy1, strategy2;
 int flag;

 if(ctx->output_profile==0) {
  iw_set_error(ctx,"Output profile not set");
  return 0;
 }

 if(!ctx->prng) {


  ctx->prng = iwpvt_prng_create(ctx);
 }

 if(ctx->randomize) {


  ctx->random_seed = iwpvt_util_randomize(ctx->prng);
 }

 if(ctx->req.out_true_valid) {
  ctx->resize_settings[IW_DIMENSION_H].out_true_size = ctx->req.out_true_width;
  ctx->resize_settings[IW_DIMENSION_V].out_true_size = ctx->req.out_true_height;
 }
 else {
  ctx->resize_settings[IW_DIMENSION_H].out_true_size = (double)var_105;
  ctx->resize_settings[IW_DIMENSION_V].out_true_size = (double)var_105;
 }

 if(!iw_check_image_dimensions(ctx,ctx->img1.width,ctx->img1.height)) {
  return 0;
 }
 if(!iw_check_image_dimensions(ctx,var_105,var_105)) {
  return 0;
 }

 if(ctx->to_grayscale) {
  prepare_grayscale(ctx);
 }

 init_channel_info(ctx);

 ctx->img2.width = var_105;
 ctx->img2.height = var_105;


 if(ctx->input_start_x<0) ctx->input_start_x=0;
 if(ctx->input_start_y<0) ctx->input_start_y=0;
 if(ctx->input_start_x>ctx->img1.width-1) ctx->input_start_x=ctx->img1.width-1;
 if(ctx->input_start_y>ctx->img1.height-1) ctx->input_start_x=ctx->img1.height-1;
 if(ctx->input_w<0) ctx->input_w = ctx->img1.width - ctx->input_start_x;
 if(ctx->input_h<0) ctx->input_h = ctx->img1.height - ctx->input_start_y;
 if(ctx->input_w<1) ctx->input_w = 1;
 if(ctx->input_h<1) ctx->input_h = 1;
 if(ctx->input_w>(ctx->img1.width-ctx->input_start_x)) ctx->input_w=ctx->img1.width-ctx->input_start_x;
 if(ctx->input_h>(ctx->img1.height-ctx->input_start_y)) ctx->input_h=ctx->img1.height-ctx->input_start_y;


 if(ctx->req.output_cs_valid) {

  ctx->img2cs = ctx->req.output_cs;

  if(ctx->output_profile&IW_PROFILE_ALWAYSLINEAR) {
   if(ctx->img2cs.cstype!=IW_CSTYPE_LINEAR) {
    iw_warning(ctx,"Forcing output colorspace to linear; required by the output format.");
    iw_make_linear_csdescr(&ctx->img2cs);
   }
  }
 }
 else {

  if(ctx->output_profile&IW_PROFILE_ALWAYSLINEAR) {
   iw_make_linear_csdescr(&ctx->img2cs);
  }
  else {
   iw_make_srgb_csdescr_2(&ctx->img2cs);
  }
 }


 if(ctx->img1.sampletype!=IW_SAMPLETYPE_FLOATINGPOINT) {
  ctx->input_maxcolorcode_int = (1 << ctx->img1.bit_depth)-1;
  ctx->input_maxcolorcode = (double)ctx->input_maxcolorcode_int;

  for(i=0;i<IW_CI_COUNT;i++) {
   if(ctx->img1_ci[i].maxcolorcode_int<=0) {
    ctx->img1_ci[i].maxcolorcode_int = ctx->input_maxcolorcode_int;
   }
   ctx->img1_ci[i].maxcolorcode_dbl = (double)ctx->img1_ci[i].maxcolorcode_int;

   if(ctx->img1_ci[i].maxcolorcode_int != ctx->input_maxcolorcode_int) {


    ctx->support_reduced_input_bitdepths = 1;
   }
  }
 }

 if(ctx->support_reduced_input_bitdepths ||
  ctx->img1.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)
 {
  for(i=0;i<ctx->img1_numchannels_physical;i++) {
   ctx->img1_ci[i].disable_fast_get_sample=1;
  }
 }



 for(i=0;i<2;i++) {
  for(j=0;j<3;j++) {
   if(fabs(ctx->resize_settings[i].channel_offset[j])>0.00001) {
    ctx->resize_settings[i].use_offset=1;
   }
  }
 }

 if(ctx->to_grayscale &&
  (ctx->resize_settings[IW_DIMENSION_H].use_offset ||
  ctx->resize_settings[IW_DIMENSION_V].use_offset) )
 {
  iw_warning(ctx,"Disabling channel offset, due to grayscale output.");
  ctx->resize_settings[IW_DIMENSION_H].use_offset=0;
  ctx->resize_settings[IW_DIMENSION_V].use_offset=0;
 }

 decide_how_to_apply_bkgd(ctx);


 for(i=0;i<2;i++) {
  if(ctx->resize_settings[i].use_offset ||
    (ctx->apply_bkgd &&
     ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_EARLY &&
     ctx->resize_settings[i].edge_policy==IW_EDGE_POLICY_TRANSPARENT))
  {






   ctx->resize_settings[i].disable_rrctx_cache=1;
  }
 }

 decide_strategy(ctx,&strategy1,&strategy2);

 switch(strategy1) {
 case 0x044:
  ctx->intermed_imgtype = IW_IMGTYPE_RGBA;
  break;
 case 0x024:
  ctx->intermed_imgtype = IW_IMGTYPE_RGBA;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  ctx->intermed_ci[1].corresponding_input_channel=0;
  ctx->intermed_ci[2].corresponding_input_channel=0;
  ctx->intermed_ci[3].corresponding_input_channel=1;
  break;
 case 0x033:
 case 0x043:
  ctx->intermed_imgtype = IW_IMGTYPE_RGB;
  break;
 case 0x013:
 case 0x023:
  ctx->intermed_imgtype = IW_IMGTYPE_RGB;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  ctx->intermed_ci[1].corresponding_input_channel=0;
  ctx->intermed_ci[2].corresponding_input_channel=0;
  break;
 case 0x042:
  ctx->intermed_imgtype = IW_IMGTYPE_GRAYA;
  ctx->intermed_ci[0].cvt_to_grayscale=1;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  ctx->intermed_ci[1].corresponding_input_channel=3;
  break;
 case 0x022:
  ctx->intermed_imgtype = IW_IMGTYPE_GRAYA;
  break;
 case 0x031:
  ctx->intermed_imgtype = IW_IMGTYPE_GRAY;
  ctx->intermed_ci[0].cvt_to_grayscale=1;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  break;
 case 0x011:
  ctx->intermed_imgtype = IW_IMGTYPE_GRAY;
  ctx->intermed_ci[0].corresponding_input_channel=0;
  break;
 default:
  iw_set_errorf(ctx,"Internal error, unknown strategy %d",strategy1);
  return 0;
 }

 ctx->intermed_numchannels = iw_imgtype_num_channels(ctx->intermed_imgtype);
 ctx->intermed_alpha_channel_index = iw_imgtype_alpha_channel_index(ctx->intermed_imgtype);


 for(i=0;i<ctx->intermed_numchannels;i++) {
  ctx->intermed_ci[i].corresponding_output_channel = i;
 }

 switch(strategy2) {
 case 0x144:
  ctx->img2.imgtype = IW_IMGTYPE_RGBA;
  break;
 case 0x133:
  ctx->img2.imgtype = IW_IMGTYPE_RGB;
  break;
 case 0x143:
  ctx->img2.imgtype = IW_IMGTYPE_RGB;
  ctx->intermed_ci[3].corresponding_output_channel= -1;
  break;
 case 0x122:
  ctx->img2.imgtype = IW_IMGTYPE_GRAYA;
  break;
 case 0x111:
  ctx->img2.imgtype = IW_IMGTYPE_GRAY;
  break;
 case 0x121:
  ctx->img2.imgtype = IW_IMGTYPE_GRAY;
  ctx->intermed_ci[1].corresponding_output_channel= -1;
  break;
 default:
  iw_set_error(ctx,"Internal error");
  return 0;
 }

 ctx->img2_numchannels = iw_imgtype_num_channels(ctx->img2.imgtype);

 iw_set_intermed_channeltypes(ctx);
 iw_set_out_channeltypes(ctx);



 if(IW_IMGTYPE_HAS_ALPHA(ctx->intermed_imgtype)) {
  for(i=0;i<ctx->intermed_numchannels;i++) {
   if(ctx->intermed_ci[i].channeltype!=IW_CHANNELTYPE_ALPHA)
    ctx->intermed_ci[i].need_unassoc_alpha_processing = 1;
  }
 }


 decide_output_bit_depth(ctx);

 if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {
  flag=0;
  for(i=0;i<IW_NUM_CHANNELTYPES;i++) {
   if(ctx->req.color_count[i]) flag=1;
  }
  if(flag) {
   iw_warning(ctx,"Posterization is not supported with floating point output.");
  }
 }
 else {
  output_maxcolorcode_int = (1 << ctx->img2.bit_depth)-1;


  for(i=0;i<ctx->img2_numchannels;i++) {
   ctx->img2_ci[i].maxcolorcode_int = output_maxcolorcode_int;
  }


  if((ctx->output_profile&IW_PROFILE_REDUCEDBITDEPTHS)) {
   for(i=0;i<ctx->img2_numchannels;i++) {
    int mccr;
    mccr = ctx->req.output_maxcolorcode[ctx->img2_ci[i].channeltype];
    if(mccr>0) {
     if(mccr>output_maxcolorcode_int) mccr=output_maxcolorcode_int;
     ctx->img2_ci[i].maxcolorcode_int = mccr;
    }
   }
  }


  for(i=0;i<ctx->img2_numchannels;i++) {
   if(ctx->img2_ci[i].maxcolorcode_int != output_maxcolorcode_int) {
    ctx->reduced_output_maxcolor_flag = 1;
    ctx->disable_output_lookup_tables = 1;
   }

   ctx->img2_ci[i].maxcolorcode_dbl = (double)ctx->img2_ci[i].maxcolorcode_int;
  }
 }

 for(i=0;i<ctx->img2_numchannels;i++) {
  ctx->img2_ci[i].color_count = ctx->req.color_count[ctx->img2_ci[i].channeltype];
  if(ctx->img2_ci[i].color_count) {
   iw_restrict_to_range(2,ctx->img2_ci[i].maxcolorcode_int,&ctx->img2_ci[i].color_count);
  }
  if(ctx->img2_ci[i].color_count==1+ctx->img2_ci[i].maxcolorcode_int) {
   ctx->img2_ci[i].color_count = 0;
  }

  ctx->img2_ci[i].ditherfamily = ctx->ditherfamily_by_channeltype[ctx->img2_ci[i].channeltype];
  ctx->img2_ci[i].dithersubtype = ctx->dithersubtype_by_channeltype[ctx->img2_ci[i].channeltype];
 }


 for(i=0;i<ctx->img2_numchannels;i++) {
  if(ctx->img2_ci[i].ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
   ctx->uses_errdiffdither=1;
  }
 }

 if(!ctx->support_reduced_input_bitdepths && ctx->img1.sampletype==IW_SAMPLETYPE_UINT) {
  iw_make_x_to_linear_table(ctx,&ctx->input_color_corr_table,&ctx->img1,&ctx->img1cs);
 }

 if(ctx->img1_bkgd_label_set) {

  for(i=0;i<3;i++) {
   ctx->img1_bkgd_label_lin.c[i] = x_to_linear_sample(ctx->img1_bkgd_label_inputcs.c[i],&ctx->img1cs);
  }
  ctx->img1_bkgd_label_lin.c[3] = ctx->img1_bkgd_label_inputcs.c[3];
 }

 if(ctx->apply_bkgd) {
  prepare_apply_bkgd(ctx);
 }

 if(ctx->req.output_rendering_intent==IW_INTENT_UNKNOWN) {

  ctx->img2.rendering_intent = ctx->img1.rendering_intent;
 }
 else {
  ctx->img2.rendering_intent = ctx->req.output_rendering_intent;
 }

 if(ctx->resize_settings[IW_DIMENSION_H].family==IW_RESIZETYPE_AUTO) {
  iw_set_auto_resizetype(ctx,ctx->input_w,ctx->img2.width,IW_DIMENSION_H);
 }
 if(ctx->resize_settings[IW_DIMENSION_V].family==IW_RESIZETYPE_AUTO) {
  iw_set_auto_resizetype(ctx,ctx->input_h,ctx->img2.height,IW_DIMENSION_V);
 }

 if(IW_IMGTYPE_HAS_ALPHA(ctx->img2.imgtype)) {
  if(!ctx->opt_strip_alpha) {




   ctx->opt_palette = 0;
   ctx->opt_binary_trns = 0;
  }
 }

 return 1;
}

IW_IMPL(int) fn_105(struct struct_106 *ctx)
{
 int ret;
 int var_106 = 0;

 if(ctx->use_count>0) {
  iw_set_error(ctx,"Internal: Incorrect attempt to reprocess image");
  goto done;
 }
 ctx->use_count++;

 ret = iw_prepare_processing(ctx,ctx->canvas_width,ctx->canvas_height);
 if(!ret) goto done;

 ret = iw_process_internal(ctx);
 if(!ret) goto done;

 iwpvt_optimize_image(ctx);

 var_106 = 1;
done:
 return var_106;
}
