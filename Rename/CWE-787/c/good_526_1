







void fn_0(GF_ISOFile *file, u32 var_86);

enum
{
 enum_2 = 0,
 enum_3,
 enum_4,
 enum_5,
 enum_6,
 enum_7,
 enum_8,
 enum_9,
};

s32 fn_10(FILE *in_src)
{
 u32 var_66;
 unsigned char BOM[5];
 var_66 = (u32) fread(BOM, sizeof(char), 5, in_src);
 if ((s32) var_66 < 1)
  return -1;

 if ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {

  if (!BOM[2] && !BOM[3]) return -1;
  gf_fseek(in_src, 2, SEEK_SET);
  return 3;
 }
 if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {

  if (!BOM[2] && !BOM[3]) return -1;
  gf_fseek(in_src, 2, SEEK_SET);
  return 2;
 } else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {
  gf_fseek(in_src, 3, SEEK_SET);
  return 1;
 }
 if (BOM[0]<0x80) {
  gf_fseek(in_src, 0, SEEK_SET);
  return 0;
 }
 return -1;
}

static GF_Err fn_12(char *filename, u32 *fmt)
{
 char szLine[2048];
 u32 val;
 s32 uni_type;
 FILE *test = gf_fopen(filename, "rb");
 if (!test) return GF_URL_ERROR;
 uni_type = gf_text_get_utf_type(test);

 if (uni_type>1) {
  const u16 *sptr;
  char szUTF[1024];
  u32 var_66 = (u32) fread(szUTF, 1, 1023, test);
  if ((s32) var_66 < 0) {
   gf_fclose(test);
   return GF_IO_ERR;
  }
  szUTF[var_66]=0;
  sptr = (u16*)szUTF;
                   gf_utf8_wcstombs(szLine, var_66, &sptr);
 } else {
  val = (u32) fread(szLine, 1, 1024, test);
  if ((s32) val<0) return GF_IO_ERR;

  szLine[val]=0;
 }
 while 1 { u32 var_67 = (u32) strlen(szLine); if (!var_67) break; var_67--; if (strchr("\r\n\t ", szLine[var_67])) szLine[var_67] = 0; else break; }

 *fmt = GF_TEXT_IMPORT_NONE;
 if ((szLine[0]=='{') && strstr(szLine, "}{")) *fmt = GF_TEXT_IMPORT_SUB;
 else if (szLine[0] == '<') {
  char *ext = strrchr(filename, '.');
  if (!strnicmp(ext, ".ttxt", 5)) *fmt = GF_TEXT_IMPORT_TTXT;
  else if (!strnicmp(ext, ".ttml", 5)) *fmt = GF_TEXT_IMPORT_TTML;
  ext = strstr(szLine, "?>");
  if (ext) ext += 2;
  if (ext && !ext[0]) {
   if (!fgets(szLine, 2048, test))
    szLine[0] = '\0';
  }
  if (strstr(szLine, "x-quicktime-tx3g") || strstr(szLine, "text3GTrack")) *fmt = GF_TEXT_IMPORT_TEXML;
  else if (strstr(szLine, "TextStream")) *fmt = GF_TEXT_IMPORT_TTXT;
  else if (strstr(szLine, "tt")) *fmt = GF_TEXT_IMPORT_TTML;
 }
 else if (strstr(szLine, "WEBVTT") )
  *fmt = GF_TEXT_IMPORT_WEBVTT;
 else if (strstr(szLine, " --> ") )
  *fmt = GF_TEXT_IMPORT_SRT;

 gf_fclose(test);
 return var_87;
}







void fn_15(GF_MediaImporter *import, u32 *width, u32 *height)
{
 u32 var_82, var_82, f_w, f_h, var_86;
 GF_ISOFile *dest = import->dest;

 if (import->text_track_width && import->text_track_height) {
  (*width) = import->text_track_width;
  (*height) = import->text_track_height;
  return;
 }

 f_w = f_h = 0;
 for (var_86=0; var_86<gf_isom_get_track_count(dest); var_86++) {
  switch (gf_isom_get_media_type(dest, var_86+1)) {
  case GF_ISOM_MEDIA_SCENE:
  case GF_ISOM_MEDIA_VISUAL:
        case GF_ISOM_MEDIA_AUXV:
        case GF_ISOM_MEDIA_PICT:
   gf_isom_get_visual_info(dest, var_86+1, 1, &var_82, &var_82);
   if (var_82 > f_w) f_w = var_82;
   if (var_82 > f_h) f_h = var_82;
   gf_isom_get_track_layout_info(dest, var_86+1, &var_82, &var_82, NULL, NULL, NULL);
   if (var_82 > f_w) f_w = var_82;
   if (var_82 > f_h) f_h = var_82;
   break;
  }
 }
 (*width) = f_w ? f_w : 400;
 (*height) = f_h ? f_h : 60;
}


void fn_19(GF_MediaImporter *import, u32 var_86)
{
 if (import->esd && import->esd->langDesc) {
  char lang[4];
  lang[0] = (import->esd->langDesc->langCode>>16) & 0xFF;
  lang[1] = (import->esd->langDesc->langCode>>8) & 0xFF;
  lang[2] = (import->esd->langDesc->langCode) & 0xFF;
  lang[3] = 0;
  gf_isom_set_media_language(import->dest, var_86, lang);
 }
}


char *fn_20(char *szLine, u32 var_24, FILE *txt_in, s32 var_67)
{
 u32 var_86, j, var_77;
 char *sOK;
 char szLineConv[1024];
 unsigned short *sptr;

 memset(szLine, 0, sizeof(char)*var_24);
 sOK = fgets(szLine, var_24, txt_in);
 if (!sOK) return NULL;
 if (var_67<=1) {
  j=0;
  var_77 = (u32) strlen(szLine);
  for (var_86=0; var_86<var_77 && j < sizeof(szLineConv) - 1; var_86++, j++) {

   if (!var_67 && (szLine[var_86] & 0x80)) {

    if ((szLine[var_86+1] & 0xc0) != 0x80) {
     if (j + 1 < sizeof(szLineConv) - 1) {
      szLineConv[j] = 0xc0 | ((szLine[var_86] >> 6) & 0x3);
      j++;
      szLine[var_86] &= 0xbf;
     }
     else
      break;
    }

    else if ( (szLine[var_86] & 0xe0) == 0xc0) {


     if (j + 1 < sizeof(szLineConv) - 1 && var_86 + 1 < var_77) {
      szLineConv[j] = szLine[var_86];
      var_86++;
      j++;
     }
     else {
      break;
     }
    }

    else if ( (szLine[var_86] & 0xf0) == 0xe0) {
     if (j + 2 < sizeof(szLineConv) - 1 && var_86 + 2 < var_77) {
      szLineConv[j] = szLine[var_86];
      var_86++;
      j++;
      szLineConv[j] = szLine[var_86];
      var_86++;
      j++;
     }
     else {
      break;
     }
    }

    else if ( (szLine[var_86] & 0xf8) == 0xf0) {
     if (j + 3 < sizeof(szLineConv) - 1 && var_86 + 3 < var_77) {
      szLineConv[j] = szLine[var_86];
      var_86++;
      j++;
      szLineConv[j] = szLine[var_86];
      var_86++;
      j++;
      szLineConv[j] = szLine[var_86];
      var_86++;
      j++;
     }
     else {
      break;
     }
    } else {
     var_86+=1;
     continue;
    }
   }
   if (j < sizeof(szLineConv)-1 && var_86<var_77)
    szLineConv[j] = szLine[var_86];

  }
  if (j >= sizeof(szLineConv))
   szLineConv[sizeof(szLineConv) - 1] = 0;
  else
   szLineConv[j] = 0;

  strcpy(szLine, szLineConv);
  return sOK;
 }




 if (var_67==2) {

  var_86=0;
  while 1 {
   char c;
   if (!szLine[var_86] && !szLine[var_86+1]) break;
   c = szLine[var_86+1];
   szLine[var_86+1] = szLine[var_86];
   szLine[var_86] = c;
   var_86+=2;
  }
 }
 sptr = (u16 *)szLine;
 var_86 = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);
 if (var_86 >= (u32)ARRAY_LENGTH(szLineConv))
  return NULL;
 szLineConv[var_86] = 0;
 strcpy(szLine, szLineConv);

 if (var_67==3) fgetc(txt_in);
 return sOK;
}




static GF_Err fn_24(GF_MediaImporter *import)
{
 FILE *srt_in;
 u32 var_86, timescale, var_86, var_80;
 GF_TextConfig*cfg;
 GF_Err var_87;
 GF_StyleRecord rec;
 GF_TextSample * samp;
 GF_ISOSample *s;
 u32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len, char_line, nb_samp, j, duration, rem_styles;
 Bool set_start_char, set_end_char, first_samp, rem_color;
 u64 var_86, end, prev_end, file_size;
 u32 var_42, curLine, line, var_77, ID, OCR_ES_ID, default_color;
 s32 var_67;
 char szLine[2048], szText[2048], *ptr;
 unsigned short uniLine[5000], uniText[5000], *sptr;

 srt_in = gf_fopen(import->in_name, "rt");
 gf_fseek(srt_in, 0, SEEK_END);
 file_size = gf_ftell(srt_in);
 gf_fseek(srt_in, 0, SEEK_SET);

 var_67 = gf_text_get_utf_type(srt_in);
 if (var_67<0) {
  gf_fclose(srt_in);
  return gf_import_message(import, GF_NOT_SUPPORTED, "Unsupported SRT UTF encoding");
 }

 cfg = NULL;
 if (import->esd) {
  if (!import->esd->slConfig) {
   import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);
   import->esd->slConfig->predefined = 2;
   import->esd->slConfig->timestampResolution = 1000;
  }
  timescale = import->esd->slConfig->timestampResolution;
  if (!timescale) timescale = 1000;


  if (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {
   cfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;
   import->esd->decoderConfig->decoderSpecificInfo = NULL;
  }
  ID = import->esd->ESID;
  OCR_ES_ID = import->esd->OCRESID;
 } else {
  timescale = 1000;
  OCR_ES_ID = ID = 0;
 }

 if (cfg && cfg->timescale) timescale = cfg->timescale;
 var_86 = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);
 if (!var_86) {
  gf_fclose(srt_in);
  return gf_import_message(import, gf_isom_last_error(import->dest), "Error creating text track");
 }
 gf_isom_set_track_enabled(import->dest, var_86, 1);
 import->final_trackID = gf_isom_get_track_id(import->dest, var_86);
 if (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;

 if (OCR_ES_ID) gf_isom_set_track_reference(import->dest, var_86, GF_ISOM_REF_OCR, OCR_ES_ID);


 if (cfg) {
  char *firstFont = NULL;

  gf_isom_set_track_layout_info(import->dest, var_86, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);


  var_80 = gf_list_count(cfg->sample_descriptions);
  for (var_86=0; var_86<var_80; var_86++) {
   GF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, var_86);
   if (!sd->font_count) {
    sd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));
    sd->font_count = 1;
    sd->fonts[0].fontID = 1;
    sd->fonts[0].fontName = gf_strdup("Serif");
   }
   if (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;
   if (!sd->default_style.font_size) sd->default_style.font_size = 16;
   if (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;

   if (!var_86) rec = sd->default_style;

   gf_isom_new_text_description(import->dest, var_86, sd, NULL, NULL, &var_42);
   if (!firstFont) firstFont = sd->fonts[0].fontName;
  }
  gf_import_message(import, var_87, "Timed Text (SRT) import - text track %d x %d, font %s (size %d)", cfg->text_width, cfg->text_height, firstFont, rec.font_size);

  gf_odf_desc_del((GF_Descriptor *)cfg);
 } else {
  u32 var_82, var_82;
  GF_TextSampleDescriptor *sd;
  gf_text_get_video_size(import, &var_82, &var_82);



  gf_isom_set_track_layout_info(import->dest, var_86, var_82<<16, var_82<<16, 0, 0, 0);
  sd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);
  sd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));
  sd->font_count = 1;
  sd->fonts[0].fontID = 1;
  sd->fonts[0].fontName = gf_strdup(import->fontName ? import->fontName : "Serif");
  sd->back_color = 0x00000000;
  sd->default_style.fontID = 1;
  sd->default_style.font_size = import->fontSize ? import->fontSize : 18;
  sd->default_style.text_color = 0xFFFFFFFF;
  sd->default_style.style_flags = 0;
  sd->horiz_justif = 1;
  sd->vert_justif = (s8) -1;

  if (import->flags & GF_IMPORT_SKIP_TXT_BOX) {
   sd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;
  } else {
   if ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {
    sd->default_pos.left = import->text_x;
    sd->default_pos.top = import->text_y;
    sd->default_pos.right = (import->text_width ? import->text_width : var_82) + sd->default_pos.left;
    sd->default_pos.bottom = (import->text_height ? import->text_height : var_82) + sd->default_pos.top;
   }
  }


  rec = sd->default_style;
  gf_isom_new_text_description(import->dest, var_86, sd, NULL, NULL, &var_42);

  gf_import_message(import, var_87, "Timed Text (SRT) import - text track %d x %d, font %s (size %d)", var_82, var_82, sd->fonts[0].fontName, rec.font_size);
  gf_odf_desc_del((GF_Descriptor *)sd);
 }
 gf_text_import_set_language(import, var_86);
 duration = (u32) (((Double) import->duration)*timescale/1000.0);

 default_color = rec.text_color;

 var_87 = var_87;
 var_42 = 0;
 end = prev_end = 0;
 curLine = 0;
 txt_line = 0;
 set_start_char = set_end_char = var_82;
 char_len = 0;
 var_86 = 0;
 nb_samp = 0;
 samp = gf_isom_new_text_sample();

 first_samp = GF_TRUE;
 while 1 {
  char *sOK = gf_text_get_utf8_line(szLine, 2048, srt_in, var_67);

  if (sOK) while 1 { u32 var_67 = (u32) strlen(szLine); if (!var_67) break; var_67--; if (strchr("\r\n\t ", szLine[var_67])) szLine[var_67] = 0; else break; }
   if (!sOK || !strlen(szLine)) {
    rec.style_flags = 0;
    rec.startCharOffset = rec.endCharOffset = 0;
    if (txt_line) {
     if (prev_end && (var_86 != prev_end)) {
      GF_TextSample * empty_samp = gf_isom_new_text_sample();
      s = gf_isom_text_to_sample(empty_samp);
      gf_isom_delete_text_sample(empty_samp);
      if (var_42<=2) {
       s->DTS = (u64) ((timescale*prev_end)/1000);
       s->IsRAP = RAP;
       gf_isom_add_sample(import->dest, var_86, 1, s);
       nb_samp++;
      }
      gf_isom_sample_del(&s);
     }

     s = gf_isom_text_to_sample(samp);
     if (var_42<=2) {
      s->DTS = (u64) ((timescale*var_86)/1000);
      s->IsRAP = RAP;
      gf_isom_add_sample(import->dest, var_86, 1, s);
      gf_isom_sample_del(&s);
      nb_samp++;
      prev_end = end;
     }
     txt_line = 0;
     char_len = 0;
     set_start_char = set_end_char = var_82;
     rec.startCharOffset = rec.endCharOffset = 0;
     gf_isom_text_reset(samp);


     gf_set_progress("Importing SRT", gf_ftell(srt_in), file_size);
     if (duration && (end >= duration)) break;
    }
    var_42 = 0;
    if (!sOK) break;
    continue;
   }

  switch (var_42) {
  case 0:
   if (sscanf(szLine, "%u", &line) != 1) {
    var_87 = gf_import_message(import, GF_CORRUPTED_DATA, "Bad SRT formatting - expecting number got \"%s\"", szLine);
    goto exit;
   }
   if (line != curLine + 1) gf_import_message(import, var_87, "WARNING: corrupted SRT frame %d after frame %d", line, curLine);
   curLine = line;
   var_42 = 1;
   break;
  case 1:
   if (sscanf(szLine, "%u:%u:%u,%u --> %u:%u:%u,%u", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {
    sh = eh = 0;
    if (sscanf(szLine, "%u:%u,%u --> %u:%u,%u", &sm, &ss, &sms, &em, &es, &ems) != 6) {
     var_87 = gf_import_message(import, GF_CORRUPTED_DATA, "Error scanning SRT frame %d timing", curLine);
     goto exit;
    }
   }
   var_86 = (3600*sh + 60*sm + ss)*1000 + sms;
   if (var_86<end) {
    gf_import_message(import, var_87, "WARNING: overlapping SRT frame %d - starts "LLD" ms is before end of previous one "LLD" ms - adjusting time stamps", curLine, var_86, end);
    var_86 = end;
   }

   end = (3600*eh + 60*em + es)*1000 + ems;

   if (first_samp && (var_86>0)) {
    s = gf_isom_text_to_sample(samp);
    s->DTS = 0;
    gf_isom_add_sample(import->dest, var_86, 1, s);
    gf_isom_sample_del(&s);
    nb_samp++;
   }
   rec.style_flags = 0;
   var_42 = 2;
   if (end<=prev_end) {
    gf_import_message(import, var_87, "WARNING: overlapping SRT frame %d end "LLD" is at or before previous end "LLD" - removing", curLine, end, prev_end);
    var_86 = end;
    var_42 = 3;
   }
   break;

  default:

   first_samp = var_82;


   if (txt_line) {
    gf_isom_text_add_text(samp, "\n", 1);
    char_len += 1;
   }

   ptr = (char *) szLine;
   {
    size_t var_67 = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);
    if (var_67 == (size_t) -1) {
     var_87 = gf_import_message(import, GF_CORRUPTED_DATA, "Invalid UTF data (line %d)", curLine);
     goto exit;
    }
    var_77 = (u32) var_67;
   }
   var_86=j=0;
   rem_styles = 0;
   rem_color = 0;
   while (var_86<var_77) {
    u32 var_34 = 0;
    u32 var_34 = 0;
    u32 var_34 = 0;

    if ( (uniLine[var_86]=='<') && (uniLine[var_86+2]=='>')) {
     var_34 = 3;
     var_34 = 1;
    }
    else if ( (uniLine[var_86]=='<') && (uniLine[var_86+1]=='/') && (uniLine[var_86+3]=='>')) {
     var_34 = 2;
     var_34 = 4;
    }
    else if (uniLine[var_86]=='<') {
     const unsigned short* src = uniLine + var_86;
     size_t var_34 = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);
     szLine[var_34] = 0;
     strlwr(szLine);
     if (!strncmp(szLine, "<font ", 6) ) {
      char *a_sep = strstr(szLine, "color");
      if (a_sep) a_sep = strchr(a_sep, '"');
      if (a_sep) {
       char *e_sep = strchr(a_sep+1, '"');
       if (e_sep) {
        e_sep[0] = 0;
        var_34 = gf_color_parse(a_sep+1);
        e_sep[0] = '"';
        e_sep = strchr(e_sep+1, '>');
        if (e_sep) {
         var_34 = (u32) (1 + e_sep - szLine);
         var_34 = 1;
        }
       }

      }
     }
     else if (!strncmp(szLine, "</font>", 7) ) {
      var_34 = 7;
      var_34 = 2;
      var_34 = 0xFFFFFFFF;
     }

     else {
      char *a_sep = strstr(szLine, ">");
      if (a_sep) {
       var_34 = (u32) (a_sep - szLine);
       var_86 += var_34;
       continue;
      }
     }

    }


    if (var_34==1) {

     if (set_end_char) {
      assert(set_start_char);
      gf_isom_text_add_style(samp, &rec);
      set_end_char = set_start_char = var_82;
      rec.style_flags &= ~rem_styles;
      rem_styles = 0;
      if (rem_color) {
       rec.text_color = default_color;
       rem_color = 0;
      }
     }
     if (set_start_char && (rec.startCharOffset != j)) {
      rec.endCharOffset = char_len + j;
      if (rec.style_flags) gf_isom_text_add_style(samp, &rec);
     }
     switch (uniLine[var_86+1]) {
     case 'b':
     case 'B':
      rec.style_flags |= GF_TXT_STYLE_BOLD;
      set_start_char = GF_TRUE;
      rec.startCharOffset = char_len + j;
      break;
     case 'i':
     case 'I':
      rec.style_flags |= GF_TXT_STYLE_ITALIC;
      set_start_char = GF_TRUE;
      rec.startCharOffset = char_len + j;
      break;
     case 'u':
     case 'U':
      rec.style_flags |= GF_TXT_STYLE_UNDERLINED;
      set_start_char = GF_TRUE;
      rec.startCharOffset = char_len + j;
      break;
     case 'f':
     case 'F':
      if (var_34) {
       rec.text_color = var_34;
       set_start_char = GF_TRUE;
       rec.startCharOffset = char_len + j;
      }
      break;
     }
     var_86 += var_34;
     continue;
    }


    if (var_34==2) {
     switch (uniLine[var_86+2]) {
     case 'b':
     case 'B':
      rem_styles |= GF_TXT_STYLE_BOLD;
      set_end_char = GF_TRUE;
      rec.endCharOffset = char_len + j;
      break;
     case 'i':
     case 'I':
      rem_styles |= GF_TXT_STYLE_ITALIC;
      set_end_char = GF_TRUE;
      rec.endCharOffset = char_len + j;
      break;
     case 'u':
     case 'U':
      rem_styles |= GF_TXT_STYLE_UNDERLINED;
      set_end_char = GF_TRUE;
      rec.endCharOffset = char_len + j;
      break;
     case 'f':
     case 'F':
      if (var_34) {
       rem_color = 1;
       set_end_char = GF_TRUE;
       rec.endCharOffset = char_len + j;
      }
     }
     var_86+=var_34;
     continue;
    }

    if (set_end_char) {
     gf_isom_text_add_style(samp, &rec);
     set_end_char = var_82;
     set_start_char = GF_TRUE;
     rec.startCharOffset = char_len + j;
     rec.style_flags &= ~rem_styles;
     rem_styles = 0;
     rec.text_color = default_color;
     rem_color = 0;
    }

    uniText[j] = uniLine[var_86];
    j++;
    var_86++;
   }

   if (set_end_char) {
    gf_isom_text_add_style(samp, &rec);
    set_end_char = var_82;
    set_start_char = GF_TRUE;
    rec.startCharOffset = char_len + j;
    rec.style_flags &= ~rem_styles;
   }

   char_line = j;
   uniText[j] = 0;

   sptr = (u16 *) uniText;
   var_77 = (u32) gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);

   gf_isom_text_add_text(samp, szText, var_77);
   char_len += char_line;
   txt_line ++;
   break;
  }
  if (duration && (var_86 >= duration)) {
   end = 0;
   break;
  }
 }


 if (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {
  gf_isom_text_reset(samp);
  s = gf_isom_text_to_sample(samp);
  s->DTS = (u64) ((timescale*end)/1000);
  s->IsRAP = RAP;
  gf_isom_add_sample(import->dest, var_86, 1, s);
  gf_isom_sample_del(&s);
  nb_samp++;
  gf_isom_set_last_sample_duration(import->dest, var_86, 0);
 } else {
  if (duration && (var_86 >= duration)) {
   gf_isom_set_last_sample_duration(import->dest, var_86, (timescale*duration)/1000);
  } else {
   gf_isom_set_last_sample_duration(import->dest, var_86, 0);
  }
 }
 gf_isom_delete_text_sample(samp);
 gf_set_progress("Importing SRT", nb_samp, nb_samp);

exit:
 if (var_87) gf_isom_remove_track(import->dest, var_86);
 gf_fclose(srt_in);
 return var_87;
}



typedef struct {
 GF_MediaImporter *import;
 u32 timescale;
 u32 track;
 u32 descriptionIndex;
} GF_ISOFlusher;



static GF_Err fn_34(void *user, GF_Err var_87, char *message, const char *line)
{
 GF_ISOFlusher *flusher = (GF_ISOFlusher *)user;
 return gf_import_message(flusher->import, var_87, message, line);
}

static void fn_35(void *user, const char *config)
{
 GF_ISOFlusher *flusher = (GF_ISOFlusher *)user;
 gf_isom_update_webvtt_description(flusher->import->dest, flusher->track, flusher->descriptionIndex, config);
}

static void fn_36(void *user, GF_WebVTTSample *samp)
{
 GF_ISOSample *s;
 GF_ISOFlusher *flusher = (GF_ISOFlusher *)user;

 s = gf_isom_webvtt_to_sample(samp);
 if (s) {
  s->DTS = (u64) (flusher->timescale*gf_webvtt_sample_get_start(samp)/1000);
  s->IsRAP = RAP;
  gf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);
  gf_isom_sample_del(&s);
 }
 gf_webvtt_sample_del(samp);
}

static GF_Err fn_37(GF_MediaImporter *import)
{
 GF_Err var_87;
 u32 var_86;
 u32 timescale;
 u32 duration;
 u32 var_86=1;
 u32 ID;
 u32 OCR_ES_ID;
 GF_GenericSubtitleConfig *cfg;
 GF_WebVTTParser *vttparser;
 GF_ISOFlusher flusher;

 cfg = NULL;
 if (import->esd) {
  if (!import->esd->slConfig) {
   import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);
   import->esd->slConfig->predefined = 2;
   import->esd->slConfig->timestampResolution = 1000;
  }
  timescale = import->esd->slConfig->timestampResolution;
  if (!timescale) timescale = 1000;


  if (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {
   cfg = (GF_GenericSubtitleConfig *) import->esd->decoderConfig->decoderSpecificInfo;
   import->esd->decoderConfig->decoderSpecificInfo = NULL;
  }
  ID = import->esd->ESID;
  OCR_ES_ID = import->esd->OCRESID;
 } else {
  timescale = 1000;
  OCR_ES_ID = ID = 0;
 }

 if (cfg && cfg->timescale) timescale = cfg->timescale;
 var_86 = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);
 if (!var_86) {
  return gf_import_message(import, gf_isom_last_error(import->dest), "Error creating WebVTT track");
 }
 gf_isom_set_track_enabled(import->dest, var_86, 1);
 import->final_trackID = gf_isom_get_track_id(import->dest, var_86);
 if (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;

 if (OCR_ES_ID) gf_isom_set_track_reference(import->dest, var_86, GF_ISOM_REF_OCR, OCR_ES_ID);


 if (cfg) {
  u32 var_86;
  u32 var_80;

  gf_isom_set_track_layout_info(import->dest, var_86, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);


  var_80 = gf_list_count(cfg->sample_descriptions);
  for (var_86=0; var_86<var_80; var_86++) {
   gf_isom_new_webvtt_description(import->dest, var_86, NULL, NULL, NULL, &var_86);
  }
  gf_import_message(import, var_87, "WebVTT import	- text track %d	x %d", cfg->text_width, cfg->text_height);
  gf_odf_desc_del((GF_Descriptor *)cfg);
 } else {
  u32 var_82;
  u32 var_82;

  gf_text_get_video_size(import, &var_82, &var_82);
  gf_isom_set_track_layout_info(import->dest, var_86, var_82<<16, var_82<<16, 0, 0, 0);

  gf_isom_new_webvtt_description(import->dest, var_86, NULL, NULL, NULL, &var_86);

  gf_import_message(import, var_87, "WebVTT import");
 }
 gf_text_import_set_language(import, var_86);
 duration = (u32) (((Double) import->duration)*timescale/1000.0);

 vttparser = gf_webvtt_parser_new();
 flusher.import = import;
 flusher.timescale = timescale;
 flusher.track = var_86;
 flusher.descriptionIndex = var_86;
 var_87 = gf_webvtt_parser_init(vttparser, import->in_name, &flusher, gf_webvtt_import_report, gf_webvtt_flush_sample_to_iso, gf_webvtt_import_header);
 if (var_87 != var_87) {
  gf_webvtt_parser_del(vttparser);
  return gf_import_message(import, GF_NOT_SUPPORTED, "Unsupported WebVTT UTF encoding");
 }
 var_87 = gf_webvtt_parser_parse(vttparser, duration);
 if (var_87 != var_87) {
  gf_isom_remove_track(import->dest, var_86);
 }




 gf_isom_set_last_sample_duration(import->dest, var_86, (u32) gf_webvtt_parser_last_duration(vttparser));

 gf_webvtt_parser_del(vttparser);
 return var_87;
}



static char *fn_39(GF_MediaImporter *import, char *str, Bool var_42)
{
 u32 var_86=0;
 u32 var_82=0;
 u32 var_77 = (u32) strlen(str);
 u32 var_42 = 0;

 if (!var_42) {
  for (var_86=0; var_86<var_77; var_86++) {
   if ((str[var_86] == '\r') && (str[var_86+1] == '\n')) {
    var_86++;
   }
   str[var_82] = str[var_86];
   var_82++;
  }
  str[var_82]=0;
  return str;
 }

 if (str[0]!='\'') return str;
 for (var_86=0; var_86<var_77; var_86++) {
  if (str[var_86] == '\'') {

   if (!var_42) {
    if (var_82) {
     str[var_82]='\n';
     var_82++;
    }
    var_42 = !var_42;
   } else if (var_42) {
    if ( (var_86+1==var_77) ||
            ((str[var_86+1]==' ') || (str[var_86+1]=='\n') || (str[var_86+1]=='\r') || (str[var_86+1]=='\t') || (str[var_86+1]=='\''))
       ) {
     var_42 = !var_42;
    } else {
     str[var_82] = str[var_86];
     var_82++;
    }
   }
  } else if (var_42) {
   str[var_82] = str[var_86];
   var_82++;
  }
 }
 str[var_82]=0;
 return str;
}

static void fn_42(void *cbk, u64 var_80, u64 var_80)
{
 gf_set_progress("TTML Loading", var_80, var_80);
}

static void fn_44(GF_XMLNode *root, GF_XMLNode **sample_list_node)
{
 u32 var_76 = 0, var_48 = 0;
 GF_XMLNode *node = NULL;
 *sample_list_node = NULL;
 while ( (node = (GF_XMLNode*)gf_list_enum(root->content, &var_76))) {
  if (!strcmp(node->name, "body")) {
   GF_XMLNode *body_node;
   u32 var_49 = 0;
   while ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &var_49))) {
    if (!strcmp(body_node->name, "div")) {
     *sample_list_node = body_node;
     var_48 = gf_list_count(body_node->content);
     while (var_48--) {
      GF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);
      assert(gf_list_find(body_node->content, content_node) == 0);
      gf_list_rem(body_node->content, 0);
      gf_xml_dom_node_del(content_node);
     }
     return;
    }
   }
  }
 }
}


static GF_Err fn_48(GF_MediaImporter *import, GF_DOMParser *parser, GF_XMLNode *root)
{
 GF_Err var_87, e_opt;
 u32 var_86, var_86, ID, desc_idx, nb_samples, nb_children;
 u64 last_sample_duration, last_sample_end;
 GF_XMLAttribute *att;
 GF_XMLNode *node, *root_working_copy, *sample_list_node;
 GF_DOMParser *parser_working_copy;
 char *samp_text;
 Bool has_body;

 samp_text = NULL;
 root_working_copy = NULL;
 parser_working_copy = NULL;


 ID = (import->esd) ? import->esd->ESID : 0;
 var_86 = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_MPEG_SUBT, 1000);
 if (!var_86) {
  var_87 = gf_isom_last_error(import->dest);
  goto exit;
 }
 gf_isom_set_track_enabled(import->dest, var_86, 1);


 if (import->esd) {
  if (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, var_86);
  if (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);
  if (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);
  import->esd->slConfig->timestampResolution = 1000;
  import->esd->decoderConfig->streamType = GF_STREAM_TEXT;
  import->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;
  if (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, var_86, GF_ISOM_REF_OCR, import->esd->OCRESID);
 }

 gf_import_message(import, var_87, "TTML EBU-TTD Import");


 var_86=0;
 while ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &var_86))) {
  GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, ("Found root attribute name %s, value %s\n", att->name, att->value));

  if (!strcmp(att->name, "xmlns")) {
   if (strcmp(att->value, "http:
    var_87 = gf_import_message(import, GF_BAD_PARAM, "Found invalid EBU-TTD root attribute name %s, value %s (shall be \"%s\")\n", att->name, att->value, "http:
    goto exit;
   }
  } else if (!strcmp(att->name, "xml:lang")) {
   if (import->esd && !import->esd->langDesc) {
    char *lang;
    lang = gf_strdup(att->value);
    import->esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);
    gf_isom_set_media_language(import->dest, var_86, lang);
   } else {
    gf_isom_set_media_language(import->dest, var_86, att->value);
   }
  }
 }

 var_87 = gf_isom_new_xml_subtitle_description(import->dest, var_86, "http:

 if (var_87 != var_87) {
  GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] incorrect sample description. Abort.\n"));
  var_87 = gf_isom_last_error(import->dest);
  goto exit;
 }


 parser_working_copy = gf_xml_dom_new();
 var_87 = gf_xml_dom_parse(parser_working_copy, import->in_name, NULL, NULL);
 assert (var_87 == var_87);
 root_working_copy = gf_xml_dom_get_root(parser_working_copy);
 assert(root_working_copy);
 last_sample_duration = 0;
 last_sample_end = 0;
 nb_samples = 0;
 nb_children = gf_list_count(root->content);
 has_body = var_82;
 var_86=0;
 while ( (node = (GF_XMLNode*)gf_list_enum(root->content, &var_86))) {
  if (node->type) {
   nb_children--;
   continue;
  }

  e_opt = gf_xml_get_element_check_namespace(node, "body", root->ns);
  if (e_opt == GF_BAD_PARAM) {
   GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] ignored \"%s\" node, check your namespaces\n", node->name));
  } else if (e_opt == var_87) {
   GF_XMLNode *body_node;
   u32 var_49 = 0;

   if (has_body) {
    var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML EBU-TTD] duplicated \"body\" element. Abort.\n");
    goto exit;
   }
   has_body = GF_TRUE;


   gf_text_import_ebu_ttd_remove_samples(root_working_copy, &sample_list_node);

   while ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &var_49))) {
    e_opt = gf_xml_get_element_check_namespace(body_node, "div", root->ns);
    if (e_opt == GF_BAD_PARAM) {
     GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] ignored \"%s\" node, check your namespaces\n", node->name));
    } else if (e_opt == var_87) {
     GF_XMLNode *div_node;
     u32 var_51 = 0, var_56 = 0;
     while ( (div_node = (GF_XMLNode*)gf_list_enum(body_node->content, &var_51))) {
      e_opt = gf_xml_get_element_check_namespace(div_node, "p", root->ns);
      if (e_opt != var_87) {
       GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML] ignored \"%s\" node, check your namespaces\n", node->name));
      } else if (e_opt == var_87) {
       GF_XMLNode *p_node;
       GF_XMLAttribute *p_att;
       u32 var_55 = 0, var_82, var_85, s, f, ms;
       s64 var_56 = -1, var_56 = -1;


       while ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_node->attributes, &var_55))) {
        if (!p_att) continue;

        if (!strcmp(p_att->name, "begin")) {
         if (var_56 != -1) {
          var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated \"begin\" attribute. Abort.\n");
          goto exit;
         }
         if (sscanf(p_att->value, "%u:%u:%u.%u", &var_82, &var_85, &s, &ms) == 4) {
          var_56 = (var_82*3600 + var_85*60+s)*1000+ms;
         } else if (sscanf(p_att->value, "%u:%u:%u:%u", &var_82, &var_85, &s, &f) == 4) {
          var_56 = (var_82*3600 + var_85*60+s)*1000+f*40;
         } else if (sscanf(p_att->value, "%u:%u:%u", &var_82, &var_85, &s) == 3) {
          var_56 = (var_82*3600 + var_85*60+s)*1000;
         }
        } else if (!strcmp(p_att->name, "end")) {
         if (var_56 != -1) {
          var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated \"end\" attribute. Abort.\n");
          goto exit;
         }
         if (sscanf(p_att->value, "%u:%u:%u.%u", &var_82, &var_85, &s, &ms) == 4) {
          var_56 = (var_82*3600 + var_85*60+s)*1000+ms;
         } else if (sscanf(p_att->value, "%u:%u:%u:%u", &var_82, &var_85, &s, &f) == 4) {
          var_56 = (var_82*3600 + var_85*60+s)*1000+f*40;
         } else if (sscanf(p_att->value, "%u:%u:%u", &var_82, &var_85, &s) == 3) {
          var_56 = (var_82*3600 + var_85*60+s)*1000;
         }
        }
        if ((var_56 != -1) && (var_56 != -1) && !samp_text && sample_list_node) {
         var_87 = gf_xml_dom_append_child(sample_list_node, div_node);
         assert(var_87 == var_87);
         assert(!samp_text);
         samp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, var_82);
         var_87 = gf_xml_dom_rem_child(sample_list_node, div_node);
         assert(var_87 == var_87);
        }
       }


       var_55 = 0;
       while ( (p_node = (GF_XMLNode*)gf_list_enum(div_node->content, &var_55))) {
        e_opt = gf_xml_get_element_check_namespace(p_node, "span", root->ns);
        if (e_opt == GF_BAD_PARAM) {
         GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML] ignored \"%s\" node, check your namespaces\n", node->name));
        } else if (e_opt == var_87) {
         u32 var_56 = 0;
         GF_XMLAttribute *span_att;
         while ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &var_56))) {
          if (!span_att) continue;

          if (!strcmp(span_att->name, "begin")) {
           if (var_56 != -1) {
            var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated \"begin\" attribute under <span>. Abort.\n");
            goto exit;
           }
           if (sscanf(span_att->value, "%u:%u:%u.%u", &var_82, &var_85, &s, &ms) == 4) {
            var_56 = (var_82*3600 + var_85*60+s)*1000+ms;
           } else if (sscanf(p_att->value, "%u:%u:%u:%u", &var_82, &var_85, &s, &f) == 4) {
            var_56 = (var_82*3600 + var_85*60+s)*1000+f*40;
           } else if (sscanf(span_att->value, "%u:%u:%u", &var_82, &var_85, &s) == 3) {
            var_56 = (var_82*3600 + var_85*60+s)*1000;
           }
          } else if (!strcmp(span_att->name, "end")) {
           if (var_56 != -1) {
            var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated \"end\" attribute under <span>. Abort.\n");
            goto exit;
           }
           if (sscanf(span_att->value, "%u:%u:%u.%u", &var_82, &var_85, &s, &ms) == 4) {
            var_56 = (var_82*3600 + var_85*60+s)*1000+ms;
           } else if (sscanf(p_att->value, "%u:%u:%u:%u", &var_82, &var_85, &s, &f) == 4) {
            var_56 = (var_82*3600 + var_85*60+s)*1000+f*40;
           } else if (sscanf(span_att->value, "%u:%u:%u", &var_82, &var_85, &s) == 3) {
            var_56 = (var_82*3600 + var_85*60+s)*1000;
           }
          }
          if ((var_56 != -1) && (var_56 != -1) && !samp_text && sample_list_node) {
           if (samp_text) {
            var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated sample text under <span>. Abort.\n");
            goto exit;
           }


           var_87 = gf_xml_dom_append_child(sample_list_node, div_node);
           assert(var_87 == var_87);
           assert(!samp_text);
           samp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, var_82);
           var_87 = gf_xml_dom_rem_child(sample_list_node, div_node);
           assert(var_87 == var_87);
          }
         }
        }
       }

       if ((var_56 != -1) && (var_56 != -1) && samp_text) {
        GF_ISOSample *s;
        GF_GenericSubtitleSample *samp;
        u32 var_77;
        char *str;

        if (var_56 < var_56) {
         var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML] invalid timings: \"begin\"="LLD" , \"end\"="LLD". Abort.\n", var_56, var_56);
         goto exit;
        }

        if (var_56 < (s64)last_sample_end) {
         var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML] timing overlapping not supported: \"begin\" is "LLD" , last \"end\" was "LLD". Abort.\n", var_56, last_sample_end);
         goto exit;
        }

        str = ttxt_parse_string(import, samp_text, GF_TRUE);
        var_77 = (u32) strlen(str);
        samp = gf_isom_new_xml_subtitle_sample();

        var_87 = gf_isom_xml_subtitle_sample_add_text(samp, str, var_77);
        if (var_87) {
         GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TTML] ISOM - sample add text: %s", gf_error_to_string(var_87)));
         goto exit;
        }
        gf_free(samp_text);
        samp_text = NULL;

        s = gf_isom_xml_subtitle_to_sample(samp);
        gf_isom_delete_xml_subtitle_sample(samp);
        if (!nb_samples) {
         s->DTS = 0;
         last_sample_duration = var_56;
        } else {
         s->DTS = var_56;
         last_sample_duration = var_56 - var_56;
        }
        last_sample_end = var_56;
        GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, ("ts_begin="LLD", ts_end="LLD", last_sample_duration="LLU" (real duration: "LLU"), last_sample_end="LLU"\n", var_56, var_56, var_56 - last_sample_end, last_sample_duration, last_sample_end));

        var_87 = gf_isom_add_sample(import->dest, var_86, desc_idx, s);
        if (var_87) {
         GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TTML] ISOM - Add Sample: %s", gf_error_to_string(var_87)));
         goto exit;
        }
        gf_isom_sample_del(&s);
        nb_samples++;

        var_56++;
        gf_set_progress("Importing TTML", nb_samples, nb_children);
        if (import->duration && (var_56 > import->duration))
         break;
       } else {
        GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML] incomplete sample (begin="LLD", end="LLD", text=\"%s\"). Skip.\n", var_56, var_56, samp_text ? samp_text : "NULL"));
       }
      }
     }

     if (!var_56) {
      GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] \"%s\" div node has no <p> elements. Aborting.\n", node->name));
      goto exit;
     }
    }
   }
  }
 }
 if (!has_body) {
  var_87 = gf_import_message(import, GF_BAD_PARAM, "[TTML EBU-TTD] missing \"body\" element. Abort.\n");
  goto exit;
 }
 GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, ("last_sample_duration="LLU", last_sample_end="LLU"\n", last_sample_duration, last_sample_end));
 gf_isom_set_last_sample_duration(import->dest, var_86, (u32) last_sample_duration);
 gf_media_update_bitrate(import->dest, var_86);
 gf_set_progress("Importing TTML EBU-TTD", nb_samples, nb_samples);

exit:
 gf_free(samp_text);
 gf_xml_dom_del(parser_working_copy);
 if (!gf_isom_get_sample_count(import->dest, var_86)) {
  GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] No sample imported. Might be an error. Check your content.\n"));
 }
 return var_87;
}

static GF_Err fn_56(GF_MediaImporter *import)
{
 GF_Err var_87;
 GF_DOMParser *parser;
 GF_XMLNode *root;

 if (import->flags == GF_IMPORT_PROBE_ONLY)
  return var_87;

 parser = gf_xml_dom_new();
 var_87 = gf_xml_dom_parse(parser, import->in_name, ttml_import_progress, import);
 if (var_87) {
  gf_import_message(import, var_87, "Error parsing TTML file: Line %d - %s. Abort.", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));
  gf_xml_dom_del(parser);
  return var_87;
 }
 root = gf_xml_dom_get_root(parser);
 if (!root) {
  gf_import_message(import, var_87, "Error parsing TTML file: no \"root\" found. Abort.");
  gf_xml_dom_del(parser);
  return var_87;
 }


 if (gf_xml_get_element_check_namespace(root, "tt", NULL) == var_87) {
  var_87 = gf_text_import_ebu_ttd(import, parser, root);
  if (var_87 == var_87) {
   GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("Note: TTML import - EBU-TTD detected\n"));
  } else {
   GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("Parsing TTML file with error: %s\n", gf_error_to_string(var_87)));
   GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ("Unsupported TTML file - only EBU-TTD is supported (root shall be \"tt\", got \"%s\")\n", root->name));
   GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ("Importing as generic TTML\n"));
   var_87 = var_87;
  }
 } else {
  if (root->ns) {
   GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("TTML file not recognized: root element is \"%s:%s\" (check your namespaces)\n", root->ns, root->name));
  } else {
   GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("TTML file not recognized: root element is \"%s\"\n", root->name));
  }
  var_87 = GF_BAD_PARAM;
 }

 gf_xml_dom_del(parser);
 return var_87;
}


GF_Box *fn_57(u32 var_58, const char *string);






static GF_Err fn_59(void *user, const char *data, u32 var_65, u64 var_63, Bool var_63)
{
 GF_Err var_87 = var_87;
 GF_ISOFlusher *flusher = (GF_ISOFlusher *)user;
 GF_ISOSample *s;
 GF_BitStream *bs;

 bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
 if (!bs) return GF_BAD_PARAM;
 gf_bs_write_data(bs, data, var_65);
 s = gf_isom_sample_new();
 if (s) {
  gf_bs_get_content(bs, &s->data, &s->dataLength);
  s->DTS = (u64) (flusher->timescale*var_63/1000);
  s->IsRAP = var_63 ? RAP : RAP_NO;
  gf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);
  gf_isom_sample_del(&s);
 } else {
  var_87 = GF_BAD_PARAM;
 }
 gf_bs_del(bs);
 return var_87;
}

static GF_Err fn_63(void *user, const char *data, u32 var_65, Bool var_65)
{
 GF_ISOFlusher *flusher = (GF_ISOFlusher *)user;
 if (!flusher) return GF_BAD_PARAM;
 if (var_65) {
  return gf_isom_update_stxt_description(flusher->import->dest, flusher->track, NULL, data, flusher->descriptionIndex);
 } else {
  return gf_isom_append_sample_data(flusher->import->dest, flusher->track, (char *)data, var_65);
 }
}

GF_EXPORT
GF_Err fn_65(GF_MediaImporter *import)
{
 GF_Err var_87 = var_87;
 u32 var_86;
 u32 timescale;

 u32 var_86;
 u32 ID;
 u32 OCR_ES_ID;
 GF_GenericSubtitleConfig *cfg;
 SWFReader *var_66;
 GF_ISOFlusher flusher;
 char *mime;

 if (import->flags & GF_IMPORT_PROBE_ONLY) {
  import->nb_tracks = 1;
  return var_87;
 }

 cfg = NULL;
 if (import->esd) {
  if (!import->esd->slConfig) {
   import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);
   import->esd->slConfig->predefined = 2;
   import->esd->slConfig->timestampResolution = 1000;
  }
  timescale = import->esd->slConfig->timestampResolution;
  if (!timescale) timescale = 1000;


  if (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {
   cfg = (GF_GenericSubtitleConfig *) import->esd->decoderConfig->decoderSpecificInfo;
   import->esd->decoderConfig->decoderSpecificInfo = NULL;
  }
  ID = import->esd->ESID;
  OCR_ES_ID = import->esd->OCRESID;
 } else {
  timescale = 1000;
  OCR_ES_ID = ID = 0;
 }

 if (cfg && cfg->timescale) timescale = cfg->timescale;
 var_86 = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);
 if (!var_86) {
  return gf_import_message(import, gf_isom_last_error(import->dest), "Error creating text track");
 }
 gf_isom_set_track_enabled(import->dest, var_86, 1);
 if (import->esd && !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, var_86);

 if (OCR_ES_ID) gf_isom_set_track_reference(import->dest, var_86, GF_ISOM_REF_OCR, OCR_ES_ID);

 if (!stricmp(import->streamFormat, "SVG")) {
  mime = "image/svg+xml";
 } else {
  mime = "application/octet-stream";
 }

 var_66 = gf_swf_reader_new(NULL, import->in_name);
 gf_swf_read_header(var_66);


 if (cfg) {
  u32 var_86;
  u32 var_80;

  gf_isom_set_track_layout_info(import->dest, var_86, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);


  var_80 = gf_list_count(cfg->sample_descriptions);
  for (var_86=0; var_86<var_80; var_86++) {
   gf_isom_new_stxt_description(import->dest, var_86, GF_ISOM_SUBTYPE_STXT, mime, NULL, NULL, &var_86);
  }
  gf_import_message(import, var_87, "SWF import - text track %d	x %d", cfg->text_width, cfg->text_height);
  gf_odf_desc_del((GF_Descriptor *)cfg);
 } else {
  u32 var_82 = (u32)var_66->width;
  u32 var_82 = (u32)var_66->height;

  if (!var_82 || !var_82)
   gf_text_get_video_size(import, &var_82, &var_82);

  gf_isom_set_track_layout_info(import->dest, var_86, var_82<<16, var_82<<16, 0, 0, 0);

  gf_isom_new_stxt_description(import->dest, var_86, GF_ISOM_SUBTYPE_STXT, mime, NULL, NULL, &var_86);

  gf_import_message(import, var_87, "SWF import (as text - type: %s)", import->streamFormat);
 }
 gf_text_import_set_language(import, var_86);


 flusher.import = import;
 flusher.track = var_86;
 flusher.timescale = timescale;
 flusher.descriptionIndex = var_86;
 gf_swf_reader_set_user_mode(var_66, &flusher, swf_svg_add_iso_sample, swf_svg_add_iso_header);

 if (!import->streamFormat || (import->streamFormat && !stricmp(import->streamFormat, "SVG"))) {

  var_87 = swf_to_svg_init(var_66, import->swf_flags, import->swf_flatten_angle);

 } else {

  var_87 = swf_to_bifs_init(var_66);

 }
 if (var_87) {
  goto exit;
 }

 while (var_87 == var_87) {
  var_87 = swf_parse_tag(var_66);
 }
 if (var_87==GF_EOS) var_87 = var_87;
exit:
 gf_swf_reader_del(var_66);
 gf_media_update_bitrate(import->dest, var_86);
 return var_87;
}

static GF_Err fn_66(GF_MediaImporter *import)
{
 FILE *sub_in;
 u32 var_86, ID, timescale, var_86, j, desc_idx, var_86, end, prev_end, nb_samp, duration, var_77, line;
 u64 file_size;
 GF_TextConfig*cfg;
 GF_Err var_87;
 Double FPS;
 GF_TextSample * samp;
 Bool first_samp;
 s32 var_67;
 char szLine[2048], szTime[20], szText[2048];
 GF_ISOSample *s;

 sub_in = gf_fopen(import->in_name, "rt");
 var_67 = gf_text_get_utf_type(sub_in);
 if (var_67<0) {
  gf_fclose(sub_in);
  return gf_import_message(import, GF_NOT_SUPPORTED, "Unsupported SUB UTF encoding");
 }

 FPS = GF_IMPORT_DEFAULT_FPS;
 if (import->video_fps) FPS = import->video_fps;

 cfg = NULL;
 if (import->esd) {
  if (!import->esd->slConfig) {
   import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);
   import->esd->slConfig->predefined = 2;
   import->esd->slConfig->timestampResolution = 1000;
  }
  timescale = import->esd->slConfig->timestampResolution;
  if (!timescale) timescale = 1000;


  if (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {
   cfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;
   import->esd->decoderConfig->decoderSpecificInfo = NULL;
  }
  ID = import->esd->ESID;
 } else {
  timescale = 1000;
  ID = 0;
 }

 if (cfg && cfg->timescale) timescale = cfg->timescale;
 var_86 = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);
 if (!var_86) {
  gf_fclose(sub_in);
  return gf_import_message(import, gf_isom_last_error(import->dest), "Error creating text track");
 }
 gf_isom_set_track_enabled(import->dest, var_86, 1);
 if (import->esd && !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, var_86);

 gf_text_import_set_language(import, var_86);

 file_size = 0;

 if (cfg) {
  u32 var_80;
  char *firstFont = NULL;

  gf_isom_set_track_layout_info(import->dest, var_86, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);


  var_80 = gf_list_count(cfg->sample_descriptions);
  for (var_86=0; var_86<var_80; var_86++) {
   GF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, var_86);
   if (!sd->font_count) {
    sd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));
    sd->font_count = 1;
    sd->fonts[0].fontID = 1;
    sd->fonts[0].fontName = gf_strdup("Serif");
   }
   if (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;
   if (!sd->default_style.font_size) sd->default_style.font_size = 16;
   if (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;
   file_size = sd->default_style.font_size;
   gf_isom_new_text_description(import->dest, var_86, sd, NULL, NULL, &desc_idx);
   if (!firstFont) firstFont = sd->fonts[0].fontName;
  }
  gf_import_message(import, var_87, "Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)", FPS, cfg->text_width, cfg->text_height, firstFont, file_size);

  gf_odf_desc_del((GF_Descriptor *)cfg);
 } else {
  u32 var_82, var_82;
  GF_TextSampleDescriptor *sd;
  gf_text_get_video_size(import, &var_82, &var_82);



  gf_isom_set_track_layout_info(import->dest, var_86, var_82<<16, var_82<<16, 0, 0, 0);
  sd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);
  sd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));
  sd->font_count = 1;
  sd->fonts[0].fontID = 1;
  sd->fonts[0].fontName = gf_strdup("Serif");
  sd->back_color = 0x00000000;
  sd->default_style.fontID = 1;
  sd->default_style.font_size = 18;
  sd->default_style.text_color = 0xFFFFFFFF;
  sd->default_style.style_flags = 0;
  sd->horiz_justif = 1;
  sd->vert_justif = (s8) -1;

  if (import->flags & GF_IMPORT_SKIP_TXT_BOX) {
   sd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;
  } else {
   if ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {
    sd->default_pos.left = import->text_x;
    sd->default_pos.top = import->text_y;
    sd->default_pos.right = (import->text_width ? import->text_width : var_82) + sd->default_pos.left;
    sd->default_pos.bottom = (import->text_height ? import->text_height : var_82) + sd->default_pos.top;
   }
  }

  gf_isom_new_text_description(import->dest, var_86, sd, NULL, NULL, &desc_idx);
  gf_import_message(import, var_87, "Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)", FPS, var_82, var_82, sd->fonts[0].fontName, 18);
  gf_odf_desc_del((GF_Descriptor *)sd);
 }

 duration = (u32) (((Double) import->duration)*timescale/1000.0);

 var_87 = var_87;
 nb_samp = 0;
 samp = gf_isom_new_text_sample();

 FPS = ((Double) timescale ) / FPS;
 end = prev_end = 0;

 line = 0;
 first_samp = GF_TRUE;
 while 1 {
  char *sOK = gf_text_get_utf8_line(szLine, 2048, sub_in, var_67);
  if (!sOK) break;

  while 1 { u32 var_67 = (u32) strlen(szLine); if (!var_67) break; var_67--; if (strchr("\r\n\t ", szLine[var_67])) szLine[var_67] = 0; else break; }

  line++;
  var_77 = (u32) strlen(szLine);
  if (!var_77) continue;

  var_86=0;
  if (szLine[var_86] != '{') {
   var_87 = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, "Bad SUB file (line %d): expecting \"{\" got \"%c\"", line, szLine[var_86]);
   goto exit;
  }
  while (szLine[var_86+1] && szLine[var_86+1]!='}') {
   szTime[var_86] = szLine[var_86+1];
   var_86++;
  }
  szTime[var_86] = 0;
  var_86 = atoi(szTime);
  if (var_86<end) {
   gf_import_message(import, var_87, "WARNING: corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps", line, var_86, end);
   var_86 = end;
  }
  j=var_86+2;
  var_86=0;
  if (szLine[var_86+j] != '{') {
   var_87 = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, "Bad SUB file - expecting \"{\" got \"%c\"", szLine[var_86]);
   goto exit;
  }
  while (szLine[var_86+1+j] && szLine[var_86+1+j]!='}') {
   szTime[var_86] = szLine[var_86+1+j];
   var_86++;
  }
  szTime[var_86] = 0;
  end = atoi(szTime);
  j+=var_86+2;

  if (var_86>end) {
   gf_import_message(import, var_87, "WARNING: corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping", line, end, var_86);
   continue;
  }

  gf_isom_text_reset(samp);

  if (var_86 && first_samp) {
   s = gf_isom_text_to_sample(samp);
   s->DTS = 0;
   s->IsRAP = RAP;
   gf_isom_add_sample(import->dest, var_86, 1, s);
   gf_isom_sample_del(&s);
   first_samp = var_82;
   nb_samp++;
  }

  for (var_86=j; var_86<var_77; var_86++) {
   if (szLine[var_86]=='|') {
    szText[var_86-j] = '\n';
   } else {
    szText[var_86-j] = szLine[var_86];
   }
  }
  szText[var_86-j] = 0;
  gf_isom_text_add_text(samp, szText, (u32) strlen(szText) );

  if (prev_end) {
   GF_TextSample * empty_samp = gf_isom_new_text_sample();
   s = gf_isom_text_to_sample(empty_samp);
   s->DTS = (u64) (FPS*(s64)prev_end);
   gf_isom_add_sample(import->dest, var_86, 1, s);
   gf_isom_sample_del(&s);
   nb_samp++;
   gf_isom_delete_text_sample(empty_samp);
  }

  s = gf_isom_text_to_sample(samp);
  s->DTS = (u64) (FPS*(s64)var_86);
  gf_isom_add_sample(import->dest, var_86, 1, s);
  gf_isom_sample_del(&s);
  nb_samp++;
  gf_isom_text_reset(samp);
  prev_end = end;
  gf_set_progress("Importing SUB", gf_ftell(sub_in), file_size);
  if (duration && (end >= duration)) break;
 }

 if (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {
  gf_isom_text_reset(samp);
  s = gf_isom_text_to_sample(samp);
  s->DTS = (u64)(FPS*(s64)end);
  gf_isom_add_sample(import->dest, var_86, 1, s);
  gf_isom_sample_del(&s);
  nb_samp++;
 }
 gf_isom_delete_text_sample(samp);

 gf_isom_set_last_sample_duration(import->dest, var_86, 0);
 gf_set_progress("Importing SUB", nb_samp, nb_samp);

exit:
 if (var_87) gf_isom_remove_track(import->dest, var_86);
 gf_fclose(sub_in);
 return var_87;
}

u32 fn_67(GF_MediaImporter *import, char *val)
{
 u32 r, g, b, a, res;
 r = g = b = a = 0;
 if (sscanf(val, "%x %x %x %x", &r, &g, &b, &a) != 4) {
  gf_import_message(import, var_87, "Warning: color badly formatted");
 }
 res = (a&0xFF);
 res<<=8;
 res |= (r&0xFF);
 res<<=8;
 res |= (g&0xFF);
 res<<=8;
 res |= (b&0xFF);
 return res;
}

void fn_68(GF_MediaImporter *import, GF_XMLNode *var_82, GF_BoxRecord *box)
{
 u32 var_86=0;
 GF_XMLAttribute *att;
 memset(box, 0, sizeof(GF_BoxRecord));
 while ( (att=(GF_XMLAttribute *)gf_list_enum(var_82->attributes, &var_86))) {
  if (!stricmp(att->name, "top")) box->top = atoi(att->value);
  else if (!stricmp(att->name, "bottom")) box->bottom = atoi(att->value);
  else if (!stricmp(att->name, "left")) box->left = atoi(att->value);
  else if (!stricmp(att->name, "right")) box->right = atoi(att->value);
 }
}

void fn_70(GF_MediaImporter *import, GF_XMLNode *var_82, GF_StyleRecord *style)
{
 u32 var_86=0;
 GF_XMLAttribute *att;
 memset(style, 0, sizeof(GF_StyleRecord));
 style->fontID = 1;
 style->font_size = 18;
 style->text_color = 0xFFFFFFFF;

 while ( (att=(GF_XMLAttribute *)gf_list_enum(var_82->attributes, &var_86))) {
  if (!stricmp(att->name, "fromChar")) style->startCharOffset = atoi(att->value);
  else if (!stricmp(att->name, "toChar")) style->endCharOffset = atoi(att->value);
  else if (!stricmp(att->name, "fontID")) style->fontID = atoi(att->value);
  else if (!stricmp(att->name, "fontSize")) style->font_size = atoi(att->value);
  else if (!stricmp(att->name, "color")) style->text_color = ttxt_get_color(import, att->value);
  else if (!stricmp(att->name, "styles")) {
   if (strstr(att->value, "Bold")) style->style_flags |= GF_TXT_STYLE_BOLD;
   if (strstr(att->value, "Italic")) style->style_flags |= GF_TXT_STYLE_ITALIC;
   if (strstr(att->value, "Underlined")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;
  }
 }
}

static void fn_71(void *cbk, u64 var_80, u64 var_80)
{
 gf_set_progress("TTXT Loading", var_80, var_80);
}

static GF_Err fn_72(GF_MediaImporter *import)
{
 GF_Err var_87;
 Bool last_sample_empty;
 u32 var_86, j, var_82, var_86, ID, nb_samples, nb_descs, nb_children;
 u64 last_sample_duration;
 GF_XMLAttribute *att;
 GF_DOMParser *parser;
 GF_XMLNode *root, *node, *ext;

 if (import->flags==GF_IMPORT_PROBE_ONLY) return var_87;

 parser = gf_xml_dom_new();
 var_87 = gf_xml_dom_parse(parser, import->in_name, ttxt_import_progress, import);
 if (var_87) {
  gf_import_message(import, var_87, "Error parsing TTXT file: Line %d - %s", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));
  gf_xml_dom_del(parser);
  return var_87;
 }
 root = gf_xml_dom_get_root(parser);

 var_87 = var_87;
 if (strcmp(root->name, "TextStream")) {
  var_87 = gf_import_message(import, GF_BAD_PARAM, "Invalid Timed Text file - expecting \"TextStream\" got %s", "TextStream", root->name);
  goto exit;
 }


 ID = (import->esd) ? import->esd->ESID : 0;
 var_86 = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, 1000);
 if (!var_86) {
  var_87 = gf_isom_last_error(import->dest);
  goto exit;
 }
 gf_isom_set_track_enabled(import->dest, var_86, 1);

 if (import->esd) {
  if (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, var_86);
  if (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);
  if (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);
  import->esd->slConfig->timestampResolution = 1000;
  import->esd->decoderConfig->streamType = GF_STREAM_TEXT;
  import->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;
  if (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, var_86, GF_ISOM_REF_OCR, import->esd->OCRESID);
 }
 gf_text_import_set_language(import, var_86);

 gf_import_message(import, var_87, "Timed Text (GPAC TTXT) Import");

 last_sample_empty = var_82;
 last_sample_duration = 0;
 nb_descs = 0;
 nb_samples = 0;
 nb_children = gf_list_count(root->content);

 var_86=0;
 while ( (node = (GF_XMLNode*)gf_list_enum(root->content, &var_86))) {
  if (node->type) {
   nb_children--;
   continue;
  }

  if (!strcmp(node->name, "TextStreamHeader")) {
   GF_XMLNode *sdesc;
   s32 var_82, var_82, tx, ty, layer;
   u32 tref_id;
   var_82 = 400;
   var_82 = 60;
   tx = ty = layer = 0;
   nb_children--;
   tref_id = 0;

   j=0;
   while ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {
    if (!strcmp(att->name, "width")) var_82 = atoi(att->value);
    else if (!strcmp(att->name, "height")) var_82 = atoi(att->value);
    else if (!strcmp(att->name, "layer")) layer = atoi(att->value);
    else if (!strcmp(att->name, "translation_x")) tx = atoi(att->value);
    else if (!strcmp(att->name, "translation_y")) ty = atoi(att->value);
    else if (!strcmp(att->name, "trefID")) tref_id = atoi(att->value);
   }

   if (tref_id)
    gf_isom_set_track_reference(import->dest, var_86, GF_ISOM_BOX_TYPE_CHAP, tref_id);

   gf_isom_set_track_layout_info(import->dest, var_86, var_82<<16, var_82<<16, tx<<16, ty<<16, (s16) layer);

   j=0;
   while ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {
    if (sdesc->type) continue;

    if (!strcmp(sdesc->name, "TextSampleDescription")) {
     GF_TextSampleDescriptor td;
     u32 var_76;
     memset(&td, 0, sizeof(GF_TextSampleDescriptor));
     td.tag = GF_ODF_TEXT_CFG_TAG;
     td.vert_justif = (s8) -1;
     td.default_style.fontID = 1;
     td.default_style.font_size = 18;

     var_82=0;
     while ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &var_82))) {
      if (!strcmp(att->name, "horizontalJustification")) {
       if (!stricmp(att->value, "center")) td.horiz_justif = 1;
       else if (!stricmp(att->value, "right")) td.horiz_justif = (s8) -1;
       else if (!stricmp(att->value, "left")) td.horiz_justif = 0;
      }
      else if (!strcmp(att->name, "verticalJustification")) {
       if (!stricmp(att->value, "center")) td.vert_justif = 1;
       else if (!stricmp(att->value, "bottom")) td.vert_justif = (s8) -1;
       else if (!stricmp(att->value, "top")) td.vert_justif = 0;
      }
      else if (!strcmp(att->name, "backColor")) td.back_color = ttxt_get_color(import, att->value);
      else if (!strcmp(att->name, "verticalText") && !stricmp(att->value, "yes") ) td.displayFlags |= GF_TXT_VERTICAL;
      else if (!strcmp(att->name, "fillTextRegion") && !stricmp(att->value, "yes") ) td.displayFlags |= GF_TXT_FILL_REGION;
      else if (!strcmp(att->name, "continuousKaraoke") && !stricmp(att->value, "yes") ) td.displayFlags |= GF_TXT_KARAOKE;
      else if (!strcmp(att->name, "scroll")) {
       if (!stricmp(att->value, "inout")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;
       else if (!stricmp(att->value, "in")) td.displayFlags |= GF_TXT_SCROLL_IN;
       else if (!stricmp(att->value, "out")) td.displayFlags |= GF_TXT_SCROLL_OUT;
      }
      else if (!strcmp(att->name, "scrollMode")) {
       u32 var_82 = var_82;
       if (!stricmp(att->value, "Credits")) var_82 = var_82;
       else if (!stricmp(att->value, "Marquee")) var_82 = GF_TXT_SCROLL_MARQUEE;
       else if (!stricmp(att->value, "Right")) var_82 = GF_TXT_SCROLL_RIGHT;
       else if (!stricmp(att->value, "Down")) var_82 = GF_TXT_SCROLL_DOWN;
       td.displayFlags |= ((var_82<<7) & GF_TXT_SCROLL_DIRECTION);
      }
     }

     var_82=0;
     while ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &var_82))) {
      if (ext->type) continue;
      if (!strcmp(ext->name, "TextBox")) ttxt_parse_text_box(import, ext, &td.default_pos);
      else if (!strcmp(ext->name, "Style")) ttxt_parse_text_style(import, ext, &td.default_style);
      else if (!strcmp(ext->name, "FontTable")) {
       GF_XMLNode *ftable;
       u32 var_82=0;
       while ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &var_82))) {
        u32 var_85;
        if (ftable->type || strcmp(ftable->name, "FontTableEntry")) continue;
        td.font_count += 1;
        td.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);
        var_85=0;
        while ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &var_85))) {
         if (!stricmp(att->name, "fontID")) td.fonts[td.font_count-1].fontID = atoi(att->value);
         else if (!stricmp(att->name, "fontName")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);
        }
       }
      }
     }
     if (import->flags & GF_IMPORT_SKIP_TXT_BOX) {
      td.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;
     } else {
      if ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {
       td.default_pos.top = td.default_pos.left = 0;
       td.default_pos.right = var_82;
       td.default_pos.bottom = var_82;
      }
     }
     if (!td.fonts) {
      td.font_count = 1;
      td.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));
      td.fonts[0].fontID = 1;
      td.fonts[0].fontName = gf_strdup("Serif");
     }
     gf_isom_new_text_description(import->dest, var_86, &td, NULL, NULL, &var_76);
     for (var_82=0; var_82<td.font_count; var_82++) gf_free(td.fonts[var_82].fontName);
     gf_free(td.fonts);
     nb_descs ++;
    }
   }
  }

  else if (!strcmp(node->name, "TextSample")) {
   GF_ISOSample *s;
   GF_TextSample * samp;
   u32 ts, var_86;
   Bool var_77 = var_82;
   if (!nb_descs) {
    var_87 = gf_import_message(import, GF_BAD_PARAM, "Invalid Timed Text file - text stream header not found or empty");
    goto exit;
   }
   samp = gf_isom_new_text_sample();
   ts = 0;
   var_86 = 1;
   last_sample_empty = GF_TRUE;

   j=0;
   while ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {
    if (!strcmp(att->name, "sampleTime")) {
     u32 var_82, var_85, s, ms;
     if (sscanf(att->value, "%u:%u:%u.%u", &var_82, &var_85, &s, &ms) == 4) {
      ts = (var_82*3600 + var_85*60 + s)*1000 + ms;
     } else {
      ts = (u32) (atof(att->value) * 1000);
     }
    }
    else if (!strcmp(att->name, "sampleDescriptionIndex")) var_86 = atoi(att->value);
    else if (!strcmp(att->name, "text")) {
     u32 var_77;
     char *str = ttxt_parse_string(import, att->value, GF_TRUE);
     var_77 = (u32) strlen(str);
     gf_isom_text_add_text(samp, str, var_77);
     last_sample_empty = var_77 ? var_82 : GF_TRUE;
     var_77 = GF_TRUE;
    }
    else if (!strcmp(att->name, "scrollDelay")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));
    else if (!strcmp(att->name, "highlightColor")) gf_isom_text_set_highlight_color_argb(samp, ttxt_get_color(import, att->value));
    else if (!strcmp(att->name, "wrap") && !strcmp(att->value, "Automatic")) gf_isom_text_set_wrap(samp, 0x01);
   }


   j=0;
   while ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {
    if (!var_77 && (ext->type==GF_XML_TEXT_TYPE)) {
     u32 var_77;
     char *str = ttxt_parse_string(import, ext->name, var_82);
     var_77 = (u32) strlen(str);
     gf_isom_text_add_text(samp, str, var_77);
     last_sample_empty = var_77 ? var_82 : GF_TRUE;
     var_77 = GF_TRUE;
    }
    if (ext->type) continue;

    if (!stricmp(ext->name, "Style")) {
     GF_StyleRecord r;
     ttxt_parse_text_style(import, ext, &r);
     gf_isom_text_add_style(samp, &r);
    }
    else if (!stricmp(ext->name, "TextBox")) {
     GF_BoxRecord r;
     ttxt_parse_text_box(import, ext, &r);
     gf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);
    }
    else if (!stricmp(ext->name, "Highlight")) {
     u16 var_86, end;
     var_86 = end = 0;
     var_82=0;
     while ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &var_82))) {
      if (!strcmp(att->name, "fromChar")) var_86 = atoi(att->value);
      else if (!strcmp(att->name, "toChar")) end = atoi(att->value);
     }
     gf_isom_text_add_highlight(samp, var_86, end);
    }
    else if (!stricmp(ext->name, "Blinking")) {
     u16 var_86, end;
     var_86 = end = 0;
     var_82=0;
     while ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &var_82))) {
      if (!strcmp(att->name, "fromChar")) var_86 = atoi(att->value);
      else if (!strcmp(att->name, "toChar")) end = atoi(att->value);
     }
     gf_isom_text_add_blink(samp, var_86, end);
    }
    else if (!stricmp(ext->name, "HyperLink")) {
     u16 var_86, end;
     char *url, *url_tt;
     var_86 = end = 0;
     url = url_tt = NULL;
     var_82=0;
     while ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &var_82))) {
      if (!strcmp(att->name, "fromChar")) var_86 = atoi(att->value);
      else if (!strcmp(att->name, "toChar")) end = atoi(att->value);
      else if (!strcmp(att->name, "URL")) url = gf_strdup(att->value);
      else if (!strcmp(att->name, "URLToolTip")) url_tt = gf_strdup(att->value);
     }
     gf_isom_text_add_hyperlink(samp, url, url_tt, var_86, end);
     if (url) gf_free(url);
     if (url_tt) gf_free(url_tt);
    }
    else if (!stricmp(ext->name, "Karaoke")) {
     u32 startTime;
     GF_XMLNode *krok;
     startTime = 0;
     var_82=0;
     while ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &var_82))) {
      if (!strcmp(att->name, "startTime")) startTime = (u32) (1000*atof(att->value));
     }
     gf_isom_text_add_karaoke(samp, startTime);
     var_82=0;
     while ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &var_82))) {
      u16 var_86, end;
      u32 endTime, var_85;
      if (krok->type) continue;
      if (strcmp(krok->name, "KaraokeRange")) continue;
      var_86 = end = 0;
      endTime = 0;
      var_85=0;
      while ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &var_85))) {
       if (!strcmp(att->name, "fromChar")) var_86 = atoi(att->value);
       else if (!strcmp(att->name, "toChar")) end = atoi(att->value);
       else if (!strcmp(att->name, "endTime")) endTime = (u32) (1000*atof(att->value));
      }
      gf_isom_text_set_karaoke_segment(samp, endTime, var_86, end);
     }
    }
   }


   if (ts && !nb_samples) {
    GF_TextSample * firstsamp = gf_isom_new_text_sample();
    s = gf_isom_text_to_sample(firstsamp);
    s->DTS = 0;
    gf_isom_add_sample(import->dest, var_86, 1, s);
    nb_samples++;
    gf_isom_delete_text_sample(firstsamp);
    gf_isom_sample_del(&s);
   }

   s = gf_isom_text_to_sample(samp);
   gf_isom_delete_text_sample(samp);
   s->DTS = ts;
   if (last_sample_empty) {
    last_sample_duration = s->DTS - last_sample_duration;
   } else {
    last_sample_duration = s->DTS;
   }

   var_87 = gf_isom_add_sample(import->dest, var_86, var_86, s);
   if (var_87) goto exit;
   gf_isom_sample_del(&s);
   nb_samples++;

   gf_set_progress("Importing TTXT", nb_samples, nb_children);
   if (import->duration && (ts>import->duration)) break;
  }
 }
 if (last_sample_empty) {
  gf_isom_remove_sample(import->dest, var_86, nb_samples);
  gf_isom_set_last_sample_duration(import->dest, var_86, (u32) last_sample_duration);
 }
 gf_set_progress("Importing TTXT", nb_samples, nb_samples);

exit:
 gf_xml_dom_del(parser);
 return var_87;
}


u32 fn_77(GF_MediaImporter *import, char *value)
{
 u32 r, g, b, a;
 u32 res, v;
 r = g = b = a = 0;
 if (sscanf(value, "%u%%, %u%%, %u%%, %u%%", &r, &g, &b, &a) != 4) {
  gf_import_message(import, var_87, "Warning: color badly formatted");
 }
 v = (u32) (a*255/100);
 res = (v&0xFF);
 res<<=8;
 v = (u32) (r*255/100);
 res |= (v&0xFF);
 res<<=8;
 v = (u32) (g*255/100);
 res |= (v&0xFF);
 res<<=8;
 v = (u32) (b*255/100);
 res |= (v&0xFF);
 return res;
}

void fn_78(GF_MediaImporter *import, GF_XMLNode *var_82, GF_BoxRecord *box)
{
 u32 var_86=0;
 GF_XMLAttribute *att;
 memset(box, 0, sizeof(GF_BoxRecord));
 while ((att=(GF_XMLAttribute *)gf_list_enum(var_82->attributes, &var_86))) {
  if (!stricmp(att->name, "x")) box->left = atoi(att->value);
  else if (!stricmp(att->name, "y")) box->top = atoi(att->value);
  else if (!stricmp(att->name, "height")) box->bottom = atoi(att->value);
  else if (!stricmp(att->name, "width")) box->right = atoi(att->value);
 }
}

typedef struct
{
 u32 id;
 u32 pos;
} Marker;

static void fn_79(void *cbk, u64 var_80, u64 var_80)
{
 gf_set_progress("TeXML Loading", var_80, var_80);
}

static GF_Err fn_80(GF_MediaImporter *import)
{
 GF_Err var_87;
 u32 var_86, ID, nb_samples, nb_children, nb_descs, timescale, var_82, var_82, var_86, j, var_82;
 u64 DTS;
 s32 tx, ty, layer;
 GF_StyleRecord styles[50];
 Marker marks[50];
 GF_XMLAttribute *att;
 GF_DOMParser *parser;
 GF_XMLNode *root, *node;

 if (import->flags==GF_IMPORT_PROBE_ONLY) return var_87;

 parser = gf_xml_dom_new();
 var_87 = gf_xml_dom_parse(parser, import->in_name, texml_import_progress, import);
 if (var_87) {
  gf_import_message(import, var_87, "Error parsing TeXML file: Line %d - %s", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));
  gf_xml_dom_del(parser);
  return var_87;
 }
 root = gf_xml_dom_get_root(parser);

 if (strcmp(root->name, "text3GTrack")) {
  var_87 = gf_import_message(import, GF_BAD_PARAM, "Invalid QT TeXML file - expecting root \"text3GTrack\" got \"%s\"", root->name);
  goto exit;
 }
 var_82 = 400;
 var_82 = 60;
 tx = ty = 0;
 layer = 0;
 timescale = 1000;
 var_86=0;
 while ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &var_86))) {
  if (!strcmp(att->name, "trackWidth")) var_82 = atoi(att->value);
  else if (!strcmp(att->name, "trackHeight")) var_82 = atoi(att->value);
  else if (!strcmp(att->name, "layer")) layer = atoi(att->value);
  else if (!strcmp(att->name, "timescale")) timescale = atoi(att->value);
  else if (!strcmp(att->name, "transform")) {
   Float fx, fy;
   sscanf(att->value, "translate(%f,%f)", &fx, &fy);
   tx = (u32) fx;
   ty = (u32) fy;
  }
 }


 ID = (import->esd) ? import->esd->ESID : 0;
 var_86 = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);
 if (!var_86) {
  var_87 = gf_isom_last_error(import->dest);
  goto exit;
 }
 gf_isom_set_track_enabled(import->dest, var_86, 1);

 if (import->esd) {
  if (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, var_86);
  if (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);
  if (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);
  import->esd->slConfig->timestampResolution = timescale;
  import->esd->decoderConfig->streamType = GF_STREAM_TEXT;
  import->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;
  if (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, var_86, GF_ISOM_REF_OCR, import->esd->OCRESID);
 }
 DTS = 0;
 gf_isom_set_track_layout_info(import->dest, var_86, var_82<<16, var_82<<16, tx<<16, ty<<16, (s16) layer);

 gf_text_import_set_language(import, var_86);
 var_87 = var_87;

 gf_import_message(import, var_87, "Timed Text (QT TeXML) Import - Track Size %d x %d", var_82, var_82);

 nb_children = gf_list_count(root->content);
 nb_descs = 0;
 nb_samples = 0;
 var_86=0;
 while ( (node=(GF_XMLNode*)gf_list_enum(root->content, &var_86))) {
  GF_XMLNode *desc;
  GF_TextSampleDescriptor td;
  GF_TextSample * samp = NULL;
  GF_ISOSample *s;
  u32 duration, var_86, nb_styles, nb_marks;
  Bool isRAP, same_style, same_box;

  if (node->type) continue;
  if (strcmp(node->name, "sample")) continue;

  isRAP = var_82;
  duration = 1000;
  j=0;
  while ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {
   if (!strcmp(att->name, "duration")) duration = atoi(att->value);
   else if (!strcmp(att->name, "keyframe")) isRAP = (!stricmp(att->value, "true") ? GF_TRUE : var_82);
  }
  nb_styles = 0;
  nb_marks = 0;
  same_style = same_box = var_82;
  var_86 = 1;
  j=0;
  while ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {
   if (desc->type) continue;

   if (!strcmp(desc->name, "description")) {
    GF_XMLNode *sub;
    memset(&td, 0, sizeof(GF_TextSampleDescriptor));
    td.tag = GF_ODF_TEXT_CFG_TAG;
    td.vert_justif = (s8) -1;
    td.default_style.fontID = 1;
    td.default_style.font_size = 18;

    var_82=0;
    while ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &var_82))) {
     if (!strcmp(att->name, "horizontalJustification")) {
      if (!stricmp(att->value, "center")) td.horiz_justif = 1;
      else if (!stricmp(att->value, "right")) td.horiz_justif = (s8) -1;
      else if (!stricmp(att->value, "left")) td.horiz_justif = 0;
     }
     else if (!strcmp(att->name, "verticalJustification")) {
      if (!stricmp(att->value, "center")) td.vert_justif = 1;
      else if (!stricmp(att->value, "bottom")) td.vert_justif = (s8) -1;
      else if (!stricmp(att->value, "top")) td.vert_justif = 0;
     }
     else if (!strcmp(att->name, "backgroundColor")) td.back_color = tx3g_get_color(import, att->value);
     else if (!strcmp(att->name, "displayFlags")) {
      Bool var_82 = var_82;
      if (strstr(att->value, "scroll")) {
       u32 var_82 = 0;
       if (strstr(att->value, "scrollIn")) td.displayFlags |= GF_TXT_SCROLL_IN;
       if (strstr(att->value, "scrollOut")) td.displayFlags |= GF_TXT_SCROLL_OUT;
       if (strstr(att->value, "reverse")) var_82 = GF_TRUE;
       if (strstr(att->value, "horizontal")) var_82 = var_82 ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;
       else var_82 = (var_82 ? GF_TXT_SCROLL_DOWN : var_82);
       td.displayFlags |= (var_82<<7) & GF_TXT_SCROLL_DIRECTION;
      }

      if (strstr(att->value, "writeTextVertically")) td.displayFlags |= GF_TXT_VERTICAL;
      if (!strcmp(att->name, "continuousKaraoke")) td.displayFlags |= GF_TXT_KARAOKE;
     }
    }

    var_82=0;
    while ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &var_82))) {
     if (sub->type) continue;
     if (!strcmp(sub->name, "defaultTextBox")) tx3g_parse_text_box(import, sub, &td.default_pos);
     else if (!strcmp(sub->name, "fontTable")) {
      GF_XMLNode *ftable;
      u32 var_85=0;
      while ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &var_85))) {
       if (ftable->type) continue;
       if (!strcmp(ftable->name, "font")) {
        u32 var_82=0;
        td.font_count += 1;
        td.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);
        while ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &var_82))) {
         if (!stricmp(att->name, "id")) td.fonts[td.font_count-1].fontID = atoi(att->value);
         else if (!stricmp(att->name, "name")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);
        }
       }
      }
     }
     else if (!strcmp(sub->name, "sharedStyles")) {
      GF_XMLNode *style, *ftable;
      u32 var_85=0;
      while ((style=(GF_XMLNode*)gf_list_enum(sub->content, &var_85))) {
       if (style->type) continue;
       if (!strcmp(style->name, "style")) break;
      }
      if (style) {
       char *cur;
       s32 var_86=0;
       char css_style[1024], css_val[1024];
       memset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));
       var_85=0;
       while ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &var_85))) {
        if (!strcmp(att->name, "id")) styles[nb_styles].startCharOffset = atoi(att->value);
       }
       var_85=0;
       while ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &var_85))) {
        if (ftable->type) break;
       }
       cur = ftable->name;
       while (cur) {
        var_86 = gf_token_get_strip(cur, 0, "{:", " ", css_style, 1024);
        if (var_86 <0) break;
        var_86 = gf_token_get_strip(cur, var_86, ":}", " ", css_val, 1024);
        if (var_86 <0) break;
        cur = strchr(cur+var_86, '{');

        if (!strcmp(css_style, "font-table")) {
         u32 var_82;
         styles[nb_styles].fontID = atoi(css_val);
         for (var_82=0; var_82<td.font_count; var_82++) {
          if (td.fonts[var_82].fontID == styles[nb_styles].fontID)
           break;
         }
        }
        else if (!strcmp(css_style, "font-size")) styles[nb_styles].font_size = atoi(css_val);
        else if (!strcmp(css_style, "font-style") && !strcmp(css_val, "italic")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;
        else if (!strcmp(css_style, "font-weight") && !strcmp(css_val, "bold")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;
        else if (!strcmp(css_style, "text-decoration") && !strcmp(css_val, "underline")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;
        else if (!strcmp(css_style, "color")) styles[nb_styles].text_color = tx3g_get_color(import, css_val);
       }
       if (!nb_styles) td.default_style = styles[0];
       nb_styles++;
      }
     }

    }
    if ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {
     td.default_pos.top = td.default_pos.left = 0;
     td.default_pos.right = var_82;
     td.default_pos.bottom = var_82;
    }
    if (!td.fonts) {
     td.font_count = 1;
     td.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));
     td.fonts[0].fontID = 1;
     td.fonts[0].fontName = gf_strdup("Serif");
    }
    gf_isom_text_has_similar_description(import->dest, var_86, &td, &var_86, &same_box, &same_style);
    if (!var_86) {
     gf_isom_new_text_description(import->dest, var_86, &td, NULL, NULL, &var_86);
     same_style = same_box = GF_TRUE;
    }

    for (var_82=0; var_82<td.font_count; var_82++) gf_free(td.fonts[var_82].fontName);
    gf_free(td.fonts);
    nb_descs ++;
   }
   else if (!strcmp(desc->name, "sampleData")) {
    GF_XMLNode *sub;
    u16 var_86, end;
    u32 styleID;
    u32 nb_chars, txt_len, var_85;
    nb_chars = 0;

    samp = gf_isom_new_text_sample();

    var_82=0;
    while ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &var_82))) {
     if (!strcmp(att->name, "targetEncoding") && !strcmp(att->value, "utf16")) ;
     else if (!strcmp(att->name, "scrollDelay")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );
     else if (!strcmp(att->name, "highlightColor")) gf_isom_text_set_highlight_color_argb(samp, tx3g_get_color(import, att->value));
    }
    var_86 = end = 0;
    var_82=0;
    while ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &var_82))) {
     if (sub->type) continue;
     if (!strcmp(sub->name, "text")) {
      GF_XMLNode *text;
      styleID = 0;
      var_85=0;
      while ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &var_85))) {
       if (!strcmp(att->name, "styleID")) styleID = atoi(att->value);
      }
      txt_len = 0;

      var_85=0;
      while ((text=(GF_XMLNode*)gf_list_enum(sub->content, &var_85))) {
       if (!text->type) {
        if (!strcmp(text->name, "marker")) {
         u32 var_82;
         memset(&marks[nb_marks], 0, sizeof(Marker));
         marks[nb_marks].pos = nb_chars+txt_len;

         var_82 = 0;
         while ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &var_82))) {
          if (!strcmp(att->name, "id")) marks[nb_marks].id = atoi(att->value);
         }
         nb_marks++;
        }
       } else if (text->type==GF_XML_TEXT_TYPE) {
        txt_len += (u32) strlen(text->name);
        gf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));
       }
      }
      if (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {
       GF_StyleRecord var_83 = td.default_style;
       for (var_85=0; var_85<nb_styles; var_85++) {
        if (styles[var_85].startCharOffset==styleID) {
         var_83 = styles[var_85];
         break;
        }
       }
       var_83.startCharOffset = nb_chars;
       var_83.endCharOffset = nb_chars + txt_len;
       gf_isom_text_add_style(samp, &var_83);
      }
      nb_chars += txt_len;
     }
     else if (!stricmp(sub->name, "highlight")) {
      var_85=0;
      while ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &var_85))) {
       if (!strcmp(att->name, "startMarker")) { u32 var_86, var_86 = atoi(att->value); var_86 = 0; for (var_86=0; var_86<nb_marks; var_86++) { if (var_86==marks[var_86].id) { var_86 = marks[var_86].pos; break; } } }
        else if (!strcmp(att->name, "endMarker")) { u32 var_86, var_86 = atoi(att->value); end = 0; for (var_86=0; var_86<nb_marks; var_86++) { if (var_86==marks[var_86].id) { end = marks[var_86].pos; break; } } }
        }
      gf_isom_text_add_highlight(samp, var_86, end);
     }
     else if (!stricmp(sub->name, "blink")) {
      var_85=0;
      while ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &var_85))) {
       if (!strcmp(att->name, "startMarker")) { u32 var_86, var_86 = atoi(att->value); var_86 = 0; for (var_86=0; var_86<nb_marks; var_86++) { if (var_86==marks[var_86].id) { var_86 = marks[var_86].pos; break; } } }
        else if (!strcmp(att->name, "endMarker")) { u32 var_86, var_86 = atoi(att->value); end = 0; for (var_86=0; var_86<nb_marks; var_86++) { if (var_86==marks[var_86].id) { end = marks[var_86].pos; break; } } }
        }
      gf_isom_text_add_blink(samp, var_86, end);
     }
     else if (!stricmp(sub->name, "link")) {
      char *url, *url_tt;
      url = url_tt = NULL;
      var_85=0;
      while ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &var_85))) {
       if (!strcmp(att->name, "startMarker")) { u32 var_86, var_86 = atoi(att->value); var_86 = 0; for (var_86=0; var_86<nb_marks; var_86++) { if (var_86==marks[var_86].id) { var_86 = marks[var_86].pos; break; } } }
        else if (!strcmp(att->name, "endMarker")) { u32 var_86, var_86 = atoi(att->value); end = 0; for (var_86=0; var_86<nb_marks; var_86++) { if (var_86==marks[var_86].id) { end = marks[var_86].pos; break; } } }
         else if (!strcmp(att->name, "URL") || !strcmp(att->name, "href")) url = gf_strdup(att->value);
         else if (!strcmp(att->name, "URLToolTip") || !strcmp(att->name, "altString")) url_tt = gf_strdup(att->value);
      }
      gf_isom_text_add_hyperlink(samp, url, url_tt, var_86, end);
      if (url) gf_free(url);
      if (url_tt) gf_free(url_tt);
     }
     else if (!stricmp(sub->name, "karaoke")) {
      u32 var_86 = 0;
      GF_XMLNode *krok;
      var_85=0;
      while ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &var_85))) {
       if (!strcmp(att->name, "startTime")) var_86 = atoi(att->value);
      }
      gf_isom_text_add_karaoke(samp, var_86);
      var_85=0;
      while ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &var_85))) {
       u32 var_86=0;
       if (krok->type) continue;
       if (strcmp(krok->name, "run")) continue;
       var_86 = end = 0;
       while ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &var_86))) {
        if (!strcmp(att->name, "startMarker")) { u32 var_86, var_86 = atoi(att->value); var_86 = 0; for (var_86=0; var_86<nb_marks; var_86++) { if (var_86==marks[var_86].id) { var_86 = marks[var_86].pos; break; } } }
         else if (!strcmp(att->name, "endMarker")) { u32 var_86, var_86 = atoi(att->value); end = 0; for (var_86=0; var_86<nb_marks; var_86++) { if (var_86==marks[var_86].id) { end = marks[var_86].pos; break; } } }
          else if (!strcmp(att->name, "duration")) var_86 += atoi(att->value);
       }
       gf_isom_text_set_karaoke_segment(samp, var_86, var_86, end);
      }
     }
    }
   }
  }

  if (samp) {
   if (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);


   s = gf_isom_text_to_sample(samp);
   gf_isom_delete_text_sample(samp);
   s->IsRAP = isRAP ? RAP : RAP_NO;
   s->DTS = DTS;
   gf_isom_add_sample(import->dest, var_86, var_86, s);
   gf_isom_sample_del(&s);
   nb_samples++;
   DTS += duration;
   gf_set_progress("Importing TeXML", nb_samples, nb_children);
   if (import->duration && (DTS*1000> timescale*import->duration)) break;
  }
 }
 gf_isom_set_last_sample_duration(import->dest, var_86, 0);
 gf_set_progress("Importing TeXML", nb_samples, nb_samples);

exit:
 gf_xml_dom_del(parser);
 return var_87;
}


GF_Err fn_86(GF_MediaImporter *import)
{
 GF_Err var_87;
 u32 fmt;
 var_87 = gf_text_guess_format(import->in_name, &fmt);
 if (var_87) return var_87;
 if (import->streamFormat) {
  if (!strcmp(import->streamFormat, "VTT")) fmt = GF_TEXT_IMPORT_WEBVTT;
  else if (!strcmp(import->streamFormat, "TTML")) fmt = GF_TEXT_IMPORT_TTML;
  if ((strstr(import->in_name, ".swf") || strstr(import->in_name, ".SWF")) && !stricmp(import->streamFormat, "SVG")) fmt = GF_TEXT_IMPORT_SWF_SVG;
 }
 if (!fmt) {
  GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTXT Import] Input %s does not look like a supported text format - ignoring\n", import->in_name));
  return GF_NOT_SUPPORTED;
 }
 if (import->flags & GF_IMPORT_PROBE_ONLY) {
  if (fmt==GF_TEXT_IMPORT_SUB) import->flags |= GF_IMPORT_OVERRIDE_FPS;
  return var_87;
 }
 switch (fmt) {
 case GF_TEXT_IMPORT_SRT:
  return gf_text_import_srt(import);
 case GF_TEXT_IMPORT_SUB:
  return gf_text_import_sub(import);
 case GF_TEXT_IMPORT_TTXT:
  return gf_text_import_ttxt(import);
 case GF_TEXT_IMPORT_TEXML:
  return gf_text_import_texml(import);

 case GF_TEXT_IMPORT_WEBVTT:
  return gf_text_import_webvtt(import);

 case GF_TEXT_IMPORT_SWF_SVG:
  return gf_text_import_swf(import);
 case GF_TEXT_IMPORT_TTML:
  return gf_text_import_ttml(import);
 default:
  return GF_BAD_PARAM;
 }
}
