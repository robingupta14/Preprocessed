







struct struct_1;
typedef struct struct_1 {
    regnode *last_regnode;
    regnode *next_regnode;
    U32 prev_recursed_depth;
    I32 stopparen;

    struct struct_1 *this_prev_frame;
    struct struct_1 *prev_frame;
    struct struct_1 *next_frame;
} scan_frame;






struct struct_1 {
    U32 flags;
    U32 pm_flags;
    char *precomp;
    char *precomp_end;
    REGEXP *rx_sv;
    regexp *rx;
    regexp_internal *rxi;

    char *start;
    char *end;
    char *parse;
    char *copy_start;

    char *save_copy_start;

    char *copy_start_in_input;

    SSize_t whilem_seen;
    regnode *emit_start;
    regnode_offset emit;
    I32 naughty;
    I32 sawback;
    U32 seen;
    SSize_t size;







    Size_t latest_warn_offset;

    I32 npar;


    I32 total_par;





    I32 nestroot;

    I32 seen_zerolen;
    regnode_offset *open_parens;
    regnode_offset *close_parens;
    I32 parens_buf_size;
    regnode *end_op;
    I32 utf8;
    I32 orig_utf8;


    I32 uni_semantics;


    HV *paren_names;

    regnode **recurse;
    I32 recurse_count;
    U8 *study_chunk_recursed;

    U32 study_chunk_recursed_bytes;
    I32 in_lookbehind;
    I32 contains_locale;
    I32 override_recoding;



    I32 in_multi_char_class;
    struct struct_195 *code_blocks;

    int code_index;
    SSize_t maxlen;
    scan_frame *frame_head;
    scan_frame *frame_last;
    U32 frame_count;
    AV *warn_text;
    HV *unlexed_names;




    SV *runtime_code_qr;

    bool seen_d_op;
    bool strict;
    bool study_started;
    bool in_script_run;
    bool use_BRANCHJ;
};

struct struct_219 {
    SV *str;
    SSize_t min_offset;
    SSize_t max_offset;
    SSize_t *minlenp;
    SSize_t lookbehind;
    I32 flags;
};

typedef struct struct_4 {


    SSize_t pos_min;
    SSize_t pos_delta;
    SV *last_found;
    SSize_t last_end;
    SSize_t last_start_min;
    SSize_t last_start_max;
    U8 cur_is_floating;




    struct struct_219 substrs[2];

    I32 flags;
    I32 whilem_c;
    SSize_t *last_closep;
    regnode_ssc *start_class;
} scan_data_t;





static const scan_data_t var_243 = {
    0, 0, NULL, 0, 0, 0, 0,
    {
        { NULL, 0, 0, 0, 0, 0 },
        { NULL, 0, 0, 0, 0, 0 },
    },
    0, 0, NULL, NULL
};

struct struct_7{
  UV key;
  UV value;
  struct struct_7* next;
};
typedef struct struct_7 item;


PERL_STATIC_INLINE item*
fn_7(UV var_533, item* curr)
{
    item* var_23;
    Newx(var_23, 1, item);
    var_23->key = var_533;
    var_23->value = 0;
    var_23->next = curr;
    return var_23;
}


PERL_STATIC_INLINE item*
fn_10(item* var_23, UV var_533)
{
    item* var_15 = var_23;
    while (var_15){
        if (var_15->key == var_533){
            return var_15;
        }
        var_15 = var_15->next;
    }

    return NULL;
}

PERL_STATIC_INLINE item*
fn_12(item* var_23, UV var_533)
{
    item* var_15 = var_23;

    while (var_15){
        if (var_15->key == var_533) {
            return var_23;
        }
        var_15 = var_15->next;
    }

    return push(var_533, var_23);
}

PERL_STATIC_INLINE void
fn_13(item* var_23)
{
    item* var_15 = var_23;

    while (var_15) {
        item* var_537 = var_15;
        var_15 = var_15->next;
        Safefree(var_537);
    }

    var_23 = NULL;
}




static int
fn_15(const UV* src,
                const UV* tgt,
                const STRLEN var_23,
                const STRLEN var_23,
                const SSize_t var_23
)
{
    item *var_23 = NULL;
    UV swapCount, swapScore, targetCharCount, var_531, var_533;
    UV *scores;
    UV var_22 = var_23 + var_23;

    PERL_ARGS_ASSERT_EDIT_DISTANCE;


    Newx(scores, ( (var_23 + 2) * (var_23 + 2)), UV);
    scores[0] = var_22;
    scores[1 * (var_23 + 2) + 0] = var_22;
    scores[0 * (var_23 + 2) + 1] = var_22;
    scores[1 * (var_23 + 2) + 1] = 0;
    var_23 = uniquePush(uniquePush(var_23, src[0]), tgt[0]);




    for (var_531=1;var_531<=var_23;var_531++) {
        if (var_531 < var_23)
            var_23 = uniquePush(var_23, src[var_531]);
        scores[(var_531+1) * (var_23 + 2) + 1] = var_531;
        scores[(var_531+1) * (var_23 + 2) + 0] = var_22;
        swapCount = 0;

        for (var_533=1;var_533<=var_23;var_533++) {
            if (var_531 == 1) {
                if(var_533 < var_23)
                var_23 = uniquePush(var_23, tgt[var_533]);
                scores[1 * (var_23 + 2) + (var_533 + 1)] = var_533;
                scores[0 * (var_23 + 2) + (var_533 + 1)] = var_22;
            }

            targetCharCount = find(var_23, tgt[var_533-1])->value;
            swapScore = scores[targetCharCount * (var_23 + 2) + swapCount] + var_531 - targetCharCount - 1 + var_533 - swapCount;

            if (src[var_531-1] != tgt[var_533-1]){
                scores[(var_531+1) * (var_23 + 2) + (var_533 + 1)] = MIN(swapScore,(MIN(scores[var_531 * (var_23 + 2) + var_533], MIN(scores[(var_531+1) * (var_23 + 2) + var_533], scores[var_531 * (var_23 + 2) + (var_533 + 1)])) + 1));
            }
            else {
                swapCount = var_533;
                scores[(var_531+1) * (var_23 + 2) + (var_533 + 1)] = MIN(scores[var_531 * (var_23 + 2) + var_533], swapScore);
            }
        }

        find(var_23, src[var_531-1])->value = var_531;
    }

    {
        IV var_23 = scores[(var_23+1) * (var_23 + 2) + (var_23 + 1)];
        dict_free(var_23);
        Safefree(scores);
        return (var_23 != 0 && var_23 < var_23)?-1:var_23;
    }
}







static const char *
fn_23(const U8 var_453)
{




    switch (var_453) {
        case '\a': return "\\a";
        case '\b': return "\\b";
        case ESC_NATIVE: return "\\e";
        case '\f': return "\\f";
        case '\n': return "\\n";
        case '\r': return "\\r";
        case '\t': return "\\t";
    }

    return NULL;
}





static void
fn_25(pTHX_ const RExC_state_t *var_491, scan_data_t *data,
                    SSize_t *minlenp, int var_182)
{
    const STRLEN var_178 = (cBOOL((var_491->utf8)) ? sv_len_utf8(data->last_found) : SvCUR(data->last_found));
    SV * const longest_sv = data->substrs[data->cur_is_floating].str;
    const STRLEN var_30 = (cBOOL((var_491->utf8)) ? sv_len_utf8(longest_sv) : SvCUR(longest_sv));
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_SCAN_COMMIT;

    if ((var_178 >= var_30) && ((var_178 > var_30) || (data->flags & (0x0001|0x0002)))) {
        const U8 var_531 = data->cur_is_floating;
 SvSetMagicSV(longest_sv, data->last_found);
        data->substrs[var_531].min_offset = var_178 ? data->last_start_min : data->pos_min;

 if (!var_531)
     data->substrs[0].max_offset = data->substrs[0].min_offset;
 else {
     data->substrs[1].max_offset = (var_178
                          ? data->last_start_max
                          : (data->pos_delta > var_245 - data->pos_min
      ? var_245
      : data->pos_min + data->pos_delta));
     if (var_182
   || (STRLEN)data->substrs[1].max_offset > (STRLEN)var_245)
  data->substrs[1].max_offset = var_245;
        }

        if (data->flags & (0x0001|0x0002))
            data->substrs[var_531].flags |= (data->flags & (0x0001|0x0002));
        else
            data->substrs[var_531].flags &= ~(0x0001|0x0002);
        data->substrs[var_531].minlenp = minlenp;
        data->substrs[var_531].lookbehind = 0;
    }

    SvCUR_set(data->last_found, 0);
    {
 SV * const sv = data->last_found;
 if (SvUTF8(sv) && SvMAGICAL(sv)) {
     MAGIC * const mg = mg_find(sv, PERL_MAGIC_utf8);
     if (mg)
  mg->mg_len = 0;
 }
    }
    data->last_end = -1;
    data->flags &= ~(0x0001|0x0002);
    NOOP;
}




static void
fn_31(pTHX_ regnode_ssc *ssc)
{


    PERL_ARGS_ASSERT_SSC_ANYTHING;

    assert(is_ANYOF_SYNTHETIC(ssc));


    ssc->invlist = sv_2mortal(_add_range_to_invlist(NULL, 0, var_459));
    ANYOF_FLAGS(ssc) |= SSC_MATCHES_EMPTY_STRING;
}

static int
fn_33(const regnode_ssc *ssc)
{





    UV var_463, var_454;
    bool var_483;

    PERL_ARGS_ASSERT_SSC_IS_ANYTHING;

    assert(is_ANYOF_SYNTHETIC(ssc));

    if (! (ANYOF_FLAGS(ssc) & SSC_MATCHES_EMPTY_STRING)) {
        return FALSE;
    }


    invlist_iterinit(ssc->invlist);
    var_483 = invlist_iternext(ssc->invlist, &var_463, &var_454)
          && var_463 == 0
          && var_454 == var_459;

    invlist_iterfinish(ssc->invlist);

    if (var_483) {
        return TRUE;
    }


    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
        int var_531;
        for (var_531 = 0; var_531 < ANYOF_POSIXL_MAX; var_531 += 2) {
            if (ANYOF_POSIXL_TEST(ssc, var_531) && ANYOF_POSIXL_TEST(ssc, var_531+1)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

static void
fn_37(pTHX_ const RExC_state_t *var_491, regnode_ssc *ssc)
{



    PERL_ARGS_ASSERT_SSC_INIT;

    Zero(ssc, 1, regnode_ssc);
    set_ANYOF_SYNTHETIC(ssc);
    ARG_SET(ssc, ANYOF_ONLY_HAS_BITMAP);
    ssc_anything(ssc);

    if ((var_491->contains_locale)) {
 ANYOF_POSIXL_SETALL(ssc);
    }
    else {
 ANYOF_POSIXL_ZERO(ssc);
    }
}

static int
fn_38(const RExC_state_t *var_491,
                        const regnode_ssc *ssc)
{




    UV var_463, var_454;
    bool var_483;

    PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT;

    assert(is_ANYOF_SYNTHETIC(ssc));

    invlist_iterinit(ssc->invlist);
    var_483 = invlist_iternext(ssc->invlist, &var_463, &var_454)
          && var_463 == 0
          && var_454 == var_459;

    invlist_iterfinish(ssc->invlist);

    if (! var_483) {
        return FALSE;
    }

    if ((var_491->contains_locale) && ! ANYOF_POSIXL_SSC_TEST_ALL_SET(ssc)) {
        return FALSE;
    }

    return TRUE;
}





static SV*
fn_39(pTHX_ const RExC_state_t *var_491,
                               const regnode_charclass* const var_467)
{






    dVAR;
    SV* invlist = NULL;
    SV* only_utf8_locale_invlist = NULL;
    unsigned int var_531;
    const U32 var_498 = ARG(var_467);
    bool var_44 = FALSE;
    const U8 var_451 = OP(var_467) == ANYOFH ? 0 : ANYOF_FLAGS(var_467);

    PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC;


    if (var_498 != ANYOF_ONLY_HAS_BITMAP) {
        SV * const rv = MUTABLE_SV((var_491->rxi)->data->data[var_498]);
        AV * const av = MUTABLE_AV(SvRV(rv));
        SV **const ary = AvARRAY(av);
        assert((var_491->rxi)->data->what[var_498] == 's');

        if (av_tindex_skip_len_mg(av) >= 2) {



            invlist = sv_2mortal(_new_invlist(1));
            return _add_range_to_invlist(invlist, 0, var_459);
        }
        else if (ary[0]) {


            invlist = sv_2mortal(invlist_clone(ary[0], NULL));
        }


        if ( (var_451 & ANYOFL_FOLD)
            && av_tindex_skip_len_mg(av) >= 1)
        {
            only_utf8_locale_invlist = ary[1];
        }
    }

    if (! invlist) {
        invlist = sv_2mortal(_new_invlist(0));
    }

    if (var_451 & ANYOF_INVERT) {
        _invlist_intersection_maybe_complement_2nd(invlist, PL_UpperLatin1, TRUE, &invlist);


    }


    if (OP(var_467) != ANYOFH) {
        for (var_531 = 0; var_531 < NUM_ANYOF_CODE_POINTS; var_531++) {
            if (ANYOF_BITMAP_TEST(var_467, var_531)) {
                unsigned int var_463 = var_531++;

                for (; var_531 < NUM_ANYOF_CODE_POINTS
                       && ANYOF_BITMAP_TEST(var_467, var_531); ++var_531)
                {

                }
                invlist = _add_range_to_invlist(invlist, var_463, var_531-1);
                var_44 = TRUE;
            }
        }
    }





    if (! (var_451 & ANYOF_INVERT) && OP(var_467) == ANYOFD
        && (var_451 & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))
    {
        _invlist_union(invlist, PL_UpperLatin1, &invlist);
    }


    if (var_451 & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {
        _invlist_union_maybe_complement_2nd(invlist, PL_InBitmap, TRUE, &invlist);
    }

    if (var_451 & ANYOF_INVERT) {
        _invlist_invert(invlist);
    }
    else if (var_451 & ANYOFL_FOLD) {
        if (var_44) {



            _invlist_union(invlist, PL_Latin1, &invlist);

            invlist = add_cp_to_invlist(invlist, LATIN_SMALL_LETTER_DOTLESS_I);
            invlist = add_cp_to_invlist(invlist, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);
        }
        else {
            if (_invlist_contains_cp(invlist, LATIN_SMALL_LETTER_DOTLESS_I)) {
                invlist = add_cp_to_invlist(invlist, 'I');
            }
            if (_invlist_contains_cp(invlist,
                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE))
            {
                invlist = add_cp_to_invlist(invlist, 'i');
            }
        }
    }




    if (only_utf8_locale_invlist) {
        _invlist_union_maybe_complement_2nd(invlist,
                                            only_utf8_locale_invlist,
                                            var_451 & ANYOF_INVERT,
                                            &invlist);
    }

    return invlist;
}

static void
fn_44(pTHX_ const RExC_state_t *var_491, regnode_ssc *ssc,
                const regnode_charclass *and_with)
{



    SV* anded_cp_list;
    U8 var_47 = (OP(and_with) == ANYOFH) ? 0 : ANYOF_FLAGS(and_with);
    U8 anded_flags;

    PERL_ARGS_ASSERT_SSC_AND;

    assert(is_ANYOF_SYNTHETIC(ssc));



    if (is_ANYOF_SYNTHETIC(and_with)) {
        anded_cp_list = ((regnode_ssc *)and_with)->invlist;
        anded_flags = var_47;

        if (ssc_is_anything((regnode_ssc *)and_with)) {
            anded_flags |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
        }
    }
    else {
        anded_cp_list = get_ANYOF_cp_list_for_ssc(var_491, and_with);
        if (OP(and_with) == ANYOFD) {
            anded_flags = var_47 & ANYOF_COMMON_FLAGS;
        }
        else {
            anded_flags = var_47
            &( ANYOF_COMMON_FLAGS
              |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
              |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);
            if (ANYOFL_UTF8_LOCALE_REQD(var_47)) {
                anded_flags &=
                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
            }
        }
    }

    ANYOF_FLAGS(ssc) &= anded_flags;

    if ((var_47 & ANYOF_INVERT)
        && ! is_ANYOF_SYNTHETIC(and_with))
    {
        unsigned int var_531;

        ssc_intersection(ssc,
                         anded_cp_list,
                         FALSE
                         );



        if (! (var_47 & ANYOF_MATCHES_POSIXL)) {
            ANYOF_POSIXL_ZERO(ssc);
        }
        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {

            regnode_charclass_posixl var_537;
            int var_47 = 1;

            Zero(&var_537, 1, regnode_charclass_posixl);
            ANYOF_POSIXL_ZERO(&var_537);
            for (var_531 = 0; var_531 < ANYOF_MAX; var_531++) {
                assert(var_531 % 2 != 0
                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, var_531)
                       || ! ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, var_531 + 1));

                if (ANYOF_POSIXL_TEST((regnode_charclass_posixl*) and_with, var_531)) {
                    ANYOF_POSIXL_SET(&var_537, var_531 + var_47);
                }
                var_47 = 0 - var_47;
            }
            ANYOF_POSIXL_AND(&var_537, ssc);

        }
    }

    else if (! is_ANYOF_SYNTHETIC(and_with)
             || ! ssc_is_cp_posixl_init(var_491, (regnode_ssc *)and_with))
    {


        if (ssc_is_cp_posixl_init(var_491, ssc)) {
            if (is_ANYOF_SYNTHETIC(and_with)) {
                StructCopy(and_with, ssc, regnode_ssc);
            }
            else {
                ssc->invlist = anded_cp_list;
                ANYOF_POSIXL_ZERO(ssc);
                if (var_47 & ANYOF_MATCHES_POSIXL) {
                    ANYOF_POSIXL_OR((regnode_charclass_posixl*) and_with, ssc);
                }
            }
        }
        else if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)
                 || (var_47 & ANYOF_MATCHES_POSIXL))
        {

            if (var_47 & ANYOF_MATCHES_POSIXL) {
                ANYOF_POSIXL_AND((regnode_charclass_posixl*) and_with, ssc);
            }
            ssc_union(ssc, anded_cp_list, FALSE);
        }
        else {
            ssc_intersection(ssc, anded_cp_list, FALSE);
        }
    }
}

static void
fn_47(pTHX_ const RExC_state_t *var_491, regnode_ssc *ssc,
               const regnode_charclass *or_with)
{




    SV* ored_cp_list;
    U8 ored_flags;
    U8 var_49 = (OP(or_with) == ANYOFH) ? 0 : ANYOF_FLAGS(or_with);

    PERL_ARGS_ASSERT_SSC_OR;

    assert(is_ANYOF_SYNTHETIC(ssc));



    if (is_ANYOF_SYNTHETIC(or_with)) {
        ored_cp_list = ((regnode_ssc*) or_with)->invlist;
        ored_flags = var_49;
    }
    else {
        ored_cp_list = get_ANYOF_cp_list_for_ssc(var_491, or_with);
        ored_flags = var_49 & ANYOF_COMMON_FLAGS;
        if (OP(or_with) != ANYOFD) {
            ored_flags
            |= var_49
             & ( ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
                |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP);
            if (ANYOFL_UTF8_LOCALE_REQD(var_49)) {
                ored_flags |=
                    ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
            }
        }
    }

    ANYOF_FLAGS(ssc) |= ored_flags;

    if ((var_49 & ANYOF_INVERT)
        && ! is_ANYOF_SYNTHETIC(or_with))
    {

    }
    else if (var_49 & ANYOF_MATCHES_POSIXL) {
        ANYOF_POSIXL_OR((regnode_charclass_posixl*)or_with, ssc);
        if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
            unsigned int var_531;
            for (var_531 = 0; var_531 < ANYOF_MAX; var_531 += 2) {
                if (ANYOF_POSIXL_TEST(ssc, var_531) && ANYOF_POSIXL_TEST(ssc, var_531 + 1))
                {
                    ssc_add_range(ssc, 0, var_459);
                    ANYOF_POSIXL_CLEAR(ssc, var_531);
                    ANYOF_POSIXL_CLEAR(ssc, var_531+1);
                }
            }
        }
    }

    ssc_union(ssc,
              ored_cp_list,
              FALSE
              );
}

PERL_STATIC_INLINE void
fn_49(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool var_52)
{
    PERL_ARGS_ASSERT_SSC_UNION;

    assert(is_ANYOF_SYNTHETIC(ssc));

    _invlist_union_maybe_complement_2nd(ssc->invlist,
                                        invlist,
                                        var_52,
                                        &ssc->invlist);
}

PERL_STATIC_INLINE void
fn_51(pTHX_ regnode_ssc *ssc,
                         SV* const invlist,
                         const bool var_52)
{
    PERL_ARGS_ASSERT_SSC_INTERSECTION;

    assert(is_ANYOF_SYNTHETIC(ssc));

    _invlist_intersection_maybe_complement_2nd(ssc->invlist,
                                               invlist,
                                               var_52,
                                               &ssc->invlist);
}

PERL_STATIC_INLINE void
fn_52(pTHX_ regnode_ssc *ssc, const UV var_463, const UV var_454)
{
    PERL_ARGS_ASSERT_SSC_ADD_RANGE;

    assert(is_ANYOF_SYNTHETIC(ssc));

    ssc->invlist = _add_range_to_invlist(ssc->invlist, var_463, var_454);
}

PERL_STATIC_INLINE void
fn_53(pTHX_ regnode_ssc *ssc, const UV var_470)
{


    SV* cp_list = _new_invlist(2);

    PERL_ARGS_ASSERT_SSC_CP_AND;

    assert(is_ANYOF_SYNTHETIC(ssc));

    cp_list = add_cp_to_invlist(cp_list, var_470);
    ssc_intersection(ssc, cp_list,
                     FALSE
                     );
    SvREFCNT_dec_NN(cp_list);
}

PERL_STATIC_INLINE void
fn_55(regnode_ssc *ssc)
{

    PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE;

    assert(is_ANYOF_SYNTHETIC(ssc));

    ANYOF_POSIXL_ZERO(ssc);
    ANYOF_FLAGS(ssc) &= ~ANYOF_LOCALE_FLAGS;
}



static bool
fn_56(const RExC_state_t * var_491, const regnode_ssc * ssc)
{

    U32 var_489 = 0;

    UV var_463, var_454;

    const U32 var_60 = ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET))
                                ? 256
                                : (( ! (get_regex_charset((var_491->flags)) == REGEX_UNICODE_CHARSET)
                                    || invlist_highest(ssc->invlist) < 256)
                                  ? 128
                                  : NON_OTHER_COUNT_FOR_USE_ONLY_BY_REGCOMP_DOT_C);
    const U32 var_60 = var_60 / 2;

    PERL_ARGS_ASSERT_IS_SSC_WORTH_IT;

    invlist_iterinit(ssc->invlist);
    while (invlist_iternext(ssc->invlist, &var_463, &var_454)) {
        if (var_463 >= var_60) {
            break;
        }
        var_454 = MIN(var_454, var_60 - 1);
        var_489 += var_454 - var_463 + 1;
        if (var_489 >= var_60) {
            invlist_iterfinish(ssc->invlist);
            return FALSE;
        }
    }

    return TRUE;
}


static void
fn_60(pTHX_ RExC_state_t *var_491, regnode_ssc *ssc)
{





    SV* invlist = invlist_clone(ssc->invlist, NULL);

    PERL_ARGS_ASSERT_SSC_FINALIZE;

    assert(is_ANYOF_SYNTHETIC(ssc));




    assert(! (ANYOF_FLAGS(ssc)
        & ~( ANYOF_COMMON_FLAGS
            |ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER
            |ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP)));

    populate_ANYOF_from_invlist( (regnode *) ssc, &invlist);

    set_ANYOF_arg(var_491, (regnode *) ssc, invlist, NULL, NULL);


    ssc->invlist = NULL;

    if (ANYOF_POSIXL_SSC_TEST_ANY_SET(ssc)) {
        ANYOF_FLAGS(ssc) |= ANYOF_MATCHES_POSIXL;
        OP(ssc) = ANYOFPOSIXL;
    }
    else if ((var_491->contains_locale)) {
        OP(ssc) = ANYOFL;
    }

    assert(! (ANYOF_FLAGS(ssc) & ANYOF_LOCALE_FLAGS) || (var_491->contains_locale));
}

static I32
fn_61(pTHX_ RExC_state_t *var_491, regnode *startbranch,
                  regnode *var_369, regnode *last, regnode *tail,
                  U32 var_97, U32 var_451, U32 var_486)
{

    reg_trie_data *trie;
    HV *widecharmap = NULL;
    AV *revcharmap = newAV();
    regnode *var_531;
    STRLEN var_531 = 0;
    UV var_97 = 0;
    U16 var_97 = 0;
    U32 var_103 = 0;
    regnode *jumper = NULL;
    regnode *nextbranch = NULL;
    regnode *var_108 = NULL;
    U32 *prev_states;

    const U8 * folder = NULL;

    const U32 var_117 = add_data( var_491, STR_WITH_LEN("tu"));
    STRLEN var_72=0;

    SV *re_trie_maxbuff;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_MAKE_TRIE;

    PERL_UNUSED_ARG(var_486);


    switch (var_451) {
        case var_454: case EXACT_ONLY8: case EXACTL: break;
 case EXACTFAA:
        case EXACTFUP:
 case EXACTFU:
 case EXACTFLU8: folder = PL_fold_latin1; break;
 case EXACTF: folder = PL_fold; break;
        default: Perl_croak( aTHX_ "panic! In trie construction, unknown node type %u %s", (unsigned) var_451, PL_reg_name[var_451] );
    }

    trie = (reg_trie_data *) PerlMemShared_calloc( 1, sizeof(reg_trie_data) );
    trie->refcount = 1;
    trie->startstate = 1;
    trie->wordcount = var_97;
    (var_491->rxi)->data->data[ var_117 ] = (void*)trie;
    trie->charmap = (U16 *) PerlMemShared_calloc( 256, sizeof(U16) );
    if (var_451 == var_454 || var_451 == EXACT_ONLY8 || var_451 == EXACTL)
 trie->bitmap = (char *) PerlMemShared_calloc( ANYOF_BITMAP_SIZE, 1 );
    trie->wordinfo = (reg_trie_wordinfo *) PerlMemShared_calloc(
                       trie->wordcount+1, sizeof(reg_trie_wordinfo));

    DEBUG_r({
        trie_words = newAV();
    });

    re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, GV_ADD);
    assert(re_trie_maxbuff);
    if (!SvIOK(re_trie_maxbuff)) {
        sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);
    }
    DEBUG_TRIE_COMPILE_r({
        Perl_re_indentf( aTHX_
          "make_trie start==%d, first==%d, last==%d, tail==%d depth=%d\n",
          var_486+1,
          ((startbranch) ? (int)((startbranch)-(var_491->emit_start)) : -1), ((var_369) ? (int)((var_369)-(var_491->emit_start)) : -1),
          ((last) ? (int)((last)-(var_491->emit_start)) : -1), ((tail) ? (int)((tail)-(var_491->emit_start)) : -1), (int)var_486);
    });


    if ( var_369 == startbranch && OP( last ) != BRANCH ) {

        var_108 = var_369;
    } else {

        var_108 = NEXTOPER( var_369 );
    }

    for ( var_531 = var_369 ; var_531 < last ; var_531 = regnext( var_531 ) ) {
        regnode *noper = NEXTOPER( var_531 );
        const U8 *uc;
        const U8 *var_512;
        int var_454 = 0;
        U32 var_97 = 0;
        STRLEN var_82 = 0;
        STRLEN var_82 = 0;
        bool var_82 = trie->bitmap ? 1 : 0;


        if (OP(noper) == NOTHING) {

            regnode *noper_next= regnext(noper);
            if (noper_next < tail)
                noper= noper_next;
        }

        if ( noper < tail
            && ( OP(noper) == var_451
                || (var_451 == var_454 && OP(noper) == EXACT_ONLY8)
                || (var_451 == EXACTFU && ( OP(noper) == EXACTFU_ONLY8
                                         || OP(noper) == EXACTFUP))))
        {
            uc= (U8*)STRING(noper);
            var_512= uc + STR_LEN(noper);
        } else {
            trie->minlen= 0;
            continue;
        }


        if ( var_82 ) {
            TRIE_BITMAP_SET(trie,*uc);

            if (OP( noper ) == EXACTFUP) {

                TRIE_BITMAP_SET(trie, LATIN_SMALL_LETTER_SHARP_S);
            }
        }

        for ( ; uc < var_512 ; uc += var_531 ) {

            TRIE_CHARCOUNT(trie)++;
            STMT_START { var_97++; if ( cBOOL((var_491->utf8)) ) { var_97 = valid_utf8_to_uvchr( (const U8*) uc, &var_531); } else if (folder == PL_fold_latin1) { assert(*uc != LATIN_SMALL_LETTER_SHARP_S); var_97 = toLOWER_L1(*uc); if (UNLIKELY(var_97 == MICRO_SIGN)) var_97 = GREEK_SMALL_LETTER_MU; var_531 = 1; } else { var_97 = (U32)*uc; var_531 = 1; } } STMT_END;

            var_82++;

            if (folder == NULL) {
                var_82++;
            }
            else if (var_454 > 0) {
                var_454 -= (cBOOL((var_491->utf8))) ? UTF8SKIP(uc) : 1;
            }
            else {
                var_82++;

                if (cBOOL((var_491->utf8))) {
                    if ((var_454 = is_MULTI_CHAR_FOLD_utf8_safe(uc, var_512))) {
                        var_454 -= UTF8SKIP(uc);
                    }
                }
                else if ((var_454 = is_MULTI_CHAR_FOLD_latin1_safe(uc, var_512))) {
                    var_454--;
                }
            }




            if ( var_97 < 256 ) {
                if ( folder ) {
                    U8 var_455= folder[ (U8) var_97 ];
                    if ( !trie->charmap[ var_455 ] ) {
                        trie->charmap[ var_455 ]=( ++trie->uniquecharcount );
                        STMT_START { if (cBOOL((var_491->utf8))) { SV *zlopp = newSV(UTF8_MAXBYTES); unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp); unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, var_455); SvCUR_set(zlopp, kapow - flrbbbbb); SvPOK_on(zlopp); SvUTF8_on(zlopp); av_push(revcharmap, zlopp); } else { char var_82 = (char)var_455; av_push(revcharmap, newSVpvn(&var_82, 1)); } } STMT_END;
                    }
                }
                if ( !trie->charmap[ var_97 ] ) {
                    trie->charmap[ var_97 ]=( ++trie->uniquecharcount );
                    STMT_START { if (cBOOL((var_491->utf8))) { SV *zlopp = newSV(UTF8_MAXBYTES); unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp); unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, var_97); SvCUR_set(zlopp, kapow - flrbbbbb); SvPOK_on(zlopp); SvUTF8_on(zlopp); av_push(revcharmap, zlopp); } else { char var_82 = (char)var_97; av_push(revcharmap, newSVpvn(&var_82, 1)); } } STMT_END;
                }
                if ( var_82 ) {


                    STMT_START { TRIE_BITMAP_SET(trie, var_97); if ( folder ) TRIE_BITMAP_SET(trie, folder[(U8) var_97 ]); if ( !cBOOL((var_491->utf8)) ) { if (! UVCHR_IS_INVARIANT(var_97)) { TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(var_97)); } } } STMT_END;
                    var_82 = 0;
                }
            } else {

                SV** svpp;
                if ( !widecharmap )
                    widecharmap = newHV();

                svpp = hv_fetch( widecharmap, (char*)&var_97, sizeof( UV ), 1 );

                if ( !svpp )
                    Perl_croak( aTHX_ "error creating/fetching widecharmap entry for 0x%" UVXf, var_97 );

                if ( !SvTRUE( *svpp ) ) {
                    sv_setiv( *svpp, ++trie->uniquecharcount );
                    STMT_START { if (cBOOL((var_491->utf8))) { SV *zlopp = newSV(UTF8_MAXBYTES); unsigned char *flrbbbbb = (unsigned char *) SvPVX(zlopp); unsigned const char *const kapow = uvchr_to_utf8(flrbbbbb, var_97); SvCUR_set(zlopp, kapow - flrbbbbb); SvPOK_on(zlopp); SvUTF8_on(zlopp); av_push(revcharmap, zlopp); } else { char var_82 = (char)var_97; av_push(revcharmap, newSVpvn(&var_82, 1)); } } STMT_END;
                }
            }
        }



        if( var_531 == var_369 ) {
            trie->minlen = var_82;
            trie->maxlen = var_82;
        } else if (var_82 < trie->minlen) {
            trie->minlen = var_82;
        } else if (var_82 > trie->maxlen) {
            trie->maxlen = var_82;
        }
    }
    DEBUG_TRIE_COMPILE_r(
        Perl_re_indentf( aTHX_
                "TRIE(%s): W:%d C:%d Uq:%d Min:%d Max:%d\n",
                var_486+1,
                ( widecharmap ? "UTF8" : "NATIVE" ), (int)var_97,
  (int)TRIE_CHARCOUNT(trie), trie->uniquecharcount,
  (int)trie->minlen, (int)trie->maxlen )
    );

    Newx(prev_states, TRIE_CHARCOUNT(trie) + 2, U32);
    prev_states[1] = 0;

    if ( (IV)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount + 1)
                                                    > SvIV(re_trie_maxbuff) )
    {

        STRLEN var_94 = 1;

        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_ "Compiling trie using list compiler\n",
            var_486+1));

 trie->states = (reg_trie_state *)
     PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,
      sizeof(reg_trie_state) );
        STMT_START { Newx( trie->states[ 1 ].trans.list, 4, reg_trie_trans_le ); ( (trie->states[1].trans.list)[ 0 ].forid ) = 1; ( (trie->states[1].trans.list)[ 0 ].newstate ) = 4; } STMT_END;
        var_103 = 2;

        for ( var_531 = var_369 ; var_531 < last ; var_531 = regnext( var_531 ) ) {

            regnode *noper = NEXTOPER( var_531 );
     U32 var_108 = 1;
     U16 var_119 = 0;
            U32 var_97 = 0;

            if (OP(noper) == NOTHING) {
                regnode *noper_next= regnext(noper);
                if (noper_next < tail)
                    noper= noper_next;



            }

            if ( noper < tail
                && ( OP(noper) == var_451
                    || (var_451 == var_454 && OP(noper) == EXACT_ONLY8)
                    || (var_451 == EXACTFU && ( OP(noper) == EXACTFU_ONLY8
                                             || OP(noper) == EXACTFUP))))
            {
                const U8 *uc= (U8*)STRING(noper);
                const U8 *var_512= uc + STR_LEN(noper);

                for ( ; uc < var_512 ; uc += var_531 ) {

                    STMT_START { var_97++; if ( cBOOL((var_491->utf8)) ) { var_97 = valid_utf8_to_uvchr( (const U8*) uc, &var_531); } else if (folder == PL_fold_latin1) { assert(*uc != LATIN_SMALL_LETTER_SHARP_S); var_97 = toLOWER_L1(*uc); if (UNLIKELY(var_97 == MICRO_SIGN)) var_97 = GREEK_SMALL_LETTER_MU; var_531 = 1; } else { var_97 = (U32)*uc; var_531 = 1; } } STMT_END;

                    if ( var_97 < 256 ) {
                        var_119 = trie->charmap[ var_97 ];
      } else {
                        SV** const svpp = hv_fetch( widecharmap,
                                                    (char*)&var_97,
                                                    sizeof( UV ),
                                                    0);
                        if ( !svpp ) {
                            var_119 = 0;
                        } else {
                            var_119=(U16)SvIV( *svpp );
                        }
      }


                    if ( var_119 ) {

                        U16 check;
                        U32 var_117 = 0;

                        var_119--;
                        if ( !trie->states[ var_108 ].trans.list ) {
                            STMT_START { Newx( trie->states[ var_108 ].trans.list, 4, reg_trie_trans_le ); ( (trie->states[var_108].trans.list)[ 0 ].forid ) = 1; ( (trie->states[var_108].trans.list)[ 0 ].newstate ) = 4; } STMT_END;
   }
                        for ( check = 1;
                              check <= ( trie->states[var_108].trans.list ? (( (trie->states[var_108].trans.list)[ 0 ].forid ) - 1) : 0 );
                              check++ )
                        {
                            if ( (trie->states[var_108].trans.list)[ check ].forid
                                                                    == var_119 )
                            {
                                var_117 = (trie->states[var_108].trans.list)[ check ].newstate;
                                break;
                            }
                        }
                        if ( ! var_117 ) {
                            var_117 = var_103++;
       prev_states[var_117] = var_108;
                            STMT_START { if ( ( (trie->states[var_108].trans.list)[ 0 ].forid ) >=( (trie->states[var_108].trans.list)[ 0 ].newstate ) ) { U32 var_87 = ( (trie->states[var_108].trans.list)[ 0 ].newstate ) * 2; Renew( trie->states[ var_108 ].trans.list, var_87, reg_trie_trans_le ); ( (trie->states[var_108].trans.list)[ 0 ].newstate ) = var_87; } (trie->states[var_108].trans.list)[ ( (trie->states[var_108].trans.list)[ 0 ].forid ) ].forid = var_119; (trie->states[var_108].trans.list)[ ( (trie->states[var_108].trans.list)[ 0 ].forid ) ].newstate = var_117; ( (trie->states[var_108].trans.list)[ 0 ].forid )++; } STMT_END;
                            var_94++;
                        }
                        var_108 = var_117;
                    } else {
                        Perl_croak( aTHX_ "panic! In trie construction, no char mapping for %" IVdf, var_97 );
      }
  }
            } else {




                noper= NEXTOPER(var_531);
            }
            STMT_START { U16 var_97= trie->states[ var_108 ].wordnum; regnode * const noper_next = regnext( noper ); DEBUG_r({ SV* tmp; if (OP(noper) != NOTHING) tmp = newSVpvn_utf8(STRING(noper), STR_LEN(noper), cBOOL((var_491->utf8))); else tmp = newSVpvn_utf8( "", 0, cBOOL((var_491->utf8)) ); av_push( trie_words, tmp ); }); var_97++; trie->wordinfo[var_97].prev = 0; trie->wordinfo[var_97].len = var_97; trie->wordinfo[var_97].accept = var_108; if ( noper_next < tail ) { if (!trie->jump) trie->jump = (U16 *) PerlMemShared_calloc( var_97 + 1, sizeof(U16) ); trie->jump[var_97] = (U16)(noper_next - var_108); if (!jumper) jumper = noper_next; if (!nextbranch) nextbranch= regnext(var_531); } if ( var_97 ) { trie->wordinfo[var_97].prev = trie->wordinfo[var_97].prev; trie->wordinfo[var_97].prev = var_97; } else { trie->states[ var_108 ].wordnum = var_97; } } STMT_END;

        }


        trie->statecount = var_103;
        trie->states = (reg_trie_state *)
     PerlMemShared_realloc( trie->states,
       var_103
       * sizeof(reg_trie_state) );


        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_list(trie, widecharmap,
        revcharmap, var_103,
        var_486+1)
        );

        trie->trans = (reg_trie_trans *)
     PerlMemShared_calloc( var_94, sizeof(reg_trie_trans) );
        {
            U32 var_108;
            U32 var_96 = 0;
            U32 var_103 = 0;


            for( var_108=1 ; var_108 < var_103 ; var_108 ++ ) {
                U32 var_118=0;







                if (trie->states[var_108].trans.list) {
                    U16 var_96=(trie->states[var_108].trans.list)[ 1 ].forid;
                    U16 var_96=var_96;
      U16 idx;

                    for( idx = 2 ; idx <= ( trie->states[var_108].trans.list ? (( (trie->states[var_108].trans.list)[ 0 ].forid ) - 1) : 0 ) ; idx++ ) {
   const U16 var_94 = (trie->states[var_108].trans.list)[ idx ].forid;
   if ( var_94 < var_96 ) {
       var_96=var_94;
   } else if ( var_94 > var_96 ) {
       var_96=var_94;
   }
                    }
                    if ( var_94 < var_96 + var_96 - var_96 + 1) {
                        var_94 *= 2;
   trie->trans = (reg_trie_trans *)
       PerlMemShared_realloc( trie->trans,
           var_94
           * sizeof(reg_trie_trans) );
                        Zero( trie->trans + (var_94 / 2),
                              var_94 / 2,
                              reg_trie_trans );
                    }
                    var_118 = trie->uniquecharcount + var_96 - var_96;
                    if ( var_96 == var_96 ) {
                        U32 var_95 = 0;
                        for ( ; var_103 < var_96 ; var_103++ ) {
                            if ( ! trie->trans[ var_103 ].next ) {
                                var_118 = trie->uniquecharcount + var_103 - var_96;
                                trie->trans[ var_103 ].next = (trie->states[var_108].trans.list)[ 1 ].newstate;

                                trie->trans[ var_103 ].check = var_108;
                                var_95 = 1;
                                break;
                            }
                        }
                        if ( !var_95 ) {
                            trie->trans[ var_96 ].next = (trie->states[var_108].trans.list)[ 1 ].newstate;

                            trie->trans[ var_96 ].check = var_108;
                            var_96++;
                            var_103 = var_96;
                        }
                    } else {
                        for ( idx=1; idx <= ( trie->states[var_108].trans.list ? (( (trie->states[var_108].trans.list)[ 0 ].forid ) - 1) : 0 ) ; idx++ ) {
                            const U32 var_96 = var_118
                                           - trie->uniquecharcount
                                           + (trie->states[var_108].trans.list)[ idx ].forid;
                            trie->trans[ var_96 ].next = (trie->states[var_108].trans.list)[ idx ].newstate;

                            trie->trans[ var_96 ].check = var_108;
                        }
                        var_96 += ( var_96 - var_96 + 1 );
                    }
                    Safefree(trie->states[ var_108 ].trans.list);
                }





                trie->states[ var_108 ].trans.base=var_118;
            }
            trie->lasttrans = var_96 + 1;
        }
    } else {

        DEBUG_TRIE_COMPILE_MORE_r( Perl_re_indentf( aTHX_ "Compiling trie using table compiler\n",
            var_486+1));

 trie->trans = (reg_trie_trans *)
     PerlMemShared_calloc( ( TRIE_CHARCOUNT(trie) + 1 )
      * trie->uniquecharcount + 1,
      sizeof(reg_trie_trans) );
        trie->states = (reg_trie_state *)
     PerlMemShared_calloc( TRIE_CHARCOUNT(trie) + 2,
      sizeof(reg_trie_state) );
        var_103 = trie->uniquecharcount + 1;


        for ( var_531 = var_369 ; var_531 < last ; var_531 = regnext( var_531 ) ) {

            regnode *noper = NEXTOPER( var_531 );

            U32 var_108 = 1;

            U16 var_119 = 0;
            U32 var_97 = 0;

            U32 var_97 = 0;

            if (OP(noper) == NOTHING) {
                regnode *noper_next= regnext(noper);
                if (noper_next < tail)
                    noper= noper_next;



            }

            if ( noper < tail
                && ( OP(noper) == var_451
                    || (var_451 == var_454 && OP(noper) == EXACT_ONLY8)
                    || (var_451 == EXACTFU && ( OP(noper) == EXACTFU_ONLY8
                                             || OP(noper) == EXACTFUP))))
            {
                const U8 *uc= (U8*)STRING(noper);
                const U8 *var_512= uc + STR_LEN(noper);

                for ( ; uc < var_512 ; uc += var_531 ) {

                    STMT_START { var_97++; if ( cBOOL((var_491->utf8)) ) { var_97 = valid_utf8_to_uvchr( (const U8*) uc, &var_531); } else if (folder == PL_fold_latin1) { assert(*uc != LATIN_SMALL_LETTER_SHARP_S); var_97 = toLOWER_L1(*uc); if (UNLIKELY(var_97 == MICRO_SIGN)) var_97 = GREEK_SMALL_LETTER_MU; var_531 = 1; } else { var_97 = (U32)*uc; var_531 = 1; } } STMT_END;

                    if ( var_97 < 256 ) {
                        var_119 = trie->charmap[ var_97 ];
                    } else {
                        SV* const * const svpp = hv_fetch( widecharmap,
                                                           (char*)&var_97,
                                                           sizeof( UV ),
                                                           0);
                        var_119 = svpp ? (U16)SvIV(*svpp) : 0;
                    }
                    if ( var_119 ) {
                        var_119--;
                        if ( !trie->trans[ var_108 + var_119 ].next ) {
                            trie->trans[ var_108 + var_119 ].next = var_103;
                            trie->trans[ var_108 ].check++;
       prev_states[TRIE_NODENUM(var_103)]
        = TRIE_NODENUM(var_108);
                            var_103 += trie->uniquecharcount;
                        }
                        var_108 = trie->trans[ var_108 + var_119 ].next;
                    } else {
                        Perl_croak( aTHX_ "panic! In trie construction, no char mapping for %" IVdf, var_97 );
                    }


                }
            } else {




                noper= NEXTOPER(var_531);
            }
            var_97 = TRIE_NODENUM( var_108 );
            STMT_START { U16 var_97= trie->states[ var_97 ].wordnum; regnode * const noper_next = regnext( noper ); DEBUG_r({ SV* tmp; if (OP(noper) != NOTHING) tmp = newSVpvn_utf8(STRING(noper), STR_LEN(noper), cBOOL((var_491->utf8))); else tmp = newSVpvn_utf8( "", 0, cBOOL((var_491->utf8)) ); av_push( trie_words, tmp ); }); var_97++; trie->wordinfo[var_97].prev = 0; trie->wordinfo[var_97].len = var_97; trie->wordinfo[var_97].accept = var_97; if ( noper_next < tail ) { if (!trie->jump) trie->jump = (U16 *) PerlMemShared_calloc( var_97 + 1, sizeof(U16) ); trie->jump[var_97] = (U16)(noper_next - var_108); if (!jumper) jumper = noper_next; if (!nextbranch) nextbranch= regnext(var_531); } if ( var_97 ) { trie->wordinfo[var_97].prev = trie->wordinfo[var_97].prev; trie->wordinfo[var_97].prev = var_97; } else { trie->states[ var_97 ].wordnum = var_97; } } STMT_END;

        }


        DEBUG_TRIE_COMPILE_MORE_r(dump_trie_interim_table(trie, widecharmap,
         revcharmap,
         var_103, var_486+1));

        {

        const U32 var_103 = TRIE_NODENUM( var_103 );
 U32 var_108, var_119;
        U32 var_538 = 0, var_103=0;
        trie->statecount = var_103;

        for ( var_108 = 1 ; var_108 < var_103 ; var_108++ ) {
            U8 var_367 = 0;
     const U32 var_103 = TRIE_NODEIDX( var_108 );
     const U32 var_103 = trie->trans[ var_103 ].check;
     U32 var_103 = trie->trans[ var_103 ].check;
            trie->trans[ var_103 ].check = 0;

            for ( var_119 = 0;
                  var_103 && var_119 < trie->uniquecharcount;
                  var_119++ )
            {
                if ( var_367 || trie->trans[ var_103 + var_119 ].next ) {
                    if ( trie->trans[ var_103 + var_119 ].next ) {
                        if (var_103 == 1) {
                            for ( ; var_103 < var_538 ; var_103++ ) {
                                if ( ! trie->trans[ var_103 ].next ) {
                                    break;
                                }
                            }
                            trie->states[ var_108 ].trans.base
                                                    = var_103
                                                      + trie->uniquecharcount
                                                      - var_119 ;
                            trie->trans[ var_103 ].next
                                = SAFE_TRIE_NODENUM( trie->trans[ var_103
                                                             + var_119 ].next );
                            trie->trans[ var_103 ].check = var_108;
                            if ( ++var_103 > var_538 ) var_538 = var_103;
                            break;
                        }
                        var_103--;
                    }
                    if ( !var_367 ) {
                        var_367 = 1;
                        trie->states[ var_108 ].trans.base
                                       = var_538 + trie->uniquecharcount - var_119 ;
                    }
                    trie->trans[ var_538 ].next
                        = SAFE_TRIE_NODENUM(
                                       trie->trans[ var_103 + var_119 ].next );
                    trie->trans[ var_538 ].check = var_108;
                    var_538++;
                }
            }
        }
        trie->lasttrans = var_538 + 1;
        trie->states = (reg_trie_state *)
     PerlMemShared_realloc( trie->states, var_103
       * sizeof(reg_trie_state) );
        DEBUG_TRIE_COMPILE_MORE_r(
            Perl_re_indentf( aTHX_ "Alloc: %d Orig: %" IVdf " elements, Final:%" IVdf ". Savings of %%%5.2f\n",
                var_486+1,
                (int)( ( TRIE_CHARCOUNT(trie) + 1 ) * trie->uniquecharcount
                       + 1 ),
                (IV)var_103,
                (IV)var_538,
                ( ( var_103 - var_538 ) * 100 ) / (double)var_103 );
            );

        }
    }
    DEBUG_TRIE_COMPILE_MORE_r(
            Perl_re_indentf( aTHX_ "Statecount:%" UVxf " Lasttrans:%" UVxf "\n",
                var_486+1,
                (UV)trie->statecount,
                (UV)trie->lasttrans)
    );

    trie->trans = (reg_trie_trans *)
 PerlMemShared_realloc( trie->trans, trie->lasttrans
          * sizeof(reg_trie_trans) );

    {
        U8 var_108 =(U8)(var_451 & 0xFF);
        char *str=NULL;

        if ( var_369 != startbranch || OP( last ) == BRANCH ) {

            NEXT_OFF( var_369 ) = (U16)(last - var_369);







        }

        trie->startstate= 1;
        if ( trie->bitmap && !widecharmap && !trie->jump ) {




            U32 var_108;
            for ( var_108 = 1 ; var_108 < trie->statecount-1 ; var_108++ ) {
                U32 var_107 = 0;
                I32 var_107 = -1;

                U32 var_489 = 0;
                const U32 var_118 = trie->states[ var_108 ].trans.base;


                if ( trie->states[var_108].wordnum )
                        var_489 = 1;

                for ( var_107 = 0 ; var_107 < trie->uniquecharcount ; var_107++ ) {
                    if ( ( var_118 + var_107 >= trie->uniquecharcount ) &&
                         ( var_118 + var_107 - trie->uniquecharcount < trie->lasttrans ) &&
                         trie->trans[ var_118 + var_107 - trie->uniquecharcount ].check == var_108 )
                    {
                        if ( ++var_489 > 1 ) {

                            SV **tmp;
                            U8 *var_385;


                            if ( var_108 == 1 ) break;
                            tmp = av_fetch( revcharmap, var_107, 0);
                            var_385 = (U8*)SvPV_nolen_const( *tmp );




                            if ( var_489 == 2 ) {

                                Zero(trie->bitmap, ANYOF_BITMAP_SIZE, char);
                                DEBUG_OPTIMISE_r(
                                    Perl_re_indentf( aTHX_ "New Start State=%" UVuf " Class: [",
                                        var_486+1,
                                        (UV)var_108));
                                if (var_107 >= 0) {
                                    SV ** const tmp = av_fetch( revcharmap, var_107, 0);
        const U8 * const var_385 = (U8*)SvPV_nolen_const( *tmp );

                                    STMT_START { TRIE_BITMAP_SET(trie, *var_385); if ( folder ) TRIE_BITMAP_SET(trie, folder[(U8) *var_385 ]); if ( !cBOOL((var_491->utf8)) ) { if (! UVCHR_IS_INVARIANT(*var_385)) { TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(*var_385)); } } } STMT_END;
                                    DEBUG_OPTIMISE_r(
                                        Perl_re_printf( aTHX_ "%s", (char*)var_385)
                                    );
    }
       }

                            STMT_START { TRIE_BITMAP_SET(trie, *var_385); if ( folder ) TRIE_BITMAP_SET(trie, folder[(U8) *var_385 ]); if ( !cBOOL((var_491->utf8)) ) { if (! UVCHR_IS_INVARIANT(*var_385)) { TRIE_BITMAP_SET(trie, UTF8_TWO_BYTE_HI(*var_385)); } } } STMT_END;
                            DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ "%s", var_385));
   }
                        var_107 = var_107;
      }
                }
                if ( var_489 == 1 ) {



                    SV **tmp = av_fetch( revcharmap, var_107, 0);
                    STRLEN var_531;
                    char *var_385 = SvPV( *tmp, var_531 );
                    DEBUG_OPTIMISE_r({
                        SV *sv=sv_newmortal();
                        Perl_re_indentf( aTHX_ "Prefix State: %" UVuf " Ofs:%" UVuf " Char='%s'\n",
                            var_486+1,
                            (UV)var_108, (UV)var_107,
                            pv_pretty(sv, SvPV_nolen_const(*tmp), SvCUR(*tmp), 6,
                         PL_colors[0], PL_colors[1],
                         (SvUTF8(*tmp) ? PERL_PV_ESCAPE_UNI : 0) |
                         PERL_PV_ESCAPE_FIRSTCHAR
                            )
                        );
                    });
                    if ( var_108==1 ) {
                        OP( var_108 ) = var_108;
                        str=STRING(var_108);
                        STR_LEN(var_108)=0;
                    }
                    STR_LEN(var_108) += var_531;
                    while (var_531--)
                        *str++ = *var_385++;
  } else {




      break;
  }
     }
     trie->prefixlen = (var_108-1);
            if (str) {
                regnode *var_498 = var_108+NODE_SZ_STR(var_108);
                NEXT_OFF(var_108) = NODE_SZ_STR(var_108);
                trie->startstate = var_108;
                trie->minlen -= (var_108 - 1);
                trie->maxlen -= (var_108 - 1);

                if (trie->maxlen) {
                    var_108 = var_498;
  } else {
                    NEXT_OFF(var_108) = (U16)(tail - var_108);
                    DEBUG_r(optimize= var_498);
                }
            }
        }
        if (!jumper)
            jumper = last;
        if ( trie->maxlen ) {
     NEXT_OFF( var_108 ) = (U16)(tail - var_108);
     ARG_SET( var_108, var_117 );



     if (trie->jump)
         trie->jump[0] = (U16)(nextbranch - var_108);







            if ( !trie->states[trie->startstate].wordnum
   && trie->bitmap
   && ( (char *)jumper - (char *)var_108) >= (int)sizeof(struct struct_117) )
            {
                OP( var_108 ) = TRIEC;
                Copy(trie->bitmap, ((struct struct_117 *)var_108)->bitmap, ANYOF_BITMAP_SIZE, char);
                PerlMemShared_free(trie->bitmap);
                trie->bitmap= NULL;
            } else
                OP( var_108 ) = TRIE;


            var_108->flags = var_108;
            DEBUG_r({
            optimize = var_108
                      + NODE_STEP_REGNODE
                      + regarglen[ OP( var_108 ) ];
            });


        }

        DEBUG_r(if (optimize) {
            regnode *opt = var_108;

            while ( ++opt < optimize) {
                                                 ;
            }




            while( optimize < jumper ) {
                                                                     ;
                OP( optimize ) = OPTIMIZED;
                                                      ;
                optimize++;
            }
                                                                    ;
        });
    }

    {
 U16 word;
 U32 var_108;
 U16 prev;

 for (word=1; word <= trie->wordcount; word++) {
     prev = 0;
     if (trie->wordinfo[word].prev)
  continue;
     var_108 = trie->wordinfo[word].accept;
     while (var_108) {
  var_108 = prev_states[var_108];
  if (!var_108)
      break;
  prev = trie->states[var_108].wordnum;
  if (prev)
      break;
     }
     trie->wordinfo[word].prev = prev;
 }
 Safefree(prev_states);
    }



    DEBUG_TRIE_COMPILE_r(dump_trie(trie, widecharmap, revcharmap, var_486+1));

    (var_491->rxi)->data->data[ var_117 + 1 ] = (void*)widecharmap;




    SvREFCNT_dec_NN(revcharmap);

    return trie->jump
           ? 2
           : trie->startstate>1
             ? 4
             : 1;
}

static regnode *
fn_108(pTHX_ RExC_state_t *var_491, regnode *source, U32 var_486)
{

    const U32 var_117 = ARG(source);
    reg_trie_data *trie=(reg_trie_data *)(var_491->rxi)->data->data[var_117];
    U32 *q;
    const U32 var_119 = trie->uniquecharcount;
    const U32 var_119 = trie->statecount;
    const U32 var_119 = trie->lasttrans + var_119;
    U32 var_119 = 0;
    U32 var_119 = 0;
    U32 var_119;
    U32 var_118 = trie->states[ 1 ].trans.base;
    U32 *fail;
    reg_ac_data *aho;
    const U32 var_117 = add_data( var_491, STR_WITH_LEN("T"));
    regnode *stclass;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE;
    PERL_UNUSED_CONTEXT;

    PERL_UNUSED_ARG(var_486);


    if ( OP(source) == TRIE ) {
        struct struct_117 *var_512 = (struct struct_117 *)
            PerlMemShared_calloc(1, sizeof(struct struct_117));
        StructCopy(source, var_512, struct regnode_1);
        stclass = (regnode *)var_512;
    } else {
        struct struct_117 *var_512 = (struct struct_117 *)
            PerlMemShared_calloc(1, sizeof(struct struct_117));
        StructCopy(source, var_512, struct regnode_charclass);
        stclass = (regnode *)var_512;
    }
    OP(stclass)+=2;

    ARG_SET( stclass, var_117 );
    aho = (reg_ac_data *) PerlMemShared_calloc( 1, sizeof(reg_ac_data) );
    (var_491->rxi)->data->data[ var_117 ] = (void*)aho;
    aho->trie=var_117;
    aho->states=(reg_trie_state *)PerlMemShared_malloc( var_119 * sizeof(reg_trie_state) );
    Copy( trie->states, aho->states, var_119, reg_trie_state );
    Newx( q, var_119, U32);
    aho->fail = (U32 *) PerlMemShared_calloc( var_119, sizeof(U32) );
    aho->refcount = 1;
    fail = aho->fail;


    fail[ 0 ] = fail[ 1 ] = 1;

    for ( var_119 = 0; var_119 < var_119 ; var_119++ ) {
 const U32 var_117 = ( ( var_118 + var_119 >= var_119 && var_118 + var_119 < var_119 && 1 == trie->trans[ var_118 - var_119 + var_119 ].check && trie->trans[ var_118 - var_119 + var_119 ].next ) ? trie->trans[ var_118 - var_119 + var_119 ].next : ( 1==1 ? 0 : 0 ) );
 if ( var_117 ) {
            q[ var_119 ] = var_117;

            fail[ q[ var_119++ ] ]=1;
        }
    }
    while ( var_119 < var_119) {
 const U32 var_531 = q[ var_119++ % var_119 ];
        var_118 = trie->states[ var_531 ].trans.base;

        for ( var_119 = 0 ; var_119 < var_119 ; var_119++ ) {
     const U32 var_119 = ( ( var_118 + var_119 >= var_119 && var_118 + var_119 < var_119 && var_531 == trie->trans[ var_118 - var_119 + var_119 ].check && trie->trans[ var_118 - var_119 + var_119 ].next ) ? trie->trans[ var_118 - var_119 + var_119 ].next : ( var_531==1 ? 1 : 0 ) );
     if (var_119) {
                U32 var_119 = var_531;
                U32 fail_base;
                do {
                    var_119 = fail[ var_119 ];
                    fail_base = aho->states[ var_119 ].trans.base;
                } while ( !( ( fail_base + var_119 >= var_119 && fail_base + var_119 < var_119 && var_119 == trie->trans[ fail_base - var_119 + var_119 ].check && trie->trans[ fail_base - var_119 + var_119 ].next ) ? trie->trans[ fail_base - var_119 + var_119 ].next : ( var_119==1 ? 1 : 0 ) ) );

                var_119 = ( ( fail_base + var_119 >= var_119 && fail_base + var_119 < var_119 && var_119 == trie->trans[ fail_base - var_119 + var_119 ].check && trie->trans[ fail_base - var_119 + var_119 ].next ) ? trie->trans[ fail_base - var_119 + var_119 ].next : ( var_119==1 ? 1 : 0 ) );
                fail[ var_119 ] = var_119;
                if ( !aho->states[ var_119 ].wordnum && aho->states[ var_119 ].wordnum )
                {
                        aho->states[ var_119 ].wordnum = aho->states[ var_119 ].wordnum;
                }
                q[ var_119++ % var_119] = var_119;
            }
        }
    }






    fail[ 0 ] = fail[ 1 ] = 0;
    DEBUG_TRIE_COMPILE_r({
        Perl_re_indentf( aTHX_ "Stclass Failtable (%" UVuf " states): 0",
                      var_486, (UV)var_119
        );
        for( var_119=1; var_119<var_119; var_119++ ) {
            Perl_re_printf( aTHX_ ", %" UVuf, (UV)fail[var_119]);
        }
        Perl_re_printf( aTHX_ "\n");
    });
    Safefree(q);

    return stclass;
}

static U32
fn_119(pTHX_ RExC_state_t *var_491, regnode *var_486,
                   UV *var_167, bool *var_167,
                   U32 var_451, regnode *var_486, U32 var_486)
{


    regnode *var_498 = regnext(var_486);
    U32 var_127 = 1;
    regnode *next = var_486 + NODE_SZ_STR(var_486);
    U32 var_128 = 0;
    U32 var_135 = 0;




    PERL_UNUSED_ARG(var_486);


    PERL_ARGS_ASSERT_JOIN_EXACT;

    PERL_UNUSED_ARG(var_451);
    PERL_UNUSED_ARG(var_486);

    NOOP;

    assert(PL_regkind[OP(var_486)] == var_454);



    while ( var_498
           && ( PL_regkind[OP(var_498)] == NOTHING
               || (var_127 && PL_regkind[OP(var_498)] == var_454))
           && NEXT_OFF(var_498)
           && NEXT_OFF(var_486) + NEXT_OFF(var_498) < I16_MAX)
    {

        if (OP(var_498) == TAIL || var_498 > next)
            var_127 = 0;
        if (PL_regkind[OP(var_498)] == NOTHING) {
            NOOP;
            NEXT_OFF(var_486) += NEXT_OFF(var_498);
            next = var_498 + NODE_STEP_REGNODE;




            var_498 = regnext(var_498);
        }
        else if (var_127) {
            const unsigned int var_128 = STR_LEN(var_486);
            regnode * const nnext = regnext(var_498);





            if (var_128 + STR_LEN(var_498) > U8_MAX)
                break;



            if (OP(var_486) == var_454 && (OP(var_498) == EXACT_ONLY8)) {
                OP(var_486) = EXACT_ONLY8;
            }
            else if (OP(var_486) == EXACT_ONLY8 && (OP(var_498) == var_454)) {
                ;
            }
            else if ((OP(var_486) == EXACTFU) && (OP(var_498) == EXACTFU_ONLY8)) {
                OP(var_486) = EXACTFU_ONLY8;
            }
            else if ((OP(var_486) == EXACTFU_ONLY8) && (OP(var_498) == EXACTFU)) {
                ;
            }
            else if (OP(var_486) == EXACTFU && OP(var_498) == EXACTFU) {
                ;
            }
            else if (OP(var_486) == EXACTFU && OP(var_498) == EXACTFU_S_EDGE) {

                if (STRING(var_498)[STR_LEN(var_498)-1] == 's') {





                    if (OP(nnext) == EXACTF) {
                        break;
                    }

                    OP(var_486) = EXACTFU_S_EDGE;

                }

            }
            else if (OP(var_486) == EXACTF && OP(var_498) == EXACTF) {
                ;
            }
            else if (OP(var_486) == EXACTF && OP(var_498) == EXACTFU_S_EDGE) {






                if (OP(nnext) == EXACTFU) {
                    break;
                }



            }
            else if (OP(var_486) == EXACTFU_S_EDGE && OP(var_498) == EXACTFU_S_EDGE) {
                if ( STRING(var_486)[STR_LEN(var_486)-1] == 's'
                    && STRING(var_498)[0] == 's')
                {


                    OP(var_486) = EXACTF;
                }
            }
            else if (OP(var_486) == EXACTFU_S_EDGE && OP(var_498) == EXACTFU) {
                if (STRING(var_498)[0] == 's') {
                    ;

                }
                else {
                    OP(var_486) = EXACTFU;
                }
            }
            else if (OP(var_486) == EXACTFU_S_EDGE && OP(var_498) == EXACTF) {



                OP(var_486) = EXACTF;
            }
            else if (OP(var_486) != OP(var_498)) {


                break;
            }

            NOOP;
            var_128++;

            NEXT_OFF(var_486) += NEXT_OFF(var_498);
            STR_LEN(var_486) += STR_LEN(var_498);
            next = var_498 + NODE_SZ_STR(var_498);

            Move(STRING(var_498), STRING(var_486) + var_128, STR_LEN(var_498), char);



            var_498 = nnext;
            if (var_135) break;
        }

    }



    if (OP(var_486) == EXACTFU_S_EDGE) {
        OP(var_486) = EXACTFU;
    }

    *var_167 = 0;
    *var_167 = FALSE;






    if (OP(var_486) != var_454 && OP(var_486) != EXACT_ONLY8 && OP(var_486) != EXACTL) {
        U8* var_512 = (U8*) STRING(var_486);
        U8* var_512 = var_512;
        U8* s_end = var_512 + STR_LEN(var_486);

        int var_134 = 0;






 if (cBOOL((var_491->utf8))) {
            U8* var_455 = NULL;

            if (OP(var_486) == EXACTFL) {
                U8 *var_451;

                Newx(var_455, UTF8_MAX_FOLD_CHAR_EXPAND * STR_LEN(var_486) + 1, U8);
                var_451 = var_455;
                while (var_512 < s_end) {
                    STRLEN var_133 = UTF8SKIP(var_512);
                    if (! is_PROBLEMATIC_LOCALE_FOLD_utf8(var_512)) {
                        Copy(var_512, var_451, var_133, U8);
                        var_451 += var_133;
                    }
                    else if (is_FOLDS_TO_MULTI_utf8(var_512)) {
                        *var_167 = TRUE;
                        Copy(var_512, var_451, var_133, U8);
                        var_451 += var_133;
                    }
                    else if (isASCII(*var_512)) {
                        *(var_451++) = toFOLD(*var_512);
                    }
                    else {
                        STRLEN var_531;
                        _toFOLD_utf8_flags(var_512, s_end, var_451, &var_531, FOLD_FLAGS_FULL);
                        var_451 += var_531;
                    }
                    var_512 += var_133;
                }



                var_512 = var_455;
                s_end = var_451;
            }




            while (var_512 < s_end - 1)

     {
                int var_489 = 0;
                int var_531 = is_MULTI_CHAR_FOLD_utf8_safe(var_512, s_end);
                if (! var_531) {
                    var_512 += UTF8SKIP(var_512);
                    continue;
                }

                {
                    U8* multi_end = var_512 + var_531;




                    if (OP(var_486) != EXACTFAA && OP(var_486) != EXACTFAA_NO_TRIE) {
                        var_489 = utf8_length(var_512, multi_end);
                        var_512 = multi_end;
                    }
                    else {
                        while (var_512 < multi_end) {
                            if (isASCII(*var_512)) {
                                var_512++;
                                goto next_iteration;
                            }
                            else {
                                var_512 += UTF8SKIP(var_512);
                            }
                            var_489++;
                        }
                    }
                }



                var_134 += var_489 - 1;
              next_iteration: ;
     }




            if (OP(var_486) == EXACTFL) {
                int var_134 = utf8_length((U8*) STRING(var_486),
                                           (U8*) STRING(var_486) + STR_LEN(var_486));
                if (var_134 > var_134) {
                    var_134 = var_134;
                }
            }

            *var_167 += var_134;
            Safefree(var_455);
 }
 else if (OP(var_486) == EXACTFAA) {

 }

        if ( STR_LEN(var_486) == 1
            && isALPHA_A(* STRING(var_486))
            && ( OP(var_486) == EXACTFAA
                 || ( OP(var_486) == EXACTFU
                     && ! _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(* STRING(var_486)))))
        {
            U8 var_171 = ~ ('A' ^ 'a');





            OP(var_486) = ANYOFM;
            ARG_SET(var_486, *STRING(var_486) & var_171);
            FLAGS(var_486) = var_171;
        }
    }

    DEBUG_OPTIMISE_r(if (merged){NOOP;});
    return var_135;
}

static void
fn_135(pTHX_ const void *var_499)
{
    scan_frame *var_182= (scan_frame *)var_499;
    do {
        scan_frame *var_498= var_182->next_frame;
        Safefree(var_182);
        var_182= var_498;
    } while (var_182);
}


static SSize_t
fn_138(pTHX_ RExC_state_t *var_491, regnode **scanp,
                        SSize_t *minlenp, SSize_t *deltap,
   regnode *last,
   scan_data_t *data,
   I32 var_182,
                        U32 var_182,
   regnode_ssc *and_withp,
   U32 var_451, U32 var_486)







{
    dVAR;

    SSize_t var_512 = 0;
    I32 var_182 = 0, var_205;
    regnode *var_486 = *scanp, *next;
    SSize_t var_183 = 0;
    int var_182 = (var_451 & 0x0400) && (data->flags & 0x0040);
    int var_182 = 0;
    I32 var_182 = OP(var_486) == OPEN ? ARG(var_486) : 0;
    scan_data_t data_fake;
    SV *re_trie_maxbuff = NULL;
    regnode *first_non_open = var_486;
    SSize_t var_183 = var_245;
    scan_frame *frame = NULL;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_STUDY_CHUNK;
    (var_491->study_started)= 1;

    Zero(&data_fake, 1, scan_data_t);

    if ( var_486 == 0 ) {
        while (first_non_open && OP(first_non_open) == OPEN)
            first_non_open=regnext(first_non_open);
    }


  fake_study_recurse:
    DEBUG_r(
        RExC_study_chunk_recursed_count++;
    );
    DEBUG_OPTIMISE_MORE_r(
    {
        Perl_re_indentf( aTHX_ "study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p",
            var_486, (long)var_182,
            (unsigned long)RExC_study_chunk_recursed_count,
            (unsigned long)var_486, (unsigned long)var_182,
            var_486,
            last);
        if (var_182) {
            U32 var_531;
            U32 var_533;
            for ( var_533 = 0 ; var_533 < var_182 ; var_533++ ) {
                for ( var_531 = 0 ; var_531 < (U32)(var_491->total_par) ; var_531++ ) {
                    if (
                        ( ((U8*)((var_491->study_chunk_recursed) + ( var_533 * (var_491->study_chunk_recursed_bytes))))[(var_531) >> 3] & (1 << ((var_531) & 7)))

                        && (
                            !var_533 ||
                            !( ((U8*)((var_491->study_chunk_recursed) + (( var_533 - 1 ) * (var_491->study_chunk_recursed_bytes))))[(var_531) >> 3] & (1 << ((var_531) & 7)))

                        )
                    ) {
                        Perl_re_printf( aTHX_ " %d",(int)var_531);
                        break;
                    }
                }
                if ( var_533 + 1 < var_182 ) {
                    Perl_re_printf( aTHX_ ",");
                }
            }
        }
        Perl_re_printf( aTHX_ "\n");
    }
    );
    while ( var_486 && OP(var_486) != var_461 && var_486 < last ){
        UV var_167 = 0;


 bool var_167 = FALSE;

        NOOP;
        NOOP;







        if (PL_regkind[OP(var_486)] == var_454) join_exact(var_491,(var_486),(&var_167),&var_167, 0, NULL, var_486+1);



 if (OP(var_486) != CURLYX) {
     const int var_512 = (reg_off_by_arg[OP(var_486)]
         ? var_387

         : (var_387 < U16_MAX ? var_387 : U16_MAX));
     int var_152 = (reg_off_by_arg[OP(var_486)] ? ARG(var_486) : NEXT_OFF(var_486));
     int noff;
     regnode *var_498 = var_486;


     while ((var_498 = regnext(var_498))
     && ((PL_regkind[OP(var_498)] == NOTHING && (noff = NEXT_OFF(var_498)))
         || ((OP(var_498) == LONGJMP) && (noff = ARG(var_498))))
     && var_152 + noff < var_512)
  var_152 += noff;
     if (reg_off_by_arg[OP(var_486)])
  ARG(var_486) = var_152;
     else
  NEXT_OFF(var_486) = var_152;
 }



        if ( OP(var_486) == DEFINEP ) {
            SSize_t var_245 = 0;
            SSize_t var_182 = 0;
            SSize_t var_155 = 0;
            I32 var_182 = 0x20000;

            StructCopy(&var_243, &data_fake, scan_data_t);
            var_486 = regnext(var_486);
            assert( OP(var_486) == IFTHEN );
            NOOP;

            data_fake.last_closep= &var_155;
            var_245 = *minlenp;
            next = regnext(var_486);
            var_486 = NEXTOPER(NEXTOPER(var_486));
            NOOP;
            NOOP;




            (void)study_chunk(var_491, &var_486, &var_245,
                              &var_182, next, &data_fake, var_182,
                              var_182, NULL, var_182, var_486+1);

            var_486 = next;
        } else
        if (
            OP(var_486) == BRANCH ||
            OP(var_486) == BRANCHJ ||
            OP(var_486) == IFTHEN
        ) {
     next = regnext(var_486);
     var_205 = OP(var_486);






     if (OP(next) == var_205 || var_205 == IFTHEN) {



  SSize_t var_159 = 0, var_159 = var_245, var_387 = 0;
  regnode_ssc accum;
  regnode * const startbranch=var_486;

                if (var_451 & 0x0400) {

                    scan_commit(var_491, data, minlenp, var_182);
                }

                if (var_451 & (0x0800|0x1000))
      ssc_init(var_491, &accum);

  while (OP(var_486) == var_205) {
      SSize_t var_182, minnext, var_245;
      I32 var_182 = 0;
      regnode_ssc this_class;

                    NOOP;

      var_387++;
                    StructCopy(&var_243, &data_fake, scan_data_t);
      if (data) {
   data_fake.whilem_c = data->whilem_c;
   data_fake.last_closep = data->last_closep;
      }
      else
   data_fake.last_closep = &var_245;

      data_fake.pos_delta = var_183;
      next = regnext(var_486);

                    var_486 = NEXTOPER(var_486);
                    if (var_205 != BRANCH)
   var_486 = NEXTOPER(var_486);

      if (var_451 & (0x0800|0x1000)) {
   ssc_init(var_491, &this_class);
   data_fake.start_class = &this_class;
   var_182 = 0x0800;
      }
      if (var_451 & 0x2000)
   var_182 |= 0x2000;



      minnext = study_chunk(var_491, &var_486, minlenp,
                                      &var_182, next, &data_fake, var_182,
                                      var_182, NULL, var_182, var_486+1);

      if (var_159 > minnext)
   var_159 = minnext;
      if (var_182 == var_245) {
   var_182 = var_182 = 1;
   var_159 = var_245;
      } else if (var_159 < minnext + var_182)
   var_159 = minnext + var_182;
      var_486 = next;
      if (data_fake.flags & (0x0080|0x0100))
   var_182++;
             if (data_fake.flags & 0x8000) {
                 if ( var_183 > minnext)
                     var_183 = var_512 + var_159;
                 var_451 &= ~0x0400;
                 if (data)
                     data->flags |= 0x8000;
             }
      if (data) {
   if (data_fake.flags & 0x0200)
       data->flags |= 0x0200;
   data->whilem_c = data_fake.whilem_c;
      }
      if (var_451 & (0x0800|0x1000))
   ssc_or(var_491, &accum, (regnode_charclass*)&this_class);
  }
  if (var_205 == IFTHEN && var_387 < 2)
      var_159 = 0;
  if (var_451 & 0x0400) {
      data->pos_min += var_159;
      if (data->pos_delta >= var_245 - (var_159 - var_159))
          data->pos_delta = var_245;
      else
          data->pos_delta += var_159 - var_159;
      if (var_159 != var_159 || var_182)
   data->cur_is_floating = 1;
  }
  var_512 += var_159;
  if (var_183 == var_245
   || var_245 - var_183 - (var_159 - var_159) < 0)
      var_183 = var_245;
  else
      var_183 += var_159 - var_159;
  if (var_451 & 0x1000) {
      ssc_or(var_491, data->start_class, (regnode_charclass*) &accum);
      if (var_159) {
   ssc_and(var_491, data->start_class, (regnode_charclass *) and_withp);
   var_451 &= ~(0x0800|0x1000);
      }
  }
  else if (var_451 & 0x0800) {
      if (var_159) {
   ssc_and(var_491, data->start_class, (regnode_charclass *) &accum);
   var_451 &= ~(0x0800|0x1000);
      }
      else {


   assert(!and_withp); Newx(and_withp, 1, regnode_ssc); SAVEFREEPV(and_withp);
   StructCopy(data->start_class, and_withp, regnode_ssc);
   var_451 &= ~0x0800;
   StructCopy(&accum, data->start_class, regnode_ssc);
   var_451 |= 0x1000;
      }
  }

                if (PERL_ENABLE_TRIE_OPTIMISATION &&
                        OP( startbranch ) == BRANCH )
                {

      int var_165=0;
      if (!re_trie_maxbuff) {
   re_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);
   if (!SvIOK(re_trie_maxbuff))
       sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);
      }
                    if ( SvIV(re_trie_maxbuff)>=0 ) {
                        regnode *var_531;
                        regnode *var_369 = (regnode *)NULL;
                        regnode *last = (regnode *)NULL;
                        regnode *tail = var_486;
                        U8 var_165 = 0;
                        U32 var_489=0;

                        while ( OP( tail ) == TAIL ) {

                            tail = regnext( tail );
                        }


                        DEBUG_TRIE_COMPILE_r({
                            regprop((var_491->rx), RExC_mysv, tail, NULL, var_491);
                            Perl_re_indentf( aTHX_ "%s %" UVuf ":%s\n",
                              var_486+1,
                              "Looking for TRIE'able sequences. Tail node is ",
                              (UV) ((tail) - (var_491->emit_start)),
                              SvPV_nolen_const( RExC_mysv )
                            );
                        });

                        for ( var_531 = startbranch ; var_531 != var_486 ; var_531 = regnext( var_531 ) ) {
                            regnode * const noper = NEXTOPER( var_531 );
                            U8 var_163 = OP( noper );
                            U8 var_165 = ( ( NOTHING == (var_163) ) ? NOTHING : ( var_454 == (var_163) || EXACT_ONLY8 == (var_163) ) ? var_454 : ( EXACTFU == (var_163) || EXACTFU_ONLY8 == (var_163) || EXACTFUP == (var_163) ) ? EXACTFU : ( EXACTFAA == (var_163) ) ? EXACTFAA : ( EXACTL == (var_163) ) ? EXACTL : ( EXACTFLU8 == (var_163) ) ? EXACTFLU8 : 0 );






                            DEBUG_TRIE_COMPILE_r({
                                regprop((var_491->rx), RExC_mysv, var_531, NULL, var_491);
                                Perl_re_indentf( aTHX_ "- %d:%s (%d)",
                                   var_486+1,
                                   ((var_531) ? (int)((var_531)-(var_491->emit_start)) : -1), SvPV_nolen_const( RExC_mysv ), ((var_531) ? (int)((var_531)-(var_491->emit_start)) : -1) );

                                regprop((var_491->rx), RExC_mysv, noper, NULL, var_491);
                                Perl_re_printf( aTHX_ " -> %d:%s",
                                    ((noper) ? (int)((noper)-(var_491->emit_start)) : -1), SvPV_nolen_const(RExC_mysv));

                                if ( noper_next ) {
                                  regprop((var_491->rx), RExC_mysv, noper_next, NULL, var_491);
                                  Perl_re_printf( aTHX_ "\t=> %d:%s\t",
                                    ((noper_next) ? (int)((noper_next)-(var_491->emit_start)) : -1), SvPV_nolen_const(RExC_mysv));
                                }
                                Perl_re_printf( aTHX_ "(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\n",
                                   ((var_369) ? (int)((var_369)-(var_491->emit_start)) : -1), ((last) ? (int)((last)-(var_491->emit_start)) : -1), ((var_531) ? (int)((var_531)-(var_491->emit_start)) : -1),
       PL_reg_name[var_165], PL_reg_name[var_165], PL_reg_name[var_165]
    );
                            });



                            if ( var_165
                                  &&
                                  (
                                        ( var_165 == NOTHING )
                                        || ( var_165 == NOTHING )
                                        || ( var_165 == var_165 )
                                  )



                                  && var_489 < U16_MAX)
                            {




                                if ( !var_369 ) {
                                    var_369 = var_531;
        if ( var_165 == NOTHING ) {

     regnode * const noper_next = regnext( noper );
                                        U8 var_165 = (noper_next && noper_next < tail) ? OP(noper_next) : 0;
     U8 var_165 = var_165 ? ( ( NOTHING == (var_165) ) ? NOTHING : ( var_454 == (var_165) || EXACT_ONLY8 == (var_165) ) ? var_454 : ( EXACTFU == (var_165) || EXACTFU_ONLY8 == (var_165) || EXACTFUP == (var_165) ) ? EXACTFU : ( EXACTFAA == (var_165) ) ? EXACTFAA : ( EXACTL == (var_165) ) ? EXACTL : ( EXACTFLU8 == (var_165) ) ? EXACTFLU8 : 0 ) :0;


                                        if ( var_165 ) {
         var_165 = var_165;
                                        } else if (var_165) {



                                            var_369 = NULL;
                                        }
                                    } else {
                                        var_165 = var_165;
                                    }
                                } else {
                                    if ( var_165 == NOTHING )
                                        var_165 = var_165;
                                    last = var_531;
                                }
    if (var_369)
        var_489++;
                            }
                            else {




                                if ( last ) {

                                    if ( var_165 && var_165 != NOTHING )
                                        make_trie( var_491,
                                                startbranch, var_369, var_531, tail,
                                                var_489, var_165, var_486+1 );
                                    last = NULL;


                                }
                                if ( var_165



                                ){


                                    var_489 = 1;
                                    var_369 = var_531;
                                    var_165 = var_165;
                                } else if (var_369) {



                                    var_489 = 0;
                                    var_369 = NULL;
                                    var_165 = 0;
                                }
                            }
                        }
                        DEBUG_TRIE_COMPILE_r({
                            regprop((var_491->rx), RExC_mysv, var_531, NULL, var_491);
                            Perl_re_indentf( aTHX_ "- %s (%d) <SCAN FINISHED> ",
                              var_486+1, SvPV_nolen_const( RExC_mysv ), ((var_531) ? (int)((var_531)-(var_491->emit_start)) : -1));
                            Perl_re_printf( aTHX_ "(First==%d, Last==%d, Cur==%d, tt==%s)\n",
                               ((var_369) ? (int)((var_369)-(var_491->emit_start)) : -1), ((last) ? (int)((last)-(var_491->emit_start)) : -1), ((var_531) ? (int)((var_531)-(var_491->emit_start)) : -1),
                               PL_reg_name[var_165]
                            );

                        });
                        if ( last && var_165 ) {
                            if ( var_165 != NOTHING ) {



                                var_165= make_trie( var_491, startbranch,
                                                 var_369, var_486, tail, var_489,
                                                 var_165, var_486+1 );

                            } else {





                                if ( startbranch == var_369 ) {
                                    regnode *opt;



                                    DEBUG_TRIE_COMPILE_r({
                                        regprop((var_491->rx), RExC_mysv, var_531, NULL, var_491);
                                        Perl_re_indentf( aTHX_ "- %s (%d) <NOTHING BRANCH SEQUENCE>\n",
                                          var_486+1,
                                          SvPV_nolen_const( RExC_mysv ), ((var_531) ? (int)((var_531)-(var_491->emit_start)) : -1));

                                    });
                                    OP(startbranch)= NOTHING;
                                    NEXT_OFF(startbranch)= tail - startbranch;
                                    for ( opt= startbranch + 1; opt < tail ; opt++ )
                                        OP(opt)= OPTIMIZED;
                                }
                            }
                        }
                    }

                }

     }
     else if ( var_205 == BRANCHJ ) {
  var_486 = NEXTOPER(NEXTOPER(var_486));
     } else
  var_486 = NEXTOPER(var_486);
     continue;
        } else if (OP(var_486) == SUSPEND || OP(var_486) == GOSUB) {
            I32 var_485 = 0;
            regnode *var_463 = NULL;
            regnode *var_454 = NULL;
            U32 var_167= var_182;

            if (OP(var_486) != SUSPEND) {




                var_485 = ARG(var_486);
                (var_491->recurse)[ARG2L(var_486)] = var_486;
                var_463 = ((var_491->emit_start) + ((var_491->open_parens)[var_485]));
                var_454 = ((var_491->emit_start) + ((var_491->close_parens)[var_485]));



                if (
                    ( var_451 & 0x20000 )
                    ||
                    (
                        (var_182 || var_182 || (data && data->flags & 0x0040))
                        &&
                        ( (var_451 & ((0x0800|0x1000) | 0x0400)) == 0 )
                    )
                ) {

                    var_486= regnext(var_486);
                    continue;
                }

                if (
                    !var_182
                    ||
                    !( ((U8*)((var_491->study_chunk_recursed) + ((var_182-1) * (var_491->study_chunk_recursed_bytes))))[(var_485) >> 3] & (1 << ((var_485) & 7)))
                ) {

                    if (!var_182) {
                        Zero((var_491->study_chunk_recursed), (var_491->study_chunk_recursed_bytes), U8);
                    } else {
                        Copy((var_491->study_chunk_recursed) + ((var_182-1) * (var_491->study_chunk_recursed_bytes)),
                             (var_491->study_chunk_recursed) + (var_182 * (var_491->study_chunk_recursed_bytes)),
                             (var_491->study_chunk_recursed_bytes), U8);
                    }

                    NOOP;
                    ((U8*)((var_491->study_chunk_recursed) + (var_182 * (var_491->study_chunk_recursed_bytes))))[(var_485) >> 3] |= (1 << ((var_485) & 7));
                    var_167= var_182 + 1;
                } else {
                    NOOP;


                    if (var_451 & 0x0400) {
                        scan_commit(var_491, data, minlenp, var_182);
                        data->cur_is_floating = 1;
                    }
                    var_182 = var_182 = 1;
                    if (var_451 & 0x1000)
                        ssc_anything(data->start_class);
                    var_451 &= ~(0x0800|0x1000);

                    var_463= NULL;
         }
            } else {
         var_485 = var_182;
                var_463 = var_486 + 2;
         var_454 = regnext(var_486);
     }
            if (var_463) {
                scan_frame *newframe;
                assert(var_454);
                if (!(var_491->frame_last)) {
                    Newxz(newframe, 1, scan_frame);
                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);
                    (var_491->frame_head)= newframe;
                    (var_491->frame_count)++;
                } else if (!(var_491->frame_last)->next_frame) {
                    Newxz(newframe, 1, scan_frame);
                    (var_491->frame_last)->next_frame= newframe;
                    newframe->prev_frame= (var_491->frame_last);
                    (var_491->frame_count)++;
                } else {
                    newframe= (var_491->frame_last)->next_frame;
                }
                (var_491->frame_last)= newframe;

                newframe->next_regnode = regnext(var_486);
                newframe->last_regnode = last;
                newframe->stopparen = var_182;
                newframe->prev_recursed_depth = var_182;
                newframe->this_prev_frame= frame;

                NOOP;
                NOOP;

         frame = newframe;
         var_486 = var_463;
         var_182 = var_485;
         last = var_454;
                var_486 = var_486 + 1;
                var_182= var_167;

         continue;
     }
 }
 else if ( OP(var_486) == var_454
                 || OP(var_486) == EXACT_ONLY8
                 || OP(var_486) == EXACTL)
        {
     SSize_t var_178 = STR_LEN(var_486);
     UV uc;
            assert(var_178);
     if (cBOOL((var_491->utf8))) {
  const U8 * const var_512 = (U8*)STRING(var_486);
  uc = utf8_to_uvchr_buf(var_512, var_512 + var_178, NULL);
  var_178 = utf8_length(var_512, var_512 + var_178);
     } else {
  uc = *((U8*)STRING(var_486));
     }
     var_512 += var_178;
     if (var_451 & 0x0400) {


  if (data->last_end == -1) {
      data->last_start_min = data->pos_min;
       data->last_start_max = var_182
    ? var_245 : data->pos_min + data->pos_delta;
  }
  sv_catpvn(data->last_found, STRING(var_486), STR_LEN(var_486));
  if (cBOOL((var_491->utf8)))
      SvUTF8_on(data->last_found);
  {
      SV * const sv = data->last_found;
      MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?
   mg_find(sv, PERL_MAGIC_utf8) : NULL;
      if (mg && mg->mg_len >= 0)
   mg->mg_len += utf8_length((U8*)STRING(var_486),
                                              (U8*)STRING(var_486)+STR_LEN(var_486));
  }
  data->last_end = data->pos_min + var_178;
  data->pos_min += var_178;
  data->flags &= ~(0x0001|0x0002);
     }



     if (var_451 & 0x0800) {
                ssc_cp_and(data->start_class, uc);
                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
                ssc_clear_locale(data->start_class);
     }
     else if (var_451 & 0x1000) {
                ssc_add_range((data->start_class), (uc), (uc));
  ssc_and(var_491, data->start_class, (regnode_charclass *) and_withp);


                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
     }
     var_451 &= ~(0x0800|0x1000);
 }
        else if (PL_regkind[OP(var_486)] == var_454) {

     SSize_t var_178 = STR_LEN(var_486);
            const U8 * var_512 = (U8*)STRING(var_486);


     if (var_451 & 0x0400) {
  assert(data);
                scan_commit(var_491, data, minlenp, var_182);
     }
     if (cBOOL((var_491->utf8))) {
  var_178 = utf8_length(var_512, var_512 + var_178);
     }
     if (var_167) {
                (var_491->seen) |= REG_UNFOLDED_MULTI_SEEN;
     }
     var_512 += var_178 - var_167;
            assert (var_512 >= 0);
            var_183 += var_167;
     if (var_451 & 0x0400) {
  data->pos_min += var_178 - var_167;
  if (data->pos_min < 0) {
                    data->pos_min = 0;
                }
                data->pos_delta += var_167;
  if (var_167) {
      data->cur_is_floating = 1;
  }
     }

            if (var_451 & (0x0800|0x1000)) {
                SV* EXACTF_invlist = _make_exactf_invlist(var_491, var_486);

                assert(EXACTF_invlist);
                if (var_451 & 0x0800) {
                    if (OP(var_486) != EXACTFL)
                        ssc_clear_locale(data->start_class);
                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
                    ANYOF_POSIXL_ZERO(data->start_class);
                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);
                }
                else {
                    ssc_union(data->start_class, EXACTF_invlist, FALSE);
                    ssc_and(var_491, data->start_class, (regnode_charclass *) and_withp);


                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;
                }
                var_451 &= ~(0x0800|0x1000);
                SvREFCNT_dec(EXACTF_invlist);
            }
 }
 else if (REGNODE_VARIES(OP(var_486))) {
     SSize_t mincount, maxcount, minnext, var_182, var_178 = 0;
     I32 var_178 = 0, var_182 = var_451;
     regnode * const oscan = var_486;
     regnode_ssc this_class;
     regnode_ssc *oclass = NULL;
     I32 var_172 = 0;

     switch (PL_regkind[OP(var_486)]) {
     case WHILEM:
  var_486 = NEXTOPER(var_486);
  goto finish;
     case PLUS:
  if (var_451 & (0x0400 | (0x0800|0x1000))) {
      next = NEXTOPER(var_486);
      if ( OP(next) == var_454
                        || OP(next) == EXACT_ONLY8
                        || OP(next) == EXACTL
                        || (var_451 & (0x0800|0x1000)))
                    {
   mincount = 1;
   maxcount = var_372;
   next = regnext(var_486);
   var_486 = NEXTOPER(var_486);
   goto do_curly;
      }
  }
  if (var_451 & 0x0400)
      data->pos_min++;
  var_512++;

     case STAR:
                next = NEXTOPER(var_486);



                if (OP(next) == EXACTFU_S_EDGE) {
                    OP(next) = EXACTFU;
                }

                if ( STR_LEN(next) == 1
                    && isALPHA_A(* STRING(next))
                    && ( OP(next) == EXACTFAA
                        || ( OP(next) == EXACTFU
                            && ! _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(* STRING(next)))))
                {

                    U8 var_171 = ~ ('A' ^ 'a');

                    assert(isALPHA_A(* STRING(next)));






                    OP(next) = ANYOFM;
                    ARG_SET(next, *STRING(next) & var_171);
                    FLAGS(next) = var_171;
                }

  if (var_451 & (0x0800|0x1000)) {
      mincount = 0;
      maxcount = var_372;
      next = regnext(var_486);
      var_486 = NEXTOPER(var_486);
      goto do_curly;
  }
  if (var_451 & 0x0400) {
                    scan_commit(var_491, data, minlenp, var_182);

      data->cur_is_floating = 1;
  }
                var_182 = var_182 = 1;
                var_486 = regnext(var_486);
  goto optimize_curly_tail;
     case CURLY:
         if (var_182>0 && (OP(var_486)==CURLYN || OP(var_486)==CURLYM)
             && (var_486->flags == var_182))
  {
      mincount = 1;
      maxcount = 1;
  } else {
      mincount = ARG1(var_486);
      maxcount = ARG2(var_486);
  }
  next = regnext(var_486);
  if (OP(var_486) == CURLYX) {
      I32 var_172 = (data ? *(data->last_closep) : 0);
      var_486->flags = ((var_172 <= (I32)U8_MAX) ? (U8)var_172 : U8_MAX);
  }
  var_486 = NEXTOPER(var_486) + EXTRA_STEP_2ARGS;
  var_172 = (OP(var_486) == EVAL);
       do_curly:
  if (var_451 & 0x0400) {
                    if (mincount == 0)
                        scan_commit(var_491, data, minlenp, var_182);

      var_178 = data->pos_min;
  }
  if (data) {
      var_178 = data->flags;
      data->flags &= ~(0x0080|0x0100|0x0200);
      if (var_182)
   data->flags |= 0x0040;
  }
  if (var_451 & (0x0800|0x1000)) {
      ssc_init(var_491, &this_class);
      oclass = data->start_class;
      data->start_class = &this_class;
      var_182 |= 0x0800;
      var_182 &= ~0x1000;
  }

               if ((mincount > 1) || (maxcount > 1 && maxcount != var_372))
      var_182 &= ~0x2000;



  minnext = study_chunk(var_491, &var_486, minlenp, &var_182,
                                  last, data, var_182, var_182, NULL,
                                  (mincount == 0
                                   ? (var_182 & ~0x0400)
                                   : var_182)
                                  ,var_486+1);

  if (var_451 & (0x0800|0x1000))
      data->start_class = oclass;
  if (mincount == 0 || minnext == 0) {
      if (var_451 & 0x1000) {
   ssc_or(var_491, data->start_class, (regnode_charclass *) &this_class);
      }
      else if (var_451 & 0x0800) {


   assert(!and_withp); Newx(and_withp, 1, regnode_ssc); SAVEFREEPV(and_withp);
   StructCopy(data->start_class, and_withp, regnode_ssc);
   var_451 &= ~0x0800;
   StructCopy(&this_class, data->start_class, regnode_ssc);
   var_451 |= 0x1000;
                        ANYOF_FLAGS(data->start_class)
                                                |= SSC_MATCHES_EMPTY_STRING;
      }
  } else {
      if (var_451 & 0x1000) {
   ssc_or(var_491, data->start_class, (regnode_charclass *) &this_class);
   ssc_and(var_491, data->start_class, (regnode_charclass *) and_withp);
      }
      else if (var_451 & 0x0800)
   ssc_and(var_491, data->start_class, (regnode_charclass *) &this_class);
      var_451 &= ~(0x0800|0x1000);
  }
  if (!var_486)
      var_486 = next;
  if (((var_451 & (0x10000|0x0400))==0x0400)

      && (var_172 || !(mincount == 0 && maxcount == 1))
      && (minnext == 0) && (var_182 == 0)
      && data && !(data->flags & (0x0080|0x0100))
                    && maxcount <= var_372/3)

  {
      STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 5488, (var_491->precomp_end)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->precomp_end) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Quantifier unexpected on zero-length expression " "in regex m/%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (var_491->precomp_end) - (var_491->precomp), (var_491->precomp))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->precomp_end) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->precomp_end) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;





                }

  var_512 += minnext * mincount;
  var_182 |= var_182 == var_245
                         || (maxcount == var_372 && minnext + var_182 > 0);
  var_182 |= var_182;
                if (var_182) {
      var_183 = var_245;
                } else {
      var_183 += (minnext + var_182) * maxcount
                             - minnext * mincount;
                }

  if ( OP(oscan) == CURLYX && data
        && data->flags & 0x0100
        && !(data->flags & 0x0200)
        && !var_182 && minnext == 1 ) {

      regnode *var_174 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;
      regnode * const nxt1 = var_174;





      var_174 = regnext(var_174);
      if (!REGNODE_SIMPLE(OP(var_174))
   && !(PL_regkind[OP(var_174)] == var_454
        && STR_LEN(var_174) == 1))
   goto nogo;



      var_174 = regnext(var_174);
      if (OP(var_174) != CLOSE)
   goto nogo;
      if ((var_491->open_parens)) {


                        (var_491->open_parens)[ARG(nxt1)] = ((oscan) - (var_491->emit_start));


                        (var_491->close_parens)[ARG(nxt1)] = ((var_174) - (var_491->emit_start)) + 2;
      }

      oscan->flags = (U8)ARG(var_174);
      OP(oscan) = CURLYN;
      OP(nxt1) = NOTHING;

  }
       nogo:


  if ( OP(oscan) == CURLYX && data
        && !(data->flags & 0x0080)
        && !(data->flags & 0x0200)
        && !var_182
        && minnext != 0



                      && ! ((var_491->seen) & REG_UNFOLDED_MULTI_SEEN)
  ) {


      regnode *var_174 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;
      regnode *nxt2;

      OP(oscan) = CURLYM;
      while ( (nxt2 = regnext(var_174))
       && (OP(nxt2) != WHILEM))
   var_174 = nxt2;
      OP(nxt2) = SUCCEED;

      if ((data->flags & 0x0100) && OP(var_174) == CLOSE) {

   regnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;

   oscan->flags = (U8)ARG(var_174);
   if ((var_491->open_parens)) {

                            (var_491->open_parens)[ARG(nxt1)] = ((oscan) - (var_491->emit_start));


                            (var_491->close_parens)[ARG(nxt1)] = ((nxt2) - (var_491->emit_start))
                                                         + 1;
   }
   OP(nxt1) = OPTIMIZED;
   OP(var_174) = OPTIMIZED;

   study_chunk(var_491, &nxt1, minlenp, &var_182, var_174,
                                    NULL, var_182, var_182, NULL, 0,
                                    var_486+1);
      }
      else
   oscan->flags = 0;
  }
  else if ((OP(oscan) == CURLYX)
    && (var_451 & 0x2000)



    && (maxcount == var_372)
    && data) {


      regnode *var_174 = oscan + NEXT_OFF(oscan);

      if (OP(PREVOPER(var_174)) == NOTHING)
   var_174 += ARG(var_174);
                    var_174 = PREVOPER(var_174);
                    if (var_174->flags & 0xf) {

                    } else if (++data->whilem_c < 16) {
                        assert(data->whilem_c <= (var_491->whilem_seen));
                        var_174->flags = (U8)(data->whilem_c
                            | ((var_491->whilem_seen) << 4));
                    }
  }
  if (data && var_178 & (0x0080|0x0100))
      var_182++;
  if (var_451 & 0x0400) {
      SV *last_str = NULL;
                    STRLEN var_178 = 0;
      int var_178 = mincount != 0;

                    if (data->last_end > 0 && mincount != 0) {

   SSize_t var_307 = var_178 >= data->last_start_min
       ? var_178 : data->last_start_min;
   STRLEN var_178;
   const char * const var_512 = SvPV_const(data->last_found, var_178);
   SSize_t var_178 = var_307 - data->last_start_min;
                        assert(var_178 >= 0);

   if (cBOOL((var_491->utf8)))
       var_178 = utf8_hop_forward((U8*)var_512, var_178,
                                               (U8 *) SvEND(data->last_found))
                                - (U8*)var_512;
   var_178 -= var_178;

   last_str = newSVpvn_utf8(var_512 + var_178, var_178, cBOOL((var_491->utf8)));
                        var_178 = cBOOL((var_491->utf8)) ? utf8_length((U8*)(var_512 + var_178),
                                            (U8*)(var_512 + var_178 + var_178)) : var_178;
   if (var_182 == 0 && var_178 == var_307) {

       if (mincount > 1) {

    SvGROW(last_str, (mincount * var_178) + 1);
    repeatcpy(SvPVX(last_str) + var_178,
       SvPVX_const(last_str), var_178,
                                          mincount - 1);
    SvCUR_set(last_str, SvCUR(last_str) * mincount);

    SvCUR_set(data->last_found,
       SvCUR(data->last_found) - var_178);
    sv_catsv(data->last_found, last_str);
    {
        SV * sv = data->last_found;
        MAGIC *mg =
     SvUTF8(sv) && SvMAGICAL(sv) ?
     mg_find(sv, PERL_MAGIC_utf8) : NULL;
        if (mg && mg->mg_len >= 0)
     mg->mg_len += var_178 * (mincount-1);
    }
                                var_178 *= mincount;
    data->last_end += var_178 * (mincount - 1);
       }
   } else {

       data->last_start_min += minnext * (mincount - 1);
       data->last_start_max =
                              var_182
                               ? var_245
          : data->last_start_max +
                                 (maxcount - 1) * (minnext + data->pos_delta);
   }
      }

      data->pos_min += minnext * (mincount - var_178);

      if (var_182 == var_245
                        || -var_178 * var_182 + (minnext + var_182) * maxcount - minnext * mincount >= var_245 - data->pos_delta)
          data->pos_delta = var_245;
      else
          data->pos_delta += - var_178 * var_182 +
   (minnext + var_182) * maxcount - minnext * mincount;
      if (mincount != maxcount) {


                        scan_commit(var_491, data, minlenp, var_182);
   if (mincount && last_str) {
       SV * const sv = data->last_found;
       MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?
    mg_find(sv, PERL_MAGIC_utf8) : NULL;

       if (mg)
    mg->mg_len = -1;
       sv_setsv(sv, last_str);
       data->last_end = data->pos_min;
       data->last_start_min = data->pos_min - var_178;
       data->last_start_max = var_182
    ? var_245
    : data->pos_min + data->pos_delta - var_178;
   }
   data->cur_is_floating = 1;
      }
      SvREFCNT_dec(last_str);
  }
  if (data && (var_178 & 0x0200))
      data->flags |= 0x0200;
       optimize_curly_tail:
  if (OP(oscan) != CURLYX) {
      while (PL_regkind[OP(next = regnext(oscan))] == NOTHING
      && NEXT_OFF(next))
   NEXT_OFF(oscan) += NEXT_OFF(next);
  }
  continue;

     default:




            case REF:
            case CLUMP:
  if (var_451 & 0x0400) {

                    scan_commit(var_491, data, minlenp, var_182);
      data->cur_is_floating = 1;
  }
  var_182 = var_182 = 1;
  if (var_451 & 0x1000) {
                    if (OP(var_486) == CLUMP) {


                        ssc_add_range(data->start_class, 0, var_459);
                    }
                    else {
                        ssc_anything(data->start_class);
                    }
                }
  var_451 &= ~(0x0800|0x1000);
  break;
     }
 }
 else if (OP(var_486) == LNBREAK) {
     if (var_451 & (0x0800|0x1000)) {
             if (var_451 & 0x0800) {
                    ssc_intersection(data->start_class,
                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);
                    ssc_clear_locale(data->start_class);
                    ANYOF_FLAGS(data->start_class)
                                                &= ~SSC_MATCHES_EMPTY_STRING;
                }
                else if (var_451 & 0x1000) {
                    ssc_union(data->start_class,
                              PL_XPosix_ptrs[_CC_VERTSPACE],
                              FALSE);
      ssc_and(var_491, data->start_class, (regnode_charclass *) and_withp);



                    ANYOF_FLAGS(data->start_class)
                                                &= ~SSC_MATCHES_EMPTY_STRING;
                }
  var_451 &= ~(0x0800|0x1000);
            }
     var_512++;
            if (var_183 != var_245)
                var_183++;
            if (var_451 & 0x0400) {

                scan_commit(var_491, data, minlenp, var_182);
             data->pos_min += 1;
                if (data->pos_delta != var_245) {
                    data->pos_delta += 1;
                }
  data->cur_is_floating = 1;
         }
 }
 else if (REGNODE_SIMPLE(OP(var_486))) {

     if (var_451 & 0x0400) {
                scan_commit(var_491, data, minlenp, var_182);
  data->pos_min++;
     }
     var_512++;
     if (var_451 & (0x0800|0x1000)) {
                bool var_463 = 0;
                SV* my_invlist = NULL;
                U8 var_454;


                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;



  switch (OP(var_486)) {

  default:




  case SANY:
      if (var_451 & 0x1000)
   ssc_add_range(data->start_class, 0, var_459);
      break;

  case REG_ANY:
                    {
                        SV* REG_ANY_invlist = _new_invlist(2);
                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,
                                                            '\n');
                        if (var_451 & 0x1000) {
                            ssc_union(data->start_class,
                                      REG_ANY_invlist,
                                      TRUE

                                      );
                        }
                        else if (var_451 & 0x0800) {
                            ssc_intersection(data->start_class,
                                             REG_ANY_invlist,
                                             TRUE
                                             );
                            ssc_clear_locale(data->start_class);
                        }
                        SvREFCNT_dec_NN(REG_ANY_invlist);
      }
      break;

                case ANYOFD:
                case ANYOFL:
                case ANYOFPOSIXL:
                case ANYOFH:
                case ANYOF:
      if (var_451 & 0x0800)
   ssc_and(var_491, data->start_class,
                                (regnode_charclass *) var_486);
      else
   ssc_or(var_491, data->start_class,
                                                          (regnode_charclass *) var_486);
      break;

                case NANYOFM:
                case ANYOFM:
                  {
                    SV* cp_list = get_ANYOFM_contents(var_486);

                    if (var_451 & 0x1000) {
                        ssc_union(data->start_class, cp_list, var_463);
                    }
                    else if (var_451 & 0x0800) {
                        ssc_intersection(data->start_class, cp_list, var_463);
                    }

                    SvREFCNT_dec_NN(cp_list);
                    break;
                  }

  case NPOSIXL:
                    var_463 = 1;


  case POSIXL:
                    var_454 = ((FLAGS(var_486)) * 2) + var_463;
                    if (var_451 & 0x0800) {
                        bool var_181 = cBOOL(
                                          ANYOF_POSIXL_TEST(data->start_class,
                                                                 var_454));
                        ANYOF_POSIXL_ZERO(data->start_class);
                        if (var_181) {
                            ANYOF_POSIXL_SET(data->start_class, var_454);
                        }

                        data->start_class->invlist
                                                = sv_2mortal(_new_invlist(0));
                    }
                    else {
                        int var_418 = var_454 + ((var_463) ? -1 : 1);

                        assert(var_451 & 0x1000);






                        if (ANYOF_POSIXL_TEST(data->start_class, var_418)) {
                            ssc_add_range(data->start_class, 0, var_459);
                            ANYOF_POSIXL_CLEAR(data->start_class, var_454);
                            ANYOF_POSIXL_CLEAR(data->start_class, var_418);
                        }
                        else {

                            ANYOF_POSIXL_SET(data->start_class, var_454);
                        }
                    }
                    break;

                case NPOSIXA:

                    var_463 = 1;

  case POSIXA:
                    my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(var_486)], NULL);
                    goto join_posix_and_ascii;

  case NPOSIXD:
  case NPOSIXU:
                    var_463 = 1;

  case POSIXD:
  case POSIXU:
                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(var_486)], NULL);






                    if (OP(var_486) == NPOSIXD) {
                        _invlist_subtract(my_invlist, PL_UpperLatin1,
                                          &my_invlist);
                    }

                  join_posix_and_ascii:

                    if (var_451 & 0x0800) {
                        ssc_intersection(data->start_class, my_invlist, var_463);
                        ssc_clear_locale(data->start_class);
                    }
                    else {
                        assert(var_451 & 0x1000);
                        ssc_union(data->start_class, my_invlist, var_463);
                    }
                    SvREFCNT_dec(my_invlist);
  }
  if (var_451 & 0x1000)
      ssc_and(var_491, data->start_class, (regnode_charclass *) and_withp);
  var_451 &= ~(0x0800|0x1000);
     }
 }
 else if (PL_regkind[OP(var_486)] == EOL && var_451 & 0x0400) {
     data->flags |= (OP(var_486) == MEOL
       ? 0x0002
       : 0x0001);
            scan_commit(var_491, data, minlenp, var_182);

 }
 else if ( PL_regkind[OP(var_486)] == BRANCHJ

     && (var_486->flags || data || (var_451 & (0x0800|0x1000)))
     && (OP(var_486) == IFMATCH || OP(var_486) == UNLESSM))
        {
            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY
                || OP(var_486) == UNLESSM )
            {




                SSize_t var_182, minnext, var_245 = 0;
                regnode *nscan;
                regnode_ssc intrnl;
                int var_182 = 0;

                StructCopy(&var_243, &data_fake, scan_data_t);
                if (data) {
                    data_fake.whilem_c = data->whilem_c;
                    data_fake.last_closep = data->last_closep;
  }
                else
                    data_fake.last_closep = &var_245;
  data_fake.pos_delta = var_183;
                if ( var_451 & (0x0800|0x1000) && !var_486->flags
                     && OP(var_486) == IFMATCH ) {
                    ssc_init(var_491, &intrnl);
                    data_fake.start_class = &intrnl;
                    var_182 |= 0x0800;
  }
                if (var_451 & 0x2000)
                    var_182 |= 0x2000;
                next = regnext(var_486);
                nscan = NEXTOPER(NEXTOPER(var_486));


                minnext = study_chunk(var_491, &nscan, minlenp, &var_182,
                                      last, &data_fake, var_182,
                                      var_182, NULL, var_182, var_486+1);
                if (var_486->flags) {
                    if ( var_182 < 0
                        || var_182 > (I32) U8_MAX
                        || minnext > (I32)U8_MAX
                        || minnext + var_182 > (I32)U8_MAX)
                    {
   STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "Lookbehind longer than %" UVuf " not implemented" " in regex m/%" UTF8f "%s/", (UV)U8_MAX, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

                    }






                    if (var_182) {
                        var_486->next_off = var_182;
                        STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 6040, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_EXPERIMENTAL__VLB))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner_d(aTHX_ fn_538(WARN_EXPERIMENTAL__VLB), "Variable length lookbehind is experimental" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 6040, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


                    }
                    var_486->flags = (U8)minnext + var_182;
                }
                if (data) {
                    if (data_fake.flags & (0x0080|0x0100))
                        var_182++;
                    if (data_fake.flags & 0x0200)
                        data->flags |= 0x0200;
                    data->whilem_c = data_fake.whilem_c;
                }
                if (var_182 & 0x0800) {
      if (var_451 & 0x1000) {






   ssc_init(var_491, data->start_class);
      } else {



   ssc_and(var_491, data->start_class, (regnode_charclass *) &intrnl);
                        ANYOF_FLAGS(data->start_class)
                                                   |= SSC_MATCHES_EMPTY_STRING;
      }
                }
     }

 }

 else if (OP(var_486) == OPEN) {
     if (var_182 != (I32)ARG(var_486))
         var_182++;
 }
 else if (OP(var_486) == CLOSE) {
     if (var_182 == (I32)ARG(var_486)) {
         break;
     }
     if ((I32)ARG(var_486) == var_182) {
  next = regnext(var_486);

  if ( next && (OP(next) != WHILEM) && next < last)
      var_182 = 0;
     }
     if (data)
  *(data->last_closep) = ARG(var_486);
 }
 else if (OP(var_486) == EVAL) {
  if (data)
      data->flags |= 0x0200;
 }
 else if ( PL_regkind[OP(var_486)] == ENDLIKE ) {
     if (var_451 & 0x0400) {
                scan_commit(var_491, data, minlenp, var_182);
  var_451 &= ~0x0400;
     }
     if (data && OP(var_486)==ACCEPT) {
         data->flags |= 0x8000;
         if (var_183 > var_512)
             var_183 = var_512;
     }
 }
 else if (OP(var_486) == LOGICAL && var_486->flags == 2)
 {
  if (var_451 & 0x0400) {
                    scan_commit(var_491, data, minlenp, var_182);
      data->cur_is_floating = 1;
  }
  var_182 = var_182 = 1;
  if (var_451 & 0x1000)
      ssc_anything(data->start_class);
  var_451 &= ~(0x0800|0x1000);
 }
 else if (OP(var_486) == GPOS) {
            if (!((var_491->rx)->intflags & PREGf_GPOS_FLOAT) &&
         !(var_183 || var_182 || (data && data->pos_delta)))
     {
                if (!((var_491->rx)->intflags & PREGf_ANCH) && (var_451 & 0x0400))
                    (var_491->rx)->intflags |= PREGf_ANCH_GPOS;
         if ((var_491->rx)->gofs < (STRLEN)var_512)
      (var_491->rx)->gofs = var_512;
            } else {
                (var_491->rx)->intflags |= PREGf_GPOS_FLOAT;
                (var_491->rx)->gofs = 0;
            }
 }

 var_486 = regnext(var_486);
    }

  finish:
    if (frame) {

        var_486 = var_486 - 1;

        NOOP;
        NOOP;


        last = frame->last_regnode;
        var_486 = frame->next_regnode;
        var_182 = frame->stopparen;
        var_182 = frame->prev_recursed_depth;

        (var_491->frame_last) = frame->prev_frame;
        frame = frame->this_prev_frame;
        goto fake_study_recurse;
    }

    assert(!frame);
    NOOP;

    *scanp = var_486;
    *deltap = var_182 ? var_245 : var_183;

    if (var_451 & 0x0400 && var_182)
 data->pos_delta = var_245 - data->pos_min;
    if (var_182 > (I32)U8_MAX)
 var_182 = 0;
    if (var_182 && var_182==1 && data) {
 data->flags |= 0x0100;
 data->flags &= ~0x0080;
    }
    else if (var_182 && data) {
 data->flags |= 0x0080;
 data->flags &= ~0x0100;
    }
    if (var_451 & 0x1000)
 ssc_and(var_491, data->start_class, (regnode_charclass *) and_withp);
    if (var_451 & 0x4000)
        data->flags |= 0x4000;

    NOOP;

    {
        SSize_t var_183= var_512 < var_183 ? var_512 : var_183;

        if (!((var_491->seen) & REG_UNBOUNDED_QUANTIFIER_SEEN)) {
            if (var_183 > var_245 - var_183)
                (var_491->maxlen) = var_245;
            else if ((var_491->maxlen) < var_183 + var_183)
                (var_491->maxlen) = var_183 + var_183;
        }
        return var_183;
    }
    NOT_REACHED;
}

static U32
fn_183(RExC_state_t* const var_491, const char* const var_512, const U32 var_498)
{
    U32 var_489 = (var_491->rxi)->data ? (var_491->rxi)->data->count : 0;

    PERL_ARGS_ASSERT_ADD_DATA;

    Renewc((var_491->rxi)->data,
    sizeof(*(var_491->rxi)->data) + sizeof(void*) * (var_489 + var_498 - 1),
    char, struct reg_data);
    if(var_489)
 Renew((var_491->rxi)->data->what, var_489 + var_498, U8);
    else
 Newx((var_491->rxi)->data->what, var_498, U8);
    (var_491->rxi)->data->count = var_489 + var_498;
    Copy(var_512, (var_491->rxi)->data->what + var_489, var_498, U8);
    return var_489;
}




void
fn_184(pTHX)
{
    const char * const var_512 = PerlEnv_getenv("PERL_RE_COLORS");
    if (var_512) {
 char *t = savepv(var_512);
 int var_531 = 0;
 PL_colors[0] = t;
 while (++var_531 < 6) {
     t = strchr(t, '\t');
     if (t) {
  *t = '\0';
  PL_colors[var_531] = ++t;
     }
     else
  PL_colors[var_531] = t = (char *)"";
 }
    } else {
 int var_531 = 0;
 while (var_531 < 6)
     PL_colors[var_531++] = (char *)"";
    }
    PL_colorset = 1;
}

regexp_engine const *
fn_185(pTHX)
{
    if (IN_PERL_COMPILETIME) {
 HV * const table = GvHV(PL_hintgv);
 SV **var_483;

 if (!table || !(PL_hints & HINT_LOCALIZE_HH))
     return &PL_core_reg_engine;
 var_483 = hv_fetchs(table, "regcomp", FALSE);
 if ( !(var_483 && SvIOK(*var_483) && SvIV(*var_483)))
     return &PL_core_reg_engine;
 return INT2PTR(regexp_engine*, SvIV(*var_483));
    }
    else {
 SV *var_483;
 if (!PL_curcop->cop_hints_hash)
     return &PL_core_reg_engine;
 var_483 = cop_hints_fetch_pvs(PL_curcop, "regcomp", 0);
 if ( !(var_483 && SvIOK(var_483) && SvIV(var_483)))
     return &PL_core_reg_engine;
 return INT2PTR(regexp_engine*, SvIV(var_483));
    }
}


REGEXP *
fn_187(pTHX_ SV * const var_192, const U32 var_451)
{
    regexp_engine const *eng = current_re_engine();
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_PREGCOMP;


    DEBUG_COMPILE_r({
        Perl_re_printf( aTHX_ "Using engine %" UVxf "\n",
   PTR2UV(eng));
    });
    return CALLREGCOMP_ENG(eng, var_192, var_451);
}







REGEXP *
fn_189(pTHX_ SV * const var_192, U32 var_243)
{
    SV *var_242 = var_192;
    PERL_ARGS_ASSERT_RE_COMPILE;
    return Perl_re_op_compile(aTHX_ &var_242, 1, NULL,



                                &PL_core_reg_engine,

                                NULL, NULL, var_243, 0);
}


static void
fn_192(pTHX_ struct reg_code_blocks *cbs)
{
    int var_498;

    if (--cbs->refcnt > 0)
        return;
    for (var_498 = 0; var_498 < cbs->count; var_498++) {
        REGEXP *rx = cbs->cb[var_498].src_regex;
        if (rx) {
            cbs->cb[var_498].src_regex = NULL;
            SvREFCNT_dec_NN(rx);
        }
    }
    Safefree(cbs->cb);
    Safefree(cbs);
}


static struct struct_195 *
fn_193(pTHX_ int var_242)
{
     struct struct_195 *cbs;
    Newx(cbs, 1, struct reg_code_blocks);
    cbs->count = var_242;
    cbs->refcnt = 1;
    SAVEDESTRUCTOR_X(S_free_codeblocks, cbs);
    if (var_242)
        Newx(cbs->cb, var_242, struct reg_code_block);
    else
        cbs->cb = NULL;
    return cbs;
}

static void
fn_195(pTHX_ RExC_state_t * const var_491,
      char **pat_p, STRLEN *plen_p, int var_198)
{
    U8 *const src = (U8*)*pat_p;
    U8 *dst, *var_451;
    int var_498=0;
    STRLEN var_512 = 0;
    bool var_198 = 0;
    GET_RE_DEBUG_FLAGS_DECL;

    DEBUG_PARSE_r(Perl_re_printf( aTHX_
        "UTF8 mismatch! Converting to utf8 for resizing and compile\n"));


    Newx(dst, *plen_p + variant_under_utf8_count(src, src + *plen_p) + 1, U8);
    var_451 = dst;

    while (var_512 < *plen_p) {
        append_utf8_from_native_byte(src[var_512], &var_451);

        if (var_498 < var_198) {
            assert(var_491->code_blocks);
            if (!var_198 && var_491->code_blocks->cb[var_498].start == var_512) {
                var_491->code_blocks->cb[var_498].start = var_451 - dst - 1;
                assert(*(var_451 - 1) == '(');
                var_198 = 1;
            }
            else if (var_198 && var_491->code_blocks->cb[var_498].end == var_512) {
                var_491->code_blocks->cb[var_498].end = var_451 - dst - 1;
                assert(*(var_451 - 1) == ')');
                var_198 = 0;
                var_498++;
            }
        }
        var_512++;
    }
    *var_451 = '\0';
    *plen_p = var_451 - dst;
    *pat_p = (char*) dst;
    SAVEFREEPV(*pat_p);
    (var_491->orig_utf8) = (var_491->utf8) = 1;
}

static SV*
fn_198(pTHX_ RExC_state_t * const var_491,
                SV *var_242, SV ** const var_235, int var_242,
                OP *oplist, bool *recompile_p, SV *delim)
{
    SV **svp;
    int var_498 = 0;
    bool var_204 = FALSE;
    bool var_208 = FALSE;



    if (!var_242 && var_242 != 1) {
        var_242 = newSVpvs("");
        SAVEFREESV(var_242);
        var_208 = TRUE;
    }

    for (svp = var_235; svp < var_235 + var_242; svp++) {
        SV *sv;
        SV *rx = NULL;
        STRLEN var_208 = 0;
        bool var_205 = 0;
        SV *msv = var_204 ? delim : *svp;
        if (!msv) msv = &PL_sv_undef;




        if (var_204) {
            svp--;
            var_204 = FALSE;
        }
        else if (delim)
            var_204 = TRUE;

        if (SvTYPE(msv) == SVt_PVAV) {





            AV *const av = (AV*)msv;
            const SSize_t var_205 = AvFILL(av) + 1;
            SV **array;

            if (oplist) {
                assert(oplist->op_type == OP_PADAV
                    || oplist->op_type == OP_RV2AV);
                oplist = OpSIBLING(oplist);
            }

            if (SvRMAGICAL(av)) {
                SSize_t var_531;

                Newx(array, var_205, SV*);
                SAVEFREEPV(array);
                for (var_531=0; var_531 < var_205; var_531++) {
                    SV ** const svp = av_fetch(av, var_531, FALSE);
                    array[var_531] = svp ? *svp : &PL_sv_undef;
                }
            }
            else
                array = AvARRAY(av);

            var_242 = S_concat_pat(aTHX_ var_491, var_242,
                                array, var_205, NULL, recompile_p,

                                GvSV((gv_fetchpvs("\"", GV_ADDMULTI, SVt_PV))));

            continue;
        }

        if (oplist) {
            if (oplist->op_type == OP_NULL
                && (oplist->op_flags & OPf_SPECIAL))
            {
                assert(var_498 < var_491->code_blocks->count);
                var_491->code_blocks->cb[var_498].start = var_242 ? SvCUR(var_242) : 0;
                var_491->code_blocks->cb[var_498].block = oplist;
                var_491->code_blocks->cb[var_498].src_regex = NULL;
                var_498++;
                var_205 = 1;
                oplist = OpSIBLING(oplist);
                assert(oplist);
            }
            oplist = OpSIBLING(oplist);;
        }



        SvGETMAGIC(msv);
        if (SvROK(msv) && SvAMAGIC(msv)) {
            SV *sv = AMG_CALLunary(msv, regexp_amg);
            if (sv) {
                if (SvROK(sv))
                    sv = SvRV(sv);
                if (SvTYPE(sv) != SVt_REGEXP)
                    Perl_croak(aTHX_ "Overloaded qr did not return a REGEXP");
                msv = sv;
            }
        }


        if (var_242 && (SvAMAGIC(var_242) || SvAMAGIC(msv)) &&
                (sv = amagic_call(var_242, msv, concat_amg, AMGf_assign)))
        {
            sv_setsv(var_242, sv);


            if (var_498)
                var_491->code_blocks->count -= var_498;
            var_498 = 0;
        }
        else {

            while (SvAMAGIC(msv)
                    && (sv = AMG_CALLunary(msv, string_amg))
                    && sv != msv
                    && !( SvROK(msv)
                          && SvROK(sv)
                          && SvRV(msv) == SvRV(sv))
            ) {
                msv = sv;
                SvGETMAGIC(msv);
            }
            if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP)
                msv = SvRV(msv);

            if (var_242) {




                STRLEN dlen;
                char *dst = SvPV_force_nomg(var_242, dlen);
                var_208 = dlen;
                if (SvUTF8(msv) && !SvUTF8(var_242)) {
                    S_pat_upgrade_to_utf8(aTHX_ var_491, &dst, &dlen, var_498);
                    sv_setpvn(var_242, dst, dlen);
                    SvUTF8_on(var_242);
                }
                sv_catsv_nomg(var_242, msv);
                rx = msv;
            }
            else {




                if ( SvTYPE(msv) != SVt_PV || (SvLEN(msv) > SvCUR(msv) && *(SvEND(msv)) == 0) || SvIsCOW_shared_hash(msv) ) {

                    var_242 = msv;
                } else {


                    var_242 = sv_2mortal(newSVsv(msv));
                }
            }

            if (var_205)
                var_491->code_blocks->cb[var_498-1].end = SvCUR(var_242)-1;
        }


        if (rx && SvTYPE(rx) == SVt_REGEXP
            && RX_ENGINE((REGEXP*)rx)->op_comp)
        {

            RXi_GET_DECL(ReANY((REGEXP *)rx), ri);
            if (ri->code_blocks && ri->code_blocks->count) {
                int var_531;




                *recompile_p = 1;
                if (var_491->code_blocks) {
                    int var_206 = var_491->code_blocks->count
                            + ri->code_blocks->count;
                    Renew(var_491->code_blocks->cb,
                            var_206, struct reg_code_block);
                    var_491->code_blocks->count = var_206;
                }
                else
                    var_491->code_blocks = S_alloc_code_blocks(aTHX_
                                                    ri->code_blocks->count);

                for (var_531=0; var_531 < ri->code_blocks->count; var_531++) {
                    struct struct_361 *src, *dst;
                    STRLEN var_499 = var_208
                        + ReANY((REGEXP *)rx)->pre_prefix;
                    assert(var_498 < var_491->code_blocks->count);
                    src = &ri->code_blocks->cb[var_531];
                    dst = &var_491->code_blocks->cb[var_498];
                    dst->start = src->start + var_499;
                    dst->end = src->end + var_499;
                    dst->block = src->block;
                    dst->src_regex = (REGEXP*) SvREFCNT_inc( (SV*)
                                            src->src_regex
                                                ? src->src_regex
                                                : (REGEXP*)rx);
                    var_498++;
                }
            }
        }
    }

    if (var_208)
        SvSETMAGIC(var_242);

    return var_242;
}






static bool
fn_208(pTHX_ RExC_state_t * const var_491,
      char *var_242, STRLEN var_243)
{
    int var_498 = 0;
    STRLEN var_512;

    PERL_UNUSED_CONTEXT;

    for (var_512 = 0; var_512 < var_243; var_512++) {
 if ( var_491->code_blocks
            && var_498 < var_491->code_blocks->count
     && var_512 == var_491->code_blocks->cb[var_498].start)
 {
     var_512 = var_491->code_blocks->cb[var_498].end;
     var_498++;
     continue;
 }


 if (var_242[var_512] == '(' && var_512+2 <= var_243 && var_242[var_512+1] == '?' &&
     (var_242[var_512+2] == '{'
                || (var_512 + 2 <= var_243 && var_242[var_512+2] == '?' && var_242[var_512+3] == '{'))
 )
     return 1;
    }
    return 0;
}

static bool
fn_210(pTHX_ RExC_state_t * const var_491,
    char *var_242, STRLEN var_243)
{
    SV *qr;

    GET_RE_DEBUG_FLAGS_DECL;

    if (var_491->runtime_code_qr) {





 qr = var_491->runtime_code_qr;
 var_491->runtime_code_qr = NULL;
 assert((var_491->utf8) && SvUTF8(qr));
    }
    else {
 int var_498 = 0;
 STRLEN var_512;
 char *var_499, *newpat;
 int var_212 = var_243 + 7;
 SV *sv, *qr_ref;
 dSP;


 for (var_512 = 0; var_512 < var_243; var_512++) {
     if (var_242[var_512] == '\'' || var_242[var_512] == '\\')
  var_212++;
 }

 Newx(newpat, var_212, char);
 var_499 = newpat;
 *var_499++ = 'q'; *var_499++ = 'r'; *var_499++ = '\'';

 for (var_512 = 0; var_512 < var_243; var_512++) {
     if ( var_491->code_blocks
         && var_498 < var_491->code_blocks->count
  && var_512 == var_491->code_blocks->cb[var_498].start)
     {

  assert(var_242[var_512] == '(');
  assert(var_242[var_512+1] == '?');
                *var_499++ = '(';
                *var_499++ = '?';
                var_512 += 2;
  while (var_512 < var_491->code_blocks->cb[var_498].end) {
      *var_499++ = '=';
      var_512++;
  }
                *var_499++ = ')';
  var_498++;
  continue;
     }
     if (var_242[var_512] == '\'' || var_242[var_512] == '\\')
  *var_499++ = '\\';
     *var_499++ = var_242[var_512];
 }
 *var_499++ = '\'';
 if (var_491->pm_flags & RXf_PMf_EXTENDED) {
     *var_499++ = 'x';
            if (var_491->pm_flags & RXf_PMf_EXTENDED_MORE) {
                *var_499++ = 'x';
            }
        }
 *var_499++ = '\0';
 DEBUG_COMPILE_r({
            Perl_re_printf( aTHX_
  "%sre-parsing pattern for runtime code:%s %s\n",
  PL_colors[4], PL_colors[5], newpat);
 });

 sv = newSVpvn_flags(newpat, var_499-newpat-1, (var_491->utf8) ? SVf_UTF8 : 0);
 Safefree(newpat);

 ENTER;
 SAVETMPS;
 save_re_context();
 PUSHSTACKi(PERLSI_REQUIRE);



 eval_sv(sv, G_SCALAR|G_RE_REPARSING);
 SvREFCNT_dec_NN(sv);
 SPAGAIN;
 qr_ref = var_533;
 PUTBACK;
 {
     SV * const errsv = var_533;
     if (SvTRUE_NN(errsv))

  Perl_croak_nocontext("%" SVf, SVfARG(errsv));
 }
 assert(SvROK(qr_ref));
 qr = SvRV(qr_ref);
 assert(SvTYPE(qr) == SVt_REGEXP && RX_ENGINE((REGEXP*)qr)->op_comp);


 SvREFCNT_inc(qr);
 POPSTACK;
 FREETMPS;
 LEAVE;

    }

    if (!(var_491->utf8) && SvUTF8(qr)) {


 assert(!var_491->runtime_code_qr);
 var_491->runtime_code_qr = qr;
 return 0;
    }






    {
 RXi_GET_DECL(ReANY((REGEXP *)qr), r2);
 struct struct_361 *new_block, *dst;
 RExC_state_t * const r1 = var_491;
 int var_217 = 0, var_217 = 0;
        int r1c, r2c;

 if (!r2->code_blocks || !r2->code_blocks->count)
 {
     SvREFCNT_dec_NN(qr);
     return 1;
 }

        if (!r1->code_blocks)
            r1->code_blocks = S_alloc_code_blocks(aTHX_ 0);

        r1c = r1->code_blocks->count;
        r2c = r2->code_blocks->count;

 Newx(new_block, r1c + r2c, struct reg_code_block);

 dst = new_block;

 while (var_217 < r1c || var_217 < r2c) {
     struct struct_361 *src;
     bool var_217 = 0;

     if (var_217 == r1c) {
  src = &r2->code_blocks->cb[var_217++];
  var_217 = 1;
     }
     else if (var_217 == r2c)
  src = &r1->code_blocks->cb[var_217++];
     else if ( r1->code_blocks->cb[var_217].start
              < r2->code_blocks->cb[var_217].start)
     {
  src = &r1->code_blocks->cb[var_217++];
  assert(src->end < r2->code_blocks->cb[var_217].start);
     }
     else {
  assert( r1->code_blocks->cb[var_217].start
         > r2->code_blocks->cb[var_217].start);
  src = &r2->code_blocks->cb[var_217++];
  var_217 = 1;
  assert(src->end < r1->code_blocks->cb[var_217].start);
     }

     assert(var_242[src->start] == '(');
     assert(var_242[src->end] == ')');
     dst->start = src->start;
     dst->end = src->end;
     dst->block = src->block;
     dst->src_regex = var_217 ? (REGEXP*) SvREFCNT_inc( (SV*) qr)
        : src->src_regex;
     dst++;
 }
 r1->code_blocks->count += r2c;
 Safefree(r1->code_blocks->cb);
 r1->code_blocks->cb = new_block;
    }

    SvREFCNT_dec_NN(qr);
    return 1;
}


static bool
fn_217(pTHX_ RExC_state_t *var_491,
                      struct struct_218 *rsd,
                      struct struct_219 *sub,
                      STRLEN var_245)
{




    I32 t;
    SSize_t ml;
    bool var_222 = cBOOL(sub->flags & (0x0001|0x0002));
    bool var_222 = cBOOL(sub->flags & 0x0002);

    if (! (var_245
           || (var_222
               && (! var_222 || ((var_491->flags) & RXf_PMf_MULTILINE)))
          )

        || ((var_491->seen) & REG_UNFOLDED_MULTI_SEEN))
    {
        return FALSE;
    }



    if (SvUTF8(sub->str)) {
        rsd->substr = NULL;
        rsd->utf8_substr = sub->str;
    } else {
        rsd->substr = sub->str;
        rsd->utf8_substr = NULL;
    }




    ml = sub->minlenp ? *(sub->minlenp) : (SSize_t)var_245;
    rsd->end_shift = ml - sub->min_offset
        - var_245




        + sub->lookbehind;

    t = (var_222
         && (! var_222 || ((var_491->flags) & RXf_PMf_MULTILINE)));
    fbm_compile(sub->str, t ? FBMcf_TAIL : 0);

    return TRUE;
}

static void
fn_222(pTHX_ RExC_state_t *var_491, REGEXP *Rx)
{



    bool var_232 = (((var_491->rx)->extflags & RXf_PMf_KEEPCOPY) == RXf_PMf_KEEPCOPY);
    bool var_231 = (var_491->utf8) || (get_regex_charset((var_491->rx)->extflags)
                                                != REGEX_DEPENDS_CHARSET);



    bool var_231 =
                ((((var_491->rx)->extflags & RXf_PMf_STD_PMMOD) != RXf_PMf_STD_PMMOD)
                || ! var_231);
    bool var_232 = (((var_491->seen) & REG_RUN_ON_COMMENT_SEEN)
                                                == REG_RUN_ON_COMMENT_SEEN);
    U8 var_232 = (U8)(((var_491->rx)->extflags & RXf_PMf_STD_PMMOD)
                        >> RXf_PMf_STD_PMMOD_SHIFT);
    const char *fptr = var_231;
    char *var_499;
    STRLEN var_232 = (var_491->precomp_end) - (var_491->precomp);




    const STRLEN var_231 = var_232 + var_232 + var_232
        + var_231
        + PL_bitcount[var_232]


        + ((var_231) ? MAX_CHARSET_NAME_LENGTH : 0)
        + (sizeof("(?:)") - 1);

    PERL_ARGS_ASSERT_SET_REGEX_PV;


    assert(sizeof(var_231) <= 8);

    var_499 = sv_grow(MUTABLE_SV(Rx), var_231 + 1);
    SvPOK_on(Rx);
    if ((var_491->utf8))
        SvFLAGS(Rx) |= SVf_UTF8;
    *var_499++='('; *var_499++='?';


    if (var_231) {
        *var_499++= DEFAULT_PAT_MOD;
    }
    if (var_231) {
        STRLEN var_531;
        const char* var_538;

        var_538 = get_regex_charset_name((var_491->rx)->extflags, &var_531);
        if strEQ(var_538, DEPENDS_PAT_MODS) {
            assert((var_491->utf8));
            var_538 = UNICODE_PAT_MODS;
            var_531 = sizeof(UNICODE_PAT_MODS) - 1;
        }
        Copy(var_538, var_499, var_531, char);
        var_499 += var_531;
    }
    if (var_232)
        *var_499++ = KEEPCOPY_PAT_MOD;
    {
        char var_385;
        while((var_385 = *fptr++)) {
            if(var_232 & 1)
                *var_499++ = var_385;
            var_232 >>= 1;
        }
    }

    *var_499++ = ':';
    Copy((var_491->precomp), var_499, var_232, char);
    assert ((RX_WRAPPED(Rx) - var_499) < 16);
    (var_491->rx)->pre_prefix = var_499 - RX_WRAPPED(Rx);
    var_499 += var_232;




    if (var_232)
        *var_499++ = '\n';
    *var_499++ = ')';
    *var_499 = 0;
    SvCUR_set(Rx, var_499 - RX_WRAPPED(Rx));
}

REGEXP *
fn_232(pTHX_ SV ** const var_235, int var_242,
      OP *expr, const regexp_engine* eng, REGEXP *old_re,
       bool *is_bare_re, const U32 var_243, const U32 var_245)
{
    dVAR;
    REGEXP *Rx;
    STRLEN var_243;
    char *exp;
    regnode *var_486;
    I32 var_451;
    SSize_t var_245 = 0;
    U32 var_243;
    SV *var_242;
    SV** new_patternp = var_235;



    I32 var_245 = 0;
    I32 var_245 = 0;
    I32 var_245 = 0;
    I32 var_245 = 0;

    regex_charset var_242 = get_regex_charset(var_243);
    bool var_242 = 0;
    bool var_242 = 0;
    scan_data_t data;
    RExC_state_t RExC_state;
    RExC_state_t * const var_491 = &RExC_state;




    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_RE_OP_COMPILE;

    DEBUG_r(if (!PL_colorset) reginitcolors());



    if (! PL_InBitmap) {







 PL_InBitmap = _new_invlist(2);
 PL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,
                                                    NUM_ANYOF_CODE_POINTS - 1);

    }

    var_491->warn_text = NULL;
    var_491->unlexed_names = NULL;
    var_491->code_blocks = NULL;

    if (is_bare_re)
 *is_bare_re = FALSE;

    if (expr && (expr->op_type == OP_LIST ||
  (expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {

 OP *o;
 int var_242 = 0;

 for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))
     if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))
  var_242++;

 if (var_242)
            var_491->code_blocks = S_alloc_code_blocks(aTHX_ var_242);
    }

    if (!var_242) {


        int var_498;
        OP *o;


        assert(expr);
        var_498 = 0;
        if (expr->op_type == OP_CONST)
            var_498 = 1;
        else
            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
                if (o->op_type == OP_CONST)
                    var_498++;
            }



        assert(!new_patternp);
        Newx(new_patternp, var_498, SV*);
        SAVEFREEPV(new_patternp);
        var_242 = var_498;

        var_498 = 0;
        if (expr->op_type == OP_CONST)
            new_patternp[var_498] = cSVOPx_sv(expr);
        else
            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
                if (o->op_type == OP_CONST)
                    new_patternp[var_498++] = cSVOPo_sv;
            }

    }

    DEBUG_PARSE_r(Perl_re_printf( aTHX_
        "Assembling pattern from %d elements%s\n", var_242,
            var_243 & RXf_SPLIT ? " for split" : ""));



    if (var_491->code_blocks && var_491->code_blocks->count
         && expr->op_type != OP_CONST)
    {
            expr = cLISTOPx(expr)->op_first;
            assert( expr->op_type == OP_PUSHMARK
                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)
                   || expr->op_type == OP_PADRANGE);
            expr = OpSIBLING(expr);
    }

    var_242 = S_concat_pat(aTHX_ var_491, NULL, new_patternp, var_242,
                        expr, &var_242, NULL);


    {
        SV *re = var_242;
        if (SvROK(re))
            re = SvRV(re);
        if (SvTYPE(re) == SVt_REGEXP) {
            if (is_bare_re)
                *is_bare_re = TRUE;
            SvREFCNT_inc(re);
            DEBUG_PARSE_r(Perl_re_printf( aTHX_
                "Precompiled pattern%s\n",
                    var_243 & RXf_SPLIT ? " for split" : ""));

            return (REGEXP*)re;
        }
    }

    exp = SvPV_nomg(var_242, var_243);

    if (!eng->op_comp) {
 if ((SvUTF8(var_242) && IN_BYTES)
  || SvGMAGICAL(var_242) || SvAMAGIC(var_242))
 {


     var_242 = newSVpvn_flags(exp, var_243, SVs_TEMP |
     (IN_BYTES ? 0 : SvUTF8(var_242)));
 }
 return CALLREGCOMP_ENG(eng, var_242, var_243);
    }


    (var_491->utf8) = (var_491->orig_utf8) = (var_243 == 0 || IN_BYTES) ? 0 : SvUTF8(var_242);
    (var_491->uni_semantics) = 0;
    (var_491->contains_locale) = 0;
    (var_491->strict) = cBOOL(var_245 & RXf_PMf_STRICT);
    (var_491->in_script_run) = 0;
    (var_491->study_started) = 0;
    var_491->runtime_code_qr = NULL;
    (var_491->frame_head)= NULL;
    (var_491->frame_last)= NULL;
    (var_491->frame_count)= 0;
    (var_491->latest_warn_offset ) = 0;
    (var_491->use_BRANCHJ) = 0;
    (var_491->total_par) = 0;
    (var_491->open_parens) = NULL;
    (var_491->close_parens) = NULL;
    (var_491->paren_names) = NULL;
    (var_491->size) = 0;
    (var_491->seen_d_op) = FALSE;




    DEBUG_r({
        RExC_mysv1= sv_newmortal();
        RExC_mysv2= sv_newmortal();
    });

    DEBUG_COMPILE_r({
            SV *dsv= sv_newmortal();
            RE_PV_QUOTED_DECL(var_512, (var_491->utf8), dsv, exp, var_243, PL_dump_re_max_len);
            Perl_re_printf( aTHX_ "%sCompiling REx%s %s\n",
                          PL_colors[4], PL_colors[5], var_512);
        });




    if ((var_245 & PMf_USE_RE_EVAL)


  || (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))
    )
 var_242 = S_has_runtime_code(aTHX_ var_491, exp, var_243);

  redo_parse:







    if ( old_re
        && !var_242
        && !!RX_UTF8(old_re) == !!(var_491->utf8)
        && ( RX_COMPFLAGS(old_re) == ( var_243 & RXf_PMf_FLAGCOPYMASK ) )
 && RX_PRECOMP(old_re)
 && RX_PRELEN(old_re) == var_243
        && memEQ(RX_PRECOMP(old_re), exp, var_243)
 && !var_242 )
    {
        return old_re;
    }


    (var_491->rx_sv) = Rx = (REGEXP*) newSV_type(SVt_REGEXP);
    (var_491->rx) = ReANY(Rx);
    if ( (var_491->rx) == NULL )
        STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Regexp out of space", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

    var_243 = var_243;

    if ( (cBOOL((var_491->utf8)) || (var_491->uni_semantics))
        && var_242 == REGEX_DEPENDS_CHARSET)
    {



 set_regex_charset(&var_243, REGEX_UNICODE_CHARSET);
        (var_491->uni_semantics) = 1;
    }

    (var_491->pm_flags) = var_245;

    if (var_242) {
        assert(TAINTING_get || !var_538);
 if (var_538)
     Perl_croak(aTHX_ "Eval-group in insecure regular expression");

 if (!S_compile_runtime_code(aTHX_ var_491, exp, var_243)) {


            S_pat_upgrade_to_utf8(aTHX_ var_491, &exp, &var_243,
                var_491->code_blocks ? var_491->code_blocks->count : 0);
            goto redo_parse;
 }
    }
    assert(!var_491->runtime_code_qr);

    (var_491->sawback) = 0;

    (var_491->seen) = 0;
    (var_491->maxlen) = 0;
    (var_491->in_lookbehind) = 0;
    (var_491->seen_zerolen) = *exp == '^' ? -1 : 0;



    (var_491->in_multi_char_class) = 0;

    (var_491->start) = (var_491->copy_start) = (var_491->copy_start_in_input) = (var_491->precomp) = exp;
    (var_491->precomp_end) = (var_491->end) = exp + var_243;
    (var_491->nestroot) = 0;
    (var_491->whilem_seen) = 0;
    (var_491->end_op) = NULL;
    (var_491->recurse) = NULL;
    (var_491->study_chunk_recursed) = NULL;
    (var_491->study_chunk_recursed_bytes)= 0;
    (var_491->recurse_count) = 0;
    var_491->code_index = 0;



    set_regex_pv(var_491, Rx);

    DEBUG_PARSE_r({
        Perl_re_printf( aTHX_
            "Starting parse and generation\n");
        RExC_lastnum=0;
        RExC_lastparse=NULL;
    });




    if (! (var_491->size)) {

        (var_491->size) = STR_SZ((var_491->end) - (var_491->start));
    }

    Newxc((var_491->rxi), sizeof(regexp_internal) + (var_491->size), char, regexp_internal);
    if ( (var_491->rxi) == NULL )
        STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Regexp out of space", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

    Zero((var_491->rxi), sizeof(regexp_internal) + (var_491->size), char);
    RXi_SET( (var_491->rx), (var_491->rxi) );




    (var_491->size) = 0;


    (var_491->rx)->engine= eng;
    (var_491->rx)->extflags = var_243;
    RXp_COMPFLAGS((var_491->rx)) = var_243 & RXf_PMf_FLAGCOPYMASK;

    if (var_245 & PMf_IS_QR) {
 (var_491->rxi)->code_blocks = var_491->code_blocks;
        if ((var_491->rxi)->code_blocks) {
            (var_491->rxi)->code_blocks->refcnt++;
        }
    }

    (var_491->rx)->intflags = 0;

    (var_491->flags) = var_243;
    (var_491->parse) = exp;

    assert(*(var_491->end) == '\0');

    (var_491->naughty) = 0;
    (var_491->npar) = 1;
    (var_491->parens_buf_size) = 0;
    (var_491->emit_start) = (var_491->rxi)->program;
    var_491->code_index = 0;

    *((char*) (var_491->emit_start)) = (char) REG_MAGIC;
    (var_491->emit) = 1;


    if (reg(var_491, 0, &var_451, 1)) {



        if (((var_491->total_par) < 0)) {
            var_451 |= 0x20;
        }


        (var_491->total_par) = (var_491->npar);
    }
    else if (! ((var_451) & (0x20))) {
 ReREFCNT_dec(Rx);
        Perl_croak(aTHX_ "panic: reg returned failure to re_op_compile, flags=%#" UVxf, (UV) var_451);
    }


    if (((var_451) & (0x20))) {

        if (var_451 & 0x40) {





            if (UNLIKELY((var_491->latest_warn_offset ) > 0)) {
                (var_491->latest_warn_offset ) +=
                            variant_under_utf8_count((U8 *) exp, (U8 *) exp
                                                + (var_491->latest_warn_offset ));
            }
            S_pat_upgrade_to_utf8(aTHX_ var_491, &exp, &var_243,
            var_491->code_blocks ? var_491->code_blocks->count : 0);
            DEBUG_PARSE_r(Perl_re_printf( aTHX_ "Need to redo parse after upgrade\n"));
        }
        else {
            DEBUG_PARSE_r(Perl_re_printf( aTHX_ "Need to redo parse\n"));
        }

        if (((var_491->total_par) > 0)) {

            Renew((var_491->open_parens), (var_491->total_par), regnode_offset);
            Zero((var_491->open_parens), (var_491->total_par), regnode_offset);
            (var_491->open_parens)[0] = 1;

            Renew((var_491->close_parens), (var_491->total_par), regnode_offset);
            Zero((var_491->close_parens), (var_491->total_par), regnode_offset);
        }
        else {

            (var_491->total_par) = 0;
            if ((var_491->open_parens)) {
                Safefree((var_491->open_parens));
                (var_491->open_parens) = NULL;
            }
            if ((var_491->close_parens)) {
                Safefree((var_491->close_parens));
                (var_491->close_parens) = NULL;
            }
        }


        SvREFCNT_dec_NN((var_491->rx_sv));

        goto redo_parse;
    }






    set_regex_pv(var_491, Rx);

    (var_491->rx)->nparens = (var_491->total_par) - 1;


    if ((var_491->whilem_seen) > 15)
        (var_491->whilem_seen) = 15;

    DEBUG_PARSE_r({
        Perl_re_printf( aTHX_
            "Required size %" IVdf " nodes\n", (IV)(var_491->size));
        RExC_lastnum=0;
        RExC_lastparse=NULL;
    });

    (var_491->rxi)->u.proglen = (var_491->size);


    DEBUG_OPTIMISE_r(
        Perl_re_printf( aTHX_ "Starting post parse optimization\n");
    );



    Newx((var_491->rx)->substrs, 1, struct reg_substr_data);
    if ((var_491->recurse_count)) {
        Newx((var_491->recurse), (var_491->recurse_count), regnode *);
        SAVEFREEPV((var_491->recurse));
    }

    if ((var_491->seen) & REG_RECURSE_SEEN) {


        (var_491->study_chunk_recursed_bytes)= ((var_491->total_par) >> 3) +
                                         (((var_491->total_par) & 0x07) != 0);
        Newx((var_491->study_chunk_recursed),
             (var_491->study_chunk_recursed_bytes) * (var_491->total_par), U8);
        SAVEFREEPV((var_491->study_chunk_recursed));
    }

  reStudy:
    (var_491->rx)->minlen = var_245 = var_245 = var_245 = var_245 = var_245 = 0;
    DEBUG_r(
        RExC_study_chunk_recursed_count= 0;
    );
    Zero((var_491->rx)->substrs, 1, struct reg_substr_data);
    if ((var_491->study_chunk_recursed)) {
        Zero((var_491->study_chunk_recursed),
             (var_491->study_chunk_recursed_bytes) * (var_491->total_par), U8);
    }

    StructCopy(&var_243, &data, scan_data_t);



    (var_491->rx)->extflags = (var_491->flags);


    if (cBOOL((var_491->utf8)))
 SvUTF8_on(Rx);
    (var_491->rxi)->regstclass = NULL;
    if ((var_491->naughty) >= 10)
 (var_491->rx)->intflags |= PREGf_NAUGHTY;
    var_486 = (var_491->rxi)->program + 1;



    if (!((var_491->seen) & REG_TOP_LEVEL_BRANCHES_SEEN)) {

 SSize_t var_245;
 STRLEN var_245[2];
 regnode_ssc ch_class;
 int stclass_flag;
 SSize_t var_245 = 0;
        regnode *var_369= var_486;
        regnode *first_next= regnext(var_369);
        int var_531;

 while ((OP(var_369) == OPEN && (var_245 = 1)) ||

     (OP(var_369) == BRANCH && OP(first_next) != BRANCH) ||

     (OP(var_369) == IFMATCH && !var_369->flags && (var_245 = 1)) ||
     (OP(var_369) == PLUS) ||
     (OP(var_369) == MINMOD) ||

     (PL_regkind[OP(var_369)] == CURLY && ARG1(var_369) > 0) ||
     (OP(var_369) == NOTHING && PL_regkind[OP(first_next)] != var_461 ))
 {






  if (OP(var_369) == PLUS)
      var_245 = 1;
                else {
                    if (OP(var_369) == MINMOD)
                        var_245 = 1;
      var_369 += regarglen[OP(var_369)];
                }
  var_369 = NEXTOPER(var_369);
  first_next= regnext(var_369);
 }


      again:
        NOOP;

 if (PL_regkind[OP(var_369)] == var_454) {
     if ( OP(var_369) == var_454
                || OP(var_369) == EXACT_ONLY8
                || OP(var_369) == EXACTL)
            {
  NOOP;
            }
     else
  (var_491->rxi)->regstclass = var_369;
 }

 else if (REGNODE_SIMPLE(OP(var_369)))
     (var_491->rxi)->regstclass = var_369;
 else if (PL_regkind[OP(var_369)] == BOUND ||
   PL_regkind[OP(var_369)] == NBOUND)
     (var_491->rxi)->regstclass = var_369;
 else if (PL_regkind[OP(var_369)] == BOL) {
            (var_491->rx)->intflags |= (OP(var_369) == MBOL
                           ? PREGf_ANCH_MBOL
                           : PREGf_ANCH_SBOL);
     var_369 = NEXTOPER(var_369);
     goto again;
 }
 else if (OP(var_369) == GPOS) {
            (var_491->rx)->intflags |= PREGf_ANCH_GPOS;
     var_369 = NEXTOPER(var_369);
     goto again;
 }
 else if ((!var_245 || !(var_491->sawback)) &&
            !var_245 &&
     (OP(var_369) == STAR &&
     PL_regkind[OP(NEXTOPER(var_369))] == REG_ANY) &&
            !((var_491->rx)->intflags & PREGf_ANCH) && !var_491->code_blocks)
 {

     const int var_462 =
  (OP(NEXTOPER(var_369)) == REG_ANY)
                    ? PREGf_ANCH_MBOL
                    : PREGf_ANCH_SBOL;
            (var_491->rx)->intflags |= (var_462 | PREGf_IMPLICIT);
     var_369 = NEXTOPER(var_369);
     goto again;
 }
        if (var_245 && !var_245 && !var_245
            && (!var_245 || !(var_491->sawback))
     && !var_491->code_blocks)

     (var_491->rx)->intflags |= PREGf_SKIP;

 DEBUG_PARSE_r(
            Perl_re_printf( aTHX_ "first at %" IVdf "\n",
         (IV)(var_369 - var_486 + 1))
        );

 data.substrs[0].str = newSVpvs("");
 data.substrs[1].str = newSVpvs("");
 data.last_found = newSVpvs("");
 data.cur_is_floating = 0;
 ENTER_with_name("study_chunk");
 SAVEFREESV(data.substrs[0].str);
 SAVEFREESV(data.substrs[1].str);
 SAVEFREESV(data.last_found);
 var_369 = var_486;
 if (!(var_491->rxi)->regstclass) {
     ssc_init(var_491, &ch_class);
     data.start_class = &ch_class;
     stclass_flag = 0x0800;
 } else
     stclass_flag = 0;
 data.last_closep = &var_245;

        DEBUG_OPTIMISE_MORE_r({ Perl_re_printf( aTHX_ "RExC_seen: "); if ((var_491->seen) & REG_ZERO_LEN_SEEN) Perl_re_printf( aTHX_ "REG_ZERO_LEN_SEEN "); if ((var_491->seen) & REG_LOOKBEHIND_SEEN) Perl_re_printf( aTHX_ "REG_LOOKBEHIND_SEEN "); if ((var_491->seen) & REG_GPOS_SEEN) Perl_re_printf( aTHX_ "REG_GPOS_SEEN "); if ((var_491->seen) & REG_RECURSE_SEEN) Perl_re_printf( aTHX_ "REG_RECURSE_SEEN "); if ((var_491->seen) & REG_TOP_LEVEL_BRANCHES_SEEN) Perl_re_printf( aTHX_ "REG_TOP_LEVEL_BRANCHES_SEEN "); if ((var_491->seen) & REG_VERBARG_SEEN) Perl_re_printf( aTHX_ "REG_VERBARG_SEEN "); if ((var_491->seen) & REG_CUTGROUP_SEEN) Perl_re_printf( aTHX_ "REG_CUTGROUP_SEEN "); if ((var_491->seen) & REG_RUN_ON_COMMENT_SEEN) Perl_re_printf( aTHX_ "REG_RUN_ON_COMMENT_SEEN "); if ((var_491->seen) & REG_UNFOLDED_MULTI_SEEN) Perl_re_printf( aTHX_ "REG_UNFOLDED_MULTI_SEEN "); if ((var_491->seen) & REG_UNBOUNDED_QUANTIFIER_SEEN) Perl_re_printf( aTHX_ "REG_UNBOUNDED_QUANTIFIER_SEEN "); Perl_re_printf( aTHX_ "\n"); });;




 var_245 = study_chunk(var_491, &var_369, &var_245, &var_245,
                             var_486 + (var_491->size),
            &data, -1, 0, NULL,
            0x0400 | 0x2000 | stclass_flag
                          | (restudied ? 0x10000 : 0),
            0);


                                   (LEAVE_with_name("study_chunk"));


 if ( (var_491->total_par) == 1 && !data.cur_is_floating
      && data.last_start_min == 0 && data.last_end > 0
      && !(var_491->seen_zerolen)
             && !((var_491->seen) & REG_VERBARG_SEEN)
             && !((var_491->seen) & REG_GPOS_SEEN)
        ){
     (var_491->rx)->extflags |= RXf_CHECK_ALL;
        }
 scan_commit(var_491, &data,&var_245, 0);





        for (var_531 = 1; var_531 >= 0; var_531--) {
            var_245[var_531] = (cBOOL((var_491->utf8)) ? sv_len_utf8(data.substrs[var_531].str) : SvCUR(data.substrs[var_531].str));

            if ( !( var_531
                     && SvCUR(data.substrs[0].str)
                     && data.substrs[0].min_offset
                        == data.substrs[1].min_offset
                     && SvCUR(data.substrs[0].str)
                        == SvCUR(data.substrs[1].str)
                    )
                && S_setup_longest (aTHX_ var_491,
                                        &((var_491->rx)->substrs->data[var_531]),
                                        &(data.substrs[var_531]),
                                        var_245[var_531]))
            {
                (var_491->rx)->substrs->data[var_531].min_offset =
                        data.substrs[var_531].min_offset - data.substrs[var_531].lookbehind;

                (var_491->rx)->substrs->data[var_531].max_offset = data.substrs[var_531].max_offset;

                if (data.substrs[var_531].max_offset < var_245)
                    (var_491->rx)->substrs->data[var_531].max_offset -= data.substrs[var_531].lookbehind;
                SvREFCNT_inc_simple_void_NN(data.substrs[var_531].str);
            }
            else {
                (var_491->rx)->substrs->data[var_531].substr = NULL;
                (var_491->rx)->substrs->data[var_531].utf8_substr = NULL;
                var_245[var_531] = 0;
            }
        }

 LEAVE_with_name("study_chunk");

 if ((var_491->rxi)->regstclass
     && (OP((var_491->rxi)->regstclass) == REG_ANY || OP((var_491->rxi)->regstclass) == SANY))
     (var_491->rxi)->regstclass = NULL;

 if ((!((var_491->rx)->substrs->data[0].substr || (var_491->rx)->substrs->data[0].utf8_substr)
              || (var_491->rx)->substrs->data[0].min_offset)
     && stclass_flag
            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)
     && is_ssc_worth_it(var_491, data.start_class))
 {
     const U32 var_498 = add_data(var_491, STR_WITH_LEN("f"));

            ssc_finalize(var_491, data.start_class);

     Newx((var_491->rxi)->data->data[var_498], 1, regnode_ssc);
     StructCopy(data.start_class,
         (regnode_ssc*)(var_491->rxi)->data->data[var_498],
         regnode_ssc);
     (var_491->rxi)->regstclass = (regnode*)(var_491->rxi)->data->data[var_498];
     (var_491->rx)->intflags &= ~PREGf_SKIP;
     DEBUG_COMPILE_r({ SV *sv = sv_newmortal();
                      regprop((var_491->rx), sv, (regnode*)data.start_class, NULL, var_491);
                      Perl_re_printf( aTHX_
        "synthetic stclass \"%s\".\n",
        SvPVX_const(sv));});
            data.start_class = NULL;
 }



 var_531 = (var_245[0] <= var_245[1]);
        (var_491->rx)->substrs->check_ix = var_531;
        (var_491->rx)->check_end_shift = (var_491->rx)->substrs->data[var_531].end_shift;
        (var_491->rx)->check_substr = (var_491->rx)->substrs->data[var_531].substr;
        (var_491->rx)->check_utf8 = (var_491->rx)->substrs->data[var_531].utf8_substr;
        (var_491->rx)->check_offset_min = (var_491->rx)->substrs->data[var_531].min_offset;
        (var_491->rx)->check_offset_max = (var_491->rx)->substrs->data[var_531].max_offset;
        if (!var_531 && ((var_491->rx)->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))
            (var_491->rx)->intflags |= PREGf_NOSCAN;

 if (((var_491->rx)->check_substr || (var_491->rx)->check_utf8) ) {
     (var_491->rx)->extflags |= RXf_USE_INTUIT;
     if (SvTAIL((var_491->rx)->check_substr ? (var_491->rx)->check_substr : (var_491->rx)->check_utf8))
  (var_491->rx)->extflags |= RXf_INTUIT_TAIL;
 }







    }
    else {

 SSize_t var_245;
 regnode_ssc ch_class;
 SSize_t var_245 = 0;

        DEBUG_PARSE_r(Perl_re_printf( aTHX_ "\nMulti Top Level\n"));

 var_486 = (var_491->rxi)->program + 1;
 ssc_init(var_491, &ch_class);
 data.start_class = &ch_class;
 data.last_closep = &var_245;

        DEBUG_OPTIMISE_MORE_r({ Perl_re_printf( aTHX_ "RExC_seen: "); if ((var_491->seen) & REG_ZERO_LEN_SEEN) Perl_re_printf( aTHX_ "REG_ZERO_LEN_SEEN "); if ((var_491->seen) & REG_LOOKBEHIND_SEEN) Perl_re_printf( aTHX_ "REG_LOOKBEHIND_SEEN "); if ((var_491->seen) & REG_GPOS_SEEN) Perl_re_printf( aTHX_ "REG_GPOS_SEEN "); if ((var_491->seen) & REG_RECURSE_SEEN) Perl_re_printf( aTHX_ "REG_RECURSE_SEEN "); if ((var_491->seen) & REG_TOP_LEVEL_BRANCHES_SEEN) Perl_re_printf( aTHX_ "REG_TOP_LEVEL_BRANCHES_SEEN "); if ((var_491->seen) & REG_VERBARG_SEEN) Perl_re_printf( aTHX_ "REG_VERBARG_SEEN "); if ((var_491->seen) & REG_CUTGROUP_SEEN) Perl_re_printf( aTHX_ "REG_CUTGROUP_SEEN "); if ((var_491->seen) & REG_RUN_ON_COMMENT_SEEN) Perl_re_printf( aTHX_ "REG_RUN_ON_COMMENT_SEEN "); if ((var_491->seen) & REG_UNFOLDED_MULTI_SEEN) Perl_re_printf( aTHX_ "REG_UNFOLDED_MULTI_SEEN "); if ((var_491->seen) & REG_UNBOUNDED_QUANTIFIER_SEEN) Perl_re_printf( aTHX_ "REG_UNBOUNDED_QUANTIFIER_SEEN "); Perl_re_printf( aTHX_ "\n"); });;




 var_245 = study_chunk(var_491,
            &var_486, &var_245, &var_245, var_486 + (var_491->size), &data, -1, 0, NULL,
            0x0800|0x2000|(restudied
                                                      ? 0x10000
                                                      : 0),
            0);

                                   (NOOP);

 (var_491->rx)->check_substr = NULL;
        (var_491->rx)->check_utf8 = NULL;
        (var_491->rx)->substrs->data[0].substr = NULL;
        (var_491->rx)->substrs->data[0].utf8_substr = NULL;
        (var_491->rx)->substrs->data[1].substr = NULL;
        (var_491->rx)->substrs->data[1].utf8_substr = NULL;

        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)
     && is_ssc_worth_it(var_491, data.start_class))
        {
     const U32 var_498 = add_data(var_491, STR_WITH_LEN("f"));

            ssc_finalize(var_491, data.start_class);

     Newx((var_491->rxi)->data->data[var_498], 1, regnode_ssc);
     StructCopy(data.start_class,
         (regnode_ssc*)(var_491->rxi)->data->data[var_498],
         regnode_ssc);
     (var_491->rxi)->regstclass = (regnode*)(var_491->rxi)->data->data[var_498];
     (var_491->rx)->intflags &= ~PREGf_SKIP;
     DEBUG_COMPILE_r({ SV* sv = sv_newmortal();
                      regprop((var_491->rx), sv, (regnode*)data.start_class, NULL, var_491);
                      Perl_re_printf( aTHX_
        "synthetic stclass \"%s\".\n",
        SvPVX_const(sv));});
            data.start_class = NULL;
 }
    }

    if ((var_491->seen) & REG_UNBOUNDED_QUANTIFIER_SEEN) {
        (var_491->rx)->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;
        (var_491->rx)->maxlen = var_372;
    }
    else {
        (var_491->rx)->maxlen = (var_491->maxlen);
    }



    DEBUG_OPTIMISE_r({
        Perl_re_printf( aTHX_ "minlen: %" IVdf " RExC_rx->minlen:%" IVdf " maxlen:%" IVdf "\n",
                      (IV)var_245, (IV)(var_491->rx)->minlen, (IV)(var_491->maxlen));
    });
    (var_491->rx)->minlenret = var_245;
    if ((var_491->rx)->minlen < var_245)
        (var_491->rx)->minlen = var_245;

    if ((var_491->seen) & REG_RECURSE_SEEN ) {
        (var_491->rx)->intflags |= PREGf_RECURSE_SEEN;
        Newx((var_491->rx)->recurse_locinput, (var_491->rx)->nparens + 1, char *);
    }
    if ((var_491->seen) & REG_GPOS_SEEN)
        (var_491->rx)->intflags |= PREGf_GPOS_SEEN;
    if ((var_491->seen) & REG_LOOKBEHIND_SEEN)
        (var_491->rx)->extflags |= RXf_NO_INPLACE_SUBST;

    if (var_491->code_blocks)
 (var_491->rx)->extflags |= RXf_EVAL_SEEN;
    if ((var_491->seen) & REG_VERBARG_SEEN)
    {
 (var_491->rx)->intflags |= PREGf_VERBARG_SEEN;
        (var_491->rx)->extflags |= RXf_NO_INPLACE_SUBST;
    }
    if ((var_491->seen) & REG_CUTGROUP_SEEN)
 (var_491->rx)->intflags |= PREGf_CUTGROUP_SEEN;
    if (var_245 & PMf_USE_RE_EVAL)
 (var_491->rx)->intflags |= PREGf_USE_RE_EVAL;
    if ((var_491->paren_names))
        RXp_PAREN_NAMES((var_491->rx)) = MUTABLE_HV(SvREFCNT_inc((var_491->paren_names)));
    else
        RXp_PAREN_NAMES((var_491->rx)) = NULL;



    if ((var_491->rx)->intflags & PREGf_ANCH)
        (var_491->rx)->extflags |= RXf_IS_ANCHORED;


    {







        regnode *var_369 = (var_491->rxi)->program + 1;
        U8 var_247 = OP(var_369);
        regnode *next = regnext(var_369);
        U8 var_247 = OP(next);

        if (PL_regkind[var_247] == NOTHING && var_247 == var_461)
            (var_491->rx)->extflags |= RXf_NULL;
        else if ((var_247 == MBOL || (var_247 == SBOL && !var_369->flags)) && var_247 == var_461)





            (var_491->rx)->extflags |= RXf_START_ONLY;
        else if (var_247 == PLUS
                 && PL_regkind[var_247] == POSIXD && FLAGS(next) == _CC_SPACE
                 && var_247 == var_461)
            (var_491->rx)->extflags |= RXf_WHITE;
        else if ( (var_491->rx)->extflags & RXf_SPLIT
                  && (var_247 == var_454 || var_247 == EXACT_ONLY8 || var_247 == EXACTL)
                  && STR_LEN(var_369) == 1
                  && *(STRING(var_369)) == ' '
                  && var_247 == var_461 )
            (var_491->rx)->extflags |= (RXf_SKIPWHITE|RXf_WHITE);

    }

    if ((var_491->contains_locale)) {
        RXp_EXTFLAGS((var_491->rx)) |= RXf_TAINTED;
    }

    (var_491->rxi)->name_list_idx = 0;

    while ( (var_491->recurse_count) > 0 ) {
        const regnode *var_486 = (var_491->recurse)[ --(var_491->recurse_count) ];

        assert(var_486 && OP(var_486) == GOSUB);
        ARG2L_SET( var_486, (var_491->open_parens)[ARG(var_486)] - ((var_486) - (var_491->emit_start)));
    }

    Newxz((var_491->rx)->offs, (var_491->total_par), regexp_paren_pair);

    DEBUG_TEST_r({
        Perl_re_printf( aTHX_ "study_chunk_recursed_count: %lu\n",
            (unsigned long)RExC_study_chunk_recursed_count);
    });
    DEBUG_DUMP_r({
        DEBUG_OPTIMISE_MORE_r({ Perl_re_printf( aTHX_ "RExC_seen: "); if ((var_491->seen) & REG_ZERO_LEN_SEEN) Perl_re_printf( aTHX_ "REG_ZERO_LEN_SEEN "); if ((var_491->seen) & REG_LOOKBEHIND_SEEN) Perl_re_printf( aTHX_ "REG_LOOKBEHIND_SEEN "); if ((var_491->seen) & REG_GPOS_SEEN) Perl_re_printf( aTHX_ "REG_GPOS_SEEN "); if ((var_491->seen) & REG_RECURSE_SEEN) Perl_re_printf( aTHX_ "REG_RECURSE_SEEN "); if ((var_491->seen) & REG_TOP_LEVEL_BRANCHES_SEEN) Perl_re_printf( aTHX_ "REG_TOP_LEVEL_BRANCHES_SEEN "); if ((var_491->seen) & REG_VERBARG_SEEN) Perl_re_printf( aTHX_ "REG_VERBARG_SEEN "); if ((var_491->seen) & REG_CUTGROUP_SEEN) Perl_re_printf( aTHX_ "REG_CUTGROUP_SEEN "); if ((var_491->seen) & REG_RUN_ON_COMMENT_SEEN) Perl_re_printf( aTHX_ "REG_RUN_ON_COMMENT_SEEN "); if ((var_491->seen) & REG_UNFOLDED_MULTI_SEEN) Perl_re_printf( aTHX_ "REG_UNFOLDED_MULTI_SEEN "); if ((var_491->seen) & REG_UNBOUNDED_QUANTIFIER_SEEN) Perl_re_printf( aTHX_ "REG_UNBOUNDED_QUANTIFIER_SEEN "); Perl_re_printf( aTHX_ "\n"); });;
        Perl_re_printf( aTHX_ "Final program:\n");
        regdump((var_491->rx));
    });

    if ((var_491->open_parens)) {
        Safefree((var_491->open_parens));
        (var_491->open_parens) = NULL;
    }
    if ((var_491->close_parens)) {
        Safefree((var_491->close_parens));
        (var_491->close_parens) = NULL;
    }

    return Rx;
}


SV*
fn_247(pTHX_ REGEXP * const rx, SV * const var_533, SV * const var_533,
                    const U32 var_451)
{
    PERL_ARGS_ASSERT_REG_NAMED_BUFF;

    PERL_UNUSED_ARG(var_533);

    if (var_451 & RXapif_FETCH) {
        return reg_named_buff_fetch(rx, var_533, var_451);
    } else if (var_451 & (RXapif_STORE | RXapif_DELETE | RXapif_CLEAR)) {
        Perl_croak_no_modify();
        return NULL;
    } else if (var_451 & RXapif_EXISTS) {
        return reg_named_buff_exists(rx, var_533, var_451)
            ? &PL_sv_yes
            : &PL_sv_no;
    } else if (var_451 & RXapif_REGNAMES) {
        return reg_named_buff_all(rx, var_451);
    } else if (var_451 & (RXapif_SCALAR | RXapif_REGNAMES_COUNT)) {
        return reg_named_buff_scalar(rx, var_451);
    } else {
        Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff", (int)var_451);
        return NULL;
    }
}

SV*
fn_249(pTHX_ REGEXP * const rx, const SV * const lastkey,
                         const U32 var_451)
{
    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ITER;
    PERL_UNUSED_ARG(lastkey);

    if (var_451 & RXapif_FIRSTKEY)
        return reg_named_buff_firstkey(rx, var_451);
    else if (var_451 & RXapif_NEXTKEY)
        return reg_named_buff_nextkey(rx, var_451);
    else {
        Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_iter",
                                            (int)var_451);
        return NULL;
    }
}

SV*
fn_250(pTHX_ REGEXP * const r, SV * const namesv,
     const U32 var_451)
{
    SV *var_483;
    struct struct_498 *const rx = ReANY(r);

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH;

    if (rx && RXp_PAREN_NAMES(rx)) {
        HE *he_str = hv_fetch_ent( RXp_PAREN_NAMES(rx), namesv, 0, 0 );
        if (he_str) {
            IV var_531;
            SV* sv_dat=HeVAL(he_str);
            I32 *nums=(I32*)SvPVX(sv_dat);
            AV * const retarray = (var_451 & RXapif_ALL) ? newAV() : NULL;
            for ( var_531=0; var_531<SvIVX(sv_dat); var_531++ ) {
                if ((I32)(rx->nparens) >= nums[var_531]
                    && rx->offs[nums[var_531]].start != -1
                    && rx->offs[nums[var_531]].end != -1)
                {
                    var_483 = newSVpvs("");
                    CALLREG_NUMBUF_FETCH(r, nums[var_531], var_483);
                    if (!retarray)
                        return var_483;
                } else {
                    if (retarray)
                        var_483 = newSVsv(&PL_sv_undef);
                }
                if (retarray)
                    av_push(retarray, var_483);
            }
            if (retarray)
                return newRV_noinc(MUTABLE_SV(retarray));
        }
    }
    return NULL;
}

bool
fn_252(pTHX_ REGEXP * const r, SV * const var_533,
                           const U32 var_451)
{
    struct struct_498 *const rx = ReANY(r);

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS;

    if (rx && RXp_PAREN_NAMES(rx)) {
        if (var_451 & RXapif_ALL) {
            return hv_exists_ent(RXp_PAREN_NAMES(rx), var_533, 0);
        } else {
     SV *sv = CALLREG_NAMED_BUFF_FETCH(r, var_533, var_451);
            if (sv) {
  SvREFCNT_dec_NN(sv);
                return TRUE;
            } else {
                return FALSE;
            }
        }
    } else {
        return FALSE;
    }
}

SV*
fn_253(pTHX_ REGEXP * const r, const U32 var_451)
{
    struct struct_498 *const rx = ReANY(r);

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY;

    if ( rx && RXp_PAREN_NAMES(rx) ) {
 (void)hv_iterinit(RXp_PAREN_NAMES(rx));

 return CALLREG_NAMED_BUFF_NEXTKEY(r, NULL, var_451 & ~RXapif_FIRSTKEY);
    } else {
 return FALSE;
    }
}

SV*
fn_254(pTHX_ REGEXP * const r, const U32 var_451)
{
    struct struct_498 *const rx = ReANY(r);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;

    if (rx && RXp_PAREN_NAMES(rx)) {
        HV *hv = RXp_PAREN_NAMES(rx);
        HE *temphe;
        while ( (temphe = hv_iternext_flags(hv, 0)) ) {
            IV var_531;
            IV var_366 = 0;
            SV* sv_dat = HeVAL(temphe);
            I32 *nums = (I32*)SvPVX(sv_dat);
            for ( var_531 = 0; var_531 < SvIVX(sv_dat); var_531++ ) {
                if ((I32)(rx->lastparen) >= nums[var_531] &&
                    rx->offs[nums[var_531]].start != -1 &&
                    rx->offs[nums[var_531]].end != -1)
                {
                    var_366 = nums[var_531];
                    break;
                }
            }
            if (var_366 || var_451 & RXapif_ALL) {
  return newSVhek(HeKEY_hek(temphe));
            }
        }
    }
    return NULL;
}

SV*
fn_256(pTHX_ REGEXP * const r, const U32 var_451)
{
    SV *var_483;
    AV *av;
    SSize_t var_385;
    struct struct_498 *const rx = ReANY(r);

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_SCALAR;

    if (rx && RXp_PAREN_NAMES(rx)) {
        if (var_451 & (RXapif_ALL | RXapif_REGNAMES_COUNT)) {
            return newSViv(HvTOTALKEYS(RXp_PAREN_NAMES(rx)));
        } else if (var_451 & RXapif_ONE) {
            var_483 = CALLREG_NAMED_BUFF_ALL(r, (var_451 | RXapif_REGNAMES));
            av = MUTABLE_AV(SvRV(var_483));
            var_385 = av_tindex(av);
     SvREFCNT_dec_NN(var_483);
            return newSViv(var_385 + 1);
        } else {
            Perl_croak(aTHX_ "panic: Unknown flags %d in named_buff_scalar",
                                                (int)var_451);
            return NULL;
        }
    }
    return &PL_sv_undef;
}

SV*
fn_258(pTHX_ REGEXP * const r, const U32 var_451)
{
    struct struct_498 *const rx = ReANY(r);
    AV *av = newAV();

    PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL;

    if (rx && RXp_PAREN_NAMES(rx)) {
        HV *hv= RXp_PAREN_NAMES(rx);
        HE *temphe;
        (void)hv_iterinit(hv);
        while ( (temphe = hv_iternext_flags(hv, 0)) ) {
            IV var_531;
            IV var_366 = 0;
            SV* sv_dat = HeVAL(temphe);
            I32 *nums = (I32*)SvPVX(sv_dat);
            for ( var_531 = 0; var_531 < SvIVX(sv_dat); var_531++ ) {
                if ((I32)(rx->lastparen) >= nums[var_531] &&
                    rx->offs[nums[var_531]].start != -1 &&
                    rx->offs[nums[var_531]].end != -1)
                {
                    var_366 = nums[var_531];
                    break;
                }
            }
            if (var_366 || var_451 & RXapif_ALL) {
                av_push(av, newSVhek(HeKEY_hek(temphe)));
            }
        }
    }

    return newRV_noinc(MUTABLE_SV(av));
}

void
fn_259(pTHX_ REGEXP * const r, const I32 var_485,
        SV * const sv)
{
    struct struct_498 *const rx = ReANY(r);
    char *var_512 = NULL;
    SSize_t var_531 = 0;
    SSize_t s1, t1;
    I32 var_498 = var_485;

    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_FETCH;

    if ( var_498 == RX_BUFF_IDX_CARET_PREMATCH
           || var_498 == RX_BUFF_IDX_CARET_FULLMATCH
           || var_498 == RX_BUFF_IDX_CARET_POSTMATCH
       )
    {
        bool var_265 = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);
        if (!var_265) {




            if (PL_curpm && r == PM_GETRE(PL_curpm))
                 var_265 = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);
        }
        if (!var_265)
            goto ret_undef;
    }

    if (!rx->subbeg)
        goto ret_undef;

    if (var_498 == RX_BUFF_IDX_CARET_FULLMATCH)

        var_498 = RX_BUFF_IDX_FULLMATCH;

    if ((var_498 == RX_BUFF_IDX_PREMATCH || var_498 == RX_BUFF_IDX_CARET_PREMATCH)
        && rx->offs[0].start != -1)
    {

 var_531 = rx->offs[0].start;
 var_512 = rx->subbeg;
    }
    else
    if ((var_498 == RX_BUFF_IDX_POSTMATCH || var_498 == RX_BUFF_IDX_CARET_POSTMATCH)
        && rx->offs[0].end != -1)
    {

 var_512 = rx->subbeg - rx->suboffset + rx->offs[0].end;
 var_531 = rx->sublen + rx->suboffset - rx->offs[0].end;
    }
    else
    if ( 0 <= var_498 && var_498 <= (I32)rx->nparens &&
        (s1 = rx->offs[var_498].start) != -1 &&
        (t1 = rx->offs[var_498].end) != -1)
    {

        var_531 = t1 - s1;
        var_512 = rx->subbeg + s1 - rx->suboffset;
    } else {
        goto ret_undef;
    }

    assert(var_512 >= rx->subbeg);
    assert((STRLEN)rx->sublen >= (var_361)((var_512 - rx->subbeg) + var_531) );
    if (var_531 >= 0) {



        const int var_274 = var_538;
        TAINT_NOT;
        sv_setpvn(sv, var_512, var_531);
        TAINT_set(var_274);

        if (RXp_MATCH_UTF8(rx))
            SvUTF8_on(sv);
        else
            SvUTF8_off(sv);
        if (TAINTING_get) {
            if (RXp_MATCH_TAINTED(rx)) {
                if (SvTYPE(sv) >= SVt_PVMG) {
                    MAGIC* const mg = SvMAGIC(sv);
                    MAGIC* mgt;
                    TAINT;
                    SvMAGIC_set(sv, mg->mg_moremagic);
                    SvTAINT(sv);
                    if ((mgt = SvMAGIC(sv))) {
                        mg->mg_moremagic = mgt;
                        SvMAGIC_set(sv, mg);
                    }
                } else {
                    TAINT;
                    SvTAINT(sv);
                }
            } else
                SvTAINTED_off(sv);
        }
    } else {
      ret_undef:
        sv_set_undef(sv);
        return;
    }
}

void
fn_263(pTHX_ REGEXP * const rx, const I32 var_485,
        SV const * const var_533)
{
    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_STORE;

    PERL_UNUSED_ARG(rx);
    PERL_UNUSED_ARG(var_485);
    PERL_UNUSED_ARG(var_533);

    if (!PL_localizing)
        Perl_croak_no_modify();
}

I32
fn_264(pTHX_ REGEXP * const r, const SV * const sv,
                              const I32 var_485)
{
    struct struct_498 *const rx = ReANY(r);
    I32 var_531;
    I32 s1, t1;

    PERL_ARGS_ASSERT_REG_NUMBERED_BUFF_LENGTH;

    if ( var_485 == RX_BUFF_IDX_CARET_PREMATCH
        || var_485 == RX_BUFF_IDX_CARET_FULLMATCH
        || var_485 == RX_BUFF_IDX_CARET_POSTMATCH
    )
    {
        bool var_265 = cBOOL(rx->extflags & RXf_PMf_KEEPCOPY);
        if (!var_265) {




            if (PL_curpm && r == PM_GETRE(PL_curpm))
                 var_265 = cBOOL(PL_curpm->op_pmflags & PMf_KEEPCOPY);
        }
        if (!var_265)
            goto warn_undef;
    }


    switch (var_485) {
      case RX_BUFF_IDX_CARET_PREMATCH:
      case RX_BUFF_IDX_PREMATCH:
        if (rx->offs[0].start != -1) {
   var_531 = rx->offs[0].start;
   if (var_531 > 0) {
    s1 = 0;
    t1 = var_531;
    goto getlen;
   }
     }
        return 0;

      case RX_BUFF_IDX_CARET_POSTMATCH:
      case RX_BUFF_IDX_POSTMATCH:
     if (rx->offs[0].end != -1) {
   var_531 = rx->sublen - rx->offs[0].end;
   if (var_531 > 0) {
    s1 = rx->offs[0].end;
    t1 = rx->sublen;
    goto getlen;
   }
     }
        return 0;

      default:
     if (var_485 <= (I32)rx->nparens &&
            (s1 = rx->offs[var_485].start) != -1 &&
            (t1 = rx->offs[var_485].end) != -1)
     {
            var_531 = t1 - s1;
            goto getlen;
        } else {
          warn_undef:
            if (ckWARN(WARN_UNINITIALIZED))
                report_uninit((const SV *)sv);
            return 0;
        }
    }
  getlen:
    if (var_531 > 0 && RXp_MATCH_UTF8(rx)) {
        const char * const var_512 = rx->subbeg - rx->suboffset + s1;
        const U8 *ep;
        STRLEN el;

        var_531 = t1 - s1;
        if (is_utf8_string_loclen((U8*)var_512, var_531, &ep, &el))
   var_531 = el;
    }
    return var_531;
}

SV*
fn_265(pTHX_ REGEXP * const rx)
{
    PERL_ARGS_ASSERT_REG_QR_PACKAGE;
 PERL_UNUSED_ARG(rx);
 if 0
     return NULL;
 else
     return newSVpvs("Regexp");
}

static SV*
fn_266(pTHX_ RExC_state_t *var_491, U32 var_451)
{
    char *name_start = (var_491->parse);
    SV* sv_name;

    PERL_ARGS_ASSERT_REG_SCAN_NAME;

    assert ((var_491->parse) <= (var_491->end));
    if ((var_491->parse) == (var_491->end)) NOOP;
    else if (isIDFIRST_lazy_if_safe((var_491->parse), (var_491->end), cBOOL((var_491->utf8)))) {


 if (cBOOL((var_491->utf8)))
     do {
  (var_491->parse) += UTF8SKIP((var_491->parse));
     } while ( (var_491->parse) < (var_491->end)
                     && isWORDCHAR_utf8_safe((U8*)(var_491->parse), (U8*) (var_491->end)));
 else
     do {
  (var_491->parse)++;
     } while ((var_491->parse) < (var_491->end) && isWORDCHAR(*(var_491->parse)));
    } else {
        (var_491->parse)++;

        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Group name must start with a non-digit word character", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 8856, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }
    sv_name = newSVpvn_flags(name_start, (int)((var_491->parse) - name_start),
        SVs_TEMP | (cBOOL((var_491->utf8)) ? SVf_UTF8 : 0));
    if ( var_451 == 1)
        return sv_name;
    else if (var_451==2) {
        HE *he_str = NULL;
        SV *sv_dat = NULL;
        if ( ! sv_name )
            Perl_croak(aTHX_ "panic: no svname in reg_scan_name");
        if ((var_491->paren_names))
            he_str = hv_fetch_ent( (var_491->paren_names), sv_name, 0, 0 );
        if ( he_str )
            sv_dat = HeVAL(he_str);
        if ( ! sv_dat ) {




            if (((var_491->total_par) > 0)) {
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Reference to nonexistent named group", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 8877, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
            }
            else {
                STMT_START { if (! ((var_491->total_par) > 0)) (var_491->total_par) = -1; } STMT_END;
            }
        }
        return sv_dat;
    }

    Perl_croak(aTHX_ "panic: bad flag %lx in reg_scan_name",
                     (unsigned long) var_451);
}

PERL_STATIC_INLINE UV*
fn_267(SV* const invlist, const bool var_269)
{

    bool* var_499 = get_invlist_offset_addr(invlist);
    UV* zero_addr = (UV *) SvPVX(invlist);

    PERL_ARGS_ASSERT__INVLIST_ARRAY_INIT;


    assert(! _invlist_len(invlist));

    *zero_addr = 0;


    *var_499 = 1 ^ var_269;
    return zero_addr + *var_499;
}

PERL_STATIC_INLINE void
fn_269(pTHX_ SV* const invlist, const UV var_531, const bool var_499)
{


    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_INVLIST_SET_LEN;

    assert(is_invlist(invlist));

    SvCUR_set(invlist,
              (var_531 == 0)
               ? 0
               : TO_INTERNAL_SIZE(var_531 + var_499));
    assert(SvLEN(invlist) == 0 || SvCUR(invlist) <= SvLEN(invlist));
}

static void
fn_270(pTHX_ SV * dest, SV * src)
{





    const UV var_274 = _invlist_len(src);
    const bool var_274 = *get_invlist_offset_addr(src);
    const STRLEN var_274 = SvLEN(src);
    char * array = SvPVX(src);

    const int var_274 = var_538;

    PERL_ARGS_ASSERT_INVLIST_REPLACE_LIST_DESTROYS_SRC;

    assert(is_invlist(src));
    assert(is_invlist(dest));
    assert(! invlist_is_iterating(src));
    assert(SvCUR(src) == 0 || SvCUR(src) < SvLEN(src));




    array[var_274 - 1] = '\0';

    TAINT_NOT;
    sv_usepvn_flags(dest,
                    (char *) array,
                    var_274 - 1,


                    SV_HAS_TRAILING_NUL);
    TAINT_set(var_274);
    SvPV_set(src, 0);
    SvLEN_set(src, 0);
    SvCUR_set(src, 0);


    *get_invlist_offset_addr(dest) = var_274;
    invlist_set_len(dest, var_274, var_274);
    *get_invlist_previous_index_addr(dest) = 0;
    invlist_iterfinish(dest);
}

PERL_STATIC_INLINE IV*
fn_274(SV* invlist)
{


    PERL_ARGS_ASSERT_GET_INVLIST_PREVIOUS_INDEX_ADDR;

    assert(is_invlist(invlist));

    return &(((XINVLIST*) SvANY(invlist))->prev_index);
}

PERL_STATIC_INLINE IV
fn_275(SV* const invlist)
{


    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;

    return *get_invlist_previous_index_addr(invlist);
}

PERL_STATIC_INLINE void
fn_276(SV* const invlist, const IV var_278)
{


    PERL_ARGS_ASSERT_INVLIST_SET_PREVIOUS_INDEX;

    assert(var_278 == 0 || var_278 < (int) _invlist_len(invlist));

    *get_invlist_previous_index_addr(invlist) = var_278;
}

PERL_STATIC_INLINE void
fn_278(SV* invlist)
{




    const UV var_280 = TO_INTERNAL_SIZE(1) + 1;

    PERL_ARGS_ASSERT_INVLIST_TRIM;

    assert(is_invlist(invlist));

    SvPV_renew(invlist, MAX(var_280, SvCUR(invlist) + 1));
}

PERL_STATIC_INLINE void
fn_280(pTHX_ SV* invlist)
{
    PERL_ARGS_ASSERT_INVLIST_CLEAR;

    assert(is_invlist(invlist));

    invlist_set_len(invlist, 0, 0);
    invlist_trim(invlist);
}



PERL_STATIC_INLINE var_499
fn_282(SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_IS_ITERATING;

    return *(get_invlist_iter_addr(invlist)) < (STRLEN) var_459;
}



PERL_STATIC_INLINE UV
fn_283(SV* const invlist)
{



    PERL_ARGS_ASSERT_INVLIST_MAX;

    assert(is_invlist(invlist));



    return SvLEN(invlist) == 0
           ? FROM_INTERNAL_SIZE(SvCUR(invlist)) - 1
           : FROM_INTERNAL_SIZE(SvLEN(invlist)) - 1;
}

static void
fn_284(pTHX_ SV* invlist, const Size_t var_401)
{
    PERL_ARGS_ASSERT_INITIALIZE_INVLIST_GUTS;



    SvGROW(invlist, TO_INTERNAL_SIZE(var_401 + 1) + 1);
    invlist_set_len(invlist, 0, 0);


    invlist_iterfinish(invlist);

    *get_invlist_previous_index_addr(invlist) = 0;
}

SV*
fn_286(pTHX_ IV var_401)
{





    SV* new_list;

    if (var_401 < 0) {
 var_401 = 10;
    }

    new_list = newSV_type(SVt_INVLIST);
    initialize_invlist_guts(new_list, var_401);

    return new_list;
}

SV*
fn_287(pTHX_ const UV* const list)
{







    const STRLEN var_385 = (STRLEN) list[0];
    const UV var_289 = list[1];
    const bool var_499 = cBOOL(list[2]);

    SV* invlist = newSV_type(SVt_INVLIST);

    PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY;

    if (var_289 != 148565664) {
        Perl_croak(aTHX_ "panic: Incorrect version for previously generated inversion list");
    }



    SvPV_set(invlist, (char *) (list + 3));

    SvLEN_set(invlist, 0);


    *(get_invlist_offset_addr(invlist)) = var_499;




    invlist_set_len(invlist, var_385 - var_499, var_499);

    invlist_set_previous_index(invlist, 0);


    invlist_iterfinish(invlist);

    SvREADONLY_on(invlist);

    return invlist;
}

static void
fn_289(pTHX_ SV* const invlist, const UV var_291)
{


    PERL_ARGS_ASSERT_INVLIST_EXTEND;

    assert(is_invlist(invlist));



    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(var_291 + 1));
}

static void
fn_291(pTHX_ SV* const invlist,
                                 const UV var_463, const UV var_454)
{




    UV* array;
    UV var_512 = invlist_max(invlist);
    UV var_531 = _invlist_len(invlist);
    bool var_499;

    PERL_ARGS_ASSERT__APPEND_RANGE_TO_INVLIST;

    if (var_531 == 0) {
        var_499 = var_463 != 0;
        array = _invlist_array_init(invlist, ! var_499);
    }
    else {






 UV var_293 = var_531 - 1;
 array = invlist_array(invlist);
 if ( array[var_293] > var_463
     || ELEMENT_RANGE_MATCHES_INVLIST(var_293))
 {
     Perl_croak(aTHX_ "panic: attempting to append to an inversion list, but wasn't at the end of the list, final=%" UVuf ", start=%" UVuf ", match=%c",
       array[var_293], var_463,
       ELEMENT_RANGE_MATCHES_INVLIST(var_293) ? 't' : 'f');
 }





        var_499 = *get_invlist_offset_addr(invlist);
 if (array[var_293] == var_463) {
     if (var_454 != var_459) {
  array[var_293] = var_454 + 1;
     }
     else {



  invlist_set_len(invlist, var_531 - 1, var_499);
     }
     return;
 }
    }



    var_531 += 2;



    if (var_512 < var_531) {
 invlist_extend(invlist, var_531);


        invlist_set_len(invlist, var_531, var_499);

 array = invlist_array(invlist);
    }
    else {
 invlist_set_len(invlist, var_531, var_499);
    }



    array[var_531 - 2] = var_463;
    if (var_454 != var_459) {
 array[var_531 - 1] = var_454 + 1;
    }
    else {


 invlist_set_len(invlist, var_531 - 1, var_499);
    }
}

SSize_t
fn_293(SV* const invlist, const UV var_470)
{







    IV var_297 = 0;
    IV mid;
    IV var_404 = _invlist_len(invlist);
    const IV var_297 = var_404 - 1;
    const UV* array;

    PERL_ARGS_ASSERT__INVLIST_SEARCH;


    if (var_404 == 0) {
 return -1;
    }


    array = invlist_array(invlist);

    mid = invlist_previous_index(invlist);
    assert(mid >=0);
    if (mid > var_297) {
        mid = var_297;
    }

    if (var_470 >= array[mid]) {
        if (var_470 >= array[var_297]) {
            return var_297;
        }





        if (var_470 < array[mid + 1]) {
            return mid;
        }
        var_404--;
        var_297 = mid + 1;
    }
    else {
        if (var_470 < array[0]) {
            return -1;
        }
        var_404 = mid;
        if (var_470 >= array[mid - 1]) {
            goto found_entry;
        }
    }





    while (var_297 < var_404) {
 mid = (var_297 + var_404) / 2;
        assert(mid <= var_297);
 if (array[mid] <= var_470) {
     var_297 = mid + 1;






 }
 else {
     var_404 = mid;
 }
    }

  found_entry:
    var_404--;
    invlist_set_previous_index(invlist, var_404);
    return var_404;
}

void
fn_297(pTHX_ SV* const a, SV* const var_307,
                                         const bool var_307, SV** output)
{

    const UV* array_a;
    const UV* array_b;
    UV len_a;
    UV len_b;

    SV* u;
    UV* array_u;
    UV var_304 = 0;

    UV var_307 = 0;
    UV var_307 = 0;
    UV var_304 = 0;

    UV var_489 = 0;

    PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND;
    assert(a != var_307);
    assert(*output == NULL || is_invlist(*output));

    len_b = _invlist_len(var_307);
    if (len_b == 0) {





        if (var_307) {
            SV* everything = _add_range_to_invlist(NULL, 0, var_459);

            if (*output == NULL) {

                *output = everything;
            }
            else {
                invlist_replace_list_destroys_src(*output, everything);
                SvREFCNT_dec_NN(everything);
            }

            return;
        }





        if (a == NULL || _invlist_len(a) == 0) {
            if (*output == NULL) {
                *output = _new_invlist(0);
            }
            else {
                invlist_clear(*output);
            }
            return;
        }




        if (*output == NULL) {
            *output = invlist_clone(a, NULL);
            return;
        }



        if (*output == a) {
            return;
        }


        u = invlist_clone(a, NULL);
        invlist_replace_list_destroys_src(*output, u);
        SvREFCNT_dec_NN(u);

        return;
    }



    if (a == NULL || ((len_a = _invlist_len(a)) == 0)) {






        SV ** dest = (*output == NULL) ? output : &u;
        *dest = invlist_clone(var_307, NULL);
        if (var_307) {
            _invlist_invert(*dest);
        }

        if (dest == &u) {
            invlist_replace_list_destroys_src(*output, u);
            SvREFCNT_dec_NN(u);
        }

 return;
    }


    array_a = invlist_array(a);
    array_b = invlist_array(var_307);



    if (var_307) {



        if (array_b[0] == 0) {
            array_b++;
            len_b--;
        }
        else {



            array_b--;
            len_b++;
        }
    }



    u = _new_invlist(len_a + len_b);


    array_u = _invlist_array_init(u, ( len_a > 0 && array_a[0] == 0)
                                      || (len_b > 0 && array_b[0] == 0));



    while (var_307 < len_a && var_307 < len_b) {
 UV var_470;
 bool cp_in_set;

 if ( array_a[var_307] < array_b[var_307]
     || ( array_a[var_307] == array_b[var_307]
  && ELEMENT_RANGE_MATCHES_INVLIST(var_307)))
 {
     cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(var_307);
     var_470 = array_a[var_307++];
 }
 else {
     cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(var_307);
     var_470 = array_b[var_307++];
 }




 if (cp_in_set) {
     if (var_489 == 0) {
  array_u[var_304++] = var_470;
     }
     var_489++;
 }
 else {
     var_489--;
     if (var_489 == 0) {
  array_u[var_304++] = var_470;
     }
 }
    }

    if ( (var_307 != len_a && PREV_RANGE_MATCHES_INVLIST(var_307))
 || (var_307 != len_b && PREV_RANGE_MATCHES_INVLIST(var_307)))
    {
 var_489--;
    }

    if (var_489 != 0) {
        var_304 = var_304;
    }
    else {
        IV var_307 = len_a - var_307;
        if (var_307 > 0) {
     Copy(array_a + var_307, array_u + var_304, var_307, UV);
        }
        else {
            var_307 = len_b - var_307;
     Copy(array_b + var_307, array_u + var_304, var_307, UV);
        }
        var_304 = var_304 + var_307;
    }




    if (var_304 != _invlist_len(u)) {
 invlist_set_len(u, var_304, *get_invlist_offset_addr(u));
 invlist_trim(u);
 array_u = invlist_array(u);
    }

    if (*output == NULL) {
        *output = u;
    }
    else {





        invlist_replace_list_destroys_src(*output, u);
        SvREFCNT_dec_NN(u);
    }

    return;
}

void
fn_304(pTHX_ SV* const a, SV* const var_307,
                                               const bool var_307, SV** var_531)
{

    const UV* array_a;
    const UV* array_b;
    UV len_a;
    UV len_b;

    SV* r;
    UV* array_r;
    UV var_307 = 0;

    UV var_307 = 0;
    UV var_307 = 0;
    UV var_307 = 0;







    UV var_489 = 0;

    PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND;
    assert(a != var_307);
    assert(*var_531 == NULL || is_invlist(*var_531));


    len_a = (a == NULL) ? 0 : _invlist_len(a);
    if ((len_a == 0) || ((len_b = _invlist_len(var_307)) == 0)) {
        if (len_a != 0 && var_307) {






            if (*var_531 == a) {
                return;
            }

            if (*var_531 == NULL) {
                *var_531 = invlist_clone(a, NULL);
                return;
            }

            r = invlist_clone(a, NULL);
            invlist_replace_list_destroys_src(*var_531, r);
            SvREFCNT_dec_NN(r);
            return;
        }



        if (*var_531 == NULL) {
            *var_531 = _new_invlist(0);
            return;
        }

        invlist_clear(*var_531);
 return;
    }


    array_a = invlist_array(a);
    array_b = invlist_array(var_307);



    if (var_307) {



        if (array_b[0] == 0) {
            array_b++;
            len_b--;
        }
        else {



            array_b--;
            len_b++;
        }
    }



    r= _new_invlist(len_a + len_b);


    array_r = _invlist_array_init(r, len_a > 0 && array_a[0] == 0
                                     && len_b > 0 && array_b[0] == 0);



    while (var_307 < len_a && var_307 < len_b) {
 UV var_470;

 bool cp_in_set;

 if ( array_a[var_307] < array_b[var_307]
     || ( array_a[var_307] == array_b[var_307]
  && ! ELEMENT_RANGE_MATCHES_INVLIST(var_307)))
 {
     cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(var_307);
     var_470 = array_a[var_307++];
 }
 else {
     cp_in_set = ELEMENT_RANGE_MATCHES_INVLIST(var_307);
     var_470= array_b[var_307++];
 }




 if (cp_in_set) {
     var_489++;
     if (var_489 == 2) {
  array_r[var_307++] = var_470;
     }
 }
 else {
     if (var_489 == 2) {
  array_r[var_307++] = var_470;
     }
     var_489--;
 }

    }







    if ( (var_307 == len_a && PREV_RANGE_MATCHES_INVLIST(var_307))
        || (var_307 == len_b && PREV_RANGE_MATCHES_INVLIST(var_307)))
    {
 var_489++;
    }

    if (var_489 < 2) {
        var_307 = var_307;
    }
    else {
        IV var_307 = len_a - var_307;
        if (var_307 > 0) {
     Copy(array_a + var_307, array_r + var_307, var_307, UV);
        }
        else {
            var_307 = len_b - var_307;
     Copy(array_b + var_307, array_r + var_307, var_307, UV);
        }
        var_307 = var_307 + var_307;
    }




    if (var_307 != _invlist_len(r)) {
 invlist_set_len(r, var_307, *get_invlist_offset_addr(r));
 invlist_trim(r);
 array_r = invlist_array(r);
    }

    if (*var_531 == NULL) {
        *var_531 = r;
    }
    else {




        if (var_307) {
            invlist_replace_list_destroys_src(*var_531, r);
        }
        else {
            invlist_clear(*var_531);
        }
        SvREFCNT_dec_NN(r);
    }

    return;
}

SV*
fn_307(pTHX_ SV* invlist, UV var_463, UV var_454)
{

    UV* array;
    UV var_531;
    SSize_t i_s;

    SSize_t var_310 = 0;
    UV cur_highest;



    if (invlist == NULL) {
 invlist = _new_invlist(2);
        _append_range_to_invlist(invlist, var_463, var_454);
        return invlist;
    }


    var_531 = _invlist_len(invlist);
    if (var_531 == 0) {
        _append_range_to_invlist(invlist, var_463, var_454);
        return invlist;
    }


    array = invlist_array(invlist);


    cur_highest = invlist_highest(invlist);
    if (var_454 > cur_highest) {


        if (var_463 > cur_highest) {
            _append_range_to_invlist(invlist, var_463, var_454);
            return invlist;
        }


        _append_range_to_invlist(invlist, cur_highest + 1, var_454);

        if (var_454 == var_459) {
            var_310 = var_531;
        }
        else {
            var_310 = var_531 - 2;
        }
    }



    if (var_463 < array[0]) {




        if (UNLIKELY(var_463 == 0)) {
            SV* range_invlist;

            range_invlist = _new_invlist(2);
            _append_range_to_invlist(range_invlist, var_463, var_454);

            _invlist_union(invlist, range_invlist, &invlist);

            SvREFCNT_dec_NN(range_invlist);

            return invlist;
        }



        if (var_454 < array[0] - 1) {
            i_s = var_310 = -1;
            goto splice_in_new_range;
        }



        array[0] = var_463;



        i_s = 0;
    }
    else {



        i_s = _invlist_search(invlist, var_463);
    }

    if (var_310 == 0) {
        var_310 = (var_463 == var_454)
              ? i_s
              : _invlist_search(invlist, var_454);
    }





    if ( ! ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {






        const bool var_310 = ( var_454 == var_459
                                              || var_454 + 1 >= array[i_s+1]);



        if (var_463 == array[i_s]) {

            if (var_310 - i_s <= 1) {






                if (var_310) {
                    Move(array + i_s + 2, array + i_s, var_531 - i_s - 2, UV);
                    invlist_set_len(invlist,
                                    var_531 - 2,
                                    *(get_invlist_offset_addr(invlist)));
                    return invlist;
                }




                var_310--;
            }




            array[i_s] = (var_454 == var_459) ? var_459 : var_454 + 1;
            i_s--;
            var_463 = array[i_s];
        }
        else if (var_310) {




            if (var_310 == i_s) {
                var_310++;
            }
            i_s++;
            array[i_s] = var_463;
        }
    }






    if (UNLIKELY(var_454 == var_459)) {
        invlist_set_len(invlist, i_s + 1, *(get_invlist_offset_addr(invlist)));
        return invlist;
    }



    if (! ELEMENT_RANGE_MATCHES_INVLIST(var_310)) {







        if (var_454 + 1 == array[var_310+1]) {
            var_310++;
            array[var_310] = var_463;
        }
        else if (var_463 <= array[var_310]) {
            array[var_310] = var_454 + 1;
            var_310--;
        }
    }

    if (i_s == var_310) {



        if (ELEMENT_RANGE_MATCHES_INVLIST(i_s)) {
            return invlist;
        }



      splice_in_new_range:

        invlist_extend(invlist, var_531 + 2);
        array = invlist_array(invlist);


        Move(array + var_310 + 1, array + var_310 + 3, var_531 - var_310 - 1, UV);


        array[var_310+1] = var_463;
        array[var_310+2] = var_454 + 1;
        invlist_set_len(invlist, var_531 + 2, *(get_invlist_offset_addr(invlist)));
        return invlist;
    }





    Move(array + var_310 + 1, array + i_s + 1, var_531 - var_310 - 1, UV);
    invlist_set_len(invlist,
                    var_531 - var_310 + i_s,
                    *(get_invlist_offset_addr(invlist)));

    return invlist;
}

SV*
fn_310(pTHX_ const var_361 var_485, const UV var_313,
                                 UV** other_elements_ptr)
{

    SV* invlist = _new_invlist(var_485);
    bool var_499;

    PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST;

    invlist = add_cp_to_invlist(invlist, var_313);
    var_499 = *get_invlist_offset_addr(invlist);

    invlist_set_len(invlist, var_485, var_499);
    *other_elements_ptr = invlist_array(invlist) + 1;
    return invlist;
}



PERL_STATIC_INLINE SV*
fn_313(pTHX_ SV* invlist, const UV var_470) {
    return _add_range_to_invlist(invlist, var_470, var_470);
}


void
fn_314(pTHX_ SV* const invlist)
{




    PERL_ARGS_ASSERT__INVLIST_INVERT;

    assert(! invlist_is_iterating(invlist));


    if (_invlist_len(invlist) == 0) {
 _append_range_to_invlist(invlist, 0, var_459);
 return;
    }

    *get_invlist_offset_addr(invlist) = ! *get_invlist_offset_addr(invlist);
}

SV*
fn_315(pTHX_ SV* const invlist, SV* new_invlist)
{



    const STRLEN var_318 = _invlist_len(invlist);
    const STRLEN var_318 = SvCUR(invlist);
    const bool var_499 = *(get_invlist_offset_addr(invlist));

    PERL_ARGS_ASSERT_INVLIST_CLONE;

    if (new_invlist == NULL) {
        new_invlist = _new_invlist(var_318);
    }
    else {
        sv_upgrade(new_invlist, SVt_INVLIST);
        initialize_invlist_guts(new_invlist, var_318);
    }

    *(get_invlist_offset_addr(new_invlist)) = var_499;
    invlist_set_len(new_invlist, var_318, var_499);
    Copy(SvPVX(invlist), SvPVX(new_invlist), var_318, char);

    return new_invlist;
}



PERL_STATIC_INLINE var_361*
fn_318(SV* invlist)
{



    PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR;

    assert(is_invlist(invlist));

    return &(((XINVLIST*) SvANY(invlist))->iterator);
}

PERL_STATIC_INLINE void
fn_319(SV* invlist)
{
    PERL_ARGS_ASSERT_INVLIST_ITERINIT;

    *get_invlist_iter_addr(invlist) = 0;
}

PERL_STATIC_INLINE void
fn_320(SV* invlist)
{

    PERL_ARGS_ASSERT_INVLIST_ITERFINISH;

    *get_invlist_iter_addr(invlist) = (STRLEN) var_459;
}

static bool
fn_321(SV* invlist, UV* var_463, UV* var_454)
{







    STRLEN* var_538 = get_invlist_iter_addr(invlist);
    UV var_531 = _invlist_len(invlist);
    UV *array;

    PERL_ARGS_ASSERT_INVLIST_ITERNEXT;

    if (*var_538 >= var_531) {
 *var_538 = (STRLEN) var_459;
 return FALSE;
    }

    array = invlist_array(invlist);

    *var_463 = array[(*var_538)++];

    if (*var_538 >= var_531) {
 *var_454 = var_459;
    }
    else {
 *var_454 = array[(*var_538)++] - 1;
    }

    return TRUE;
}

PERL_STATIC_INLINE UV
fn_322(SV* const invlist)
{





    UV var_531 = _invlist_len(invlist);
    UV *array;

    PERL_ARGS_ASSERT_INVLIST_HIGHEST;

    if (var_531 == 0) {
 return 0;
    }

    array = invlist_array(invlist);







    return (ELEMENT_RANGE_MATCHES_INVLIST(var_531 - 1))
           ? var_459
           : array[var_531 - 1] - 1;
}

static SV *
fn_323(pTHX_ SV* const invlist, const bool var_327)
{






    UV var_463, var_454;
    SV* output;
    const char var_327 = (var_327 ? '\t' : '-');
    const char var_327 = (var_327 ? '\n' : ' ');

    if (var_327) {
        output = newSVpvs("\n");
    }
    else {
        output = newSVpvs("");
    }

    PERL_ARGS_ASSERT_INVLIST_CONTENTS;

    assert(! invlist_is_iterating(invlist));

    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &var_463, &var_454)) {
 if (var_454 == var_459) {
     Perl_sv_catpvf(aTHX_ output, "%04" UVXf "%cINFTY%c",
                                          var_463, var_327,
                                                 var_327);
 }
 else if (var_454 != var_463) {
     Perl_sv_catpvf(aTHX_ output, "%04" UVXf "%c%04" UVXf "%c",
                            var_463,
                                                   var_327,
                                                  var_454, var_327);
 }
 else {
     Perl_sv_catpvf(aTHX_ output, "%04" UVXf "%c",
                                          var_463, var_327);
 }
    }

    if (SvCUR(output) && ! var_327) {
        SvCUR_set(output, SvCUR(output) - 1);
    }

    return output;
}


void
fn_327(pTHX_ PerlIO *file, I32 var_538,
                         const char * const indent, SV* const invlist)
{

    UV var_463, var_454;
    STRLEN var_489 = 0;

    PERL_ARGS_ASSERT__INVLIST_DUMP;

    if (invlist_is_iterating(invlist)) {
        Perl_dump_indent(aTHX_ var_538, file,
             "%sCan't dump inversion list because is in middle of iterating\n",
             indent);
        return;
    }

    invlist_iterinit(invlist);
    while (invlist_iternext(invlist, &var_463, &var_454)) {
 if (var_454 == var_459) {
     Perl_dump_indent(aTHX_ var_538, file,
                                       "%s[%" UVuf "] 0x%04" UVXf " .. INFTY\n",
                                   indent, (UV)var_489, var_463);
 }
 else if (var_454 != var_463) {
     Perl_dump_indent(aTHX_ var_538, file,
                                    "%s[%" UVuf "] 0x%04" UVXf " .. 0x%04" UVXf "\n",
                  indent, (UV)var_489, var_463, var_454);
 }
 else {
     Perl_dump_indent(aTHX_ var_538, file, "%s[%" UVuf "] 0x%04" UVXf "\n",
                                            indent, (UV)var_489, var_463);
 }
        var_489 += 2;
    }
}

static SV*
fn_329(pTHX_ RExC_state_t *var_491, regnode *var_467)
{
    dVAR;
    const U8 * var_512 = (U8*)STRING(var_467);
    SSize_t var_331 = STR_LEN(var_467);
    UV uc;

    SV* invlist = _new_invlist(4);

    PERL_ARGS_ASSERT__MAKE_EXACTF_INVLIST;

    if (! cBOOL((var_491->utf8))) {
        uc = *var_512;

        if (is_MULTI_CHAR_FOLD_latin1_safe(var_512, var_512 + var_331)) {
            invlist = _add_range_to_invlist(invlist, 0, var_459);
        }
        else {



            if (OP(var_467) == EXACTFL) {
                _invlist_union(invlist, PL_Latin1, &invlist);
                invlist = add_cp_to_invlist(invlist,
                                                LATIN_SMALL_LETTER_DOTLESS_I);
                invlist = add_cp_to_invlist(invlist,
                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);
            }
            else {



                invlist = add_cp_to_invlist(invlist, uc);
                if (_IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(uc))
                    invlist = add_cp_to_invlist(invlist, PL_fold_latin1[uc]);
            }



            if (_HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(uc)
                && (! isASCII(uc) || (OP(var_467) != EXACTFAA
                                    && OP(var_467) != EXACTFAA_NO_TRIE)))
            {
                add_above_Latin1_folds(var_491, (U8) uc, &invlist);
            }
        }
    }
    else {
        U8 var_455[UTF8_MAX_FOLD_CHAR_EXPAND * UTF8_MAXBYTES_CASE + 1] = { '\0' };
        const U8* var_512 = var_512 + var_331;
        IV fc;

        fc = uc = utf8_to_uvchr_buf(var_512, var_512 + var_331, NULL);



        if (OP(var_467) == EXACTFL && is_PROBLEMATIC_LOCALE_FOLDEDS_START_cp(uc)) {




            U8 *var_451 = var_455;
            int var_531;

            fc = -1;
            for (var_531 = 0; var_531 < UTF8_MAX_FOLD_CHAR_EXPAND && var_512 < var_512; var_531++) {
                if (isASCII(*var_512)) {
                    *(var_451++) = (U8) toFOLD(*var_512);
                    if (fc < 0) {
                        fc = *(var_451-1);
                    }
                    var_512++;
                }
                else {
                    STRLEN var_531;
                    UV var_332 = toFOLD_utf8_safe(var_512, var_512, var_451, &var_531);
                    if (fc < 0) {
                        fc = var_332;
                    }
                    var_451 += var_531;
                    var_512 += UTF8SKIP(var_512);
                }
            }



            var_512 = var_451;
            var_512 = var_455;
        }

        if (is_MULTI_CHAR_FOLD_utf8_safe(var_512, var_512)) {
            invlist = _add_range_to_invlist(invlist, 0, var_459);
        }
        else {
            unsigned int k;
            unsigned int first_fold;
            const unsigned int * remaining_folds;
            Size_t var_455;


            invlist = add_cp_to_invlist(invlist, fc);



            var_455 = _inverse_folds(fc, &first_fold,
                                                &remaining_folds);
            for (k = 0; k < var_455; k++) {
                UV var_453 = (k == 0) ? first_fold : remaining_folds[k-1];


                if ( (OP(var_467) == EXACTFAA || OP(var_467) == EXACTFAA_NO_TRIE)
                    && isASCII(var_453) != isASCII(fc))
                {
                    continue;
                }

                invlist = add_cp_to_invlist(invlist, var_453);
            }

            if (OP(var_467) == EXACTFL) {





                if (isALPHA_FOLD_EQ(fc, 'I')) {
                    invlist = add_cp_to_invlist(invlist,
                                                LATIN_SMALL_LETTER_DOTLESS_I);
                    invlist = add_cp_to_invlist(invlist,
                                        LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE);
                }
                else if (fc == LATIN_SMALL_LETTER_DOTLESS_I) {
                    invlist = add_cp_to_invlist(invlist, 'I');
                }
                else if (fc == LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE) {
                    invlist = add_cp_to_invlist(invlist, 'i');
                }
            }
        }
    }

    return invlist;
}

static void
fn_333(pTHX_ RExC_state_t *var_491)
{

    I32 var_346 = 0x00;
    U32 var_346 = 0, var_346 = 0;
    U32 *flagsp = &var_346;
    char var_345 = '\0';
    regex_charset cs;
    bool var_346 = FALSE;
    const char* const seqstart = (var_491->parse) - 1;
    int var_346 = 0;

    PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS;


    if (UCHARAT((var_491->parse)) == '^') {
        (var_491->parse)++;
        var_346 = TRUE;
        STD_PMMOD_FLAGS_CLEAR(&(var_491->flags));
        cs = ((var_491->uni_semantics))
             ? REGEX_UNICODE_CHARSET
             : REGEX_DEPENDS_CHARSET;
        set_regex_charset(&(var_491->flags), cs);
    }
    else {
        cs = get_regex_charset((var_491->flags));
        if ( cs == REGEX_DEPENDS_CHARSET
            && (var_491->uni_semantics))
        {
            cs = REGEX_UNICODE_CHARSET;
        }
    }

    while ((var_491->parse) < (var_491->end)) {



        switch (*(var_491->parse)) {


            CASE_STD_PMMOD_FLAGS_PARSE_SET(flagsp, var_346);

            case LOCALE_PAT_MOD:
                if (var_345) {
                    goto excess_modifier;
                }
                else if (flagsp == &var_346) {
                    goto neg_modifier;
                }
                cs = REGEX_LOCALE_CHARSET;
                var_345 = LOCALE_PAT_MOD;
                break;
            case UNICODE_PAT_MOD:
                if (var_345) {
                    goto excess_modifier;
                }
                else if (flagsp == &var_346) {
                    goto neg_modifier;
                }
                cs = REGEX_UNICODE_CHARSET;
                var_345 = UNICODE_PAT_MOD;
                break;
            case ASCII_RESTRICT_PAT_MOD:
                if (flagsp == &var_346) {
                    goto neg_modifier;
                }
                if (var_345) {
                    if (cs != REGEX_ASCII_RESTRICTED_CHARSET) {
                        goto excess_modifier;
                    }

                    cs = REGEX_ASCII_MORE_RESTRICTED_CHARSET;
                }
                else {
                    cs = REGEX_ASCII_RESTRICTED_CHARSET;
                }
                var_345 = ASCII_RESTRICT_PAT_MOD;
                break;
            case DEPENDS_PAT_MOD:
                if (var_346) {
                    goto fail_modifiers;
                }
                else if (flagsp == &var_346) {
                    goto neg_modifier;
                }
                else if (var_345) {
                    goto excess_modifier;
                }





                cs = ((var_491->uni_semantics))
                     ? REGEX_UNICODE_CHARSET
                     : REGEX_DEPENDS_CHARSET;
                var_345 = DEPENDS_PAT_MOD;
                break;
              excess_modifier:
                (var_491->parse)++;
                if (var_345 == ASCII_RESTRICT_PAT_MOD) {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Regexp modifier \"%c\" may appear a maximum of twice", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", ASCII_RESTRICT_PAT_MOD, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10880, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }
                else fn_450 (has_charset_modifier == *((pRExC_state->var_377) - 1)) {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Regexp modifier \"%c\" may not appear twice", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", *((var_491->parse) - 1), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10884, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                }
                else {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Regexp modifiers \"%c\" and \"%c\" are mutually exclusive", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_345, *((var_491->parse) - 1), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10887, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }
                NOT_REACHED;
              neg_modifier:
                (var_491->parse)++;
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Regexp modifier \"%c\" may not appear after the \"-\"", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", *((var_491->parse) - 1), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10893, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                NOT_REACHED;
            case ONCE_PAT_MOD:
            case GLOBAL_PAT_MOD:
                if (ckWARN(WARN_REGEXP)) {
                    const I32 var_346 = *(var_491->parse) == 'o'
                                         ? 0x01
                                         : 0x02;
                    if (! (var_346 & var_346) ) {
                        var_346 |= var_346;

                        STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 10911, (var_491->parse) + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "Useless (%s%c) - %suse /%c modifier" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", flagsp == &var_346 ? "?-" : "?", *(var_491->parse), flagsp == &var_346 ? "don't " : "", *(var_491->parse), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10911, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;







                    }
                }
                break;

            case CONTINUE_PAT_MOD:
                if (ckWARN(WARN_REGEXP)) {
                    if (! (var_346 & 0x04) ) {
                        var_346 |= (0x02|0x04);

                        STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 10926, (var_491->parse) + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "Useless (%sc) - %suse /gc modifier" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", flagsp == &var_346 ? "?-" : "?", flagsp == &var_346 ? "don't " : "", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10926, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;





                    }
                }
                break;
            case KEEPCOPY_PAT_MOD:
                if (flagsp == &var_346) {
                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 10932, (var_491->parse) + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Useless use of (?-p)" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10932, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;
                } else {
                    *flagsp |= RXf_PMf_KEEPCOPY;
                }
                break;
            case '-':



                if (var_346 || flagsp == &var_346) {
                    goto fail_modifiers;
                }
                flagsp = &var_346;
                var_346 = 0;
                var_346 = 0;
                break;
            case ':':
            case ')':

                if ((var_346 & (RXf_PMf_EXTENDED|RXf_PMf_EXTENDED_MORE)) == RXf_PMf_EXTENDED) {
                    var_346 |= RXf_PMf_EXTENDED_MORE;
                }
                (var_491->flags) |= var_346;

                if (var_346 & RXf_PMf_EXTENDED) {
                    var_346 |= RXf_PMf_EXTENDED_MORE;
                }
                (var_491->flags) &= ~var_346;
                set_regex_charset(&(var_491->flags), cs);

                return;
            default:
              fail_modifiers:
                (var_491->parse) += (!*((var_491->parse)) ? 0 : cBOOL((var_491->utf8)) ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end)) : 1);

                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "Sequence (%" UTF8f "...) not recognized", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (var_491->parse)-seqstart, seqstart), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10968, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;

                NOT_REACHED;
        }

        (var_491->parse) += cBOOL((var_491->utf8)) ? UTF8SKIP((var_491->parse)) : 1;
    }

    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Sequence (?... not terminated", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 10975, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
}

PERL_STATIC_INLINE regnode_offset
fn_346(pTHX_ RExC_state_t *var_491,
                             I32 *flagp,
                             char * parse_start,
                             char var_385
                      )
{
    regnode_offset var_483;
    char* name_start = (var_491->parse);
    U32 var_387 = 0;
    SV *sv_dat = reg_scan_name(var_491, 2);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF;

    if ((var_491->parse) == name_start || *(var_491->parse) != var_385) {

        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Sequence %.3s... not terminated", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", parse_start, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11011, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }

    if (sv_dat) {
        var_387 = add_data( var_491, STR_WITH_LEN("S"));
        (var_491->rxi)->data->data[var_387]=(void*)sv_dat;
        SvREFCNT_inc_simple_void_NN(sv_dat);
    }
    (var_491->sawback) = 1;
    var_483 = reganode(var_491,
                   ((! cBOOL((var_491->flags) & RXf_PMf_FOLD))
                     ? NREF
                     : ((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET))
                       ? NREFFA
                       : ((get_regex_charset((var_491->flags)) >= REGEX_UNICODE_CHARSET))
                         ? NREFFU
                         : ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET))
                           ? NREFFL
                           : NREFF),
                    var_387);
    *flagp |= 0x01;

                                                  ;
                                                    ;

    nextchar(var_491);
    return var_483;
}

static regnode_offset
fn_347(pTHX_ RExC_state_t *var_491, I32 var_485, I32 *flagp, U32 var_486)




{
    regnode_offset var_483 = 0;
    regnode_offset br;
    regnode_offset lastbr;
    regnode_offset var_401 = 0;
    I32 var_366 = 0;
    I32 var_451;
    U32 var_367 = (var_491->flags);
    bool var_366 = 0;
    bool var_365 = 0;
    I32 var_366 = 0;
    I32 var_367 = 0;
    I32 var_387;
    SV * max_open;

    char * parse_start = (var_491->parse);
    char * const oregcomp_parse = (var_491->parse);

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REG;
    DEBUG_PARSE_r({ DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", (("reg ")) ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); }); Perl_re_printf( aTHX_ "%4s","\n"); });


    max_open = get_sv(RE_COMPILE_RECURSION_LIMIT, GV_ADD);
    assert(max_open);
    if (!SvIOK(max_open)) {
        sv_setiv(max_open, RE_COMPILE_RECURSION_INIT);
    }
    if (var_486 > 4 * (UV) SvIV(max_open)) {

        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Too many nested open parens", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11086, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }

    *flagp = 0;







    assert(*(var_491->end) == '\0');


    if (var_485) {





        bool var_359 = (var_485 == 2)
                                  && *((var_491->parse) - 1) != '(';

        if ((var_491->parse) >= (var_491->end)) {
     STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unmatched (", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11110, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
        }

        if (var_485 == 'r') {
            var_485 = '>';
            goto parse_rest;
        }
        else if ( *(var_491->parse) == '*') {
     char *start_verb = (var_491->parse) + 1;
     STRLEN verb_len;
     char *start_arg = NULL;
     unsigned char var_512 = 0;
            int var_358 = 0;
            int var_358 = -1;
            bool var_418 = FALSE;

            if (var_359) {
                (var_491->parse)++;



                if (isUPPER(*(var_491->parse))) {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "In '(*VERB...)', the '(' and '*' must be adjacent", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11132, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }
                else {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "In '(*...)', the '(' and '*' must be adjacent", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11135, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }
            }
     while ((var_491->parse) < (var_491->end) && *(var_491->parse) != ')' ) {
         if ( *(var_491->parse) == ':' ) {
             start_arg = (var_491->parse) + 1;
             break;
         }
                else if (! cBOOL((var_491->utf8))) {
                    if (isUPPER(*(var_491->parse))) {
                        var_418 = TRUE;
                    }
                    (var_491->parse)++;
                }
                else {
                    (var_491->parse) += UTF8SKIP((var_491->parse));
                }
     }
     verb_len = (var_491->parse) - start_verb;
     if ( start_arg ) {
                if ((var_491->parse) >= (var_491->end)) {
                    goto unterminated_verb_pattern;
                }

         (var_491->parse) += cBOOL((var_491->utf8)) ? UTF8SKIP((var_491->parse)) : 1;
         while ( (var_491->parse) < (var_491->end) && *(var_491->parse) != ')' ) {
                    (var_491->parse) += cBOOL((var_491->utf8)) ? UTF8SKIP((var_491->parse)) : 1;
                }
         if ( (var_491->parse) >= (var_491->end) || *(var_491->parse) != ')' ) {
                  unterminated_verb_pattern:
                    if (var_418) {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unterminated verb pattern argument", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11166, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
                    else {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unterminated '(*...' argument", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11169, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
                }
     } else {
         if ( (var_491->parse) >= (var_491->end) || *(var_491->parse) != ')' ) {
                    if (var_418) {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unterminated verb pattern", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11175, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
                    else {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unterminated '(*...' construct", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11178, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
                }
     }



     switch ( *start_verb ) {
            case 'A':
                if ( memEQs(start_verb, verb_len,"ACCEPT") ) {
      var_512 = ACCEPT;
      var_358 = (var_491->nestroot);
  }
  break;
            case 'C':
                if ( memEQs(start_verb, verb_len,"COMMIT") )
                    var_512 = COMMIT;
                break;
            case 'F':
                if ( verb_len==1 || memEQs(start_verb, verb_len,"FAIL") ) {
      var_512 = OPFAIL;
  }
  break;
            case ':':
     case 'M':
         if ( verb_len==0 || memEQs(start_verb, verb_len,"MARK") ) {
                    var_512 = MARKPOINT;
                    var_358 = 1;
                }
                break;
            case 'P':
                if ( memEQs(start_verb, verb_len,"PRUNE") )
                    var_512 = PRUNE;
                break;
            case 'S':
                if ( memEQs(start_verb, verb_len,"SKIP") )
                    var_512 = SKIP;
                break;
            case 'T':

                if ( memEQs(start_verb, verb_len,"THEN") ) {
                    var_512 = CUTGROUP;
                    (var_491->seen) |= REG_CUTGROUP_SEEN;
                }
                break;
            case 'a':
                if ( memEQs(start_verb, verb_len, "asr")
                    || memEQs(start_verb, verb_len, "atomic_script_run"))
                {
                    var_485 = 'r';
                    goto script_run;
                }
                else if (memEQs(start_verb, verb_len, "atomic")) {
                    var_485 = 't';
                    goto alpha_assertions;
                }
                break;
            case 'p':
                if ( memEQs(start_verb, verb_len, "plb")
                    || memEQs(start_verb, verb_len, "positive_lookbehind"))
                {
                    var_485 = 'b';
                    goto lookbehind_alpha_assertions;
                }
                else if ( memEQs(start_verb, verb_len, "pla")
                         || memEQs(start_verb, verb_len, "positive_lookahead"))
                {
                    var_485 = 'a';
                    goto alpha_assertions;
                }
                break;
            case 'n':
                if ( memEQs(start_verb, verb_len, "nlb")
                    || memEQs(start_verb, verb_len, "negative_lookbehind"))
                {
                    var_485 = 'B';
                    goto lookbehind_alpha_assertions;
                }
                else if ( memEQs(start_verb, verb_len, "nla")
                         || memEQs(start_verb, verb_len, "negative_lookahead"))
                {
                    var_485 = 'A';
                    goto alpha_assertions;
                }
                break;
            case 's':
                if ( memEQs(start_verb, verb_len, "sr")
                    || memEQs(start_verb, verb_len, "script_run"))
                {
                    regnode_offset atomic;

                    var_485 = 's';

                   script_run:


                    STMT_START { if ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) { set_regex_charset(&(var_491->flags), REGEX_UNICODE_CHARSET); (var_491->uni_semantics) = 1; if ((var_491->seen_d_op) && LIKELY(! ((var_491->total_par) < 0))) { *flagp |= 0x20; return 0; } } } STMT_END;

                    if (! start_arg) {
                        goto no_colon;
                    }

                    (var_491->parse) = start_arg;

                    if ((var_491->in_script_run)) {







                        var_483 = 0;

                        if (var_485 == 's') {
                            var_485 = ':';
                            goto parse_rest;
                        }




                        var_485 = '>';
                        goto parse_rest;
                    }



                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 11308, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_EXPERIMENTAL__SCRIPT_RUN))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner_d(aTHX_ fn_538(WARN_EXPERIMENTAL__SCRIPT_RUN), "The script_run feature is experimental" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11308, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;



                    if (var_485 == 's') {

                        var_483 = reg_node(var_491, SROPEN);
                        (var_491->in_script_run) = 1;
                        var_365 = 1;
                        goto parse_rest;
                    }





                    var_483 = reg_node(var_491, SROPEN);

                    (var_491->in_script_run) = 1;

                    atomic = reg(var_491, 'r', &var_451, var_486);
                    if (var_451 & (0x20|0x40)) {
                        *flagp = var_451 & (0x20|0x40);
                        return 0;
                    }

                    if (! regtail((var_491),(var_483),(atomic),var_486+1)) {
                        STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                    }

                    if (! regtail((var_491),(atomic),(reg_node(var_491, SRCLOSE)),var_486+1))

                    {
                        STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                    }

                    (var_491->in_script_run) = 0;
                    return var_483;
                }

                break;

            lookbehind_alpha_assertions:
                (var_491->seen) |= REG_LOOKBEHIND_SEEN;
                (var_491->in_lookbehind)++;


            alpha_assertions:
                STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 11356, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_EXPERIMENTAL__ALPHA_ASSERTIONS))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner_d(aTHX_ fn_538(WARN_EXPERIMENTAL__ALPHA_ASSERTIONS), "The alpha_assertions feature is experimental" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11356, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;



                (var_491->seen_zerolen)++;

                if (! start_arg) {
                    goto no_colon;
                }


                if (var_485 == 'A' && (var_491->parse) == start_arg) {
                    var_483=reganode(var_491, OPFAIL, 0);
                    nextchar(var_491);
                    return var_483;
         }

                (var_491->parse) = start_arg;
                goto parse_rest;

              no_colon:
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "'(*%" UTF8f "' requires a terminating ':'", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), verb_len, start_verb), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11377, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;


  NOT_REACHED;

     }
     if ( ! var_512 ) {
         (var_491->parse) += cBOOL((var_491->utf8))
                              ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end))
                              : 1;
                if (var_418 || verb_len == 0) {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "Unknown verb pattern '%" UTF8f "'", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), verb_len, start_verb), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11388, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;


                }
                else {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "Unknown '(*...)' construct '%" UTF8f "'", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), verb_len, start_verb), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11393, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;


                }
     }
            if ( (var_491->parse) == start_arg ) {
                start_arg = NULL;
            }
            if ( var_358 && !start_arg ) {
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Verb pattern '%.*s' has a mandatory argument", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", verb_len, start_verb, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11401, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

            }
            if (var_358 == -1) {
                var_483 = reganode(var_491, var_512, 0);
            } else {
                var_483 = reg2Lanode(var_491, var_512, 0, var_358);
            }
            (var_491->seen) |= REG_VERBARG_SEEN;
            if (start_arg) {
                SV *sv = newSVpvn( start_arg,
                                    (var_491->parse) - start_arg);
                ARG(((var_491->emit_start) + (var_483))) = add_data( var_491,
                                        STR_WITH_LEN("S"));
                (var_491->rxi)->data->data[ARG(((var_491->emit_start) + (var_483)))]=(void*)sv;
                FLAGS(((var_491->emit_start) + (var_483))) = 1;
            } else {
                FLAGS(((var_491->emit_start) + (var_483))) = 0;
            }
            if ( var_358 != -1 )
                ARG2L_SET(((var_491->emit_start) + (var_483)), var_358);
     nextchar(var_491);
     return var_483;
        }
        else if (*(pRExC_state->var_377) == '?') {
     bool var_361 = 0;
     const char * const seqstart = (var_491->parse);
            const char * endptr;
            if (var_359) {
                (var_491->parse)++;
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "In '(?...)', the '(' and '?' must be adjacent", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11430, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
            }

     (var_491->parse)++;
            var_485 = *(var_491->parse);

            (var_491->parse) += cBOOL((var_491->utf8)) ? UTF8SKIP((var_491->parse)) : 1;
            if ((var_491->parse) > (var_491->end)) {
                var_485 = '\0';
            }
     var_483 = 0;
     switch (var_485) {

     case 'P':
         var_485 = *(var_491->parse);
  if ( var_485 == '<') {
                    (var_491->parse)++;
                    if ((var_491->parse) >= (var_491->end)) {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Sequence (?P<... not terminated", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11448, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
      goto named_capture;
                }
                else fn_450 (paren == '>') {
                    (var_491->parse)++;
                    if ((var_491->parse) >= (var_491->end)) {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Sequence (?P>... not terminated", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11455, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
                    goto named_recursion;
                }
                else if (var_485 == '=') {
                    (var_491->parse)++;
                    return handle_named_backref(var_491, flagp,
                                                parse_start, ')');
                }
                (var_491->parse) += (!*((var_491->parse)) ? 0 : cBOOL((var_491->utf8)) ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end)) : 1);

  STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Sequence (%.*s...) not recognized", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (var_491->parse)-seqstart, seqstart, UTF8fARG(cBOOL((pRExC_state->var_501)), (((pRExC_state->var_359) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11467, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

  NOT_REACHED;
            case '<':
  if (*(var_491->parse) == '!')
      var_485 = ',';
  else if (*(var_491->parse) != '=')
              named_capture:
  {
      char *name_start;
      SV *svname;
      var_485= '>';

            case '\'':
                    name_start = (var_491->parse);
                    svname = reg_scan_name(var_491, 1);
      if ( (var_491->parse) == name_start
                        || (var_491->parse) >= (var_491->end)
                        || *(var_491->parse) != var_485)
                    {
          STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Sequence (?%c... not terminated", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_485=='>' ? '<' : var_485, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11487, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                    }
      {
   HE *he_str;
   SV *sv_dat = NULL;
                        if (!svname)
                            Perl_croak(aTHX_
                                "panic: reg_scan_name returned NULL");
                        if (!(var_491->paren_names)) {
                            (var_491->paren_names)= newHV();
                            sv_2mortal(MUTABLE_SV((var_491->paren_names)));




                        }
                        he_str = hv_fetch_ent( (var_491->paren_names), svname, 1, 0 );
                        if ( he_str )
                            sv_dat = HeVAL(he_str);
                        if ( ! sv_dat ) {

                            Perl_croak(aTHX_
                                "panic: paren_name hash element allocation failed");
                        } else if ( SvPOK(sv_dat) ) {





                            IV var_489 = SvIV(sv_dat);
                            I32 *pv = (I32*)SvPVX(sv_dat);
                            IV var_531;
                            for ( var_531 = 0 ; var_531 < var_489 ; var_531++ ) {
                                if ( pv[var_531] == (var_491->npar) ) {
                                    var_489 = 0;
                                    break;
                                }
                            }
                            if ( var_489 ) {
                                pv = (I32*)SvGROW(sv_dat,
                                                SvCUR(sv_dat) + sizeof(I32)+1);
                                SvCUR_set(sv_dat, SvCUR(sv_dat) + sizeof(I32));
                                pv[var_489] = (var_491->npar);
                                SvIV_set(sv_dat, SvIVX(sv_dat) + 1);
                            }
                        } else {
                            (void)SvUPGRADE(sv_dat, SVt_PVNV);
                            sv_setpvn(sv_dat, (char *)&((var_491->npar)),
                                                                sizeof(I32));
                            SvIOK_on(sv_dat);
                            SvIV_set(sv_dat, 1);
                        }

                    }
                    nextchar(var_491);
      var_485 = 1;
      goto capturing_parens;
  }

                (var_491->seen) |= REG_LOOKBEHIND_SEEN;
  (var_491->in_lookbehind)++;
  (var_491->parse)++;
                if ((var_491->parse) >= (var_491->end)) {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Sequence (?... not terminated", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11558, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }


     case '=':
  (var_491->seen_zerolen)++;
                break;
     case '!':
  (var_491->seen_zerolen)++;

                skip_to_be_ignored_text(var_491, &(var_491->parse),
                                        FALSE );
         if (*(var_491->parse) == ')') {
                    var_483=reganode(var_491, OPFAIL, 0);
             nextchar(var_491);
             return var_483;
         }
         break;
     case '|':


         var_485 = ':';
         var_367 = var_366 = (var_491->npar);




                STMT_START { if (! ((var_491->total_par) > 0)) (var_491->total_par) = -1; } STMT_END;
         break;
     case ':':
     case '>':
  break;
     case '$':
     case '@':
  STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Sequence (?%c...) not implemented", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (int)var_485, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11592, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
  break;
     case '0' :
     case 'R' :
                if ((var_491->parse) == (var_491->end) || *(var_491->parse) != ')')
      STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Sequence (?R) not terminated", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
                var_387 = 0;
                (var_491->seen) |= REG_RECURSE_SEEN;



                STMT_START { if (! ((var_491->total_par) > 0)) (var_491->total_par) = -1; } STMT_END;

  *flagp |= 0x08;
                goto gen_recurse_regop;


            case '&':
                parse_start = (var_491->parse) - 1;
              named_recursion:
                {
                    SV *sv_dat = reg_scan_name(var_491,
                                               2);
                   var_387 = sv_dat ? *((I32 *)SvPVX(sv_dat)) : 0;
                }
                if ((var_491->parse) >= (var_491->end) || *(var_491->parse) != ')')
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Sequence (?&... not terminated", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11618, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                goto gen_recurse_regop;

            case '+':
                if (! inRANGE((var_491->parse)[0], '1', '9')) {
                    (var_491->parse)++;
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Illegal pattern", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11624, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }
                goto parse_recursion;

            case '-':
                if (! inRANGE((var_491->parse)[0], '1', '9')) {
                    (var_491->parse)--;
                    goto parse_flags;
                }

            case '1': case '2': case '3': case '4':
     case '5': case '6': case '7': case '8': case '9':
         (var_491->parse) = (char *) seqstart + 1;
              parse_recursion:
                {
                    bool var_361 = FALSE;
                    UV unum;
                    parse_start = (var_491->parse) - 1;
                    if (*(var_491->parse) == '-') {
                        (var_491->parse)++;
                        var_361 = TRUE;
                    }
                    endptr = (var_491->end);
                    if (grok_atoUV((var_491->parse), &unum, &endptr)
                        && unum <= var_387
                    ) {
                        var_387 = (I32)unum;
                        (var_491->parse) = (char*)endptr;
                    } else
                        var_387 = var_387;
                    if (var_361) {

                        var_387 = -var_387;
                    }
                }
         if (*(var_491->parse)!=')')
             STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Expecting close bracket", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11660, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

              gen_recurse_regop:
                if ( var_485 == '-' ) {

                    var_387 = (var_491->npar) + var_387;
                    if (var_387 < 1) {




                        if (((var_491->total_par) > 0)) {
                            (var_491->parse)++;
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Reference to nonexistent group", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11683, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                        }
                        else {
                            STMT_START { if (! ((var_491->total_par) > 0)) (var_491->total_par) = -1; } STMT_END;
                        }
                    }
                } else if ( var_485 == '+' ) {
                    var_387 = (var_491->npar) + var_387 - 1;
                }

                var_483 = reg2Lanode(var_491, GOSUB, var_387, (var_491->recurse_count));
                if (var_387 >= (var_491->npar)) {




                    if (((var_491->total_par) > 0)) {
                        if (var_387 >= (var_491->total_par)) {
                            (var_491->parse)++;
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Reference to nonexistent group", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11710, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                        }
                    }
                    else {
                        STMT_START { if (! ((var_491->total_par) > 0)) (var_491->total_par) = -1; } STMT_END;
                    }
                }
                (var_491->recurse_count)++;
                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                    "%*s%*s Recurse #%" UVuf " to %" IVdf "\n",
                            22, "|    |", (int)(var_486 * 2 + 1), "",
                            (UV)ARG(((var_491->emit_start) + (var_483))),
                            (IV)ARG2L(((var_491->emit_start) + (var_483)))));
                (var_491->seen) |= REG_RECURSE_SEEN;


                                                                  ;
                                              ;

                *flagp |= 0x08;
                assert(*(var_491->parse) == ')');
                nextchar(var_491);
                return var_483;



     case '?':
  var_361 = 1;
  if (*(var_491->parse) != '{') {
                    (var_491->parse) += (!*((var_491->parse)) ? 0 : cBOOL((var_491->utf8)) ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end)) : 1);

                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "Sequence (%" UTF8f "...) not recognized", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (var_491->parse)-seqstart, seqstart), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11743, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;


      NOT_REACHED;
  }
  *flagp |= 0x08;
  var_485 = '{';
                (var_491->parse)++;

     case '{':
     {
  U32 var_498 = 0;
  struct struct_361 *cb;
                OP * o;

  (var_491->seen_zerolen)++;

  if ( !var_491->code_blocks
      || var_491->code_index
                                        >= var_491->code_blocks->count
      || var_491->code_blocks->cb[var_491->code_index].start
   != (var_361)(((var_491->parse) -3 - (var_361 ? 1 : 0))
       - (var_491->start))
  ) {
      if ((var_491->pm_flags) & PMf_USE_RE_EVAL)
   STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "panic: Sequence (?{...}): no code block found\n", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
      STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Eval-group not allowed at runtime, use re 'eval'", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
  }

  cb = &var_491->code_blocks->cb[var_491->code_index];
  (var_491->parse) = (var_491->start) + cb->end;
  o = cb->block;
                if (cb->src_regex) {
                    var_498 = add_data(var_491, STR_WITH_LEN("rl"));
                    (var_491->rxi)->data->data[var_498] =
                        (void*)SvREFCNT_inc((SV*)cb->src_regex);
                    (var_491->rxi)->data->data[var_498+1] = (void*)o;
                }
                else {
                    var_498 = add_data(var_491,
                            ((var_491->pm_flags) & PMf_HAS_CV) ? "L" : "l", 1);
                    (var_491->rxi)->data->data[var_498] = (void*)o;
                }
  var_491->code_index++;
  nextchar(var_491);

  if (var_361) {
                    regnode_offset eval;
      var_483 = reg_node(var_491, LOGICAL);

                    eval = reg2Lanode(var_491, EVAL,
                                       var_498,



                                       (var_491->flags) & RXf_PMf_COMPILETIME
                                      );
                    FLAGS(((var_491->emit_start) + (var_483))) = 2;
                    if (! regtail((var_491),(var_483),(eval),var_486+1)) {
                        STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                    }

      return var_483;
  }
  var_483 = reg2Lanode(var_491, EVAL, var_498, 0);
                                                               ;
                                              ;
  return var_483;
     }
     case '(':
     {
         int var_363= 0;
                const int var_363 = sizeof("DEFINE") - 1;
  if ( (var_491->parse) < (var_491->end) - 1
                    && ( ( (var_491->parse)[0] == '?'
                            && ( (var_491->parse)[1] == '='
                                || (var_491->parse)[1] == '!'
                                || (var_491->parse)[1] == '<'
                                || (var_491->parse)[1] == '{'))
          || ( (var_491->parse)[0] == '*'
                            && ( memBEGINs((var_491->parse) + 1,
                                         (Size_t) ((var_491->end) - ((var_491->parse) + 1)),
                                         "pla:")
                                || memBEGINs((var_491->parse) + 1,
                                         (Size_t) ((var_491->end) - ((var_491->parse) + 1)),
                                         "plb:")
                                || memBEGINs((var_491->parse) + 1,
                                         (Size_t) ((var_491->end) - ((var_491->parse) + 1)),
                                         "nla:")
                                || memBEGINs((var_491->parse) + 1,
                                         (Size_t) ((var_491->end) - ((var_491->parse) + 1)),
                                         "nlb:")
                                || memBEGINs((var_491->parse) + 1,
                                         (Size_t) ((var_491->end) - ((var_491->parse) + 1)),
                                         "positive_lookahead:")
                                || memBEGINs((var_491->parse) + 1,
                                         (Size_t) ((var_491->end) - ((var_491->parse) + 1)),
                                         "positive_lookbehind:")
                                || memBEGINs((var_491->parse) + 1,
                                         (Size_t) ((var_491->end) - ((var_491->parse) + 1)),
                                         "negative_lookahead:")
                                || memBEGINs((var_491->parse) + 1,
                                         (Size_t) ((var_491->end) - ((var_491->parse) + 1)),
                                         "negative_lookbehind:"))))
                ) {
                    I32 var_367;
                    regnode_offset tail;

                    var_483 = reg_node(var_491, LOGICAL);
                    FLAGS(((var_491->emit_start) + (var_483))) = 1;

                    tail = reg(var_491, 1, &var_367, var_486+1);
                    STMT_START { if ((var_367) & (0x20|0x40|0)) { *(flagp) = (var_367) & (0x20|0x40|0); return 0; } } STMT_END;
                    if (! regtail((var_491),(var_483),(tail),var_486+1)) {
                        STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                    }
                    goto insert_if;
                }
  else if ( (var_491->parse)[0] == '<'
           || (var_491->parse)[0] == '\'' )
         {
             char var_385 = (var_491->parse)[0] == '<' ? '>' : '\'';
             char *name_start= (var_491->parse)++;
             U32 var_387 = 0;
             SV *sv_dat=reg_scan_name(var_491, 2);
             if ( (var_491->parse) == name_start
                        || (var_491->parse) >= (var_491->end)
                        || *(var_491->parse) != var_385)
                    {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Sequence (?(%c... not terminated", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (var_385 == '>' ? '<' : var_385), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11871, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                    }
                    (var_491->parse)++;
                    if (sv_dat) {
                        var_387 = add_data( var_491, STR_WITH_LEN("S"));
                        (var_491->rxi)->data->data[var_387]=(void*)sv_dat;
                        SvREFCNT_inc_simple_void_NN(sv_dat);
                    }
                    var_483 = reganode(var_491, NGROUPP, var_387);
                    goto insert_if_check_paren;
  }
  else if (memBEGINs((pRExC_state->var_377),
                                   (STRLEN) ((pRExC_state->var_454) - (var_491->parse)),
                                   "DEFINE"))
                {
      var_483 = reganode(var_491, DEFINEP, 0);
      (var_491->parse) += var_363;
      var_363 = 1;
      goto insert_if_check_paren;
  }
  else fn_450 ((pRExC_state->var_377)[0] == 'R') {
      (var_491->parse)++;




      var_366 = 0;
                    if ((var_491->parse)[0] == '0') {
                        var_366 = 1;
                        (var_491->parse)++;
                    }
                    else if (inRANGE((var_491->parse)[0], '1', '9')) {
                        UV uv;
                        endptr = (var_491->end);
                        if (grok_atoUV((var_491->parse), &uv, &endptr)
                            && uv <= var_387
                        ) {
                            var_366 = (I32)uv + 1;
                            (var_491->parse) = (char*)endptr;
                        }

      } else if ((var_491->parse)[0] == '&') {
          SV *sv_dat;
          (var_491->parse)++;
          sv_dat = reg_scan_name(var_491,
                                               2);
                        if (sv_dat)
                            var_366 = 1 + *((I32 *)SvPVX(sv_dat));
      }
      var_483 = reganode(var_491, INSUBP, var_366);
      goto insert_if_check_paren;
  }
                else fn_450 (inRANGE((pRExC_state->var_377)[0], '1', '9')) {

      char var_453;
                    UV uv;
                    endptr = (var_491->end);
                    if (grok_atoUV((var_491->parse), &uv, &endptr)
                        && uv <= var_387
                    ) {
                        var_366 = (I32)uv;
                        (var_491->parse) = (char*)endptr;
                    }
                    else {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "panic: grok_atoUV returned FALSE", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11935, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
                    var_483 = reganode(var_491, GROUPP, var_366);

                 insert_if_check_paren:
      if (UCHARAT((var_491->parse)) != ')') {
                        (var_491->parse) += cBOOL((var_491->utf8))
                                      ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end))
                                      : 1;
   STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Switch condition not recognized", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11944, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
      }
      nextchar(var_491);
    insert_if:
                    if (! regtail((var_491),(var_483),(reganode(var_491, IFTHEN, 0)),var_486+1))

                    {
                        STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                    }
                    br = regbranch(var_491, &var_451, 1, var_486+1);
      if (br == 0) {
                        STMT_START { if ((var_451) & (0x20|0x40|0)) { *(flagp) = (var_451) & (0x20|0x40|0); return 0; } } STMT_END;
                        STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regbranch returned failure, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) var_451, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

                    } else
                    if (! regtail((var_491),(br),(reganode(var_491, LONGJMP, 0)),var_486+1))

                    {
                        STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                    }
      var_453 = UCHARAT((var_491->parse));
                    nextchar(var_491);
      if (var_451&0x01)
   *flagp |= 0x01;
      if (var_453 == '|') {
          if (var_363)
              STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "(?(DEFINE)....) does not allow branches", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11970, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;


                        lastbr = reganode(var_491, IFTHEN, 0);

                        if (!regbranch(var_491, &var_451, 1, var_486+1)) {
                            STMT_START { if ((var_451) & (0x20|0x40|0)) { *(flagp) = (var_451) & (0x20|0x40|0); return 0; } } STMT_END;
                            STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regbranch returned failure, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) var_451, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

                        }
                        if (! regtail((var_491),(var_483),(lastbr),var_486+1)) {
                            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                        }
    if (var_451&0x01)
       *flagp |= 0x01;
                        var_453 = UCHARAT((var_491->parse));
                        nextchar(var_491);
      }
      else
   lastbr = 0;
                    if (var_453 != ')') {
                        if ((var_491->parse) >= (var_491->end))
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Switch (?(condition)... not terminated", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11992, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                        else
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Switch (?(condition)... contains too many branches", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 11994, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
      var_401 = reg_node(var_491, TAIL);
                    if (! regtail((var_491),(br),(var_401),var_486+1)) {
                        STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                    }
      if (lastbr) {
                        if (! regtail((var_491),(lastbr),(var_401),var_486+1)) {
                            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                        }
                        if (! regtail((var_491),(((NEXTOPER( NEXTOPER(((var_491->emit_start) + (lastbr))))) - (var_491->emit_start))),(var_401),var_486+1))




                        {
                            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                        }
      }
      else
                        if (! regtail((var_491),(var_483),(var_401),var_486+1)) {
                            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                        }





      return var_483;
  }
                (var_491->parse) += cBOOL((var_491->utf8))
                              ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end))
                              : 1;
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unknown switch condition (?(...))", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12027, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
     }
     case '[':
                return handle_regex_sets(var_491, NULL, flagp, var_486+1,
                                         oregcomp_parse);
            case 0:
  (var_491->parse)--;
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Sequence (? incomplete", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12034, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                break;

            case ')':
                if ((var_491->strict)) {
                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 12039, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Empty (?) without any modifiers" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12039, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;
                }

     default:
         (var_491->parse) = (char *) seqstart + 1;
              parse_flags:
  parse_lparen_question_flags(var_491);
                if (UCHARAT((var_491->parse)) != ':') {
                    if ((var_491->parse) < (var_491->end))
                        nextchar(var_491);
                    *flagp = 0x10;
                    return 0;
                }
                var_485 = ':';
                nextchar(var_491);
                var_483 = 0;
                goto parse_rest;
            }
 }
 else {
            if (*(var_491->parse) == '{') {
                STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 12063, (var_491->parse) + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN2(WARN_DEPRECATED, WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner_d(aTHX_ fn_363(WARN_DEPRECATED, WARN_REGEXP), "Unescaped left brace in regex is " "deprecated here (and will be fatal " "in Perl 5.32), passed through" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12063, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;



            }


        if (!((var_491->flags) & RXf_PMf_NOCAPTURE)) {
   capturing_parens:
     var_366 = (var_491->npar);
     (var_491->npar)++;
            if (! ((var_491->total_par) > 0)) {





                if (!(var_491->parens_buf_size)) {

                    (var_491->parens_buf_size) = 10;




                    Newxz((var_491->open_parens), (var_491->parens_buf_size),
                            regnode_offset);
                    (var_491->open_parens)[0] = 1;





                    Newxz((var_491->close_parens), (var_491->parens_buf_size),
                            regnode_offset);



                }
                else if ((var_491->npar) > (var_491->parens_buf_size)) {
                    I32 var_365 = (var_491->parens_buf_size);

                    (var_491->parens_buf_size) *= 2;

                    Renew((var_491->open_parens), (var_491->parens_buf_size),
                            regnode_offset);
                    Zero((var_491->open_parens) + var_365,
                            (var_491->parens_buf_size) - var_365, regnode_offset);

                    Renew((var_491->close_parens), (var_491->parens_buf_size),
                            regnode_offset);
                    Zero((var_491->close_parens) + var_365,
                            (var_491->parens_buf_size) - var_365, regnode_offset);
                }
            }

     var_483 = reganode(var_491, OPEN, var_366);
            if (!(var_491->nestroot))
                (var_491->nestroot) = var_366;
            if ((var_491->open_parens) && !(var_491->open_parens)[var_366])
            {
                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                    "%*s%*s Setting open paren #%" IVdf " to %d\n",
                    22, "|    |", (int)(var_486 * 2 + 1), "",
                    (IV)var_366, var_483));
                (var_491->open_parens)[var_366]= var_483;
            }

                                              ;
                                                       ;
     var_365 = 1;
 } else {

            var_485 = ':';
     var_483 = 0;
 }
        }
    }
    else
 var_483 = 0;

   parse_rest:

    parse_start = (var_491->parse);
    br = regbranch(var_491, &var_451, 1, var_486+1);



    if (br == 0) {
        STMT_START { if ((var_451) & (0x20|0x40|0)) { *(flagp) = (var_451) & (0x20|0x40|0); return 0; } } STMT_END;
        STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regbranch returned failure, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) var_451, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
    }
    if (*(var_491->parse) == '|') {
 if ((var_491->use_BRANCHJ)) {
     reginsert(var_491, BRANCHJ, br, var_486+1);
 }
 else {
     reginsert(var_491, BRANCH, br, var_486+1);
                                                      ;
                                                            ;
        }
 var_366 = 1;
    }
    else if (var_485 == ':') {
 *flagp |= var_451&0x02;
    }
    if (var_365) {
        if (! regtail((var_491),(var_483),(br),var_486+1)) {
            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
        }
    }
    else if (var_485 != '?')
 var_483 = br;
    *flagp |= var_451 & (0x04 | 0x01 | 0x08);
    lastbr = br;
    while (*(var_491->parse) == '|') {
 if ((var_491->use_BRANCHJ)) {
            bool var_367;

     var_401 = reganode(var_491, LONGJMP, 0);


            var_367 = regtail((var_491),(((NEXTOPER(NEXTOPER(((var_491->emit_start) + (lastbr))))) - (var_491->emit_start))),(var_401),var_486+1);


            PERL_UNUSED_VAR(var_367);
 }
 nextchar(var_491);
 if (var_366) {
     if ((var_491->npar) > var_367)
         var_367 = (var_491->npar);
            (var_491->npar) = var_366;
        }
        br = regbranch(var_491, &var_451, 0, var_486+1);

 if (br == 0) {
            STMT_START { if ((var_451) & (0x20|0x40|0)) { *(flagp) = (var_451) & (0x20|0x40|0); return 0; } } STMT_END;
            STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regbranch returned failure, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) var_451, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
        }
        if (! regtail((var_491),(lastbr),(br),var_486+1)) {
            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
        }
 lastbr = br;
 *flagp |= var_451 & (0x04 | 0x01 | 0x08);
    }

    if (var_366 || var_485 != ':') {
        regnode * br;


 switch (var_485) {
 case ':':
     var_401 = reg_node(var_491, TAIL);
     break;
 case 1: case 2:
     var_401 = reganode(var_491, CLOSE, var_366);
            if ( (var_491->close_parens) ) {
                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                        "%*s%*s Setting close paren #%" IVdf " to %d\n",
                        22, "|    |", (int)(var_486 * 2 + 1), "",
                        (IV)var_366, var_401));
                (var_491->close_parens)[var_366]= var_401;
         if ((var_491->nestroot) == var_366)
             (var_491->nestroot) = 0;
     }
                                                           ;
                                                ;
     break;
 case 's':
     var_401 = reg_node(var_491, SRCLOSE);
            (var_491->in_script_run) = 0;
     break;
 case '<':
        case 'a':
        case 'A':
        case 'b':
        case 'B':
 case ',':
 case '=':
 case '!':
     *flagp &= ~0x01;

        case 't':
 case '>':
     var_401 = reg_node(var_491, SUCCEED);
     break;
 case 0:
     var_401 = reg_node(var_491, var_461);
            assert(!(var_491->end_op));
            (var_491->end_op) = ((var_491->emit_start) + (var_401));
            if ((var_491->close_parens)) {
                DEBUG_OPTIMISE_MORE_r(Perl_re_printf( aTHX_
                    "%*s%*s Setting close paren #0 (END) to %d\n",
                    22, "|    |", (int)(var_486 * 2 + 1), "",
                    var_401));

                (var_491->close_parens)[0]= var_401;
            }
     break;
 }
        DEBUG_PARSE_r({
            DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", ("lsbr") ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); });
            regprop((var_491->rx), RExC_mysv1, ((var_491->emit_start) + (lastbr)), NULL, var_491);
            regprop((var_491->rx), RExC_mysv2, ((var_491->emit_start) + (var_401)), NULL, var_491);
            Perl_re_printf( aTHX_ "~ tying lastbr %s (%" IVdf ") to ender %s (%" IVdf ") offset %" IVdf "\n",
                          SvPV_nolen_const(RExC_mysv1),
                          (IV)lastbr,
                          SvPV_nolen_const(RExC_mysv2),
                          (IV)var_401,
                          (IV)(var_401 - lastbr)
            );
        });
        if (! regtail((var_491),(lastbr),(var_401),var_486+1)) {
            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
        }

 if (var_366) {
            char var_367= 1;
     if (var_486==1)
                (var_491->seen) |= REG_TOP_LEVEL_BRANCHES_SEEN;


     for (br = ((var_491->emit_start) + (var_483)); br; br = regnext(br)) {
  const U8 var_512 = PL_regkind[OP(br)];
  if (var_512 == BRANCH) {
                    if (! regtail((var_491),(((NEXTOPER(br)) - (var_491->emit_start))),(var_401),var_486+1))


                    {
                        STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                    }
                    if ( OP(NEXTOPER(br)) != NOTHING
                         || regnext(NEXTOPER(br)) != ((var_491->emit_start) + (var_401)))
                        var_367= 0;
  }
  else if (var_512 == BRANCHJ) {
                    bool var_367 = regtail((var_491),(((NEXTOPER(NEXTOPER(br))) - (var_491->emit_start))),(var_401),var_486+1);


                    PERL_UNUSED_VAR(var_367);




                        var_367= 0;
  }
     }
            if (var_367) {
                regnode * ret_as_regnode = ((var_491->emit_start) + (var_483));
                br= PL_regkind[OP(ret_as_regnode)] != BRANCH
                               ? regnext(ret_as_regnode)
                               : ret_as_regnode;
                DEBUG_PARSE_r({
                    DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", ("NADA") ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); });
                    regprop((var_491->rx), RExC_mysv1, ret_as_regnode,
                                     NULL, var_491);
                    regprop((var_491->rx), RExC_mysv2, ((var_491->emit_start) + (var_401)),
                                     NULL, var_491);
                    Perl_re_printf( aTHX_ "~ converting ret %s (%" IVdf ") to ender %s (%" IVdf ") offset %" IVdf "\n",
                                  SvPV_nolen_const(RExC_mysv1),
                                  (IV)((ret_as_regnode) ? (int)((ret_as_regnode)-(var_491->emit_start)) : -1),
                                  SvPV_nolen_const(RExC_mysv2),
                                  (IV)var_401,
                                  (IV)(var_401 - var_483)
                    );
                });
                OP(br)= NOTHING;
                if (OP(((var_491->emit_start) + (var_401))) == TAIL) {
                    NEXT_OFF(br)= 0;
                    (var_491->emit)= ((br) - (var_491->emit_start)) + 1;
                } else {
                    regnode *opt;
                    for ( opt= br + 1; opt < ((var_491->emit_start) + (var_401)) ; opt++ )
                        OP(opt)= OPTIMIZED;
                    NEXT_OFF(br)= ((var_491->emit_start) + (var_401)) - br;
                }
            }
 }
    }

    {
        const char *var_499;

        static const char parens[] = "=!aA<,>Bbt";


 if (var_485 && (var_499 = strchr(parens, var_485))) {
     U8 var_467 = ((var_499 - parens) % 2) ? UNLESSM : IFMATCH;
     int var_367 = (var_499 - parens) > 3;

     if (var_485 == '>' || var_485 == 't') {
  var_467 = SUSPEND, var_367 = 0;
            }

     reginsert(var_491, var_467, var_483, var_486+1);
                                                            ;
                                                     ;
     FLAGS(((var_491->emit_start) + (var_483))) = var_367;
            if (! regtail((var_491),(var_483),(reg_node(var_491, TAIL)),var_486+1))
            {
                STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
            }
 }
    }


    if (var_485) {


 (var_491->flags) = var_367 | ((var_491->flags) & RXf_PMf_KEEPCOPY);
        if ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET) && (var_491->uni_semantics)) {
            set_regex_charset(&(var_491->flags), REGEX_UNICODE_CHARSET);
        }
 if ((var_491->parse) >= (var_491->end) || UCHARAT((var_491->parse)) != ')') {
     (var_491->parse) = oregcomp_parse;
     STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unmatched (", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12374, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
 }
 nextchar(var_491);
    }
    else if (!var_485 && (var_491->parse) < (var_491->end)) {
 if (*(var_491->parse) == ')') {
     (var_491->parse)++;
     STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unmatched )", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12381, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
 }
 else
     STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Junk on end of regexp", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
 NOT_REACHED;
    }

    if ((var_491->in_lookbehind)) {
 (var_491->in_lookbehind)--;
    }
    if (var_367 > (var_491->npar))
        (var_491->npar) = var_367;
    return(var_483);
}

static regnode_offset
fn_367(pTHX_ RExC_state_t *var_491, I32 *flagp, I32 var_369, U32 var_486)
{
    regnode_offset var_483;
    regnode_offset var_369 = 0;
    regnode_offset latest;
    I32 var_451 = 0, var_453 = 0;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGBRANCH;

    DEBUG_PARSE_r({ DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", (("brnc")) ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); }); Perl_re_printf( aTHX_ "%4s","\n"); });

    if (var_369)
 var_483 = 0;
    else {
 if ((var_491->use_BRANCHJ))
     var_483 = reganode(var_491, BRANCHJ, 0);
 else {
     var_483 = reg_node(var_491, BRANCH);
                                              ;
        }
    }

    *flagp = 0;

    skip_to_be_ignored_text(var_491, &(var_491->parse),
                            FALSE );
    while ((var_491->parse) < (var_491->end) && *(var_491->parse) != '|' && *(var_491->parse) != ')') {
 var_451 &= ~0x10;
        latest = regpiece(var_491, &var_451, var_486+1);
 if (latest == 0) {
     if (var_451 & 0x10)
  continue;
            STMT_START { if ((var_451) & (0x20|0x40|0)) { *(flagp) = (var_451) & (0x20|0x40|0); return 0; } } STMT_END;
            STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regpiece returned failure, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) var_451, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
 }
 else if (var_483 == 0)
            var_483 = latest;
 *flagp |= var_451&(0x01|0x08);
 if (var_369 == 0)
     *flagp |= var_451&0x04;
 else {


     if ((var_491->naughty) < 10) (var_491->naughty) += 1;
            if (! regtail((var_491),(var_369),(latest),var_486+1)) {



                STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
            }
 }
 var_369 = latest;
 var_453++;
    }
    if (var_369 == 0) {
 var_369 = reg_node(var_491, NOTHING);
 if (var_483 == 0)
     var_483 = var_369;
    }
    if (var_453 == 1) {
 *flagp |= var_451&0x02;
    }

    return var_483;
}

static regnode_offset
fn_369(pTHX_ RExC_state_t *var_491, I32 *flagp, U32 var_486)
{
    regnode_offset var_483;
    char var_512;
    char *next;
    I32 var_451;
    const char * const origparse = (var_491->parse);
    I32 var_512;
    I32 var_512 = var_372;



    const char *maxpos = NULL;
    UV uv;


    const regnode_offset var_371 = (var_491->emit);

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGPIECE;

    DEBUG_PARSE_r({ DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", (("piec")) ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); }); Perl_re_printf( aTHX_ "%4s","\n"); });

    var_483 = regatom(var_491, &var_451, var_486+1);
    if (var_483 == 0) {
        STMT_START { if ((var_451) & (0x20|0x40|(0x10))) { *(flagp) = (var_451) & (0x20|0x40|(0x10)); return 0; } } STMT_END;
        STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regatom returned failure, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) var_451, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
    }

    var_512 = *(var_491->parse);

    if (var_512 == '{' && regcurly((var_491->parse))) {
 maxpos = NULL;



 next = (var_491->parse) + 1;
 while (isDIGIT(*next) || *next == ',') {
     if (*next == ',') {
  if (maxpos)
      break;
  else
      maxpos = next;
     }
     next++;
 }
 if (*next == '}') {
            const char* endptr;
     if (!maxpos)
  maxpos = next;
     (var_491->parse)++;
            if (isDIGIT(*(var_491->parse))) {
                endptr = (var_491->end);
                if (!grok_atoUV((var_491->parse), &uv, &endptr))
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Invalid quantifier in {,}", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12549, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                if (uv >= var_372)
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Quantifier in {,} bigger than %d", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_372 - 1, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12551, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                var_512 = (I32)uv;
            } else {
                var_512 = 0;
            }
     if (*maxpos == ',')
  maxpos++;
     else
  maxpos = (var_491->parse);
            if (isDIGIT(*maxpos)) {
                endptr = (var_491->end);
                if (!grok_atoUV(maxpos, &uv, &endptr))
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Invalid quantifier in {,}", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12563, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                if (uv >= var_372)
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Quantifier in {,} bigger than %d", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_372 - 1, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12565, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                var_512 = (I32)uv;
            } else {
  var_512 = var_372;
            }
     (var_491->parse) = next;
     nextchar(var_491);
            if (var_512 < var_512) {

                reginsert(var_491, OPFAIL, var_371, var_486+1);
                STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 12575, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Quantifier {n,m} with n > m can't match" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12575, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;
                NEXT_OFF(((var_491->emit_start) + (var_371))) =
                                    regarglen[OPFAIL] + NODE_STEP_REGNODE;
                return var_483;
            }
            else if (var_512 == var_512 && *(var_491->parse) == '?')
            {
                STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 12584, (var_491->parse) + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Useless use of greediness modifier '%c'" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", *(var_491->parse), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12584, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


            }

   do_curly:
     if ((var_451&0x02)) {
                if (var_512 == 0 && var_512 == var_372) {
                    reginsert(var_491, STAR, var_483, var_486+1);
                    if ((var_491->naughty) < 10) (var_491->naughty) += 4;
                    (var_491->seen) |= REG_UNBOUNDED_QUANTIFIER_SEEN;
                    goto nest_check;
                }
                if (var_512 == 1 && var_512 == var_372) {
                    reginsert(var_491, PLUS, var_483, var_486+1);
                    if ((var_491->naughty) < 10) (var_491->naughty) += 3;
                    (var_491->seen) |= REG_UNBOUNDED_QUANTIFIER_SEEN;
                    goto nest_check;
                }
                if ((var_491->naughty) < 10) (var_491->naughty) += (var_491->naughty) / 2 + 2;
  reginsert(var_491, CURLY, var_483, var_486+1);
                                                              ;
                                                                ;
     }
     else {
  const regnode_offset var_451 = reg_node(var_491, WHILEM);

  FLAGS(((var_491->emit_start) + (var_451))) = 0;
                if (! regtail((var_491),(var_483),(var_451),var_486+1)) {
                    STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                }
  if ((var_491->use_BRANCHJ)) {
      reginsert(var_491, LONGJMP, var_483, var_486+1);
      reginsert(var_491, NOTHING, var_483, var_486+1);
      NEXT_OFF(((var_491->emit_start) + (var_483))) = 3;
  }
  reginsert(var_491, CURLYX, var_483, var_486+1);

                                                              ;

                                                                           ;

  if ((var_491->use_BRANCHJ))
                    NEXT_OFF(((var_491->emit_start) + (var_483))) = 3;

                if (! regtail((var_491),(var_483),(reg_node(var_491, NOTHING)),var_486+1))

                {
                    STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
                }
                (var_491->whilem_seen)++;
                if ((var_491->naughty) < 10) (var_491->naughty) += (var_491->naughty) / 1 + 4;
     }
     FLAGS(((var_491->emit_start) + (var_483))) = 0;

     if (var_512 > 0)
  *flagp = 0;
     if (var_512 > 0)
  *flagp |= 0x01;
            ARG1_SET(((var_491->emit_start) + (var_483)), (U16)var_512);
            ARG2_SET(((var_491->emit_start) + (var_483)), (U16)var_512);
            if (var_512 == var_372)
                (var_491->seen) |= REG_UNBOUNDED_QUANTIFIER_SEEN;

     goto nest_check;
 }
    }

    if (!((var_512) == '*' || (var_512) == '+' || (var_512) == '?')) {
 *flagp = var_451;
 return(var_483);
    }

    nextchar(var_491);

    *flagp = (var_512 != '+') ? (0|0x04|0x01) : (0|0x01);

    if (var_512 == '*') {
 var_512 = 0;
 goto do_curly;
    }
    else if (var_512 == '+') {
 var_512 = 1;
 goto do_curly;
    }
    else if (var_512 == '?') {
 var_512 = 0; var_512 = 1;
 goto do_curly;
    }
  nest_check:
    if (!(var_451&(0x01|0x08)) && var_512 > var_372/3) {
 STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 12697, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "%" UTF8f " matches null string many times" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), ((var_491->parse) >= origparse ? (var_491->parse) - origparse : 0), origparse), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12697, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;





    }

    if (*(var_491->parse) == '?') {
 nextchar(var_491);
 reginsert(var_491, MINMOD, var_483, var_486+1);
        if (! regtail((var_491),(var_483),(var_483 + NODE_STEP_REGNODE),var_486+1)) {
            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
        }
    }
    else if (*(var_491->parse) == '+') {
        regnode_offset var_401;
        nextchar(var_491);
        var_401 = reg_node(var_491, SUCCEED);
        if (! regtail((var_491),(var_483),(var_401),var_486+1)) {
            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
        }
        reginsert(var_491, SUSPEND, var_483, var_486+1);
        var_401 = reg_node(var_491, TAIL);
        if (! regtail((var_491),(var_483),(var_401),var_486+1)) {
            STMT_START { (var_491->use_BRANCHJ) = 1; *flagp |= 0x20; return 0; } STMT_END;
        }
    }

    if (((*(var_491->parse)) == '*' || (*(var_491->parse)) == '+' || (*(var_491->parse)) == '?' || ((*(var_491->parse)) == '{' && regcurly((var_491->parse))))) {
 (var_491->parse)++;
 STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Nested quantifiers", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12723, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }

    return(var_483);
}

static bool
fn_372(pTHX_ RExC_state_t *var_491,
                regnode_offset * node_p,
                UV * code_point_p,
                int * var_453,
                I32 * flagp,
                const bool var_451,
                const U32 var_486
    )
{

    char * endbrace;
    char* var_499 = (var_491->parse);

    SV * substitute_parse = NULL;
    char *orig_end;
    char *save_start;
    I32 var_451;

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_GROK_BSLASH_N;

    GET_RE_DEBUG_FLAGS;

    assert(cBOOL(node_p) ^ cBOOL(code_point_p));
    assert(! (node_p && var_453));

    if (var_453) {
        *var_453 = 1;
    }




    skip_to_be_ignored_text(var_491, &var_499,
                            FALSE );




    if (*var_499 != '{' || regcurly(var_499)) {
        (var_491->parse) = var_499;
        if (var_453) {
            *var_453 = -1;
        }

        if (! node_p) {
            return FALSE;
        }

        *node_p = reg_node(var_491, REG_ANY);
        *flagp |= 0x01|0x02;
        if ((var_491->naughty) < 10) (var_491->naughty) += 1;
                                                ;
        return TRUE;
    }





    if (*(var_491->parse) != '{') {
        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Missing braces on \\N{}", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12870, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }

    (var_491->parse)++;

    endbrace = (char *) memchr((var_491->parse), '}', (var_491->end) - (var_491->parse));
    if (! endbrace) {
        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Missing right brace on \\%c{}", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", 'N', UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12877, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }



    STMT_START { if ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) { set_regex_charset(&(var_491->flags), REGEX_UNICODE_CHARSET); (var_491->uni_semantics) = 1; if ((var_491->seen_d_op) && LIKELY(! ((var_491->total_par) < 0))) { *flagp |= 0x20; return FALSE; } } } STMT_END;



    if (endbrace - (var_491->parse) == 1 && *(var_491->parse) == '_') {
        (var_491->parse) = endbrace;
        if (var_451) {
            (var_491->parse)++;
            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Zero length \\N{}", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12890, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
        }

        if (var_453) {
            *var_453 = 0;
        }
        nextchar(var_491);
        if (! node_p) {
            return FALSE;
        }

        *node_p = reg_node(var_491, NOTHING);
        return TRUE;
    }

    if (endbrace - (var_491->parse) < 2 || ! strBEGINs((var_491->parse), "U+")) {





        const STRLEN var_538 = endbrace - (var_491->parse);
        SV * value_sv;
        SV ** value_svp;
        const U8 * var_533;
        STRLEN var_533;



        if (! (var_491->unlexed_names)) {
            (var_491->unlexed_names) = newHV();
        }







        if ((value_svp = hv_fetch((var_491->unlexed_names), (var_491->parse),
                                                      var_538, 0)))
        {
            value_sv = *value_svp;
        }
        else {
            const char * error_msg = NULL;
            value_sv = get_and_check_backslash_N_name((var_491->parse), endbrace,
                                                      cBOOL((var_491->utf8)),
                                                      &error_msg);
            if (error_msg) {
                (var_491->parse) = endbrace;
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", error_msg, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 12941, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
            }


            assert (value_sv);


            if (! hv_store((var_491->unlexed_names), (var_491->parse), var_538,
                           value_sv, 0))
            {
                Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
            }
        }


        var_533 = (U8 *) SvPV(value_sv, var_533);


        if (var_533 > 0 && var_533 <= (UV) ((SvUTF8(value_sv))
                                               ? UTF8SKIP(var_533)
                                               : 1))
        {


            if (! code_point_p) {
                (var_491->parse) = var_499;
                return FALSE;
            }


            *code_point_p = (SvUTF8(value_sv))
                            ? valid_utf8_to_uvchr(var_533, NULL)
                            : *var_533;



            (var_491->parse) = endbrace;
            nextchar(var_491);
            return TRUE;
        }



        if (var_453) {
            *var_453 = 0;

            *var_453 = (SvUTF8(value_sv))
                        ? utf8_length(var_533, var_533 + var_533)
                        : var_533;
        }





        if (! node_p) {
            if (! var_453) {
                (var_491->parse) = var_499;
            }
            return FALSE;
        }






        substitute_parse = newSVpvs("?:");
        sv_catsv(substitute_parse, value_sv);
        sv_catpv(substitute_parse, ")");







    }
    else {
        Size_t var_489 = 0;





        (var_491->parse) += 2;




        do {
            UV var_470 = 0;
            char * start_digit;
            if (! isXDIGIT(*(var_491->parse))) {
                (var_491->parse)++;
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Invalid hexadecimal number in \\N{U+...}", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13036, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
            }

            start_digit = (var_491->var_377);
            var_489++;


            do {


                if (var_470 > MAX_LEGAL_CP >> 4) {


                    do {
                        (var_491->parse) ++;
                    } while (isXDIGIT(*(var_491->parse)) || *(var_491->parse) == '_');



                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Use of code point 0x%.*s is not allowed; the" " permissible max is 0x%" UVxf, " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (int) ((var_491->parse) - start_digit), start_digit, MAX_LEGAL_CP, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13058, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;



                }


                var_470 = (var_470 << 4) + READ_XDIGIT((var_491->var_377));



                if (*(var_491->parse) == '_' && isXDIGIT((var_491->parse)[1])) {
                    (var_491->parse)++;
                }
            } while (isXDIGIT(*(var_491->parse)));


            if ((var_491->parse) >= endbrace) {
                if (var_489 != 1) {
                    goto do_concat;
                }


                if (! code_point_p) {
                    (var_491->parse) = var_499;
                    return FALSE;
                }


                *code_point_p = UNI_TO_NATIVE(var_470);
                (var_491->parse) = endbrace;
                nextchar(var_491);
                return TRUE;
            }





            if (*(var_491->parse) != '.' || (var_491->parse) + 1 >= endbrace) {
                (var_491->parse) += ((var_491->orig_utf8))
                                ? UTF8SKIP((var_491->parse))
                                : 1;
                if ((var_491->parse) >= endbrace) {
                    (var_491->parse) = endbrace;
                }
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Invalid hexadecimal number in \\N{U+...}", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13101, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
            }




            if (! node_p && ! var_453) {
                return FALSE;
            }

            if (node_p && var_489 == 1) {
                substitute_parse = newSVpvs("?:");
            }

          do_concat:

            if (node_p) {

                sv_catpvs(substitute_parse, "\\x{");
                sv_catpvn(substitute_parse, start_digit,
                                            (var_491->parse) - start_digit);
                sv_catpvs(substitute_parse, "}");
            }



            (var_491->parse)++;
            var_489++;

        } while ((var_491->parse) < endbrace);

        if (! node_p) {
            assert (var_453);

            *var_453 = var_489;
            return FALSE;
        }

        sv_catpvs(substitute_parse, ")");







    }

    save_start = (var_491->start);
    orig_end = (var_491->end);

    (var_491->parse) = (var_491->start) = SvPVX(substitute_parse);
    (var_491->end) = (var_491->parse) + SvCUR(substitute_parse);
    STMT_START { (var_491->save_copy_start) = (var_491->copy_start); (var_491->copy_start) = NULL; } STMT_END;

    *node_p = reg(var_491, 1, &var_451, var_486+1);


    (var_491->copy_start) = (var_491->save_copy_start);
    (var_491->start) = save_start;
    (var_491->parse) = endbrace;
    (var_491->end) = orig_end;




    SvREFCNT_dec_NN(substitute_parse);

    if (! *node_p) {
        STMT_START { if ((var_451) & (0x20|0x40|0)) { *(flagp) = (var_451) & (0x20|0x40|0); return 0; } } STMT_END;
        STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: reg returned failure to grok_bslash_N, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) var_451, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

    }
    *flagp |= var_451&(0x01|0x04|0x02|0x08);

    nextchar(var_491);

    return TRUE;
}


PERL_STATIC_INLINE U8
fn_377(RExC_state_t *var_491)
{
    U8 var_512;

    PERL_ARGS_ASSERT_COMPUTE_EXACTISH;

    if (! cBOOL((var_491->flags) & RXf_PMf_FOLD)) {
        return ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET))
                ? EXACTL
                : var_454;
    }

    var_512 = get_regex_charset((var_491->flags));
    if (var_512 >= REGEX_ASCII_RESTRICTED_CHARSET) {
        var_512--;

    }

    return var_512 + EXACTF;
}

static bool
fn_378(const char *var_512, const char *var_512)
{

    bool var_381 = FALSE;
    bool var_381 = FALSE;

    PERL_ARGS_ASSERT_NEW_REGCURLY;

    if (var_512 >= var_512 || *var_512++ != '{')
 return FALSE;

    while (var_512 < var_512 && isSPACE(*var_512)) {
        var_512++;
    }
    while (var_512 < var_512 && isDIGIT(*var_512)) {
        var_381 = TRUE;
        var_512++;
    }
    while (var_512 < var_512 && isSPACE(*var_512)) {
        var_512++;
    }

    if (*var_512 == ',') {
 var_512++;
        while (var_512 < var_512 && isSPACE(*var_512)) {
            var_512++;
        }
        while (var_512 < var_512 && isDIGIT(*var_512)) {
            var_381 = TRUE;
            var_512++;
        }
        while (var_512 < var_512 && isSPACE(*var_512)) {
            var_512++;
        }
    }

    return var_512 < var_512 && *var_512 == '}' && (var_381 || var_381);
}




static I32
fn_381(char *var_499, char *var_512)
{
    const char* endptr = var_512;
    UV var_486;
    if (grok_atoUV(var_499, &var_486, &endptr) && var_486 <= var_387)
        return (I32)var_486;
    return var_387;
}

static regnode_offset
fn_382(pTHX_ RExC_state_t *var_491, I32 *flagp, U32 var_486)
{
    dVAR;
    regnode_offset var_483 = 0;
    I32 var_451 = 0;
    char *parse_start;
    U8 var_512;
    int var_463 = 0;
    U8 var_480;

    GET_RE_DEBUG_FLAGS_DECL;

    *flagp = 0;

    DEBUG_PARSE_r({ DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", (("atom")) ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); }); Perl_re_printf( aTHX_ "%4s","\n"); });

    PERL_ARGS_ASSERT_REGATOM;

  tryagain:
    parse_start = (var_491->parse);
    assert((var_491->parse) < (var_491->end));
    switch ((U8)*(var_491->parse)) {
    case '^':
 (var_491->seen_zerolen)++;
 nextchar(var_491);
 if ((var_491->flags) & RXf_PMf_MULTILINE)
     var_483 = reg_node(var_491, MBOL);
 else
     var_483 = reg_node(var_491, SBOL);
                                          ;
 break;
    case '$':
 nextchar(var_491);
 if (*(var_491->parse))
     (var_491->seen_zerolen)++;
 if ((var_491->flags) & RXf_PMf_MULTILINE)
     var_483 = reg_node(var_491, MEOL);
 else
     var_483 = reg_node(var_491, SEOL);
                                          ;
 break;
    case '.':
 nextchar(var_491);
 if ((var_491->flags) & RXf_PMf_SINGLELINE)
     var_483 = reg_node(var_491, SANY);
 else
     var_483 = reg_node(var_491, REG_ANY);
 *flagp |= 0x01|0x02;
 if ((var_491->naughty) < 10) (var_491->naughty) += 1;
                                          ;
 break;
    case '[':
    {
 char * const oregcomp_parse = ++(var_491->parse);
        var_483 = regclass(var_491, flagp, var_486+1,
                       FALSE,
                       TRUE,
                       FALSE,
                       (bool) (var_491->strict),
                       TRUE,
                       NULL);
        if (var_483 == 0) {
            if (((*(flagp)) & (0x20))) return 0;
            STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regclass returned failure to regatom, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) *flagp, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

        }
 if (*(var_491->parse) != ']') {
     (var_491->parse) = oregcomp_parse;
     STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unmatched [", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13419, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
 }
 nextchar(var_491);
                                                                        ;
 break;
    }
    case '(':
 nextchar(var_491);
        var_483 = reg(var_491, 2, &var_451, var_486+1);
 if (var_483 == 0) {
  if (var_451 & 0x10) {
      if ((var_491->parse) >= (var_491->end)) {

   *flagp |= 0x10;
   return0;
      }
      goto tryagain;
  }
                STMT_START { if ((var_451) & (0x20|0x40|0)) { *(flagp) = (var_451) & (0x20|0x40|0); return 0; } } STMT_END;
                STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: reg returned failure to regatom, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) var_451, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

 }
 *flagp |= var_451&(0x01|0x04|0x02|0x08);
 break;
    case '|':
    case ')':
 if (var_451 & 0x10) {
     *flagp |= 0x10;
     return 0;
 }
 STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Internal urp", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13449, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

 break;
    case '?':
    case '+':
    case '*':
 (var_491->parse)++;
 STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Quantifier follows nothing", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13456, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
 break;
    case '\\':

 (var_491->parse)++;
 switch ((U8)*(var_491->parse)) {

 case 'A':
     (var_491->seen_zerolen)++;
     var_483 = reg_node(var_491, SBOL);


            FLAGS(((var_491->emit_start) + (var_483))) = 1;
     *flagp |= 0x02;
     goto finish_meta_pat;
 case 'G':
     var_483 = reg_node(var_491, GPOS);
            (var_491->seen) |= REG_GPOS_SEEN;
     *flagp |= 0x02;
     goto finish_meta_pat;
 case 'K':
     (var_491->seen_zerolen)++;
     var_483 = reg_node(var_491, KEEPS);
     *flagp |= 0x02;




            (var_491->seen) |= REG_LOOKBEHIND_SEEN;
     goto finish_meta_pat;
 case 'Z':
     var_483 = reg_node(var_491, SEOL);
     *flagp |= 0x02;
     (var_491->seen_zerolen)++;
     goto finish_meta_pat;
 case 'z':
     var_483 = reg_node(var_491, EOS);
     *flagp |= 0x02;
     (var_491->seen_zerolen)++;
     goto finish_meta_pat;
 case 'C':
     STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "\\C no longer supported", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13508, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
 case 'X':
     var_483 = reg_node(var_491, CLUMP);
     *flagp |= 0x01;
     goto finish_meta_pat;

 case 'W':
            var_463 = 1;

 case 'w':
            var_480 = ANYOF_WORDCHAR;
            goto join_posix;

 case 'B':
            var_463 = 1;

 case 'b':
          {
            U8 var_451 = 0;
     regex_charset var_385 = get_regex_charset((var_491->flags));

     (var_491->seen_zerolen)++;
            (var_491->seen) |= REG_LOOKBEHIND_SEEN;
     var_512 = BOUND + var_385;

     if ((var_491->parse) >= (var_491->end) || *((var_491->parse) + 1) != '{') {
                var_451 = TRADITIONAL_BOUND;
                if (var_512 > BOUNDA) {
                    var_512 = BOUNDA;
                }
            }
            else {
                STRLEN var_385;
                char var_538 = *(var_491->parse);
                char * endbrace = NULL;
                (var_491->parse) += 2;
                endbrace = (char *) memchr((var_491->parse), '}', (var_491->end) - (var_491->parse));

                if (! endbrace) {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Missing right brace on \\%c{}", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_538, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13547, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }






                if (endbrace == (var_491->parse)) {
                    (var_491->parse)++;
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Empty \\%c{}", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_538, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13557, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }
                var_385 = endbrace - (var_491->parse);



                switch (*(var_491->parse)) {
                    case 'g':
                        if ( var_385 != 1
                            && (memNEs((var_491->parse) + 1, var_385 - 1, "cb")))
                        {
                            goto bad_bound_type;
                        }
                        var_451 = GCB_BOUND;
                        break;
                    case 'l':
                        if (var_385 != 2 || *((var_491->parse) + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        var_451 = LB_BOUND;
                        break;
                    case 's':
                        if (var_385 != 2 || *((var_491->parse) + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        var_451 = SB_BOUND;
                        break;
                    case 'w':
                        if (var_385 != 2 || *((var_491->parse) + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        var_451 = WB_BOUND;
                        break;
                    default:
                      bad_bound_type:
                        (var_491->parse) = endbrace;
   STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "'%" UTF8f "' is an unknown bound type", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), var_385, endbrace - var_385), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13595, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;


                        NOT_REACHED;
                }
                (var_491->parse) = endbrace;
                STMT_START { if ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) { set_regex_charset(&(var_491->flags), REGEX_UNICODE_CHARSET); (var_491->uni_semantics) = 1; if ((var_491->seen_d_op) && LIKELY(! ((var_491->total_par) < 0))) { *flagp |= 0x20; return 0; } } } STMT_END;

                if (var_512 == BOUND) {
                    var_512 = BOUNDU;
                }
                else if (var_512 >= BOUNDA) {
                    var_512 = BOUNDU;
                    var_385 += 4;



                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 13616, (var_491->parse) + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Using /u for '%.*s' instead of /%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (unsigned) var_385, endbrace - var_385 + 1, (var_385 == REGEX_ASCII_RESTRICTED_CHARSET) ? ASCII_RESTRICT_PAT_MODS : ASCII_MORE_RESTRICT_PAT_MODS, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13616, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;






                }
     }

            if (var_512 == BOUND) {
                (var_491->seen_d_op) = TRUE;
            }
            else if (var_512 == BOUNDL) {
                (var_491->contains_locale) = 1;
            }

            if (var_463) {
                var_512 += NBOUND - BOUND;
            }

     var_483 = reg_node(var_491, var_512);
            FLAGS(((var_491->emit_start) + (var_483))) = var_451;

     *flagp |= 0x02;

     goto finish_meta_pat;
          }

 case 'D':
            var_463 = 1;

 case 'd':
            var_480 = ANYOF_DIGIT;
            if (! (get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) {
                goto join_posix;
            }




            var_512 = POSIXU;
            goto join_posix_op_known;

 case 'R':
     var_483 = reg_node(var_491, LNBREAK);
     *flagp |= 0x01|0x02;
     goto finish_meta_pat;

 case 'H':
            var_463 = 1;

 case 'h':
     var_480 = ANYOF_BLANK;
            var_512 = POSIXU;
            goto join_posix_op_known;

 case 'V':
            var_463 = 1;

 case 'v':
     var_480 = ANYOF_VERTWS;
            var_512 = POSIXU;
            goto join_posix_op_known;

 case 'S':
            var_463 = 1;

 case 's':
            var_480 = ANYOF_SPACE;

          join_posix:

     var_512 = POSIXD + get_regex_charset((var_491->flags));
            if (var_512 > POSIXA) {
                var_512 = POSIXA;
            }
            else if (var_512 == POSIXL) {
                (var_491->contains_locale) = 1;
            }
            else if (var_512 == POSIXD) {
                (var_491->seen_d_op) = TRUE;
            }

          join_posix_op_known:

            if (var_463) {
                var_512 += NPOSIXD - POSIXD;
            }

     var_483 = reg_node(var_491, var_512);
            FLAGS(((var_491->emit_start) + (var_483))) = ((int) ((var_480) / 2));

     *flagp |= 0x01|0x02;


          finish_meta_pat:
            if ( UCHARAT((var_491->parse) + 1) == '{'
                && UNLIKELY(! new_regcurly((var_491->parse) + 1, (var_491->end))))
            {
                (var_491->parse) += 2;
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unescaped left brace in regex is illegal here", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13711, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
            }
     nextchar(var_491);
                                              ;
     break;
 case 'p':
 case 'P':
            (var_491->parse)--;

            var_483 = regclass(var_491, flagp, var_486+1,
                           TRUE,
                           FALSE,
                           FALSE,


                           (bool) (var_491->strict),
                           TRUE,
                           NULL);
            if (((*(flagp)) & (0x20))) return 0;


            if (!var_483)
                STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regclass returned failure to regatom, flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) *flagp, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;


            (var_491->parse)--;

                                                        ;
                                                                ;
            nextchar(var_491);
     break;
        case 'N':

            ++(var_491->parse);
            if (grok_bslash_N(var_491,
                              &var_483,
                              NULL,

                              NULL,

                              flagp,
                              (var_491->strict),
                              var_486)
            ) {
                break;
            }

            if (((*(flagp)) & (0x20))) return 0;


            (var_491->parse) = parse_start;
            goto defchar;

 case 'k':
      parse_named_seq:
        {
            char var_385;
            if ( (var_491->parse) >= (var_491->end) - 1
                || (( var_385 = (var_491->parse)[1]) != '<'
                                      && var_385 != '\''
                                      && var_385 != '{'))
            {
         (var_491->parse)++;

         STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Sequence %.2s... not terminated", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", parse_start, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13785, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
     } else {
  (var_491->parse) += 2;
                var_483 = handle_named_backref(var_491,
                                           flagp,
                                           parse_start,
                                           (var_385 == '<')
                                           ? '>'
                                           : (var_385 == '{')
                                             ? '}'
                                             : '\'');
            }
            break;
 }
 case 'g':
 case '1': case '2': case '3': case '4':
 case '5': case '6': case '7': case '8': case '9':
     {
  I32 var_387;
  bool var_387 = 0;

  if (*(var_491->parse) == 'g') {
                    bool var_387 = 0;

      (var_491->parse)++;
      if (*(var_491->parse) == '{') {
          (var_491->parse)++;
          var_387 = 1;
      }
      if (*(var_491->parse) == '-') {
          (var_491->parse)++;
          var_387 = 1;
      }
      if (var_387 && !isDIGIT(*(var_491->parse))) {
          if (var_387) (var_491->parse)--;
                        (var_491->parse) -= 2;
          goto parse_named_seq;
                    }

                    if ((var_491->parse) >= (var_491->end)) {
                        goto unterminated_g;
                    }
                    var_387 = S_backref_value((var_491->parse), (var_491->end));
                    if (var_387 == 0)
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Reference to invalid group 0", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13829, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    else fn_450 (num == var_387) {
                         if (isDIGIT(*(var_491->parse)))
       STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Reference to nonexistent group", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13832, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                        else
                          unterminated_g:
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unterminated \\g... pattern", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13835, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }

                    if (var_387) {
                        var_387 = (var_491->npar) - var_387;
                        if (var_387 < 1)
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Reference to nonexistent or unclosed group", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13841, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
                }
                else {
                    var_387 = S_backref_value((var_491->parse), (var_491->end));







                    if (

                        var_387 > 9

                        && var_387 >= (var_491->npar)

                        && *(var_491->parse) != '8'

                        && *(var_491->parse) != '9'
                    ) {




                        (var_491->parse) = parse_start;
                        goto defchar;
                    }
                }






                while (isDIGIT(*(var_491->parse)))
                    (var_491->parse)++;
                if (var_387) {
                    if (*(var_491->parse) != '}')
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unterminated \\g{...} pattern", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13881, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    (var_491->parse)++;
                }
                if (var_387 >= (I32)(var_491->npar)) {




                    if (((var_491->total_par) > 0)) {
                        if (var_387 >= (var_491->total_par)) {
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Reference to nonexistent group", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 13891, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                        }
                    }
                    else {
                        STMT_START { if (! ((var_491->total_par) > 0)) (var_491->total_par) = -1; } STMT_END;
                    }
                }
                (var_491->sawback) = 1;
                var_483 = reganode(var_491,
                               ((! cBOOL((var_491->flags) & RXf_PMf_FOLD))
                                 ? REF
                                 : ((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET))
                                   ? REFFA
                                   : ((get_regex_charset((var_491->flags)) >= REGEX_UNICODE_CHARSET))
                                     ? REFFU
                                     : ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET))
                                       ? REFFL
                                       : REFF),
                                var_387);
                if (OP(((var_491->emit_start) + (var_483))) == REFF) {
                    (var_491->seen_d_op) = TRUE;
                }
                *flagp |= 0x01;


                                                            ;
                                                                  ;
                skip_to_be_ignored_text(var_491, &(var_491->parse),
                                        FALSE );
     }
     break;
 case '\0':
     if ((var_491->parse) >= (var_491->end))
  STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Trailing \\", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

 default:


            (var_491->parse) = parse_start;
     goto defchar;
 }
 break;

    case '#':



        assert(((var_491->flags) & RXf_PMf_EXTENDED) == 0);

    default:
   defchar: {






     STRLEN var_531 = 0;
     UV var_401 = 0;
     char *var_499;
     char *var_512;





     char *var_512;
     U8 var_401 = (255-UTF8_MAXBYTES_CASE);

            U8 var_401 = var_454;




            Ptrdiff_t var_401 = STR_SZ(256);

            bool next_is_quantifier;
            char * oldp = NULL;

            bool var_401 = cBOOL((var_491->flags) & RXf_PMf_FOLD) && ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET) || (get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET));



            U8 var_401 = 0x02;



            bool var_401 = FALSE;


            bool var_401 = FALSE;


            bool var_401 = FALSE;




            var_483 = regnode_guts(var_491, var_401, var_401, "exact");
            FILL_NODE(var_483, var_401);
            (var_491->emit)++;

     var_512 = STRING(((var_491->emit_start) + (var_483)));

            var_512 = var_512;

   reparse:

            assert( ! cBOOL((var_491->utf8))
                   || UTF8_IS_INVARIANT(UCHARAT((var_491->parse)))
                   || UTF8_IS_START(UCHARAT((var_491->parse))));






     for (var_499 = (var_491->parse); var_531 < var_401 && var_499 < (var_491->end); ) {



                Size_t var_399 = 1;

  oldp = var_499;


                assert( ((var_491->flags) & RXf_PMf_EXTENDED) == 0
                       || ! is_PATWS_safe((var_499), (var_491->end), cBOOL((var_491->utf8))));

  switch ((U8)*var_499) {
  case '^':
  case '$':
  case '.':
  case '[':
  case '(':
  case ')':
  case '|':
      goto loopdone;
  case '\\':

      switch ((U8)*++var_499) {


      case 'A':
      case 'b': case 'B':
      case 'C':
      case 'd': case 'D':
      case 'g': case 'G':
      case 'h': case 'H':
      case 'k': case 'K':
      case 'p': case 'P':
                case 'R':
      case 's': case 'S':
      case 'v': case 'V':
      case 'w': case 'W':
                    case 'X':

      case 'z': case 'Z':
   --var_499;
   goto loopdone;




      case 'n':
   var_401 = '\n';
   var_499++;
   break;
      case 'N':
                        (var_491->parse) = var_499 + 1;
                        if (! grok_bslash_N(var_491,
                                            NULL,


                                            &var_401,

                                            NULL,

                                            flagp,
                                            (var_491->strict),
                                            var_486)
                        ) {
                            if (*flagp & 0x40)
                                STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "panic: grok_bslash_N set NEED_UTF8", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
                            if (((*(flagp)) & (0x20))) return 0;




                            (var_491->parse) = var_499 = oldp;
                            goto loopdone;
                        }
                        var_499 = (var_491->parse);
                        (var_491->parse) = parse_start;




                        if (var_401 == EXACTF) {
                            var_401 = EXACTFU;




                            if (! var_401) {
                                var_531 = 0;
                                var_512 = var_512;
                                goto reparse;
                            }
                        }

                        break;
      case 'r':
   var_401 = '\r';
   var_499++;
   break;
      case 't':
   var_401 = '\t';
   var_499++;
   break;
      case 'f':
   var_401 = '\f';
   var_499++;
   break;
      case 'e':
   var_401 = ESC_NATIVE;
   var_499++;
   break;
      case 'a':
   var_401 = '\a';
   var_499++;
   break;
      case 'o':
   {
       UV var_397;
       const char* error_msg;

       bool var_451 = grok_bslash_o(&var_499,
                                                       (var_491->end),
             &var_397,
             &error_msg,
             ( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset )),
                                                       (bool) (var_491->strict),
                                                       TRUE,


                                                       cBOOL((var_491->utf8)));
       if (! var_451) {
    (var_491->parse) = var_499;

    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", error_msg, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14191, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
       }
                            STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 - 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + (var_499 - 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END;
                            var_401 = var_397;
       break;
   }
      case 'x':
   {
                            UV var_397 = var_459;

       const char* error_msg;

       bool var_451 = grok_bslash_x(&var_499,
                                                       (var_491->end),
             &var_397,
             &error_msg,
                                                       ( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset )),
                                                       (bool) (var_491->strict),
                                                       TRUE,


                                                       cBOOL((var_491->utf8)));
       if (! var_451) {
    (var_491->parse) = var_499;

    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", error_msg, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14216, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
       }
                            STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 - 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + (var_499 - 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END;
                            var_401 = var_397;

                            if (var_401 < 0x100) {





       }
       break;
   }
      case 'c':
   var_499++;
   var_401 = grok_bslash_c(*var_499, ( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset )));
                        STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END;
                        var_499++;
   break;
                    case '8': case '9':
                        --var_499;



                        goto loopdone;
                    case '1': case '2': case '3':case '4':
      case '5': case '6': case '7':

                        if ( !isDIGIT(var_499[1]) || S_backref_value(var_499, (var_491->end)) < (var_491->npar))
                        {

                            --var_499;
                            goto loopdone;
                        }

                    case '0':
   {
       I32 var_451 = var_470;
       STRLEN var_451 = 3;
       var_401 = grok_oct(var_499, &var_451, &var_451, NULL);
       var_499 += var_451;
                            if ( isDIGIT(*var_499)
                                && ckWARN(WARN_REGEXP)
                                && var_451 < 3)
                            {
    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 14279, var_499 + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", form_short_octal_warning(var_499, var_451), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14279, (IV) (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


                            }
   }
   break;
      case '\0':
   if (var_499 >= (var_491->end))
       STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Trailing \\", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

      default:
   if (isALPHANUMERIC(*var_499)) {



                            if (! isALPHA(*var_499) || *(var_499 + 1) != '{') {
                                STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 14294, var_499 + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Unrecognized escape \\%.1s" " passed through" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_499, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14294, (IV) (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;

                            }
   }
   goto normal_default;
      }
      break;
  case '{':

      if (var_531 || (var_499 > (var_491->start) && isALPHA_A(*(var_499 - 1)))) {
                        if ( (var_491->strict)
                            || ( var_499 > parse_start + 1
                                && isALPHA_A(*(var_499 - 1))
                                && *(var_499 - 2) == '\\')
                            || new_regcurly(var_499, (var_491->end)))
                        {
                            (var_491->parse) = var_499 + 1;
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unescaped left brace in regex is " "illegal here", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14325, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                        }
                        STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 14328, var_499 + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Unescaped left brace in regex is" " passed through" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14328, (IV) (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;

      }
      goto normal_default;
                case '}':
                case ']':
                    if (var_499 > (var_491->parse) && (var_491->strict)) {
                        STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 14334, var_499 + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Unescaped literal '%c'" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", *var_499, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14334, (IV) (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;
                    }

  default:
    normal_default:
      if (! UTF8_IS_INVARIANT(*var_499) && cBOOL((var_491->utf8))) {
   STRLEN var_451;
   var_401 = utf8n_to_uvchr((U8*)var_499, (var_491->end) - var_499,
            &var_451, UTF8_ALLOW_DEFAULT);
   var_499 += var_451;
      }
      else
   var_401 = (U8) *var_499++;
      break;
  }





                if (var_401 > 255) {
                    STMT_START { if (!cBOOL((var_491->utf8))) { *flagp = 0x20|0x40; return 0; } } STMT_END;
                }





                skip_to_be_ignored_text(var_491, &var_499,
                                        FALSE );

                next_is_quantifier = LIKELY(var_499 < (var_491->end))
                                     && UNLIKELY(((*var_499) == '*' || (*var_499) == '+' || (*var_499) == '?' || ((*var_499) == '{' && regcurly(var_499))));

                if (next_is_quantifier && LIKELY(var_531)) {
                    var_499 = oldp;
                    goto loopdone;
                }



                if (! cBOOL((var_491->flags) & RXf_PMf_FOLD)) {

                      not_fold_common:
                        if (UVCHR_IS_INVARIANT(var_401) || ! cBOOL((var_491->utf8))) {
                            *(var_512++) = (char) var_401;
                        }
                        else {
                            U8 * new_s = uvchr_to_utf8((U8*)var_512, var_401);
                            var_399 = (char *) new_s - var_512;
                            var_512 = (char *) new_s;

                            if (var_401 > 255) {
                                var_401 = TRUE;
                            }
                        }
                }
                else if ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET) && is_PROBLEMATIC_LOCALE_FOLD_cp(var_401)) {






                    if (! var_531) {
                        var_401 = EXACTFL;
                        (var_491->contains_locale) = 1;
                    }
                    else if (var_401 == var_454) {
                        var_499 = oldp;
                        goto loopdone;
                    }



                    var_401 = FALSE;

                    goto not_fold_common;
                }
                else
                     if ( (var_401 < 256 && ! _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(var_401))
                         || (var_401 > 255
                            && ! _invlist_contains_cp(PL_in_some_fold, var_401)))
                {




                    if (var_531 && var_401 != var_454) {
                        var_499 = oldp;
                        goto loopdone;
                    }



                    goto not_fold_common;
                }
                else {





                    if (! var_531) {
                        var_401 = compute_EXACTish(var_491);
                    }
                    else if (var_401 == var_454) {
                        var_499 = oldp;
                        goto loopdone;
                    }

                    if (cBOOL((var_491->utf8))) {
                        if (UVCHR_IS_INVARIANT(var_401)) {
                            *(var_512)++ = (U8) toFOLD(var_401);
                        }
                        else {
                            var_401 = _to_uni_fold_flags(
                                    var_401,
                                    (U8 *) var_512,
                                    &var_399,
                                    FOLD_FLAGS_FULL | (((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET))
                                                    ? FOLD_FLAGS_NOMIX_ASCII
                                                    : 0));
                            var_512 += var_399;

                            if ( var_401 > 255
                                && LIKELY(var_401 != GREEK_SMALL_LETTER_MU))
                            {


                                var_401 = TRUE;
                            }
                        }
                    }
                    else {



                        if (PL_fold[var_401] != PL_fold_latin1[var_401]) {
                            var_401 = FALSE;
                        }

                        else if (UNLIKELY(var_401 == MICRO_SIGN)) {
                            var_401 = TRUE;
                        }

                        *(var_512++) = ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET))
                                 ? (char) toFOLD(var_401)







                                 : (char) toLOWER_L1(var_401);
                    }
  }

                var_531 += var_399;

  if (next_is_quantifier) {



                    goto loopdone;
  }

     }

            if (cBOOL((var_491->flags) & RXf_PMf_FOLD) && var_499 < (var_491->end) && var_401 == (255-UTF8_MAXBYTES_CASE)) {
                PERL_UINT_FAST8_T var_401 = 0;

                const STRLEN var_401 = var_531;

  assert(var_531 >= (255-UTF8_MAXBYTES_CASE));





  if (! cBOOL((var_491->utf8))) {


                    if ((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)) {
                        goto loopdone;
                    }

                    while (--var_512 >= var_512 && _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(*var_512)) {
                        var_401++;
                    }
                    var_531 = var_512 - var_512 + 1;
  }
                else {


                    var_512 = (char *) utf8_hop_back((U8 *) var_512, -1, (U8 *) var_512);

                    while (var_512 >= var_512) {

                        if (UTF8_IS_INVARIANT(*var_512)) {





                            if ((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
                                || ! _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(*var_512))
                            {
                                break;
                            }
                        }
                        else if (UTF8_IS_DOWNGRADEABLE_START(*var_512)) {
                            if (! _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(EIGHT_BIT_UTF8_TO_NATIVE( *var_512, *(var_512+1))))

                            {
                                break;
                            }
                        }
                        else if (! _invlist_contains_cp(
                                        PL_NonFinalFold,
                                        valid_utf8_to_uvchr((U8 *) var_512, NULL)))
                        {
                            break;
                        }






                        var_512 = (var_512 == var_512) ? var_512 -1 : (char *) utf8_hop((U8 *) var_512, -1);
                        var_401++;
                    }





                    var_531 = (var_512 < var_512) ? 0 : var_512 - var_512 + UTF8SKIP(var_512);
  }

                if (var_531 == 0) {
                    var_531 = var_401;

                } else {





                    if (var_401 == 0) {
                        goto loopdone;
                    }
                    else if (var_401 == 1) {




                        var_499 = oldp;
                        goto loopdone;
                    }

                    var_401 = var_531;
                    var_531 = 0;
                    var_512 = var_512;
                    goto reparse;
                }
     }

          loopdone:




            change_engine_size(var_491,
                                - (Ptrdiff_t) (var_401 - STR_SZ(var_531)));




            if (var_531 == 0) {
                OP(((var_491->emit_start) + (var_483))) = NOTHING;
            }
            else {



                if (var_401 == var_454) {
                    if ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET)) {
                        var_401 = EXACTL;
                    }
                    else if (var_401) {
                        var_401 = EXACT_ONLY8;
                    }
                } else if (cBOOL((var_491->flags) & RXf_PMf_FOLD)) {
                    if ( UNLIKELY(var_401 || var_401)
                        && (var_401 == EXACTFU || ( var_401 == EXACTF
                                                     && var_401)))
                    {

                        assert(! cBOOL((var_491->utf8)));
                        var_401 = EXACTFUP;
                    }
                    else if (var_401 == EXACTFL) {




                        if (var_401) {
                            var_401 = EXACTFLU8;
                        }
                        else if (UNLIKELY(
                             _invlist_contains_cp(PL_HasMultiCharFold, var_401)))
                        {

                            var_401 = 0;
                        }
                    }
                    else if (var_401 == EXACTF) {






                        if (! var_401) {
                            (var_491->seen_d_op) = TRUE;
                        }
                        else if ( isALPHA_FOLD_EQ(* STRING(((var_491->emit_start) + (var_483))), 's')
                                 || isALPHA_FOLD_EQ(var_401, 's'))
                        {

                            var_401 = EXACTFU_S_EDGE;
                        }
                        else {
                            var_401 = EXACTFU;
                        }
                    }

                    if (var_401 && var_401 == EXACTFU) {
                        var_401 = EXACTFU_ONLY8;
                    }
                }

                OP(((var_491->emit_start) + (var_483))) = var_401;
                STR_LEN(((var_491->emit_start) + (var_483))) = var_531;
                (var_491->emit) += STR_SZ(var_531);


                if (var_531 > (Size_t) ((cBOOL((var_491->utf8))) ? UVCHR_SKIP(var_401) : 1)) {
                    var_401 = 0;
                }

                *flagp |= 0x01 | var_401;
            }

                                                                ;
            (var_491->parse) = var_499;

     {

  IV var_402 = var_531;
  if (var_402 < 0)
      STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Internal disaster", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14832, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
     }

 }
 break;
    }


    skip_to_be_ignored_text(var_491, &(var_491->parse),
                                            FALSE );
    if ( *(var_491->parse) == '{'
        && OP(((var_491->emit_start) + (var_483))) != SBOL && ! regcurly((var_491->parse)))
    {
        if ((var_491->strict) || new_regcurly((var_491->parse), (var_491->end))) {
            (var_491->parse)++;
            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unescaped left brace in regex is illegal here", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14847, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
        }
        STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 14850, (var_491->parse) + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Unescaped left brace in regex is" " passed through" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 14850, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;

    }

    return(var_483);
}


static void
fn_402(pTHX_ regnode *var_467, SV** invlist_ptr)
{




    dVAR;

    PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST;
    assert(PL_regkind[OP(var_467)] == ANYOF);


    if (OP(var_467) == ANYOFH) {
        return;
    }

    ANYOF_BITMAP_ZERO(var_467);
    if (*invlist_ptr) {


 bool var_404 = FALSE;

 UV var_463, var_454;


 invlist_iterinit(*invlist_ptr);
 while (invlist_iternext(*invlist_ptr, &var_463, &var_454)) {
     UV var_404;
     int var_531;

            if (var_454 == var_459 && var_463 <= NUM_ANYOF_CODE_POINTS) {
                ANYOF_FLAGS(var_467) |= ANYOF_MATCHES_ALL_ABOVE_BITMAP;
            }


     if (var_463 >= NUM_ANYOF_CODE_POINTS) {
  break;
     }

     var_404 = TRUE;


     var_404 = (var_454 < NUM_ANYOF_CODE_POINTS - 1)
                   ? var_454
                   : NUM_ANYOF_CODE_POINTS - 1;
     for (var_531 = var_463; var_531 <= (int) var_404; var_531++) {
  if (! ANYOF_BITMAP_TEST(var_467, var_531)) {
      ANYOF_BITMAP_SET(var_467, var_531);
  }
     }
 }
 invlist_iterfinish(*invlist_ptr);




 if (var_404) {
     _invlist_subtract(*invlist_ptr, PL_InBitmap, invlist_ptr);
 }
        if (ANYOF_FLAGS(var_467) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {
     _invlist_intersection(*invlist_ptr, PL_InBitmap, invlist_ptr);
 }


 if (_invlist_len(*invlist_ptr) == 0) {
     SvREFCNT_dec_NN(*invlist_ptr);
     *invlist_ptr = NULL;
 }
    }
}

static int
fn_404(pTHX_ RExC_state_t *var_491,

    const char * const var_512,



    char ** updated_parse_ptr,

    AV ** posix_warnings,

    const bool var_412
)
{

    const char* var_499 = var_512;
    const char * const var_512 = (var_491->end);
    unsigned var_418 = 0;
    bool var_418 = FALSE;
    bool var_418 = FALSE;
    bool var_418 = FALSE;
    int var_418 = -1;

    const char * possible_end = NULL;
    const char* name_start;




    int var_418 = 2;




    UV input_text[15];
    STATIC_ASSERT_DECL(C_ARRAY_LENGTH(input_text) >= sizeof "alphanumeric");

    PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX;

    STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END;

    if (var_499 >= var_512) {
        return -2;
    }

    if (*(var_499 - 1) != '[') {
        STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "it doesn't start with a '['" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15107, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
        var_418 = TRUE;
    }
    else {
        var_418 = TRUE;
    }



    if (isBLANK(*var_499)) {
        var_418 = TRUE;

        do {
            var_499++;
        } while (var_499 < var_512 && isBLANK(*var_499));

        STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "no blanks are allowed in one" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15123, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
    }



    if (((*var_499) == '=' || (*var_499) == '.') && var_499 < var_512 - 3)


    {
        const char var_412 = *var_499;
        const char * temp_ptr = var_499 + 1;

        if (temp_ptr[1] == var_412) {
            temp_ptr++;
        }
        else while ( temp_ptr < var_512
                    && (isWORDCHAR(*temp_ptr) || *temp_ptr == '-'))
        {
            temp_ptr++;
        }

        if (*temp_ptr == var_412) {
            temp_ptr++;
            if (*temp_ptr == ']') {
                temp_ptr++;
                if (! var_418 && ! var_412) {
                    (var_491->parse) = (char *) temp_ptr;
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "POSIX syntax [%c %c] is reserved for future " "extensions", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_412, var_412, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15183, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                }



                if (updated_parse_ptr) {
                    *updated_parse_ptr = (char *) temp_ptr;
                }

                STMT_START { STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END; return -1; } STMT_END;
            }
        }





    }




    if (*var_499 == '^') {
        var_418 = TRUE;
        STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "the '^' must come after the colon" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15207, (IV) (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 + 1 - (var_491->copy_start)))))); } } STMT_END;
        var_418 = 1;
        var_499++;

        if (isBLANK(*var_499)) {
            var_418 = TRUE;

            do {
                var_499++;
            } while (var_499 < var_512 && isBLANK(*var_499));

            STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "no blanks are allowed in one" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15218, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
        }
    }




    if (*var_499 == ':') {
        var_499++;
        var_418 = TRUE;
    }
    else if (*var_499 == ';') {
        var_418 = TRUE;
        var_499++;
        STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "a semi-colon was found instead of a colon" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15232, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
        var_418 = TRUE;
    }
    else {
        var_418 = TRUE;
        STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "there must be a starting ':'" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15237, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;



        if (*var_499 != '^' && *var_499 != ']' && isPUNCT(*var_499)) {
            var_499++;
        }
    }


    if (isBLANK(*var_499)) {
        var_418 = TRUE;

        do {
            var_499++;
        } while (var_499 < var_512 && isBLANK(*var_499));

        STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "no blanks are allowed in one" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15254, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
    }

    if (*var_499 == '^') {



        if (var_418) {
            STMT_START { STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END; return -2; } STMT_END;
        }

        var_418 = 1;
        var_499++;
    }


    if (isBLANK(*var_499)) {
        var_418 = TRUE;

        do {
            var_499++;
        } while (var_499 < var_512 && isBLANK(*var_499));

        STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "no blanks are allowed in one" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15277, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
    }

    if (*var_499 == ']') {







        if (var_418) {
            STMT_START { STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END; return -2; } STMT_END;
        }




        var_499--;

        if (*var_499 == ';') {
            var_418 = TRUE;
            STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "a semi-colon was found instead of a colon" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15299, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
        }
        else if (*var_499 != ':') {




            STMT_START { STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END; return -2; } STMT_END;
        }




        var_418 = FALSE;
        var_499--;

        while (var_499 > (var_491->start) && isWORDCHAR(*var_499)) {
            var_499--;
        }
        var_499++;



    }

    name_start = var_499;
  parse_name:
    {
        bool var_418 = FALSE;
        bool var_418 = FALSE;
        bool var_418 = FALSE;
        bool var_418 = FALSE;
        bool var_418 = FALSE;
        unsigned int var_538 = 0;
        int var_417 = 0;

        while (var_499 < var_512) {


            if (isBLANK(*var_499) ) {
                var_418 = TRUE;
                var_418 = TRUE;
                var_499++;
                continue;
            }


            if (isPUNCT(*var_499)) {
                const char * peek = var_499 + 1;







                if (*var_499 != ']') {
                    if (peek < var_512 && isBLANK(*peek)) {
                        var_418 = TRUE;
                        var_418 = TRUE;
                        do {
                            peek++;
                        } while (peek < var_512 && isBLANK(*peek));
                    }

                    if (peek < var_512 && *peek == ']') {
                        var_418 = TRUE;
                        if (*var_499 == ':') {
                            var_418 = TRUE;
                        }
                        else if (*var_499 == ';') {
                            var_418 = TRUE;
                            var_418 = TRUE;
                        }
                        else {
                            var_418 = TRUE;
                        }
                        var_499 = peek + 1;
                        goto try_posix;
                    }
                }




                if (*var_499 == ']' || *var_499 == '[' || *var_499 == ':' || *var_499 == ';') {



                    if (possible_end) {
                        break;
                    }
                    possible_end = var_499;
                }



                if (++var_417 > var_418) {
                    break;
                }


                input_text[var_538++] = *var_499;
                var_499++;
            }
            else if (isUPPER(*var_499)) {
                input_text[var_538++] = toLOWER(*var_499);
                var_418 = TRUE;
                var_418 = TRUE;
                var_499++;
            } else if (! cBOOL((var_491->utf8)) || UTF8_IS_INVARIANT(*var_499)) {
                input_text[var_538++] = *var_499;
                var_499++;
            }
            else {
                input_text[var_538++] = utf8_to_uvchr_buf((U8 *) var_499, var_512, NULL);
                var_499+= UTF8SKIP(var_499);
            }




            if (var_538 >= C_ARRAY_LENGTH(input_text)) {
                break;
            }
        }

        var_418 = TRUE;



        if ( var_538 >= C_ARRAY_LENGTH(input_text)
            || var_417 > var_418)
        {


            if (possible_end && possible_end != (char *) -1) {
                possible_end = (char *) -1;

                var_499 = name_start;
                goto parse_name;
            }


            STMT_START { STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END; return -2; } STMT_END;
        }




        if (var_538 && var_499 == var_512 && isPUNCT(*(var_499-1))) {
            var_499--;
            var_538--;
        }

        if (var_499 < var_512 && isPUNCT(*var_499)) {
            if (*var_499 == ']') {
                var_418 = TRUE;




                if ( possible_end
                    && possible_end != (char *) -1
                    && *possible_end == ']'
                    && var_538 && input_text[var_538 - 1] == ']')
                {
                    var_538--;
                    var_499 = possible_end;



                    possible_end = (char *) -1;
                }
            }
            else {
                if (*var_499 == ':') {
                    var_418 = TRUE;
                }
                else if (*var_499 == ';') {
                    var_418 = TRUE;
                    var_418 = TRUE;
                }
                var_499++;
            }
        }

    try_posix:





        if (var_538 < 3) {
            STMT_START { STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END; return -2; } STMT_END;
        }



        switch (var_538) {
            case 4:
                if (memEQs(name_start, 4, "word")) {

                    var_418 = ANYOF_WORDCHAR;
                }
                break;
            case 5:



                switch (name_start[4]) {
                    case 'a':
                        if (memBEGINs(name_start, 5, "alph"))
                            var_418 = ANYOF_ALPHA;
                        break;
                    case 'e':
                        if (memBEGINs(name_start, 5, "spac"))
                            var_418 = ANYOF_SPACE;
                        break;
                    case 'h':
                        if (memBEGINs(name_start, 5, "grap"))
                            var_418 = ANYOF_GRAPH;
                        break;
                    case 'i':
                        if (memBEGINs(name_start, 5, "asci"))
                            var_418 = ANYOF_ASCII;
                        break;
                    case 'k':
                        if (memBEGINs(name_start, 5, "blan"))
                            var_418 = ANYOF_BLANK;
                        break;
                    case 'l':
                        if (memBEGINs(name_start, 5, "cntr"))
                            var_418 = ANYOF_CNTRL;
                        break;
                    case 'm':
                        if (memBEGINs(name_start, 5, "alnu"))
                            var_418 = ANYOF_ALPHANUMERIC;
                        break;
                    case 'r':
                        if (memBEGINs(name_start, 5, "lowe"))
                            var_418 = (cBOOL((var_491->flags) & RXf_PMf_FOLD)) ? ANYOF_CASED : ANYOF_LOWER;
                        else if (memBEGINs(name_start, 5, "uppe"))
                            var_418 = (cBOOL((var_491->flags) & RXf_PMf_FOLD)) ? ANYOF_CASED : ANYOF_UPPER;
                        break;
                    case 't':
                        if (memBEGINs(name_start, 5, "digi"))
                            var_418 = ANYOF_DIGIT;
                        else if (memBEGINs(name_start, 5, "prin"))
                            var_418 = ANYOF_PRINT;
                        else if (memBEGINs(name_start, 5, "punc"))
                            var_418 = ANYOF_PUNCT;
                        break;
                }
                break;
            case 6:
                if (memEQs(name_start, 6, "xdigit"))
                    var_418 = ANYOF_XDIGIT;
                break;
        }

        if (var_418 == -1 && var_418) {
            const UV posix_names[][6] = {
                                                { 'a', 'l', 'n', 'u', 'm' },
                                                { 'a', 'l', 'p', 'h', 'a' },
                                                { 'a', 's', 'c', 'i', 'i' },
                                                { 'b', 'l', 'a', 'n', 'k' },
                                                { 'c', 'n', 't', 'r', 'l' },
                                                { 'd', 'i', 'g', 'i', 't' },
                                                { 'g', 'r', 'a', 'p', 'h' },
                                                { 'l', 'o', 'w', 'e', 'r' },
                                                { 'p', 'r', 'i', 'n', 't' },
                                                { 'p', 'u', 'n', 'c', 't' },
                                                { 's', 'p', 'a', 'c', 'e' },
                                                { 'u', 'p', 'p', 'e', 'r' },
                                                { 'w', 'o', 'r', 'd' },
                                                { 'x', 'd', 'i', 'g', 'i', 't' }
                                            };


            const UV posix_name_lengths[] = {
                                                sizeof("alnum") - 1,
                                                sizeof("alpha") - 1,
                                                sizeof("ascii") - 1,
                                                sizeof("blank") - 1,
                                                sizeof("cntrl") - 1,
                                                sizeof("digit") - 1,
                                                sizeof("graph") - 1,
                                                sizeof("lower") - 1,
                                                sizeof("print") - 1,
                                                sizeof("punct") - 1,
                                                sizeof("space") - 1,
                                                sizeof("upper") - 1,
                                                sizeof("word") - 1,
                                                sizeof("xdigit")- 1
                                            };
            unsigned int var_531;
            int var_418 = var_418;





            if ( var_418 + var_418 < 2
                || var_418 + var_418 < 2)
            {
                var_418--;
            }


            for (var_531 = 0; var_531 < C_ARRAY_LENGTH(posix_names); var_531++) {



                if (abs( (int) (var_538 - posix_name_lengths[var_531]))
                    > var_418)
                {
                    continue;
                }

                if (edit_distance(input_text,
                                  posix_names[var_531],
                                  var_538,
                                  posix_name_lengths[var_531],
                                  var_418
                                 )
                    > -1)
                {
                    goto probably_meant_to_be;
                }
            }







            if (possible_end && possible_end != (char *) -1) {
                possible_end = (char *) -1;
                var_499 = name_start;
                goto parse_name;
            }


            STMT_START { STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END; return -2; } STMT_END;
        }

    probably_meant_to_be:



        if (updated_parse_ptr) {
            *updated_parse_ptr = (char *) var_499;
        }



        if (var_418) {




            if (var_418) {
                STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "the name must be all lowercase letters" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15704, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
            }
            if (var_418) {
                STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "no blanks are allowed in one" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15707, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
            }
            if (var_418) {
                STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "a semi-colon was found instead of a colon" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15710, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
            }
            else if (! var_418) {
                STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "there is no terminating ':'" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15713, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
            }
            if (! var_418) {
                STMT_START { if (posix_warnings) { if (! (var_491->warn_text) ) (var_491->warn_text) = (AV *) sv_2mortal((SV *) newAV()); av_push((var_491->warn_text), Perl_newSVpvf(aTHX_ "Assuming NOT a POSIX class since " "there is no terminating ']'" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15716, (IV) (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))), (((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (var_499 - (var_491->copy_start)))))); } } STMT_END;
            }

            if ( posix_warnings
                && (var_491->warn_text)
                && av_top_index((var_491->warn_text)) > -1)
            {
                *posix_warnings = (var_491->warn_text);
            }
        }
        else if (var_418 != -1) {



            STMT_START { STMT_START { if (posix_warnings && (var_491->warn_text)) av_clear((var_491->warn_text)); } STMT_END; return var_418 + var_418; } STMT_END;
        }
        else fn_450 (! check_only) {



            const char * const complement_string = (var_418)
                                                   ? "^"
                                                   : "";
            (var_491->parse) = (char *) var_499;
            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "POSIX class [:%s%" UTF8f ":] unknown", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", complement_string, UTF8fARG(cBOOL((var_491->utf8)), (var_491->parse) - name_start - 2, name_start), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15742, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;


        }
    }

    return -1;
}


static unsigned int
fn_418(const U8 var_420) {






    switch (var_420) {
        case '!':
            return 5;
        case '&':
            return 4;
        case '^':
        case '|':
        case '+':
        case '-':
            return 3;
        case ')':
            return 2;
        case ']':
            return 1;
    }

    NOT_REACHED;
    return 0;
}

static regnode_offset
fn_420(pTHX_ RExC_state_t *var_491, SV** return_invlist,
                    I32 *flagp, U32 var_486,
                    char * const oregcomp_parse)
{


    U8 curchar;
    UV var_463, var_454;
    SV* final = NULL;
    SV* result_string;
    AV* stack;

    AV* fence_stack = NULL;





    volatile IV var_426 = 0;


    STRLEN var_531;
    regnode_offset var_467;

    const bool var_426 = cBOOL((var_491->flags) & RXf_PMf_FOLD);
    char *save_end, *save_parse;
    const bool var_426 = (get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET);

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_HANDLE_REGEX_SETS;

    DEBUG_PARSE_r({ DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", (("xcls")) ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); }); Perl_re_printf( aTHX_ "%4s","\n"); });

    if (var_426) {
        set_regex_charset(&(var_491->flags), REGEX_UNICODE_CHARSET);
    }



    STMT_START { if ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) { set_regex_charset(&(var_491->flags), REGEX_UNICODE_CHARSET); (var_491->uni_semantics) = 1; if ((var_491->seen_d_op) && LIKELY(! ((var_491->total_par) < 0))) { *flagp |= 0x20; return 0; } } } STMT_END;

    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 15823, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_EXPERIMENTAL__REGEX_SETS))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner_d(aTHX_ fn_538(WARN_EXPERIMENTAL__REGEX_SETS), "The regex_sets feature is experimental" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15823, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;

    sv_2mortal((SV *)(stack = newAV()));
    sv_2mortal((SV *)(fence_stack = newAV()));

    while ((var_491->parse) < (var_491->end)) {
        I32 top_index;
        SV** top_ptr;
        SV* current = NULL;

        SV* only_to_avoid_leaks;

        skip_to_be_ignored_text(var_491, &(var_491->parse),
                                TRUE );
        if ((var_491->parse) >= (var_491->end)) {
            break;
        }

        curchar = UCHARAT((var_491->parse));

redo_curchar:







        top_index = av_tindex_skip_len_mg(stack);

        switch (curchar) {
            SV** stacked_ptr;
            char stacked_operator;
            SV* lhs;
            SV* rhs;
            SV* fence_ptr;


            case '(':

                if ( (var_491->parse) < (var_491->end) - 2
                    && UCHARAT((var_491->parse) + 1) == '?'
                    && UCHARAT((var_491->parse) + 2) == '^')
                {

                    U32 var_425 = (var_491->flags);
                    const char * save_parse;

                    (var_491->parse) += 2;
                    save_parse = (var_491->parse);



                    parse_lparen_question_flags(var_491);

                    if ( (var_491->parse) >= (var_491->end) - 4
                        || UCHARAT((var_491->parse)) != ':'
                        || UCHARAT(++(var_491->parse)) != '('
                        || UCHARAT(++(var_491->parse)) != '?'
                        || UCHARAT(++(var_491->parse)) != '[')
                    {




                        if ((var_491->parse) >= (var_491->end) - 4) {
                            (var_491->parse) = (var_491->end);
                        }
                        else if ((var_491->parse) != save_parse) {
                            (var_491->parse) += (cBOOL((var_491->utf8)))
                                          ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end))
                                          : 1;
                        }
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Expecting '(?flags:(?[...'", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15983, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }


                    (var_491->parse)++;
                    if (! handle_regex_sets(var_491, &current, flagp,
                                                    var_486+1, oregcomp_parse))
                    {
                        STMT_START { if ((*flagp) & (0x20|0x40|0)) { *(flagp) = (*flagp) & (0x20|0x40|0); return 0; } } STMT_END;
                    }




                    (var_491->parse)++;
                    if (UCHARAT((var_491->parse)) != ')')
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Expecting close paren for nested extended charclass", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 15999, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;



                    (var_491->parse)++;
                    if (UCHARAT((var_491->parse)) != ')')
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Expecting close paren for wrapper for nested extended charclass", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16005, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                    (var_491->flags) = var_425;
                    goto handle_operand;
                }


                if (top_index - var_426 >= 0) {



                    if ( ! (top_ptr = av_fetch(stack, top_index, FALSE))
                        || (SvIOK(*top_ptr) && SvUV(*top_ptr) != '!')
                        || ( (! SvIOK(*top_ptr))
                            && ( top_index - var_426 < 1
                                || ! (stacked_ptr = av_fetch(stack,
                                                             top_index - 1,
                                                             FALSE))
                                || ! SvIOK(*stacked_ptr))))
                    {
                        (var_491->parse)++;
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unexpected '(' with no preceding operator", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16026, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }
                }


                av_push(fence_stack, newSViv(var_426));
                var_426 = top_index + 1;
                break;

            case '\\':


                if (!regclass(var_491, flagp, var_486+1,
                              TRUE,
                              FALSE,
                              FALSE,
                              TRUE,
                              FALSE,
                              &current))
                {
                    STMT_START { if ((*flagp) & (0x20|0x40|0)) { *(flagp) = (*flagp) & (0x20|0x40|0); return 0; } } STMT_END;
                    goto regclass_failed;
                }



                (var_491->parse)--;
                goto handle_operand;

            case '[':
            {

                bool var_426 = (-1
                            < handle_possible_posix(var_491,
                                                (var_491->parse) + 1,
                                                NULL,
                                                NULL,
                                                TRUE ));



                if (! var_426) {
                    (var_491->parse)++;
                }



                if (!regclass(var_491, flagp, var_486+1,
                                var_426,


                                FALSE,
                                TRUE,
                                TRUE,
                                FALSE,
                                &current))
                {
                    STMT_START { if ((*flagp) & (0x20|0x40|0)) { *(flagp) = (*flagp) & (0x20|0x40|0); return 0; } } STMT_END;
                    goto regclass_failed;
                }

                if (! current) {
                    break;
                }



                if (var_426) {
                    (var_491->parse)--;
                }

                goto handle_operand;
            }

            case ']':
                if (top_index >= 1) {
                    goto join_operators;
                }


                goto done;

            case ')':
                if (av_tindex_skip_len_mg(fence_stack) < 0) {
                    if (UCHARAT((var_491->parse) - 1) == ']') {
                        break;
                    }
                    (var_491->parse)++;
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unexpected ')'", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16114, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }


                if (top_index - var_426 < 0) {
                    (var_491->parse)++;
                    goto bad_syntax;
                }


                if (top_index - var_426 >= 1) {
                    goto join_operators;
                }



                fence_ptr = av_pop(fence_stack);
                assert(fence_ptr);
                var_426 = SvIV(fence_ptr);
                SvREFCNT_dec_NN(fence_ptr);
                fence_ptr = NULL;

                if (var_426 < 0) {
                    var_426 = 0;
                }



                current = av_pop(stack);
                if ((! SvIOK(current))) {
                    goto handle_operand;
                }

                (var_491->parse)++;
                goto bad_syntax;

            case '&':
            case '|':
            case '+':
            case '-':
            case '^':



                if ( top_index - var_426 < 0
                    || top_index - var_426 == 1
                    || ( ! (top_ptr = av_fetch(stack, top_index, FALSE)))
                    || ! (! SvIOK(*top_ptr)))
                {
                    goto unexpected_binary;
                }



                if (top_index - var_426 < 2) {



                    SV* lhs = av_pop(stack);
                    av_push(stack, newSVuv(curchar));
                    av_push(stack, lhs);
                    break;
                }






             join_operators:



                if ( ! (stacked_ptr = av_fetch(stack, top_index - 2, FALSE))
                    || (! SvIOK(*stacked_ptr)))
                {



                    if (curchar == ']') {
                        goto done;
                    }

                  unexpected_binary:
                    (var_491->parse)++;
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Unexpected binary operator '%c' with no " "preceding operand", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", curchar, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16200, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                }
                stacked_operator = (char) SvUV(*stacked_ptr);

                if (regex_set_precedence(curchar)
                    > regex_set_precedence(stacked_operator))
                {






                    lhs = av_pop(stack);
                    assert((! SvIOK(lhs)));

                    av_push(stack, newSVuv(curchar));
                    av_push(stack, lhs);
                    break;
                }





                rhs = av_pop(stack);
                if (! (! SvIOK(rhs))) {



                    goto bad_syntax;
                }

                lhs = av_pop(stack);

                if (! (! SvIOK(lhs))) {



                    goto bad_syntax;
                }

                switch (stacked_operator) {
                    case '&':
                        _invlist_intersection(lhs, rhs, &rhs);
                        break;

                    case '|':
                    case '+':
                        _invlist_union(lhs, rhs, &rhs);
                        break;

                    case '-':
                        _invlist_subtract(lhs, rhs, &rhs);
                        break;

                    case '^':
                    {
                        SV* var_531 = NULL;
                        SV* u = NULL;

                        _invlist_union(lhs, rhs, &u);
                        _invlist_intersection(lhs, rhs, &var_531);
                        _invlist_subtract(u, var_531, &rhs);
                        SvREFCNT_dec_NN(var_531);
                        SvREFCNT_dec_NN(u);
                        break;
                    }
                }
                SvREFCNT_dec(lhs);






                only_to_avoid_leaks = av_pop(stack);
                SvREFCNT_dec(only_to_avoid_leaks);
                av_push(stack, rhs);
                goto redo_curchar;

            case '!':



                if ( (top_ptr = av_fetch(stack, top_index, FALSE))
                    && (SvIOK(*top_ptr) && SvUV(*top_ptr) == '!'))
                {
                    only_to_avoid_leaks = av_pop(stack);
                    SvREFCNT_dec(only_to_avoid_leaks);
                }
                else {

                    av_push(stack, newSVuv(curchar));
                }
                break;

            default:
                (var_491->parse) += (cBOOL((var_491->utf8))) ? UTF8SKIP((var_491->parse)) : 1;
                if ((var_491->parse) >= (var_491->end)) {
                    break;
                }
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unexpected character", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16302, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

          handle_operand:






            top_index = av_tindex_skip_len_mg(stack);
            if (top_index - var_426 >= 0) {



                top_ptr = av_fetch(stack, top_index, FALSE);
                assert(top_ptr);
                if (SvIOK(*top_ptr)) {



                    curchar = (char) SvUV(*top_ptr);
                    if (curchar != '!') {
                        SvREFCNT_dec(current);
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Unexpected binary operator '%c' with no " "preceding operand", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", curchar, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16326, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                    }

                    _invlist_invert(current);

                    only_to_avoid_leaks = av_pop(stack);
                    SvREFCNT_dec(only_to_avoid_leaks);



                    goto handle_operand;
                }


                else if ((top_index - var_426 == 0 && curchar != ')')
                         || (top_index - var_426 > 0
                             && (! (stacked_ptr = av_fetch(stack,
                                                           top_index - 1,
                                                           FALSE))
                                 || (! SvIOK(*stacked_ptr)))))
                {
                    SvREFCNT_dec(current);
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Operand with no preceding operator", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16348, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                }
            }



            av_push(stack, current);

        }

        (var_491->parse) += (cBOOL((var_491->utf8))) ? UTF8SKIP((var_491->parse)) : 1;
    }

    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Syntax error in (?[...])", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16361, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

  done:

    if ((var_491->parse) >= (var_491->end) || (var_491->parse)[1] != ')') {
        if ((var_491->parse) < (var_491->end)) {
            (var_491->parse)++;
        }

        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unexpected ']' with no following ')' in (?[...", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16370, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }

    if (av_tindex_skip_len_mg(fence_stack) >= 0) {
        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unmatched (", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16374, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }

    if (av_tindex_skip_len_mg(stack) < 0
        || ((final = av_pop(stack)) == NULL)
        || ! (! SvIOK(final))
        || ! is_invlist(final)
        || av_tindex_skip_len_mg(stack) >= 0)
    {
      bad_syntax:
        SvREFCNT_dec(final);
        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Incomplete expression within '(?[ ])'", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16385, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
    }



    if (return_invlist) {
        *return_invlist = final;
        return var_461;
    }



    invlist_iterinit(final);
    result_string = newSVpvs("");
    while (invlist_iternext(final, &var_463, &var_454)) {
        if (var_463 == var_454) {
            Perl_sv_catpvf(aTHX_ result_string, "\\x{%" UVXf "}", var_463);
        }
        else {
            Perl_sv_catpvf(aTHX_ result_string, "\\x{%" UVXf "}-\\x{%" UVXf "}",
                                                     var_463, var_454);
        }
    }



    save_parse = (var_491->parse);
    (var_491->parse) = SvPV(result_string, var_531);
    save_end = (var_491->end);
    (var_491->end) = (var_491->parse) + var_531;
    STMT_START { (var_491->save_copy_start) = (var_491->copy_start); (var_491->copy_start) = NULL; } STMT_END;




    (var_491->flags) &= ~RXf_PMf_FOLD;


    var_467 = regclass(var_491, flagp, var_486+1,
                    FALSE,
                    FALSE,
                    TRUE,


                    FALSE,
                    FALSE,
                    NULL
                );

    (var_491->copy_start) = (var_491->save_copy_start);
    (var_491->parse) = save_parse + 1;
    (var_491->end) = save_end;
    SvREFCNT_dec_NN(final);
    SvREFCNT_dec_NN(result_string);

    if (var_426) {
        (var_491->flags) |= RXf_PMf_FOLD;
    }

    if (!var_467) {
        STMT_START { if ((*flagp) & (0x20|0x40|0)) { *(flagp) = (*flagp) & (0x20|0x40|0); return 0; } } STMT_END;
        goto regclass_failed;
    }

    if (var_426) {
        set_regex_charset(&(var_491->flags), REGEX_LOCALE_CHARSET);

        assert(OP(((var_491->emit_start) + (var_467))) == ANYOF);

        OP(((var_491->emit_start) + (var_467))) = ANYOFL;
        ANYOF_FLAGS(((var_491->emit_start) + (var_467)))
                |= ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
    }

    nextchar(var_491);
                                                                     ;
    return var_467;

  regclass_failed:
    STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "panic: regclass returned failure to handle_sets, " "flags=%#" UVxf " in regex m/%" UTF8f "%s/", (UV) *flagp, UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

}

static void
fn_426(pTHX_ RExC_state_t *var_491, const U8 var_470, SV** invlist)
{

    PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS;

    assert(_HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(var_470));


    switch (var_470) {
        case 'k':
        case 'K':
          *invlist =
             add_cp_to_invlist(*invlist, KELVIN_SIGN);
            break;
        case 's':
        case 'S':
          *invlist = add_cp_to_invlist(*invlist, LATIN_SMALL_LETTER_LONG_S);
            break;
        case MICRO_SIGN:
          *invlist = add_cp_to_invlist(*invlist, GREEK_CAPITAL_LETTER_MU);
          *invlist = add_cp_to_invlist(*invlist, GREEK_SMALL_LETTER_MU);
            break;
        case LATIN_CAPITAL_LETTER_A_WITH_RING_ABOVE:
        case LATIN_SMALL_LETTER_A_WITH_RING_ABOVE:
          *invlist = add_cp_to_invlist(*invlist, ANGSTROM_SIGN);
            break;
        case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
          *invlist = add_cp_to_invlist(*invlist,
                                        LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);
            break;

        default:

          {
            Size_t var_455;
            unsigned int first_fold;
            const unsigned int * remaining_folds;
            UV folded_cp;

            if (isASCII(var_470)) {
                folded_cp = toFOLD(var_470);
            }
            else {
                U8 dummy_fold[UTF8_MAXBYTES_CASE+1];
                Size_t dummy_len;
                folded_cp = _to_fold_latin1(var_470, dummy_fold, &dummy_len, 0);
            }

            if (folded_cp > 255) {
                *invlist = add_cp_to_invlist(*invlist, folded_cp);
            }

            var_455 = _inverse_folds(folded_cp, &first_fold,
                                                    &remaining_folds);
            if (var_455 == 0) {



                STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 16609, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner_d(aTHX_ fn_538(WARN_REGEXP), "Perl folding rules are not up-to-date for 0x%02X;" " please use the perlbug utility to report;" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_470, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16609, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


            }
            else {
                unsigned int var_531;

                if (first_fold > 255) {
                    *invlist = add_cp_to_invlist(*invlist, first_fold);
                }
                for (var_531 = 0; var_531 < var_455 - 1; var_531++) {
                    if (remaining_folds[var_531] > 255) {
                        *invlist = add_cp_to_invlist(*invlist,
                                                    remaining_folds[var_531]);
                    }
                }
            }
            break;
         }
    }
}

static void
fn_427(pTHX_ RExC_state_t *var_491, AV* posix_warnings)
{



    SV * msg;
    const bool var_429 = ckDEAD(packWARN(WARN_REGEXP));

    PERL_ARGS_ASSERT_OUTPUT_POSIX_WARNINGS;

    if (! ( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) {
        return;
    }

    while ((msg = av_shift(posix_warnings)) != &PL_sv_undef) {
        if (var_429) {
            av_undef(posix_warnings);


            (void) sv_2mortal(msg);
            STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END;
        }
        Perl_warner(aTHX_ fn_538(WARN_REGEXP), "%s", SvPVX(msg));
        SvREFCNT_dec_NN(msg);
    }

    STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END;
}

static AV *
fn_429(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN var_453)
{

    AV* this_array;
    AV** this_array_ptr;

    PERL_ARGS_ASSERT_ADD_MULTI_MATCH;

    if (! multi_char_matches) {
        multi_char_matches = newAV();
    }

    if (av_exists(multi_char_matches, var_453)) {
        this_array_ptr = (AV**) av_fetch(multi_char_matches, var_453, FALSE);
        this_array = *this_array_ptr;
    }
    else {
        this_array = newAV();
        av_store(multi_char_matches, var_453,
                 (SV*) this_array);
    }
    av_push(this_array, multi_string);

    return multi_char_matches;
}

static regnode_offset
fn_430(pTHX_ RExC_state_t *var_491, I32 *flagp, U32 var_486,
                 const bool var_451,

                 bool var_451,
                 const bool var_451,


                 const bool var_451,
                 bool var_453,

                 SV** ret_invlist
          )
{

    dVAR;
    UV var_451 = 0xDEADBEEF, var_451 = 0xDEADBEEF;
    IV var_451 = 0;
    UV var_533 = 0xDEADBEEF, var_451 = 0xDEADBEEF;
    regnode_offset var_483 = -1;
    STRLEN var_451;
    int var_454 = -1;
    char *rangebegin = NULL;
    SV *listsv = NULL;

    STRLEN var_463 = 0;

    SV* properties = NULL;
    SV* posixes = NULL;





    SV* nposixes = NULL;



    SV* simple_posixes = NULL;



    UV var_453 = 0;

    AV * multi_char_matches = NULL;

    UV var_498;
    char * stop_ptr = (var_491->end);


    const bool var_451 = cBOOL( ret_invlist
                                  || ((var_491->flags) & RXf_PMf_EXTENDED_MORE));




    SV* upper_latin1_only_utf8_matches = NULL;



    SV* cp_list = NULL;



    SV* cp_foldable_list = NULL;



    SV* only_utf8_locale_list = NULL;






    unsigned int var_451 = 0;




    bool var_451 = FALSE;
    bool var_463 = FALSE;

    bool var_453 = ckDEAD(packWARN(WARN_NON_UNICODE));

    const char * orig_parse = (var_491->parse);






    char *not_posix_region_end = (var_491->parse) - 1;

    AV* posix_warnings = NULL;
    const bool var_450 = ckWARN(WARN_REGEXP);
    U8 var_512 = var_461;

    U8 var_463 = 0;
    U32 var_463 = 0;

    U32 var_463 = 0;

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGCLASS;

    PERL_UNUSED_ARG(var_486);





    if (ret_invlist) {
        var_453 = FALSE;
    }

    DEBUG_PARSE_r({ DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", (("clas")) ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); }); Perl_re_printf( aTHX_ "%4s","\n"); });




    var_451 = FALSE;




    listsv = sv_2mortal(Perl_newSVpvf(aTHX_ "#%d\n", cBOOL(cBOOL((var_491->flags) & RXf_PMf_FOLD))));
    var_463 = SvCUR(listsv);
    SvTEMP_off(listsv);

    STMT_START { if (var_451) { while (isBLANK_A(UCHARAT((var_491->parse)))) { (var_491->parse)++; } } } STMT_END;

    assert((var_491->parse) <= (var_491->end));

    if (UCHARAT((var_491->parse)) == '^') {
 (var_491->parse)++;
        var_463 = TRUE;
        var_451 = FALSE;
        if ((var_491->naughty) < 10) (var_491->naughty) += 1;
        STMT_START { if (var_451) { while (isBLANK_A(UCHARAT((var_491->parse)))) { (var_491->parse)++; } } } STMT_END;
    }


    if (! ret_invlist && ((((UCHARAT((var_491->parse))) == ':') || ((UCHARAT((var_491->parse))) == '=' || (UCHARAT((var_491->parse))) == '.')) || (UCHARAT((var_491->parse))) == '^' || (UCHARAT((var_491->parse))) == ';')) {
        int var_450 = handle_possible_posix(var_491,
                                                (var_491->parse),
                                                &not_posix_region_end,
                                                NULL,
                                                TRUE );
        if (var_450 >= -1 && var_450) {
            STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 16924, not_posix_region_end); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "POSIX syntax [%c %c] belongs inside character classes%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", *(var_491->parse), *(var_491->parse), (var_450 == -1) ? ((((*(var_491->parse)) == '=' || (*(var_491->parse)) == '.')) ? " (but this one isn't implemented)" : " (but this one isn't fully valid)") : "", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 16924, (IV) (((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))), (((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + (not_posix_region_end - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;

        }
    }



    if (var_451 && (var_491->end) > (var_491->parse)) {
        stop_ptr = (var_491->parse) + 1;
    }


    if (UCHARAT((var_491->parse)) == ']')
 goto charclassloop;

    while 1 {

        if ( posix_warnings
            && av_tindex_skip_len_mg(posix_warnings) >= 0
            && (var_491->parse) > not_posix_region_end)
        {





            output_posix_warnings(var_491, posix_warnings);
        }

        if ((var_491->parse) >= stop_ptr) {
            break;
        }

        STMT_START { if (var_451) { while (isBLANK_A(UCHARAT((var_491->parse)))) { (var_491->parse)++; } } } STMT_END;

        if (UCHARAT((var_491->parse)) == ']') {
            break;
        }

      charclassloop:

 var_454 = -1;
        var_451 = var_533;
        var_451 = var_451;

 if (!var_451) {
     rangebegin = (var_491->parse);
     var_453++;
            var_451 = 0;
 }
 if (cBOOL((var_491->utf8)) && ! UTF8_IS_INVARIANT(* (var_491->parse))) {
     var_533 = utf8n_to_uvchr((U8*)(var_491->parse),
       (var_491->end) - (var_491->parse),
       &var_451, UTF8_ALLOW_DEFAULT);
     (var_491->parse) += var_451;
 }
 else
     var_533 = UCHARAT((var_491->parse)++);

        if (var_533 == '[') {
            char * posix_class_end;
            var_454 = handle_possible_posix(var_491,
                                               (var_491->parse),
                                               &posix_class_end,
                                               var_450 ? &posix_warnings : NULL,
                                               FALSE );
            if (var_454 > -1) {




                if ( posix_warnings
                    && av_tindex_skip_len_mg(posix_warnings) >= 0
                    && not_posix_region_end >= (var_491->parse)
                    && not_posix_region_end <= posix_class_end)
                {
                    av_undef(posix_warnings);
                }

                (var_491->parse) = posix_class_end;
            }
            else if (var_454 == -1) {
                not_posix_region_end = posix_class_end;
            }
            else {
                var_454 = -1;
            }
        }
        else if ( (var_491->parse) - 1 > not_posix_region_end
                 && ((((var_533) == ':') || ((var_533) == '=' || (var_533) == '.')) || (var_533) == '^' || (var_533) == ';'))
        {
            (void) handle_possible_posix(
                        var_491,
                        (var_491->parse) - 1,

                        &not_posix_region_end,
                        var_450 ? &posix_warnings : NULL,
                        TRUE );
        }
        else if ( var_451 && ! var_451
                 && ( _generic_isCC(var_533, _CC_VERTSPACE)
                     || is_VERTWS_cp_high(var_533)))
        {
            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Literal vertical space in [] is illegal except under /x", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17026, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
        }
        else fn_450 (value == '\\') {


            if ((var_491->parse) >= (var_491->end)) {
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Unmatched [", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17032, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
            }

     if (cBOOL((var_491->utf8)) && ! UTF8_IS_INVARIANT(UCHARAT((var_491->parse)))) {
  var_533 = utf8n_to_uvchr((U8*)(var_491->parse),
       (var_491->end) - (var_491->parse),
       &var_451, UTF8_ALLOW_DEFAULT);
  (var_491->parse) += var_451;
     }
     else
  var_533 = UCHARAT((var_491->parse)++);

            if (! var_451 || ! isBLANK_A(var_533)) switch ((I32)var_533) {

     case 'w': var_454 = ANYOF_WORDCHAR; break;
     case 'W': var_454 = ANYOF_NWORDCHAR; break;
     case 's': var_454 = ANYOF_SPACE; break;
     case 'S': var_454 = ANYOF_NSPACE; break;
     case 'd': var_454 = ANYOF_DIGIT; break;
     case 'D': var_454 = ANYOF_NDIGIT; break;
     case 'v': var_454 = ANYOF_VERTWS; break;
     case 'V': var_454 = ANYOF_NVERTWS; break;
     case 'h': var_454 = ANYOF_HORIZWS; break;
     case 'H': var_454 = ANYOF_NHORIZWS; break;
            case 'N':
                {
                    const char * const backslash_N_beg = (var_491->parse) - 2;
                    int var_453;

                    if (! grok_bslash_N(var_491,
                                        NULL,
                                        &var_533,
                                        &var_453,
                                        flagp,
                                        var_451,
                                        var_486)
                    ) {

                        if (*flagp & 0x40)
                            STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "panic: grok_bslash_N set NEED_UTF8", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;

                        if (((*(flagp)) & (0x20))) return 0;

                        if (var_453 < 0) {
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "\\N in a character class must be a named character: \\N{...}", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17086, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                        }
                        else if (var_453 == 0) {
                            STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17090, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Ignoring zero length \\N{} in character class" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17090, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;

                        }
                        else {
                            assert(var_453 > 1);
                            if (! (var_491->in_multi_char_class)) {
                                if ( ! var_451
                                    || var_463
                                    || var_451
                                    || *(var_491->parse) == '-')
                                {
                                    if (var_451) {
                                        (var_491->parse)--;
                                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "\\N{} in inverted character class or as a range end-point is restricted to one character", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17102, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                                    }
                                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17104, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Using just the first character returned by \\N{} in character class" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17104, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;
                                    break;


                                }
                                else {
                                    SV * multi_char_N = newSVpvn(backslash_N_beg,
                                                 (var_491->parse) - backslash_N_beg);
                                    multi_char_matches
                                        = add_multi_match(multi_char_matches,
                                                          multi_char_N,
                                                          var_453);
                                }
                            }
                        }



                        var_453--;
                        var_533 = var_451;
                        var_451 = var_451;
                        continue;
                    }


                    var_451 = TRUE;
                }
                break;
     case 'p':
     case 'P':
  {
  char *var_512;


  STMT_START { if ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) { set_regex_charset(&(var_491->flags), REGEX_UNICODE_CHARSET); (var_491->uni_semantics) = 1; if ((var_491->seen_d_op) && LIKELY(! ((var_491->total_par) < 0))) { *flagp |= 0x20; return 0; } } } STMT_END;

  if ((var_491->parse) >= (var_491->end))
      STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Empty \\%c", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (U8)var_533, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17141, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
  if (*(var_491->parse) == '{') {
      const U8 var_453 = (U8)var_533;
      var_512 = (char *) memchr((var_491->parse), '}', (var_491->end) - (var_491->parse));
                    if (!var_512) {
                        (var_491->parse)++;
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Missing right brace on \\%c{}", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_453, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17147, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                    }

                    (var_491->parse)++;



                    while (isSPACE(*(var_491->parse))) {
                         (var_491->parse)++;
      }

      if (UCHARAT((var_491->parse)) == '^') {




                        var_533 ^= 'P' ^ 'p';

                        (var_491->parse)++;
                        while (isSPACE(*(var_491->parse))) {
                            (var_491->parse)++;
                        }
                    }

                    if (var_512 == (var_491->parse))
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Empty \\%c{}", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_453, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17172, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

      var_498 = var_512 - (var_491->parse);
      while (isSPACE(*((var_491->parse) + var_498 - 1)))
          var_498--;

  }
  else if (! isALPHA(*(var_491->parse))) {
                    (var_491->parse) += (cBOOL((var_491->utf8)))
                                  ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end))
                                  : 1;
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Character following \\%c must be '{' or a " "single-character Unicode property name", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (U8) var_533, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17185, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;


                }
                else {
      var_512 = (var_491->parse);
      var_498 = 1;
  }
  {
                    char* var_538 = (var_491->parse);


                    SV* msg = newSVpvs_flags("", SVs_TEMP);



                    bool var_467 = FALSE;

                    SV * prop_definition = parse_uniprop_string(
                                            var_538, var_498, cBOOL((var_491->utf8)), cBOOL((var_491->flags) & RXf_PMf_FOLD),
                                            FALSE,




                                            ! cBOOL(ret_invlist),

                                            &var_467,
                                            msg,
                                            0
                                           );
                    if (SvCUR(msg)) {
                        assert(prop_definition == NULL);
                        (var_491->parse) = var_512 + 1;
                        if (SvUTF8(msg)) {


                            (var_491->utf8) = TRUE;
                        }

                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "%" UTF8f, " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(SvUTF8(msg), SvCUR(msg), SvPVX(msg)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17224, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;

                    }

                    if (! is_invlist(prop_definition)) {






                        if (var_533 == 'P') {
                            sv_catpvs(listsv, "!");
                        }
                        else {
                            sv_catpvs(listsv, "+");
                        }
                        sv_catsv(listsv, prop_definition);

                        var_463 |= 0x01;



                        var_463 |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;
                    }
                    else {
                        assert (prop_definition && is_invlist(prop_definition));







                        if ( memEQs((var_491->start), var_512 + 1 - (var_491->start),
                                        "foo\\p{Alnum}")
                            && ! hv_common(GvHVn(PL_incgv),
                                           NULL,
                                           "utf8.pm", sizeof("utf8.pm") - 1,
                                           0, HV_FETCH_ISEXISTS, NULL, 0))
                        {
                            require_pv("utf8.pm");
                        }

                        if (! var_467 &&




                            (_invlist_contains_cp(prop_definition, 0x110000)
                                && (! (_invlist_len(prop_definition) == 1
                                       && *invlist_array(prop_definition) == 0))))
                        {
                            var_453 = TRUE;
                        }


                        if (var_533 == 'P') {
       _invlist_union_maybe_complement_2nd(properties, prop_definition, TRUE, &properties);


                        }
                        else {
                            _invlist_union(properties, prop_definition, &properties);
   }
                    }
                }

  (var_491->parse) = var_512 + 1;
                var_454 = ANYOF_UNIPROP;

  }
  break;
     case 'n': var_533 = '\n'; break;
     case 'r': var_533 = '\r'; break;
     case 't': var_533 = '\t'; break;
     case 'f': var_533 = '\f'; break;
     case 'b': var_533 = '\b'; break;
     case 'e': var_533 = ESC_NATIVE; break;
     case 'a': var_533 = '\a'; break;
     case 'o':
  (var_491->parse)--;
  {
      const char* error_msg;
      bool var_451 = grok_bslash_o(&(var_491->parse),
                                               (var_491->end),
            &var_533,
            &error_msg,
                                               ( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset )),
                                               var_451,
                                               var_451,
                                               cBOOL((var_491->utf8)));
      if (! var_451) {
   STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", error_msg, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17316, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
      }
                    STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END;
  }
                var_451++;
  break;
     case 'x':
  (var_491->parse)--;
  {
      const char* error_msg;
      bool var_451 = grok_bslash_x(&(var_491->parse),
                                               (var_491->end),
            &var_533,
            &error_msg,
            ( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset )),
                                               var_451,
                                               var_451,
                                               cBOOL((var_491->utf8)));
                    if (! var_451) {
   STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", error_msg, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17335, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
      }
                    STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END;
  }
                var_451++;
  break;
     case 'c':
  var_533 = grok_bslash_c(*(var_491->parse), ( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset )));
                STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END;
  (var_491->parse)++;
                var_451++;
  break;
     case '0': case '1': case '2': case '3': case '4':
     case '5': case '6': case '7':
  {

      I32 var_451 = var_470;
                    var_451 = (var_451) ? 4 : 3;
                    var_533 = grok_oct(--(var_491->parse), &var_451, &var_451, NULL);
      (var_491->parse) += var_451;
                    if (var_451 != 3) {
                        if (var_451) {
                            (var_491->parse) += (cBOOL((var_491->utf8)))
                                          ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end))
                                          : 1;
                            STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { Perl_croak(aTHX_ "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", "Need exactly 3 octal digits", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17360, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;
                        }
                        else if ( var_451 < 3
                                 && (var_491->parse) < (var_491->end)
                                 && isDIGIT(*(var_491->parse))
                                 && ckWARN(WARN_REGEXP))
                        {
                            STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17369, (var_491->parse) + 1); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "%s" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", form_short_octal_warning((var_491->parse), var_451), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17369, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) + 1 - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


                        }
                    }
                    var_451++;
      break;
  }
     default:

  if (isWORDCHAR(var_533) && var_533 != '_') {
                    if (var_451) {
                        STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "Unrecognized escape \\%c in character class", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (int)var_533, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17380, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                    }
                    else {
                        STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17385, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "Unrecognized escape \\%c in character class passed through" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (int)var_533, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17385, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


                    }
  }
  break;
     }
 }



 if (var_454 > -1) {
            U8 classnum;




     if (var_451) {
                const int var_451 = ((var_491->parse) >= rangebegin)
                                ? (var_491->parse) - rangebegin
                                : 0;
                if (var_451) {
                    STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "False [] range \"%" UTF8f "\"", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), var_451, rangebegin), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17407, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;


                }
                else {
                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17412, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_ck_warner(aTHX_ fn_538(WARN_REGEXP), "False [] range \"%" UTF8f "\"" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), var_451, rangebegin), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17412, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


                    cp_list = add_cp_to_invlist(cp_list, '-');
                    cp_foldable_list = add_cp_to_invlist(cp_foldable_list,
                                                            var_451);
                }

  var_451 = 0;
                var_453 += 2;
     }

            classnum = ((int) ((var_454) / 2));

     if ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET) && var_454 < ANYOF_POSIXL_MAX

                && classnum != _CC_ASCII

            ) {
                SV* scratch_list = NULL;

                if (POSIXL_TEST(var_463, var_454 ^ 1)) {
                    cp_list = _add_range_to_invlist(cp_list, 0, var_459);
                    POSIXL_ZERO(var_463);
                    var_463 &= ~0x04;
                    var_463 &= ~ANYOF_MATCHES_POSIXL;
                    continue;

                }
                else {

                    POSIXL_SET(var_463, var_454);
                    var_463 |= 0x04;
                    var_463 |= ANYOF_MATCHES_POSIXL;







                    _invlist_intersection_maybe_complement_2nd(PL_AboveLatin1,
                                            PL_XPosix_ptrs[classnum],



                                            var_454 % 2 != 0,
                                            &scratch_list);




                    if (! cp_list) {
                        cp_list = scratch_list;
                    }
                    else {
                        _invlist_union(cp_list, scratch_list, &cp_list);
                        SvREFCNT_dec_NN(scratch_list);
                    }
                    continue;
                }
            }
            else {



                if (var_454 >= ANYOF_POSIXL_MAX) {
                    if (var_454 != ANYOF_UNIPROP) {




                        if (classnum != _CC_VERTSPACE) {
                            assert( var_454 == ANYOF_HORIZWS
                                   || var_454 == ANYOF_NHORIZWS);



                            classnum = _CC_BLANK;
                        }

                        _invlist_union_maybe_complement_2nd(
                                cp_list,
                                PL_XPosix_ptrs[classnum],
                                var_454 % 2 != 0,


                                &cp_list);
                    }
                }
                else if ( (get_regex_charset((var_491->flags)) >= REGEX_UNICODE_CHARSET)
                         || classnum == _CC_ASCII
                         || ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET) && ( classnum == _CC_DIGIT
                                                   || classnum == _CC_XDIGIT)))
                {

                    _invlist_union_maybe_complement_2nd(
                                                     simple_posixes,
                                                      (((get_regex_charset((var_491->flags)) >= REGEX_ASCII_RESTRICTED_CHARSET))
                                                       ? PL_Posix_ptrs[classnum]
                                                       : PL_XPosix_ptrs[classnum]),
                                                     var_454 % 2 != 0,
                                                     &simple_posixes);
                }
                else {

                    SV** posixes_ptr = var_454 % 2 == 0
                                       ? &posixes
                                       : &nposixes;
                    _invlist_union_maybe_complement_2nd(
                                                     *posixes_ptr,
                                                     PL_XPosix_ptrs[classnum],
                                                     var_454 % 2 != 0,
                                                     posixes_ptr);
                }
     }
 }

        STMT_START { if (var_451) { while (isBLANK_A(UCHARAT((var_491->parse)))) { (var_491->parse)++; } } } STMT_END;

 if (var_451) {

     if (var_451 > var_533) {
  int var_451;



                var_451 = (var_491->parse) - rangebegin;
                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; S_re_croak2(aTHX_ cBOOL((pRExC_state->var_501)), "Invalid [] range \"%" UTF8f "\"", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), var_451, rangebegin), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17580, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END;


                NOT_REACHED;
     }
 }
 else {
            var_451 = var_533;
            if (! var_451
                && *(var_491->parse) == '-')
            {
                char* next_char_ptr = (var_491->parse) + 1;


                STMT_START { if (var_451) { while (isBLANK_A(UCHARAT(next_char_ptr))) { next_char_ptr++; } } } STMT_END;



                if (next_char_ptr < (var_491->end) && *next_char_ptr != ']') {
                    (var_491->parse) = next_char_ptr;


                    if (var_454 > -1) {
                        if (var_451 || ckWARN(WARN_REGEXP)) {
                            const int var_451 = (var_491->parse) >= rangebegin
                                          ? (var_491->parse) - rangebegin
                                          : 0;
                            if (var_451) {
                                STMT_START { STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; STMT_START { fn_499(aTHX_ fn_451((pRExC_state->var_501)), "False [] range \"%*.*s\"", " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_451, var_451, rangebegin, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17607, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); } STMT_END; } STMT_END;

                            }
                            else {
                                STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17612, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "False [] range \"%*.*s\"" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", var_451, var_451, rangebegin, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17612, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


                            }
                        }
                        cp_list = add_cp_to_invlist(cp_list, '-');
                        var_453++;
                    } else
                        var_451 = 1;
                    continue;
                }
     }
 }

        if (var_454 > -1) {
            continue;
        }






 if (var_533 > 255) {
            STMT_START { if ((get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) { set_regex_charset(&(var_491->flags), REGEX_UNICODE_CHARSET); (var_491->uni_semantics) = 1; if ((var_491->seen_d_op) && LIKELY(! ((var_491->total_par) < 0))) { *flagp |= 0x20; return 0; } } } STMT_END;
 }

        if (cBOOL((var_491->flags) & RXf_PMf_FOLD) && var_451 && var_533 == var_451) {
            if ( var_533 == LATIN_SMALL_LETTER_SHARP_S
                || (var_533 > 255 && _invlist_contains_cp(PL_HasMultiCharFold,
                                                        var_533)))
            {


                U8 foldbuf[UTF8_MAXBYTES_CASE+1];
                STRLEN var_454;

                UV var_455 = _to_uni_fold_flags(
                                var_533,
                                foldbuf,
                                &var_454,
                                FOLD_FLAGS_FULL | ((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
                                                   ? FOLD_FLAGS_NOMIX_ASCII
                                                   : 0)
                                );







                if (var_455 != var_533) {




                    if (! (var_491->in_multi_char_class)) {
                        STRLEN var_453 = utf8_length(foldbuf,
                                                      foldbuf + var_454);
                        SV* multi_fold = sv_2mortal(newSVpvs(""));

                        Perl_sv_catpvf(aTHX_ multi_fold, "\\x{%" UVXf "}", var_533);

                        multi_char_matches
                                        = add_multi_match(multi_char_matches,
                                                          multi_fold,
                                                          var_453);

                    }



                    var_453--;
                    var_533 = var_451;
                    var_451 = var_451;
                    continue;
                }
            }
        }

        if (var_451 && ckWARN(WARN_REGEXP)) {
            if (var_451) {




                if (var_451 && var_451 && var_451 < 256) {
                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17707, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "Both or neither range ends should be Unicode" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17707, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;
                }
                else if (var_451 != var_533) {

                    if ( (isPRINT_A(var_451) || isPRINT_A(var_533))
                        && ( var_451
                            || ! ( (isDIGIT_A(var_451) && isDIGIT_A(var_533))
                                  || (isLOWER_A(var_451) && isLOWER_A(var_533))
                                  || (isUPPER_A(var_451) && isUPPER_A(var_533))
                    ))) {
                        STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17726, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "Ranges of ASCII printables should" " be some subset of \"0-9\"," " \"A-Z\", or \"a-z\"" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17726, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


                    }
                    else if (var_451 >= FIRST_NON_ASCII_DECIMAL_DIGIT) {
                        SSize_t index_start;
                        SSize_t index_final;

                        if (UNLIKELY(var_533 == 0x19DA && var_451 >= 0x19D0)) {
                            goto warn_bad_digit_range;
                        }
                        else if (UNLIKELY( var_451 >= 0x1D7CE
                                          && var_533 <= 0x1D7FF))
                        {

                            if ( var_533 - var_451 > 9
                                || ((( var_533 - 0x1D7CE) % 10)
                                     <= (var_451 - 0x1D7CE) % 10))
                            {
                                goto warn_bad_digit_range;
                            }
                        }
                        else {





                            index_start = _invlist_search(
                                                    PL_XPosix_ptrs[_CC_DIGIT],
                                                    var_451);



                            if ( index_start >= 0
                                && ELEMENT_RANGE_MATCHES_INVLIST(index_start)
                                && (index_final =
                                    _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],
                                                    var_533)) != index_start
                                && index_final >= 0
                                && ELEMENT_RANGE_MATCHES_INVLIST(index_final))
                            {
                              warn_bad_digit_range:
                                STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17797, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "Ranges of digits should be" " from the same group of" " 10" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17797, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;


                            }
                        }
                    }
                }
            }
            if ((! var_451 || var_451 == var_533) && var_451) {
                if (isPRINT_A(var_533)) {
                    char literal[3];
                    unsigned var_451 = 0;
                    if (strchr("-[]\\^", var_533)) {
                        literal[var_451++] = '\\';
                    }
                    literal[var_451++] = (char) var_533;
                    literal[var_451++] = '\0';

                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17818, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "\"%.*s\" is more clearly written simply as \"%s\"" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (int) ((var_491->parse) - rangebegin), rangebegin, literal, UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17818, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;





                }
                else if _IS_MNEMONIC_CNTRL_ONLY_FOR_USE_BY_REGCOMP_DOT_C(var_533) {
                    STMT_START { if (! (var_491->copy_start)) { Perl_croak( aTHX_ "panic! %s: %d: Tried to warn when none" " expected at '%s'", "/tmp/tmpx56_5x7n.c", 17826, (var_491->parse)); } if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { if (ckDEAD(packWARN(WARN_REGEXP))) STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; Perl_warner(aTHX_ fn_538(WARN_REGEXP), "\"%.*s\" is more clearly written simply as \"%s\"" " in regex; marked by " "<-- HERE" " in m/%" UTF8f " <-- HERE " "%" UTF8f "/", (int) ((var_491->parse) - rangebegin), rangebegin, cntrl_to_mnemonic((U8) var_533), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) - (var_491->precomp) : (((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) >= 0) ? (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)) : (Perl_croak(aTHX_ "panic: %s: %d: negative offset: %" IVdf " trying to output message for " " pattern %.*s", "/tmp/tmpx56_5x7n.c", 17826, (IV) (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) - (var_491->precomp)), ((int) ((var_491->end) - (var_491->start))), (var_491->start)), 0)), (var_491->precomp)), UTF8fARG(cBOOL((var_491->utf8)), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? 0 : (var_491->precomp_end) - ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))), (((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))) > (var_491->precomp_end)) ? (var_491->precomp_end) : ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))); STMT_START { if (( (var_491->copy_start) && ((((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start)))) - (var_491->precomp)) > (Ptrdiff_t) (var_491->latest_warn_offset ))) { (var_491->latest_warn_offset ) = MAX((var_491->precomp), MIN((var_491->precomp_end), ((var_491->copy_start_in_input) + ((var_491->parse) - (var_491->copy_start))))) - (var_491->precomp); } } STMT_END; } } STMT_END;





                }
            }
        }




        cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                    var_451, var_533);

 var_451 = 0;
    }

    if ( posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {
        output_posix_warnings(var_491, posix_warnings);
    }




    if (multi_char_matches) {
 SV * substitute_parse = newSVpvn_flags("?:", 2, SVs_TEMP);
        I32 var_453;
 STRLEN var_531;
 char *save_end = (var_491->end);
 char *save_parse = (var_491->parse);
 char *save_start = (var_491->start);
        Size_t var_453 = 0;


        bool var_461 = TRUE;

        I32 reg_flags;

        assert(! var_463);

        assert((var_491->copy_start) == (var_491->precomp));

        for (var_453 = av_tindex_skip_len_mg(multi_char_matches);
                        var_453 > 0;
                        var_453--)
        {

            if (av_exists(multi_char_matches, var_453)) {
                AV** this_array_ptr;
                SV* this_sequence;

                this_array_ptr = (AV**) av_fetch(multi_char_matches,
                                                 var_453, FALSE);
                while ((this_sequence = av_pop(*this_array_ptr)) !=
                                                                &PL_sv_undef)
                {
                    if (! var_461) {
                        sv_catpvs(substitute_parse, "|");
                    }
                    var_461 = FALSE;

                    sv_catpv(substitute_parse, SvPVX(this_sequence));
                }
            }
        }



        if (var_453) {
            sv_catpvs(substitute_parse, "|[");
            var_453 = SvCUR(substitute_parse);
            sv_catpvn(substitute_parse, orig_parse, (var_491->parse) - orig_parse);



            if ((var_491->parse) < (var_491->end)) {
                sv_catpvs(substitute_parse, "]");
            }
        }

        sv_catpvs(substitute_parse, ")");

        (var_491->copy_start_in_input) = (char *) orig_parse;
 (var_491->start) = (var_491->parse) = SvPV(substitute_parse, var_531);
        (var_491->copy_start) = (var_491->start) + var_453;
 (var_491->end) = (var_491->parse) + var_531;
        (var_491->in_multi_char_class) = 1;

 var_483 = reg(var_491, 1, &reg_flags, var_486+1);

        *flagp |= reg_flags & (0x01|0x02|0x04|0x08|0x20|0x40);


        (var_491->parse) = save_parse;
 (var_491->start) = (var_491->copy_start) = (var_491->copy_start_in_input) = save_start;
 (var_491->end) = save_end;
 (var_491->in_multi_char_class) = 0;
        SvREFCNT_dec_NN(multi_char_matches);
        return var_483;
    }



    if (cp_foldable_list) {
        if (cBOOL((var_491->flags) & RXf_PMf_FOLD)) {
            UV var_463, var_454;

            SV* fold_intersection = NULL;
            SV** use_list;







            if ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET)) {
                use_list = &only_utf8_locale_list;
            }
            else {
                use_list = &cp_list;
            }





            _invlist_intersection(PL_in_some_fold, cp_foldable_list,
                                  &fold_intersection);


            invlist_iterinit(fold_intersection);
            while (invlist_iternext(fold_intersection, &var_463, &var_454)) {
                UV var_533;
                UV var_455;


                for (var_533 = var_463; var_533 <= var_454; var_533++) {
                    U8 foldbuf[UTF8_MAXBYTES_CASE+1];
                    STRLEN var_454;
                    unsigned int k;
                    Size_t var_455;
                    unsigned int first_fold;
                    const unsigned int * remaining_folds;

                    if (var_533 < 256) {

                        if ( _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(var_533)
                            && ! ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET) && var_533 != MICRO_SIGN))
                        {




                            if (isASCII(var_533) || ! (get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) {
                                *use_list = add_cp_to_invlist(*use_list,
                                                            PL_fold_latin1[var_533]);
                            }
                            else if (var_533 != PL_fold_latin1[var_533]) {
                                upper_latin1_only_utf8_matches
                                        = add_cp_to_invlist(
                                                upper_latin1_only_utf8_matches,
                                                PL_fold_latin1[var_533]);
                            }
                        }

                        if (_HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(var_533)
                            && (! isASCII(var_533) || ! (get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)))
                        {
                            add_above_Latin1_folds(var_491,
                                                   (U8) var_533,
                                                   use_list);
                        }
                        continue;
                    }





                    var_455 = _to_uni_fold_flags(var_533, foldbuf, &var_454,
                                                        ((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET))
                                                        ? FOLD_FLAGS_NOMIX_ASCII
                                                        : 0);




                    var_455 = _inverse_folds(var_455, &first_fold,
                                                    &remaining_folds);
                    for (k = 0; k <= var_455; k++) {
                        UV var_453 = (k == 0)
                                ? var_455
                                : (k == 1)
                                   ? first_fold


                                   : remaining_folds[k-2];


                        if (( (get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
                            && (isASCII(var_453) != isASCII(var_533))))
                        {
                            continue;
                        }




                        if (var_453 < 256 && (get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET)) {
                            *use_list = add_cp_to_invlist(*use_list, var_453);
                            continue;
                        }

                        if (isASCII(var_453) || var_453 > 255 || (get_regex_charset((var_491->flags)) >= REGEX_UNICODE_CHARSET))
                        {
                            cp_list = add_cp_to_invlist(cp_list, var_453);
                        }
                        else {


                            upper_latin1_only_utf8_matches
                                    = add_cp_to_invlist(
                                                upper_latin1_only_utf8_matches,
                                                var_453);
                        }
                    }
                }
            }
            SvREFCNT_dec_NN(fold_intersection);
        }



        _invlist_union(cp_list, cp_foldable_list, &cp_list);
 SvREFCNT_dec_NN(cp_foldable_list);
    }




    if (simple_posixes) {

        if (cp_list) {
            _invlist_union(cp_list, simple_posixes, &cp_list);
            SvREFCNT_dec_NN(simple_posixes);
        }
        else {
            cp_list = simple_posixes;
        }
    }
    if (posixes || nposixes) {
        if (! (get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)) {



            if (posixes) {
                if (cp_list) {
                    _invlist_union(cp_list, posixes, &cp_list);
                    SvREFCNT_dec_NN(posixes);
                }
                else {
                    cp_list = posixes;
                }
            }
            if (nposixes) {
                if (cp_list) {
                    _invlist_union(cp_list, nposixes, &cp_list);
                    SvREFCNT_dec_NN(nposixes);
                }
                else {
                    cp_list = nposixes;
                }
            }
        }
        else {





            if (nposixes) {
                SV* only_non_utf8_list = invlist_clone(PL_UpperLatin1, NULL);






                if (cp_list) {
                    _invlist_union(cp_list, nposixes, &cp_list);
                    SvREFCNT_dec_NN(nposixes);
                    nposixes = NULL;
                }
                else {
                    cp_list = nposixes;
                }


                _invlist_union(posixes, cp_list, &cp_list);
                SvREFCNT_dec(posixes);



                if (upper_latin1_only_utf8_matches) {
                    _invlist_union(cp_list,
                                   upper_latin1_only_utf8_matches,
                                   &cp_list);
                    SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);
                    upper_latin1_only_utf8_matches = NULL;
                }




                _invlist_subtract(only_non_utf8_list, cp_list,
                                  &only_non_utf8_list);
                if (_invlist_len(only_non_utf8_list) != 0) {
                    var_463 |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
                }
                SvREFCNT_dec_NN(only_non_utf8_list);
            }
            else {







                SV* nonascii_but_latin1_properties = NULL;
                _invlist_intersection(posixes, PL_UpperLatin1,
                                      &nonascii_but_latin1_properties);


                _invlist_union(upper_latin1_only_utf8_matches,
                               nonascii_but_latin1_properties,
                               &upper_latin1_only_utf8_matches);


                _invlist_subtract(posixes, nonascii_but_latin1_properties,
                                  &posixes);


                if (cp_list) {
                    _invlist_union(cp_list, posixes, &cp_list);
                    SvREFCNT_dec_NN(posixes);
                    posixes = NULL;
                }
                else {
                    cp_list = posixes;
                }

                SvREFCNT_dec(nonascii_but_latin1_properties);




                _invlist_subtract(upper_latin1_only_utf8_matches,
                                  cp_list,
                                  &upper_latin1_only_utf8_matches);
                if (_invlist_len(upper_latin1_only_utf8_matches) == 0) {
                    SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);
                    upper_latin1_only_utf8_matches = NULL;
                }
            }
        }
    }

    if (properties) {
        if (cp_list) {

            if (var_453) {
                var_453 = ! (var_463
                               ^ (invlist_highest(cp_list) > PERL_UNICODE_MAX));
            }

            _invlist_union(properties, cp_list, &cp_list);
            SvREFCNT_dec_NN(properties);
        }
        else {
            cp_list = properties;
        }

        if (var_453) {
            var_463
             |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;



            var_453 = FALSE;
        }
    }

    if ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET) && cBOOL((var_491->flags) & RXf_PMf_FOLD)) {




        if (only_utf8_locale_list && cp_list) {
            _invlist_subtract(only_utf8_locale_list, cp_list,
                              &only_utf8_locale_list);

            if (_invlist_len(only_utf8_locale_list) == 0) {
                SvREFCNT_dec_NN(only_utf8_locale_list);
                only_utf8_locale_list = NULL;
            }
        }
        if ( only_utf8_locale_list
            || (cp_list && ( _invlist_contains_cp(cp_list, LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE)
                            || _invlist_contains_cp(cp_list, LATIN_SMALL_LETTER_DOTLESS_I))))
        {
            var_463 |= 0x04;
            var_463
                 |= ANYOFL_FOLD
                 | ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
        }
        else if (cp_list) {
            UV var_463, var_454;
            invlist_iterinit(cp_list);
            if (invlist_iternext(cp_list, &var_463, &var_454) && var_463 < 256) {
                var_463 |= ANYOFL_FOLD;
                var_463 |= 0x04;
            }
            invlist_iterfinish(cp_list);
        }
    }
    else if ( (get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET)
             && ( upper_latin1_only_utf8_matches
                 || (var_463 & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)))
    {
        (var_491->seen_d_op) = TRUE;
        var_463 |= 0x02;
    }



    if ( cp_list
        && var_463
        && ! var_463)
    {
        _invlist_invert(cp_list);


 var_463 = FALSE;
    }

    if (ret_invlist) {
        *ret_invlist = cp_list;

        return (var_491->emit);
    }




    *flagp |= 0x01|0x02;

    if (var_463 & ANYOF_LOCALE_FLAGS) {
        (var_491->contains_locale) = 1;
    }






    if (var_453) {
        PERL_UINT_FAST8_T var_531;
        Size_t var_454 = 0;
        UV var_463[MAX_FOLD_FROMS+1] = { 0 };
        UV var_454[MAX_FOLD_FROMS+1] = { 0 };

        if (cp_list) {



            invlist_iterinit(cp_list);
            for (var_531 = 0; var_531 <= MAX_FOLD_FROMS; var_531++) {
                if (! invlist_iternext(cp_list, &var_463[var_531], &var_454[var_531])) {
                    break;
                }
                var_454 += var_454[var_531] - var_463[var_531] + 1;
            }

            invlist_iterfinish(cp_list);
        }



        if (var_463[0] == 0 && var_454[0] == var_459) {
            if (var_463) {
                var_483 = reganode(var_491, OPFAIL, 0);
            }
            else {
                var_483 = reg_node(var_491, SANY);
                if ((var_491->naughty) < 10) (var_491->naughty) += 1;
            }
            goto not_anyof;
        }



        if (var_463) {
            for (var_454 = 0; var_454 < ANYOF_POSIXL_MAX;
                                                        var_454 += 2)
            {
                if ( POSIXL_TEST(var_463, var_454)
                    && POSIXL_TEST(var_463, var_454 + 1))
                {
                    if (var_463) {
                        var_483 = reganode(var_491, OPFAIL, 0);
                    }
                    else {
                        var_483 = reg_node(var_491, SANY);
                        if ((var_491->naughty) < 10) (var_491->naughty) += 1;
                    }
                    goto not_anyof;
                }
            }

            if ( isPOWER_OF_2(var_463)
                && (var_454 == 0 || var_463[0] > 255))
            {
                U8 classnum;
                SV * class_above_latin1 = NULL;
                bool already_inverted;
                bool are_equivalent;





                static const int MultiplyDeBruijnBitPosition2[32] =
                    {
                    0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
                    31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
                    };

                var_454 = MultiplyDeBruijnBitPosition2[(var_463
                                                          * 0x077CB531U) >> 27];
                classnum = ((int) ((var_454) / 2));



                already_inverted = var_454
                                 - ((classnum) * 2);





                _invlist_intersection_maybe_complement_2nd(
                                                    PL_AboveLatin1,
                                                    PL_XPosix_ptrs[classnum],
                                                    already_inverted,
                                                    &class_above_latin1);
                are_equivalent = _invlistEQ(class_above_latin1, cp_list,
                                                                        FALSE);
                SvREFCNT_dec_NN(class_above_latin1);

                if (are_equivalent) {



                    var_463 = var_463 ^ already_inverted;

                    var_483 = reg_node(var_491,
                                   POSIXL + var_463 * (NPOSIXL - POSIXL));
                    FLAGS(((var_491->emit_start) + (var_483))) = classnum;
                    goto not_anyof;
                }
            }
        }



        if (var_463 & 0x01) {
            goto is_anyof;
        }

        if (! var_463) {





            if (var_454 == 0) {
                if (var_463) {
                    var_483 = reg_node(var_491, SANY);
                }
                else {
                    var_483 = reganode(var_491, OPFAIL, 0);
                }

                goto not_anyof;
            }


            if ( var_463[0] == 0 && var_454[0] == '\n' - 1
                && var_463[1] == '\n' + 1 && var_454[1] == var_459)
            {
                assert (! var_463);
                var_483 = reg_node(var_491, REG_ANY);
                if ((var_491->naughty) < 10) (var_491->naughty) += 1;
                goto not_anyof;
            }
        }

        if ( ! var_463
            && ! var_463



            && var_454 > 0 && var_454 <= MAX_FOLD_FROMS + 1

            && (var_463[0] < 256 || cBOOL((var_491->utf8)) || cBOOL((var_491->flags) & RXf_PMf_FOLD)))
        {
            if (var_454 == 1 && ! upper_latin1_only_utf8_matches)
            {



                if ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET)) {




                    var_512 = (cBOOL((var_491->flags) & RXf_PMf_FOLD)) ? EXACTFL : EXACTL;
                }
                else if (! cBOOL((var_491->flags) & RXf_PMf_FOLD)) {
                    var_512 = (var_463[0] < 256) ? var_454 : EXACT_ONLY8;
                }
                else if (var_463[0] < 256) {

                    var_512 = _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(var_463[0])
                         ? EXACTFU
                         : var_454;
                }
                else {



                    var_512 = _invlist_contains_cp(PL_InMultiCharFold,
                                              var_463[0])
                         ? EXACTFU_ONLY8
                         : EXACT_ONLY8;
                }

                var_533 = var_463[0];
            }
            else if ( ! (var_463 & ~0x02)
                     && _invlist_contains_cp(PL_in_some_fold, var_463[0]))
            {

                if (var_454 == 2 && isASCII(var_463[0])) {



                    assert(isALPHA(var_463[0]));
                    if ( var_454[0] == var_463[0]

                        && isALPHA_FOLD_EQ(var_463[0], var_463[1]))
                    {



                        if ( (get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
                            || _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(var_463[0]))
                        {






                            var_512 = EXACTFAA;
                        }
                        else if (_HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(var_463[0])) {






                            var_512 = (cBOOL((var_491->flags) & RXf_PMf_FOLD)) ? EXACTFU : EXACTFAA;
                        }
                        else {



                            var_512 = EXACTFU;
                        }

                        var_533 = toFOLD(var_463[0]);
                    }
                }
                else if ( ! upper_latin1_only_utf8_matches
                         || ( _invlist_len(upper_latin1_only_utf8_matches)
                                                                          == 2
                             && PL_fold_latin1[
                               invlist_highest(upper_latin1_only_utf8_matches)]
                             == var_463[0]))
                {

                    Size_t var_454;
                    U8 foldbuf[UTF8_MAXBYTES_CASE];
                    UV var_455 = _to_uni_fold_flags(var_463[0],
                                                        foldbuf, &var_454, 0);
                    unsigned int first_fold;
                    const unsigned int * remaining_folds;
                    Size_t var_455 = _inverse_folds(
                                                            var_455,
                                                            &first_fold,
                                                            &remaining_folds);
                    Size_t var_455 = var_455 + 1;
                    SV * fold_list = _new_invlist(var_455);
                    unsigned int var_531;



                    SV * all_cp_list = NULL;
                    SV ** use_this_list = &cp_list;

                    if (upper_latin1_only_utf8_matches) {
                        all_cp_list = _new_invlist(0);
                        use_this_list = &all_cp_list;
                        _invlist_union(cp_list,
                                       upper_latin1_only_utf8_matches,
                                       use_this_list);
                    }




                    fold_list = add_cp_to_invlist(fold_list, var_463[0]);
                    fold_list = add_cp_to_invlist(fold_list, var_455);
                    if (var_455 > 0) {
                        fold_list = add_cp_to_invlist(fold_list, first_fold);
                        for (var_531 = 0; var_531 + 1 < var_455; var_531++) {
                            fold_list = add_cp_to_invlist(fold_list,
                                                        remaining_folds[var_531]);
                        }
                    }




                    if (_invlistEQ(*use_this_list, fold_list,
                                   0 )
                    ) {

                        if (var_463[0] > 255) {
                            if (cBOOL((var_491->flags) & RXf_PMf_FOLD) || ! _invlist_contains_cp(
                                            PL_InMultiCharFold, var_455))
                            {
                                var_512 = ((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET))
                                     ? EXACTFLU8
                                     : ((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET))
                                       ? EXACTFAA
                                       : EXACTFU_ONLY8;
                                var_533 = var_455;
                            }
                        }
                        else if ( cBOOL((var_491->flags) & RXf_PMf_FOLD)
                                 && var_455 == 's'
                                 && (get_regex_charset((var_491->flags)) == REGEX_DEPENDS_CHARSET))
                        {


                            var_512 = EXACTFU_S_EDGE;
                            var_533 = var_455;
                        }
                        else if ( cBOOL((var_491->flags) & RXf_PMf_FOLD)
                                || ! _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(var_463[0]))
                        {
                            if (upper_latin1_only_utf8_matches) {
                                var_512 = EXACTF;



                                var_533 = var_463[0];
                            }
                            else if ( UNLIKELY(var_463[0] == MICRO_SIGN)
                                     && ! cBOOL((var_491->utf8)))
                            {

                                var_512 = ((get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET))
                                     ? EXACTFAA
                                     : EXACTFUP;
                                var_533 = MICRO_SIGN;
                            }
                            else if ( (get_regex_charset((var_491->flags)) == REGEX_ASCII_MORE_RESTRICTED_CHARSET)
                                     && ! isASCII(var_463[0]))
                            {

                                var_512 = EXACTFAA;
                                var_533 = var_455;
                            }
                            else {
                                var_512 = EXACTFU;
                                var_533 = var_455;
                            }
                        }
                    }

                    SvREFCNT_dec_NN(fold_list);
                    SvREFCNT_dec(all_cp_list);
                }
            }

            if (var_512 != var_461) {






                if (! cBOOL((var_491->utf8)) && var_533 > 255) {
                    SV * in_multis = NULL;

                    assert(cBOOL((var_491->flags) & RXf_PMf_FOLD));





                    _invlist_intersection(PL_InMultiCharFold, cp_list, &in_multis);
                    if (UNLIKELY(_invlist_len(in_multis) != 0)) {
                        STMT_START { if (!cBOOL((var_491->utf8))) { *flagp = 0x20|0x40; return 0; } } STMT_END;
                    }
                    else {
                        var_512 = var_461;
                    }
                }

                if (var_512 != var_461) {
                    U8 var_531 = (cBOOL((var_491->utf8))) ? UVCHR_SKIP(var_533) : 1;

                    var_483 = regnode_guts(var_491, var_512, var_531, "exact");
                    FILL_NODE(var_483, var_512);
                    (var_491->emit) += 1 + STR_SZ(var_531);
                    STR_LEN(((var_491->emit_start) + (var_483))) = var_531;
                    if (var_531 == 1) {
                        *STRING(((var_491->emit_start) + (var_483))) = (U8) var_533;
                    }
                    else {
                        uvchr_to_utf8((U8 *) STRING(((var_491->emit_start) + (var_483))), var_533);
                    }
                    goto not_anyof;
                }
            }
        }

        if (! var_463) {

            PERL_UINT_FAST8_T var_461 = 0;



            const PERL_UINT_FAST8_T var_457 = 0x7F;




            if (invlist_highest(cp_list) > var_457) {
                _invlist_invert(cp_list);
                var_461 = 1;
            }

            if (invlist_highest(cp_list) <= var_457) {
                UV var_461, this_end;
                UV var_461 = var_459;
                U8 var_461 = 0;
                Size_t var_461 = 0;
                bool var_461 = TRUE;



                invlist_iterinit(cp_list);
                while (invlist_iternext(cp_list, &var_461, &this_end)) {
                    unsigned int var_531 = var_461;

                    if (var_461) {
                        if (! UVCHR_IS_INVARIANT(var_531)) {
                            goto done_anyofm;
                        }

                        var_461 = FALSE;
                        var_461 = var_461;



                        var_531++;
                    }




                    for (; var_531 <= this_end; var_531++) {
                        if (! UVCHR_IS_INVARIANT(var_531)) {
                            goto done_anyofm;
                        }

                        var_461 |= var_531 ^ var_461;
                    }

                    var_461 += this_end - var_461 + 1;
                }
                invlist_iterfinish(cp_list);

                if ( (var_461 || var_461 > 1)
                    && var_461 == 1U << PL_bitcount[var_461])
                {
                    U8 ANYOFM_mask;

                    var_512 = ANYOFM + var_461;;


                    ANYOFM_mask = ~ var_461;


                    var_483 = reganode(var_491, var_512, var_461);
                    FLAGS(((var_491->emit_start) + (var_483))) = ANYOFM_mask;
                }
            }
          done_anyofm:

            if (var_461) {
                _invlist_invert(cp_list);
            }

            if (var_512 != var_461) {
                goto not_anyof;
            }
        }

        if (! (var_463 & ANYOF_LOCALE_FLAGS)) {
            PERL_UINT_FAST8_T var_462;
            SV * intersection = NULL;
            SV* d_invlist = NULL;






            for (var_462 = POSIXA; var_462 >= POSIXD; var_462--) {
                int posix_class;

                if (var_462 == POSIXL) {
                    continue;
                }

                for (posix_class = 0;
                     posix_class <= _HIGHEST_REGCOMP_DOT_H_SYNC;
                     posix_class++)
                {
                    SV** our_code_points = &cp_list;
                    SV** official_code_points;
                    int try_inverted;

                    if (var_462 == POSIXA) {
                        official_code_points = &PL_Posix_ptrs[posix_class];
                    }
                    else {
                        official_code_points = &PL_XPosix_ptrs[posix_class];
                    }



                    if (! *official_code_points) {
                        continue;
                    }


                    for (try_inverted = 0; try_inverted < 2; try_inverted++) {
                        bool var_462 = var_463 ^ try_inverted;

                        if (var_462 != POSIXD) {



                            if (var_463
                                                    & 0x02)
                            {
                                continue;
                            }
                        }
                        else if (! var_462) {



                            _invlist_intersection(cp_list, PL_UpperLatin1,
                                                           &intersection);
                            if (_invlist_len(intersection) != 0) {
                                continue;
                            }

                            SvREFCNT_dec(d_invlist);
                            d_invlist = invlist_clone(cp_list, NULL);





                            if (upper_latin1_only_utf8_matches) {
                                _invlist_union(
                                            d_invlist,
                                            upper_latin1_only_utf8_matches,
                                            &d_invlist);
                            }
                            our_code_points = &d_invlist;
                        }
                        else {

                            if (! (var_463 & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER))
                            {
                                continue;
                            }
                            our_code_points = &cp_list;
                        }






                        if (_invlistEQ(*our_code_points,
                                       *official_code_points,
                                       try_inverted))
                        {



                            var_483 = reg_node(var_491, (try_inverted)
                                                        ? var_462 + NPOSIXA
                                                                - POSIXA
                                                        : var_462);
                            FLAGS(((var_491->emit_start) + (var_483))) = posix_class;
                            SvREFCNT_dec(d_invlist);
                            SvREFCNT_dec(intersection);
                            goto not_anyof;
                        }
                    }
                }
            }
            SvREFCNT_dec(d_invlist);
            SvREFCNT_dec(intersection);
        }



        if ( var_463[0] >= NUM_ANYOF_CODE_POINTS
            && ! (get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET)
            && ! upper_latin1_only_utf8_matches
            && var_463 == 0)
        {
            UV var_463 = invlist_highest(cp_list);

            if (var_463 > IV_MAX) {
                var_463 = 0;
            }
            else {
                U8 low_utf8[UTF8_MAXBYTES+1];
                U8 high_utf8[UTF8_MAXBYTES+1];

                (void) uvchr_to_utf8(low_utf8, var_463[0]);
                (void) uvchr_to_utf8(high_utf8, invlist_highest(cp_list));

                var_463 = (low_utf8[0] == high_utf8[0])
                            ? low_utf8[0]
                            : 0;
            }

            var_512 = ANYOFH;
        }
    }

  is_anyof:
    if (var_512 != ANYOFH) {
        var_512 = (var_463 & 0x02)
             ? ANYOFD
             : ((var_463)
                ? ANYOFPOSIXL
                : (((get_regex_charset((var_491->flags)) == REGEX_LOCALE_CHARSET))
                   ? ANYOFL
                   : ANYOF));
    }

    var_483 = regnode_guts(var_491, var_512, regarglen[var_512], "anyof");
    FILL_NODE(var_483, var_512);
    (var_491->emit) += 1 + regarglen[var_512];
    ANYOF_FLAGS(((var_491->emit_start) + (var_483))) = var_463;







    populate_ANYOF_from_invlist(((var_491->emit_start) + (var_483)), &cp_list);

    if (var_463) {
        ANYOF_POSIXL_SET_TO_BITMAP(((var_491->emit_start) + (var_483)), var_463);
    }

    if (var_463) {
        ANYOF_FLAGS(((var_491->emit_start) + (var_483))) |= ANYOF_INVERT;
    }





    if (upper_latin1_only_utf8_matches) {
 if (cp_list) {
     _invlist_union(cp_list,
                           upper_latin1_only_utf8_matches,
                           &cp_list);
     SvREFCNT_dec_NN(upper_latin1_only_utf8_matches);
 }
 else {
     cp_list = upper_latin1_only_utf8_matches;
 }
        ANYOF_FLAGS(((var_491->emit_start) + (var_483))) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;
    }

    set_ANYOF_arg(var_491, ((var_491->emit_start) + (var_483)), cp_list,
                  ((SvCUR(listsv) != var_463))
                   ? listsv : NULL,
                  only_utf8_locale_list);
    return var_483;

  not_anyof:





                                                                   ;;
    SvREFCNT_dec(cp_list);;
    return var_483;
}



static void
fn_463(pTHX_ RExC_state_t* const var_491,
                regnode* const var_467,
                SV* const cp_list,
                SV* const runtime_defns,
                SV* const only_utf8_locale_list)
{

    UV var_498;

    PERL_ARGS_ASSERT_SET_ANYOF_ARG;

    if (! cp_list && ! runtime_defns && ! only_utf8_locale_list) {
        assert(! (ANYOF_FLAGS(var_467)
                & ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP));
 ARG_SET(var_467, ANYOF_ONLY_HAS_BITMAP);
    }
    else {
 AV * const av = newAV();
 SV *rv;

        if (cp_list) {
            av_store(av, 0, cp_list);
        }

        if (only_utf8_locale_list) {
            av_store(av, 1, only_utf8_locale_list);
        }

        if (runtime_defns) {
            av_store(av, 2, SvREFCNT_inc(runtime_defns));
        }

 rv = newRV_noinc(MUTABLE_SV(av));
 var_498 = add_data(var_491, STR_WITH_LEN("s"));
 (var_491->rxi)->data->data[var_498] = (void*)rv;
 ARG_SET(var_467, var_498);
    }
}


SV *
fn_464(pTHX_ const regexp *prog,
                                        const regnode* var_467,
                                        bool var_467,
                                        SV** listsvp,
                                        SV** only_utf8_locale_ptr,
                                        SV** output_invlist)

{

    SV *si = NULL;
    SV* invlist = NULL;

    RXi_GET_DECL(prog, progi);
    const struct struct_466 * const data = prog ? progi->data : NULL;

    PERL_ARGS_ASSERT__GET_REGCLASS_NONBITMAP_DATA;
    assert(! output_invlist || listsvp);

    if (data && data->count) {
 const U32 var_498 = ARG(var_467);

 if (data->what[var_498] == 's') {
     SV * const rv = MUTABLE_SV(data->data[var_498]);
     AV * const av = MUTABLE_AV(SvRV(rv));
     SV **const ary = AvARRAY(av);

            invlist = ary[0];

            if (av_tindex_skip_len_mg(av) >= 1) {
                *only_utf8_locale_ptr = ary[1];
            }

            if (av_tindex_skip_len_mg(av) >= 2) {
                si = ary[2];
            }

     if (var_467 && (si || invlist)) {
                if (si) {
                    bool var_467;
                    SV * msg = newSVpvs_flags("", SVs_TEMP);

                    SV * prop_definition = handle_user_defined_property(
                            "", 0, FALSE,
                            SvPVX_const(si)[1] - '0',


                            TRUE,
                            FALSE,
                            si,
                            &var_467,
                            msg,
                            0
                           );

                    if (SvCUR(msg)) {
                        assert(prop_definition == NULL);

                        Perl_croak(aTHX_ "%" UTF8f,
                                UTF8fARG(SvUTF8(msg), SvCUR(msg), SvPVX(msg)));
                    }

                    if (invlist) {
                        _invlist_union(invlist, prop_definition, &invlist);
                        SvREFCNT_dec_NN(prop_definition);
                    }
                    else {
                        invlist = prop_definition;
                    }

                    STATIC_ASSERT_STMT(1 == 1);
                    STATIC_ASSERT_STMT(2 == 2);

                    av_store(av, 0, invlist);
                    av_fill(av, (ary[1])
                                 ? 1:
                                 0);
                    si = NULL;
                }
     }
 }
    }



    if (listsvp) {
 SV* matches_string = NULL;





 if (si) {



            if (! output_invlist) {
                matches_string = newSVsv(si);
            }
            else {




                const char *si_string = SvPVX(si);
                STRLEN var_470 = SvCUR(si);
                UV var_470 = 0;
                U8 var_489 = 0;


                while (*si_string != '\n' && var_470 > 0) {
                    si_string++;
                    var_470--;
                }
                assert(var_470 > 0);

                si_string++;
                var_470--;

                while (var_470 > 0) {

                    I32 var_470 = var_470
                                     |PERL_SCAN_SILENT_NON_PORTABLE;
                    STRLEN var_531 = var_470;
                    UV var_470 = grok_hex(si_string, &var_531, &var_470, NULL);



                    if ( *(si_string + var_531) == '\n') {
                        if (var_489) {
                            *output_invlist = _add_range_to_invlist(*output_invlist, var_470, var_470);
                        }
                        else {
                            *output_invlist = add_cp_to_invlist(*output_invlist, var_470);
                        }
                        var_489 = 0;
                        goto prepare_for_next_iteration;
                    }



                    if (*(si_string + var_531) == '\t') {
                        assert(var_489 == 0);

                        var_470 = var_470;
                        var_489 = 1;
                      prepare_for_next_iteration:
                        si_string += var_531 + 1;
                        var_470 -= var_531 + 1;
                        continue;
                    }




                    var_470 -= var_531;
                    while (*(si_string + var_531) != '\n' && var_470 > 0) {
                        var_470--;
                        var_531++;
                    }
                    if (*(si_string + var_531) == '\n') {
                        var_531++;
                        var_470--;
                    }
                    if (matches_string) {
                        sv_catpvn(matches_string, si_string, var_531 - 1);
                    }
                    else {
                        matches_string = newSVpvn(si_string, var_531 - 1);
                    }
                    si_string += var_531;
                    sv_catpvs(matches_string, " ");
                }

                assert(matches_string);
                if (SvCUR(matches_string)) {
                    SvCUR_set(matches_string, SvCUR(matches_string) - 1);
                }
            }
 }


        if (invlist) {



            if (! output_invlist) {
                if ( ! matches_string) {
                    matches_string = newSVpvs("\n");
                }
                sv_catsv(matches_string, invlist_contents(invlist,
                                                  TRUE
                                                  ));
            }
            else if (! *output_invlist) {
                *output_invlist = invlist_clone(invlist, NULL);
            }
            else {
                _invlist_union(*output_invlist, invlist, output_invlist);
            }
        }

 *listsvp = matches_string;
    }

    return invlist;
}

PERL_STATIC_INLINE char*
fn_470(RExC_state_t *var_491, char* var_499)
{
    PERL_ARGS_ASSERT_REG_SKIPCOMMENT;

    assert(*var_499 == '#');

    while (var_499 < (var_491->end)) {
        if (*(++var_499) == '\n') {
            return var_499+1;
        }
    }



    (var_491->seen) |= REG_RUN_ON_COMMENT_SEEN;
    return var_499;
}

static void
fn_471(pTHX_ RExC_state_t *var_491,
                                char ** var_499,
                                const bool var_474
                         )
{





    const bool var_474 = var_474 || ((var_491->flags) & RXf_PMf_EXTENDED);

    PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT;

    assert( ! cBOOL((var_491->utf8)) || UTF8_IS_INVARIANT(**var_499) || UTF8_IS_START(**var_499));

    for (;;) {
 if ((var_491->end) - (*var_499) >= 3
     && *(*var_499) == '('
     && *(*var_499 + 1) == '?'
     && *(*var_499 + 2) == '#')
 {
     while (*(*var_499) != ')') {
  if ((*var_499) == (var_491->end))
      STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Sequence (?#... not terminated", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
  (*var_499)++;
     }
     (*var_499)++;
     continue;
 }

 if (var_474) {
            const char * save_p = *var_499;
            while ((*var_499) < (var_491->end)) {
                STRLEN var_531;
                if ((var_531 = is_PATWS_safe((*var_499), (var_491->end), cBOOL((var_491->utf8))))) {
                    (*var_499) += var_531;
                }
                else if (*(*var_499) == '#') {
                    (*var_499) = reg_skipcomment(var_491, (*var_499));
                }
                else {
                    break;
                }
            }
            if (*var_499 != save_p) {
                continue;
            }
 }

        break;
    }

    return;
}

static void
fn_474(pTHX_ RExC_state_t *var_491)
{
    PERL_ARGS_ASSERT_NEXTCHAR;

    if ((var_491->parse) < (var_491->end)) {
        assert( ! cBOOL((var_491->utf8))
               || UTF8_IS_INVARIANT(*(var_491->parse))
               || UTF8_IS_START(*(var_491->parse)));

        (var_491->parse) += (cBOOL((var_491->utf8)))
                      ? UTF8_SAFE_SKIP((var_491->parse), (var_491->end))
                      : 1;

        skip_to_be_ignored_text(var_491, &(var_491->parse),
                                FALSE );
    }
}

static void
fn_475(pTHX_ RExC_state_t *var_491, const Ptrdiff_t var_485)
{



    PERL_ARGS_ASSERT_CHANGE_ENGINE_SIZE;

    (var_491->size) += var_485;

    Renewc((var_491->rxi),
           sizeof(regexp_internal) + ((var_491->size) + 1) * sizeof(regnode),

           char,
           regexp_internal);
    if ( (var_491->rxi) == NULL )
 STMT_START { const char *ellipses = ""; IV var_531 = (var_491->precomp_end) - (var_491->precomp); STMT_START { if ((var_491->rx_sv)) SAVEFREESV((var_491->rx_sv)); if ((var_491->open_parens)) SAVEFREEPV((var_491->open_parens)); if ((var_491->close_parens)) SAVEFREEPV((var_491->close_parens)); } STMT_END; if (var_531 > 127) { var_531 = 117; ellipses = "..."; } Perl_croak(aTHX_ "%s in regex m/%" UTF8f "%s/", "Regexp out of space", UTF8fARG(cBOOL((var_491->utf8)), var_531, (var_491->precomp)), ellipses); } STMT_END;
    RXi_SET((var_491->rx), (var_491->rxi));

    (var_491->emit_start) = (var_491->rxi)->program;
    if (var_485 > 0) {
        Zero(((var_491->emit_start) + ((var_491->emit))), var_485, regnode);
    }

}

static regnode_offset
fn_476(pTHX_ RExC_state_t *var_491, const U8 var_512, const STRLEN var_478, const char* const var_538)
{





    const regnode_offset var_483 = (var_491->emit);

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGNODE_GUTS;

    SIZE_ALIGN((var_491->size));
    change_engine_size(var_491, (Ptrdiff_t) 1 + var_478);
    NODE_ALIGN_FILL(((var_491->emit_start) + (var_483)));

    PERL_UNUSED_ARG(var_538);
    PERL_UNUSED_ARG(var_512);

    return(var_483);
}




static regnode_offset
fn_478(pTHX_ RExC_state_t *var_491, U8 var_512)
{
    const regnode_offset var_483 = regnode_guts(var_491, var_512, regarglen[var_512], "reg_node");
    regnode_offset var_483 = var_483;

    PERL_ARGS_ASSERT_REG_NODE;

    assert(regarglen[var_512] == 0);

    FILL_ADVANCE_NODE(var_483, var_512);
    (var_491->emit) = var_483;
    return(var_483);
}




static regnode_offset
fn_479(pTHX_ RExC_state_t *var_491, U8 var_512, U32 var_480)
{
    const regnode_offset var_483 = regnode_guts(var_491, var_512, regarglen[var_512], "reganode");
    regnode_offset var_483 = var_483;

    PERL_ARGS_ASSERT_REGANODE;


    assert(regarglen[var_512] == 1);

    FILL_ADVANCE_NODE_ARG(var_483, var_512, var_480);
    (var_491->emit) = var_483;
    return(var_483);
}

static regnode_offset
fn_480(pTHX_ RExC_state_t *var_491, const U8 var_512, const U32 var_483, const I32 var_483)
{


    const regnode_offset var_483 = regnode_guts(var_491, var_512, regarglen[var_512], "reg2Lanode");
    regnode_offset var_483 = var_483;

    PERL_ARGS_ASSERT_REG2LANODE;

    assert(regarglen[var_512] == 2);

    FILL_ADVANCE_NODE_2L_ARG(var_483, var_512, var_483, var_483);
    (var_491->emit) = var_483;
    return(var_483);
}

static void
fn_483(pTHX_ RExC_state_t *var_491, const U8 var_512,
                  const regnode_offset var_485, const U32 var_486)
{
    regnode *src;
    regnode *dst;
    regnode *place;
    const int var_499 = regarglen[(U8)var_512];
    const int var_485 = NODE_STEP_REGNODE + var_499;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGINSERT;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(var_486);

    DEBUG_PARSE_r({ DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", (("inst")) ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); }); Perl_re_printf( aTHX_ " - %s" "\n",PL_reg_name[var_512]); });
    assert(!(var_491->study_started));


    change_engine_size(var_491, (Ptrdiff_t) var_485);
    src = ((var_491->emit_start) + ((var_491->emit)));
    (var_491->emit) += var_485;
    dst = ((var_491->emit_start) + ((var_491->emit)));




    if (! ((var_491->total_par) < 0) && (var_491->open_parens)) {
        int var_485;




        for ( var_485=0 ; var_485 < (var_491->npar) ; var_485++ ) {



            if ( var_485 && (var_491->open_parens)[var_485] >= var_485 ) {

                (var_491->open_parens)[var_485] += var_485;
            } else {

            }
            if ( (var_491->close_parens)[var_485] >= var_485 ) {

                (var_491->close_parens)[var_485] += var_485;
            } else {

            }
        }
    }
    if ((var_491->end_op))
        (var_491->end_op) += var_485;

    while (src > ((var_491->emit_start) + (var_485))) {
 StructCopy(--src, --dst, regnode);

    }

    place = ((var_491->emit_start) + (var_485));

    src = NEXTOPER(place);
    FLAGS(place) = 0;
    FILL_NODE(var_485, var_512);


    Zero(src, var_499, regnode);
}

static bool
fn_485(pTHX_ RExC_state_t * var_491,
                const regnode_offset var_499,
                const regnode_offset var_486,
                const U32 var_486)
{
    regnode_offset var_486;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGTAIL;

    PERL_UNUSED_ARG(var_486);



    var_486 = (regnode_offset) var_499;
    for (;;) {
 regnode * const var_537 = regnext(((var_491->emit_start) + (var_486)));
        DEBUG_PARSE_r({
            DEBUG_PARSE_r({ if (RExC_lastparse!=(var_491->parse)) { Perl_re_printf( aTHX_ "%s", Perl_pv_pretty(aTHX_ RExC_mysv1, (var_491->parse), (var_491->end) - (var_491->parse), 16, "", "", PERL_PV_ESCAPE_UNI_DETECT | PERL_PV_PRETTY_ELLIPSES | PERL_PV_PRETTY_LTGT | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_EXACTSIZE ) ); } else Perl_re_printf( aTHX_ "%16s",""); if (RExC_lastnum!=(var_491->emit)) Perl_re_printf( aTHX_ "|%4d", (var_491->emit)); else Perl_re_printf( aTHX_ "|%4s",""); Perl_re_printf( aTHX_ "|%*s%-4s", (int)((var_486*2)), "", ((var_486==var_499 ? "tail" : "")) ); RExC_lastnum=(var_491->emit); RExC_lastparse=(var_491->parse); });
            regprop((var_491->rx), RExC_mysv, ((var_491->emit_start) + (var_486)), NULL, var_491);
            Perl_re_printf( aTHX_ "~ %s (%d) %s %s\n",
                SvPV_nolen_const(RExC_mysv), var_486,
                    (var_537 == NULL ? "->" : ""),
                    (var_537 == NULL ? PL_reg_name[OP(((var_491->emit_start) + (var_486)))] : "")
            );
        });
        if (var_537 == NULL)
            break;
        var_486 = ((var_537) - (var_491->emit_start));
    }

    if (reg_off_by_arg[OP(((var_491->emit_start) + (var_486)))]) {
        assert((UV) (var_486 - var_486) <= U32_MAX);
        ARG_SET(((var_491->emit_start) + (var_486)), var_486 - var_486);
    }
    else {
        if (var_486 - var_486 > U16_MAX) {



            NEXT_OFF(((var_491->emit_start) + (var_486))) = U16_MAX;
            return FALSE;
        }
        NEXT_OFF(((var_491->emit_start) + (var_486))) = var_486 - var_486;
    }

    return TRUE;
}

static SV*
fn_486(pTHX_ const regnode * var_498) {




    SV * cp_list = _new_invlist(-1);
    const U8 var_489 = (U8) ARG(var_498);
    unsigned int var_531;
    U8 var_489 = 0;
    U8 var_489 = 1U << PL_bitcount[ (U8) ~ FLAGS(var_498)];

    PERL_ARGS_ASSERT_GET_ANYOFM_CONTENTS;



    for (var_531 = var_489; var_531 <= 0xFF; var_531++) {
        if ((var_531 & FLAGS(var_498)) == ARG(var_498)) {
            cp_list = add_cp_to_invlist(cp_list, var_531);
            var_489++;



            if (var_489 >= var_489) break;
        }
    }

    if (OP(var_498) == NANYOFM) {
        _invlist_invert(cp_list);
    }
    return cp_list;
}

void
fn_489(pTHX_ const regexp *r)
{

    PERL_ARGS_ASSERT_REGDUMP;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(r);

}

void
fn_490(pTHX_ const regexp *prog, SV *sv, const regnode *o, const regmatch_info *reginfo, const RExC_state_t *var_491)
{

    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(o);
    PERL_UNUSED_ARG(prog);
    PERL_UNUSED_ARG(reginfo);
    PERL_UNUSED_ARG(var_491);

}



SV *
fn_491(pTHX_ REGEXP * const r)
{
    struct struct_498 *const prog = ReANY(r);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_RE_INTUIT_STRING;
    PERL_UNUSED_CONTEXT;

    DEBUG_COMPILE_r(
 {
     const char * const var_512 = SvPV_nolen_const(RX_UTF8(r)
        ? prog->check_utf8 : prog->check_substr);

     if (!PL_colorset) reginitcolors();
            Perl_re_printf( aTHX_
        "%sUsing REx %ssubstr:%s \"%s%.60s%s%s\"\n",
        PL_colors[4],
        RX_UTF8(r) ? "utf8 " : "",
        PL_colors[5], PL_colors[0],
        var_512,
        PL_colors[1],
        (strlen(var_512) > PL_dump_re_max_len ? "..." : ""));
 } );


    return RX_UTF8(r) ? prog->check_utf8 : prog->check_substr;
}

void
fn_492(pTHX_ REGEXP *r)
{
    SvREFCNT_dec(r);
}

void
fn_493(pTHX_ REGEXP *rx)
{
    struct struct_498 *const r = ReANY(rx);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_PREGFREE2;

    if (! r)
        return;

    if (r->mother_re) {
        ReREFCNT_dec(r->mother_re);
    } else {
        CALLREGFREE_PVT(rx);
        SvREFCNT_dec(RXp_PAREN_NAMES(r));
    }
    if (r->substrs) {
        int var_531;
        for (var_531 = 0; var_531 < 2; var_531++) {
            SvREFCNT_dec(r->substrs->data[var_531].substr);
            SvREFCNT_dec(r->substrs->data[var_531].utf8_substr);
        }
 Safefree(r->substrs);
    }
    RX_MATCH_COPY_FREE(rx);



    Safefree(r->offs);
    SvREFCNT_dec(r->qr_anoncv);
    if (r->recurse_locinput)
        Safefree(r->recurse_locinput);
}

REGEXP *
fn_494(pTHX_ REGEXP *dsv, REGEXP *ssv)
{
    struct struct_498 *drx;
    struct struct_498 *const srx = ReANY(ssv);
    const bool var_496 = dsv && SvTYPE(dsv) == SVt_PVLV;

    PERL_ARGS_ASSERT_REG_TEMP_COPY;

    if (!dsv)
 dsv = (REGEXP*) newSV_type(SVt_REGEXP);
    else {
        assert(SvTYPE(dsv) == SVt_REGEXP || (SvTYPE(dsv) == SVt_PVLV));



        assert(!SvOOK(dsv));
        assert(!SvIsCOW(dsv));
        assert(!SvROK(dsv));

        if (SvPVX_const(dsv)) {
            if (SvLEN(dsv))
                Safefree(SvPVX(dsv));
            SvPVX(dsv) = NULL;
        }
        SvLEN_set(dsv, 0);
        SvCUR_set(dsv, 0);
 SvOK_off((SV *)dsv);

 if (var_496) {



     REGEXP *var_537 = (REGEXP *)newSV_type(SVt_REGEXP);
     assert(!SvPVX(dsv));
            ((XPV*)SvANY(dsv))->xpv_len_u.xpvlenu_rx = var_537->sv_any;
     var_537->sv_any = NULL;
     SvFLAGS(var_537) = (SvFLAGS(var_537) & ~SVTYPEMASK) | SVt_NULL;
     SvREFCNT_dec_NN(var_537);


     SvCUR_set(dsv, SvCUR(ssv));
 }
    }


    SvFAKE_on(dsv);
    drx = ReANY(dsv);

    SvFLAGS(dsv) |= SvFLAGS(ssv) & (SVf_POK|SVp_POK|SVf_UTF8);
    SvPV_set(dsv, RX_WRAPPED(ssv));




    memcpy(&(drx->xpv_cur), &(srx->xpv_cur),
    sizeof(regexp) - STRUCT_OFFSET(regexp, xpv_cur));
    if (!var_496)
        SvLEN_set(dsv, 0);
    if (srx->offs) {
        const I32 var_497 = srx->nparens+1;
        Newx(drx->offs, var_497, regexp_paren_pair);
        Copy(srx->offs, drx->offs, var_497, regexp_paren_pair);
    }
    if (srx->substrs) {
        int var_531;
        Newx(drx->substrs, 1, struct reg_substr_data);
 StructCopy(srx->substrs, drx->substrs, struct reg_substr_data);

        for (var_531 = 0; var_531 < 2; var_531++) {
            SvREFCNT_inc_void(drx->substrs->data[var_531].substr);
            SvREFCNT_inc_void(drx->substrs->data[var_531].utf8_substr);
        }



    }
    RX_MATCH_COPIED_off(dsv);



    drx->mother_re = ReREFCNT_inc(srx->mother_re ? srx->mother_re : ssv);
    SvREFCNT_inc_void(drx->qr_anoncv);
    if (srx->recurse_locinput)
        Newx(drx->recurse_locinput, srx->nparens + 1, char *);

    return dsv;
}

void
fn_497(pTHX_ REGEXP * const rx)
{
    struct struct_498 *const r = ReANY(rx);
    RXi_GET_DECL(r, ri);
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGFREE_INTERNAL;

    if (! ri) {
        return;
    }

    DEBUG_COMPILE_r({
 if (!PL_colorset)
     reginitcolors();
 {
     SV *dsv= sv_newmortal();
            RE_PV_QUOTED_DECL(var_512, RX_UTF8(rx),
                dsv, RX_PRECOMP(rx), RX_PRELEN(rx), PL_dump_re_max_len);
            Perl_re_printf( aTHX_ "%sFreeing REx:%s %s\n",
                PL_colors[4], PL_colors[5], var_512);
        }
    });





    if (ri->code_blocks)
        S_free_codeblocks(aTHX_ ri->code_blocks);

    if (ri->data) {
 int var_498 = ri->data->count;

 while (--var_498 >= 0) {

     switch (ri->data->what[var_498]) {
     case 'a':
     case 'r':
     case 's':
     case 'S':
     case 'u':
  SvREFCNT_dec(MUTABLE_SV(ri->data->data[var_498]));
  break;
     case 'f':
  Safefree(ri->data->data[var_498]);
  break;
     case 'l':
     case 'L':
         break;
            case 'T':
                {

                    U32 refcount;
                    reg_ac_data *aho=(reg_ac_data*)ri->data->data[var_498];



                    OP_REFCNT_LOCK;
                    refcount = --aho->refcount;
                    OP_REFCNT_UNLOCK;
                    if ( !refcount ) {
                        PerlMemShared_free(aho->states);
                        PerlMemShared_free(aho->fail);

                        PerlMemShared_free(ri->data->data[var_498]);





                        assert(ri->regstclass);
                        if (ri->regstclass) {
                            PerlMemShared_free(ri->regstclass);
                            ri->regstclass = 0;
                        }
                    }
                }
                break;
     case 't':
         {

             U32 refcount;
             reg_trie_data *trie=(reg_trie_data*)ri->data->data[var_498];



                    OP_REFCNT_LOCK;
                    refcount = --trie->refcount;
                    OP_REFCNT_UNLOCK;
                    if ( !refcount ) {
                        PerlMemShared_free(trie->charmap);
                        PerlMemShared_free(trie->states);
                        PerlMemShared_free(trie->trans);
                        if (trie->bitmap)
                            PerlMemShared_free(trie->bitmap);
                        if (trie->jump)
                            PerlMemShared_free(trie->jump);
   PerlMemShared_free(trie->wordinfo);

                        PerlMemShared_free(ri->data->data[var_498]);
      }
  }
  break;
     default:
  Perl_croak(aTHX_ "panic: regfree data code '%c'",
                                                    ri->data->what[var_498]);
     }
 }
 Safefree(ri->data->what);
 Safefree(ri->data);
    }

    Safefree(ri);
}

regnode *
fn_498(pTHX_ regnode *var_499)
{
    I32 var_499;

    if (!var_499)
 return(NULL);

    if (OP(var_499) > REGNODE_MAX) {
 Perl_croak(aTHX_ "Corrupted regexp opcode %d > %d",
                                                (int)OP(var_499), (int)REGNODE_MAX);
    }

    var_499 = (reg_off_by_arg[OP(var_499)] ? ARG(var_499) : NEXT_OFF(var_499));
    if (var_499 == 0)
 return(NULL);

    return(var_499+var_499);
}



static void
fn_499(pTHX_ var_499 var_501, const char* pat1, const char* pat2,...)
{
    va_list args;
    STRLEN var_501 = strlen(pat1);
    STRLEN var_501 = strlen(pat2);
    char buf[512];
    SV *msv;
    const char *message;

    PERL_ARGS_ASSERT_RE_CROAK2;

    if (var_501 > 510)
 var_501 = 510;
    if (var_501 + var_501 > 510)
 var_501 = 510 - var_501;
    Copy(pat1, buf, var_501 , char);
    Copy(pat2, buf + var_501, var_501 , char);
    buf[var_501 + var_501] = '\n';
    buf[var_501 + var_501 + 1] = '\0';
    va_start(args, pat2);
    msv = vmess(buf, &args);
    va_end(args);
    message = SvPV_const(msv, var_501);
    if (var_501 > 512)
 var_501 = 512;
    Copy(message, buf, var_501 , char);

    Perl_croak(aTHX_ "%" UTF8f, UTF8fARG(var_501, var_501-1, buf));
}




void
fn_501(pTHX)
{
    I32 var_503 = -1;
    I32 var_531;



    if (PL_curpm) {
 const REGEXP * const rx = PM_GETRE(PL_curpm);
 if (rx)
            var_503 = RX_NPARENS(rx);
    }






    if (var_503 == -1)
        var_503 = 3;

    for (var_531 = 1; var_531 <= var_503; var_531++) {
        char digits[TYPE_CHARS(long)];
        const STRLEN var_531 = my_snprintf(digits, sizeof(digits),
                                       "%lu", (long)var_531);
        GV *const *const gvp
            = (GV**)hv_fetch(PL_defstash, digits, var_531, 0);

        if (gvp) {
            GV * const gv = *gvp;
            if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))
                save_scalar(gv);
        }
    }
}

void
fn_503(pTHX)
{
    dVAR;

    PL_user_def_props = newHV();

    PL_XPosix_ptrs[_CC_ASCII] = _new_invlist_C_array(uni_prop_ptrs[UNI_ASCII]);
    PL_XPosix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXALNUM]);
    PL_XPosix_ptrs[_CC_ALPHA] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXALPHA]);
    PL_XPosix_ptrs[_CC_BLANK] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXBLANK]);
    PL_XPosix_ptrs[_CC_CASED] = _new_invlist_C_array(uni_prop_ptrs[UNI_CASED]);
    PL_XPosix_ptrs[_CC_CNTRL] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXCNTRL]);
    PL_XPosix_ptrs[_CC_DIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXDIGIT]);
    PL_XPosix_ptrs[_CC_GRAPH] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXGRAPH]);
    PL_XPosix_ptrs[_CC_LOWER] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXLOWER]);
    PL_XPosix_ptrs[_CC_PRINT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXPRINT]);
    PL_XPosix_ptrs[_CC_PUNCT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXPUNCT]);
    PL_XPosix_ptrs[_CC_SPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXSPACE]);
    PL_XPosix_ptrs[_CC_UPPER] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXUPPER]);
    PL_XPosix_ptrs[_CC_VERTSPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_VERTSPACE]);
    PL_XPosix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXWORD]);
    PL_XPosix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_XPOSIXXDIGIT]);

    PL_Posix_ptrs[_CC_ASCII] = _new_invlist_C_array(uni_prop_ptrs[UNI_ASCII]);
    PL_Posix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXALNUM]);
    PL_Posix_ptrs[_CC_ALPHA] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXALPHA]);
    PL_Posix_ptrs[_CC_BLANK] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXBLANK]);
    PL_Posix_ptrs[_CC_CASED] = PL_Posix_ptrs[_CC_ALPHA];
    PL_Posix_ptrs[_CC_CNTRL] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXCNTRL]);
    PL_Posix_ptrs[_CC_DIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXDIGIT]);
    PL_Posix_ptrs[_CC_GRAPH] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXGRAPH]);
    PL_Posix_ptrs[_CC_LOWER] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXLOWER]);
    PL_Posix_ptrs[_CC_PRINT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXPRINT]);
    PL_Posix_ptrs[_CC_PUNCT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXPUNCT]);
    PL_Posix_ptrs[_CC_SPACE] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXSPACE]);
    PL_Posix_ptrs[_CC_UPPER] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXUPPER]);
    PL_Posix_ptrs[_CC_VERTSPACE] = NULL;
    PL_Posix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXWORD]);
    PL_Posix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(uni_prop_ptrs[UNI_POSIXXDIGIT]);

    PL_GCB_invlist = _new_invlist_C_array(_Perl_GCB_invlist);
    PL_SB_invlist = _new_invlist_C_array(_Perl_SB_invlist);
    PL_WB_invlist = _new_invlist_C_array(_Perl_WB_invlist);
    PL_LB_invlist = _new_invlist_C_array(_Perl_LB_invlist);
    PL_SCX_invlist = _new_invlist_C_array(_Perl_SCX_invlist);

    PL_AboveLatin1 = _new_invlist_C_array(AboveLatin1_invlist);
    PL_Latin1 = _new_invlist_C_array(Latin1_invlist);
    PL_UpperLatin1 = _new_invlist_C_array(UpperLatin1_invlist);

    PL_Assigned_invlist = _new_invlist_C_array(uni_prop_ptrs[UNI_ASSIGNED]);

    PL_utf8_perl_idstart = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_IDSTART]);
    PL_utf8_perl_idcont = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_IDCONT]);

    PL_utf8_charname_begin = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_CHARNAME_BEGIN]);
    PL_utf8_charname_continue = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_CHARNAME_CONTINUE]);

    PL_in_some_fold = _new_invlist_C_array(uni_prop_ptrs[UNI__PERL_ANY_FOLDS]);
    PL_HasMultiCharFold = _new_invlist_C_array(uni_prop_ptrs[
                                            UNI__PERL_FOLDS_TO_MULTI_CHAR]);
    PL_InMultiCharFold = _new_invlist_C_array(uni_prop_ptrs[
                                            UNI__PERL_IS_IN_MULTI_CHAR_FOLD]);
    PL_NonFinalFold = _new_invlist_C_array(uni_prop_ptrs[
                                            UNI__PERL_NON_FINAL_FOLDS]);

    PL_utf8_toupper = _new_invlist_C_array(Uppercase_Mapping_invlist);
    PL_utf8_tolower = _new_invlist_C_array(Lowercase_Mapping_invlist);
    PL_utf8_totitle = _new_invlist_C_array(Titlecase_Mapping_invlist);
    PL_utf8_tofold = _new_invlist_C_array(Case_Folding_invlist);
    PL_utf8_tosimplefold = _new_invlist_C_array(Simple_Case_Folding_invlist);
    PL_utf8_foldclosures = _new_invlist_C_array(_Perl_IVCF_invlist);
    PL_utf8_mark = _new_invlist_C_array(uni_prop_ptrs[UNI_M]);
    PL_CCC_non0_non230 = _new_invlist_C_array(_Perl_CCC_non0_non230_invlist);
    PL_Private_Use = _new_invlist_C_array(uni_prop_ptrs[UNI_CO]);







}

SV *
fn_504(pTHX_

    const char * var_538,
    const STRLEN var_538,
    const bool var_538,
    const bool var_538,
    const bool var_538,
    const bool var_538,

    SV* contents,
    bool *user_defined_ptr,


    SV * msg,

    const STRLEN var_538)
{
    STRLEN var_531;
    const char * var_512 = SvPV_const(contents, var_531);
    const char * const var_512 = var_512 + var_531;
    const bool var_512 = cBOOL(SvUTF8(contents));
    const STRLEN var_512 = SvCUR(msg);

    const char * var_512 = var_512;

    const char overflow_msg[] = "Code point too large in \"";
    SV* running_definition = NULL;

    PERL_ARGS_ASSERT_HANDLE_USER_DEFINED_PROPERTY;

    *user_defined_ptr = TRUE;


    while (var_512 < var_512) {
        const char * var_512;
        char var_512 = '+';
        IV var_512 = 0;
        IV var_512 = -1;
        SV* this_definition;


        if (*var_512 == '#') {
            var_512 = strchr(var_512, '\n');
            if (var_512 == NULL) {
                break;
            }
            var_512++;
            continue;
        }


        if (*var_512 == '\n') {
            var_512++;
            continue;
        }


        if ( *var_512 == '+'
            || *var_512 == '!'
            || *var_512 == '-'
            || *var_512 == '&')
        {
            var_512 = *var_512++;
        }





        var_512 = var_512;

        if (! isXDIGIT(*var_512)) {
            goto check_if_property;
        }

        do {
            if (var_512 > ( (IV) MAX_LEGAL_CP >> 4)) {
                var_512 = strchr(var_512, '\n');
                if (var_512 == NULL) {
                    var_512 = var_512;
                }
                if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                sv_catpv(msg, overflow_msg);
                Perl_sv_catpvf(aTHX_ msg, "%" UTF8f,
                                     UTF8fARG(var_512, var_512 - var_512, var_512));
                sv_catpvs(msg, "\"");
                goto return_failure;
            }


            var_512 = (var_512 << 4) + READ_XDIGIT(var_512);
        } while (isXDIGIT(*var_512));

        while (isBLANK(*var_512)) { var_512++; }


        if (*var_512 == '#') {
            var_512 = strchr(var_512, '\n');
            if (var_512 == NULL) {
                var_512 = var_512;
            }
            var_512++;
        }
        else if (var_512 < var_512 && *var_512 != '\n') {
            if (! isXDIGIT(*var_512)) {
                goto check_if_property;
            }


            var_512 = 0;
            do {
                if (var_512 > ( (IV) MAX_LEGAL_CP >> 4)) {
                    var_512 = strchr(var_512, '\n');
                    if (var_512 == NULL) {
                        var_512 = var_512;
                    }
                    if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                    sv_catpv(msg, overflow_msg);
                    Perl_sv_catpvf(aTHX_ msg, "%" UTF8f,
                                      UTF8fARG(var_512, var_512 - var_512, var_512));
                    sv_catpvs(msg, "\"");
                    goto return_failure;
                }

                var_512 = (var_512 << 4) + READ_XDIGIT(var_512);
            } while (isXDIGIT(*var_512));

            while (isBLANK(*var_512)) { var_512++; }

            if (*var_512 == '#') {
                var_512 = strchr(var_512, '\n');
                if (var_512 == NULL) {
                    var_512 = var_512;
                }
            }
            else if (var_512 < var_512 && *var_512 != '\n') {
                goto check_if_property;
            }
        }

        if (var_512 == -1) {
            var_512 = var_512;
        }
        else if (var_512 < var_512) {
            if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
            sv_catpvs(msg, "Illegal range in \"");
            Perl_sv_catpvf(aTHX_ msg, "%" UTF8f,
                                UTF8fARG(var_512, var_512 - var_512, var_512));
            sv_catpvs(msg, "\"");
            goto return_failure;
        }

        this_definition = sv_2mortal(_new_invlist(2));
        this_definition = _add_range_to_invlist(this_definition, var_512, var_512);
        goto calculate;

      check_if_property:



        var_512 = strpbrk(var_512, "#\n");
        if (var_512 == NULL) {
            var_512 = var_512;
        }



        var_512--;
        while (var_512 > var_512 && isBLANK_A(*var_512)) {
            var_512--;
        }
        var_512++;

        this_definition = parse_uniprop_string(var_512, var_512 - var_512,
                                               var_538, var_538, var_538,
                                               var_538,
                                               user_defined_ptr, msg,
                                               (var_538 == 0)
                                                ? var_538

                                                : var_538 + 1
                                              );
        if (this_definition == NULL) {
            goto return_failure;

        }

        if (! is_invlist(this_definition)) {
            return newSVsv(this_definition);
        }

        if (*var_512 != '\n') {
            var_512 = strchr(var_512, '\n');
            if (var_512 == NULL) {
                var_512 = var_512;
            }
        }

      calculate:

        switch (var_512) {
            case '+':
                _invlist_union(running_definition, this_definition,
                                                        &running_definition);
                break;
            case '-':
                _invlist_subtract(running_definition, this_definition,
                                                        &running_definition);
                break;
            case '&':
                _invlist_intersection(running_definition, this_definition,
                                                        &running_definition);
                break;
            case '!':
                _invlist_union_maybe_complement_2nd(running_definition, this_definition, TRUE, &running_definition);

                break;
            default:
                Perl_croak(aTHX_ "panic: %s: %d: Unexpected operation %d",
                                 "/tmp/tmpx56_5x7n.c", 22497, var_512);
                break;
        }


        var_512 = var_512 + 1;
    }



    if (var_512 == SvCUR(msg)) {



        if (running_definition == NULL) {
            running_definition = _new_invlist(1);
        }

        return running_definition;
    }


    goto return_msg;

  return_failure:
    running_definition = NULL;

  return_msg:

    if (var_538 > 0) {
        sv_catpvs(msg, " in expansion of ");
        Perl_sv_catpvf(aTHX_ msg, "%" UTF8f, fn_538(is_utf8, name_len, name));
    }

    return running_definition;
}

static void
fn_513(pTHX_ void *var_533)
{




    dVAR;
    SV ** current_entry;
    const STRLEN var_515 = strlen((const char *) var_533);
                                  ;

    NOOP;




    current_entry = hv_fetch(PL_user_def_props, (const char *) var_533, var_515, 0);
    if ( current_entry
        && ! is_invlist(*current_entry)
        && ! SvPOK(*current_entry))
    {
        (void) hv_delete(PL_user_def_props, (const char *) var_533, var_515,
                                                                    G_DISCARD);
    }

    NOOP;
}

static SV *
fn_515(pTHX_
              const char * const var_538,
              const Size_t var_538,
              const bool var_538,
              const bool var_517
             )
{



    SV * fq_name;

    fq_name = newSVpvs_flags("", SVs_TEMP);


    if (! var_517) {
        const HV * pkg = (IN_PERL_COMPILETIME)
                         ? PL_curstash
                         : CopSTASH(PL_curcop);
        const char* pkgname = HvNAME(pkg);

        Perl_sv_catpvf(aTHX_ fq_name, "%" UTF8f,
                      fn_538(is_utf8, strlen(pkgname), pkgname));
        sv_catpvs(fq_name, "::");
    }

    Perl_sv_catpvf(aTHX_ fq_name, "%" UTF8f,
                         fn_538(is_utf8, name_len, name));
    return fq_name;
}

SV *
fn_517(pTHX_

    const char * const var_538,
    const Size_t var_538,

    const bool var_538,
    const bool var_538,
    const bool var_538,
    const bool var_538,

    bool *user_defined_ptr,


    SV * msg,

   const STRLEN var_538)
{
    dVAR;
    char* lookup_name;
    unsigned lookup_len;
    bool var_531 = FALSE;






    bool var_533 = FALSE;

    unsigned int var_531, var_533 = 0;
    int var_537 = -1;
    int var_537 = -1;
    int var_538 = 0;

    bool var_533 = FALSE;

    Size_t var_531 = 0;

    Size_t var_538 = 0;

    bool var_533 = TRUE;


    SV * prop_definition = NULL;




    SV * fq_name = NULL;

    bool var_538 = FALSE;


    PERL_ARGS_ASSERT_PARSE_UNIPROP_STRING;


    Newx(lookup_name, var_538, char);
    SAVEFREEPV(lookup_name);


    for (var_531 = 0; var_531 < var_538; var_531++) {
        char var_531 = var_538[var_531];



        if (isIDCONT_A(var_531)) {



            if (isUPPER_A(var_531)) {
                lookup_name[var_533++] = toLOWER_A(var_531);
                continue;
            }

            if (var_531 == '_') {
                continue;
            }

            lookup_name[var_533++] = var_531;



            if (var_531 - var_538 == 0 && ! isIDFIRST_A(var_531)) {
                var_533 = FALSE;
            }

            continue;
        }






        if (var_531 == '-' || isSPACE_A(var_531)) {
            var_533 = FALSE;
            continue;
        }



        if ( var_531 == '='
            || (var_531 == ':' && (var_531 >= var_538 - 1 || var_538[var_531+1] != ':')))
        {
            lookup_name[var_533++] = '=';
            var_537 = var_533;
            var_533 = FALSE;
            break;
        }


        lookup_name[var_533++] = var_531;



        if (var_531 == ':') {







            var_531++;
            var_538 = var_531 + 1;
            lookup_name[var_533++] = ':';
        }
        else {
            var_533 = FALSE;
        }
    }

    if (var_538 == (sizeof("" "utf8::" "") - 1) && memBEGINPs(var_538, var_538, "utf8::")) {
        lookup_name += (sizeof("" "utf8::" "") - 1);
        var_533 -= (sizeof("" "utf8::" "") - 1);
        var_537 -= (sizeof("" "utf8::" "") - 1);
    }




    if (var_537 >= 0) {
        assert(! var_531);


        var_531++;
        for (; var_531 < var_538; var_531++) {
            if (! isSPACE_A(var_538[var_531])) {
                break;
            }
        }



        if ( isPUNCT_A(var_538[var_531])
            && var_538[var_531] != '-'
            && var_538[var_531] != '+'
            && var_538[var_531] != '_'
            && var_538[var_531] != '{')
        {


            var_538 = match_uniprop((U8 *) lookup_name, var_533);
            if (var_538) {
                const char * const * prop_values
                                            = UNI_prop_value_ptrs[var_538];
                SV * subpattern;
                Size_t subpattern_len;
                REGEXP * subpattern_re;
                char var_530 = var_538[var_531++];
                char close;
                const char * pos_in_brackets;
                bool var_530 = 0;



                if (var_530 == '\\') {
                    var_530 = var_538[var_531++];
                    var_530 = 1;
                }






                pos_in_brackets = strchr("([<)]>)]>", var_530);
                close = (pos_in_brackets) ? pos_in_brackets[3] : var_530;

                if ( var_531 >= var_538
                    || var_538[var_538-1] != close
                    || (var_530 && var_538[var_538-2] != '\\'))
                {
                    sv_catpvs(msg, "Unicode property wildcard not terminated");
                    goto append_name_to_msg;
                }

                Perl_ck_warner_d(aTHX_
                    fn_538(WARN_EXPERIMENTAL__UNIPROP_WILDCARDS),
                    "The Unicode property wildcards feature is experimental");







                subpattern_len = var_538 - var_531 - 1 - var_530;
                subpattern = Perl_newSVpvf(aTHX_ "(?iaa:%.*s)",
                                              (unsigned) subpattern_len,
                                              var_538 + var_531);
                subpattern = sv_2mortal(subpattern);
                subpattern_re = re_compile(subpattern, 0);
                assert(subpattern_re);




                while (*prop_values) {
                    const char * const entry = *prop_values;
                    const Size_t var_531 = strlen(entry);
                    SV* entry_sv = newSVpvn_flags(entry, var_531, SVs_TEMP);

                    if (pregexec(subpattern_re,
                                 (char *) entry,
                                 (char *) entry + var_531,
                                 (char *) entry, 0,
                                 entry_sv,
                                 0))
                    {
                        Size_t var_531 = var_533 + var_531;
                        SV * sub_invlist = NULL;
                        char * this_string;




                        Newxz(this_string, var_531 + 1, char);
                        Copy(lookup_name, this_string, var_533, char);
                        my_strlcat(this_string, entry, var_531 + 1);
                        SAVEFREEPV(this_string);
                        sub_invlist = parse_uniprop_string(this_string,
                                                           var_531,
                                                           var_538,
                                                           var_538,
                                                           var_538,
                                                           var_538,
                                                           user_defined_ptr,
                                                           msg,
                                                           var_538 + 1);
                        _invlist_union(prop_definition, sub_invlist,
                                       &prop_definition);
                    }

                    prop_values++;
                }


                SvREFCNT_dec_NN(subpattern_re);

                if (prop_definition) {
                    return prop_definition;
                }

                sv_catpvs(msg, "No Unicode property value wildcard matches:");
                goto append_name_to_msg;
            }

        }





        if (memBEGINPs(lookup_name, var_533, "is")) {
            var_531 = 2;
        }

        var_533 = memEQs(lookup_name + var_531,
                       var_533 - 1 - var_531, "numericvalue")
                  || memEQs(lookup_name + var_531,
                      var_533 - 1 - var_531, "nv")
                  || ( memENDPs(lookup_name + var_531,
                            var_533 - 1 - var_531, "numeric")
                      && ( memBEGINPs(lookup_name + var_531,
                                      var_533 - 1 - var_531, "cjk")
                          || memBEGINPs(lookup_name + var_531,
                                      var_533 - 1 - var_531, "k")));
        if ( var_533
            || memEQs(lookup_name + var_531,
                      var_533 - 1 - var_531, "canonicalcombiningclass")
            || memEQs(lookup_name + var_531,
                      var_533 - 1 - var_531, "ccc")
            || memEQs(lookup_name + var_531,
                      var_533 - 1 - var_531, "age")
            || memEQs(lookup_name + var_531,
                      var_533 - 1 - var_531, "in")
            || memEQs(lookup_name + var_531,
                      var_533 - 1 - var_531, "presentin"))
        {
            unsigned int k;

            var_531 = TRUE;
            for (k = var_531; k < var_538; k++) {
                if ( isALPHA_A(var_538[k])
                    && (! var_533 || ! isALPHA_FOLD_EQ(var_538[k], 'E')))
                {
                    var_531 = FALSE;
                    break;
                }
            }
        }

        if (var_531) {



            if (var_538[var_531] == '+') {
                var_531++;
            }
            else if (var_538[var_531] == '-') {
                lookup_name[var_533++] = '-';
                var_531++;
            }




            for (; var_531 < var_538 - 1; var_531++) {
                if ( var_538[var_531] != '0'
                    && (var_538[var_531] != '_' || ! isDIGIT_A(var_538[var_531+1])))
                {
                    break;
                }
            }
        }
    }
    else {



        if ( memBEGINPs(lookup_name, var_533, "perl")
            && memNEs(lookup_name + 4, var_533 - 4, "space")
            && memNEs(lookup_name + 4, var_533 - 4, "word"))
        {
            var_531 = TRUE;



            var_531 = var_533 = 0;
        }
    }




    for (; var_531 < var_538; var_531++) {
        char var_531 = var_538[var_531];



        if (isUPPER_A(var_531)) {
            lookup_name[var_533++] = toLOWER(var_531);
            continue;
        }



        if (var_531 == '_') {
            if ( var_531
                && ( var_531 == 0 || (int) var_531 == var_537 || var_531 == var_538- 1
                    || ! isDIGIT_A(var_538[var_531-1]) || ! isDIGIT_A(var_538[var_531+1])))
            {
                lookup_name[var_533++] = '_';
            }
            continue;
        }


        if (var_531 == '-' && ! var_531) {
            continue;
        }




        if (isSPACE_A(var_531) && ! var_531) {
            continue;
        }

        lookup_name[var_533++] = var_531;


        if (var_531 >= var_538 - 1 || var_531 != '/') {
            continue;
        }

        var_537 = var_533;






        if (var_533) {
            var_531++;
            if (var_531 < var_538 && var_538[var_531] == '+') {
                var_531++;
            }


            for (; var_531 < var_538 - 1; var_531++) {
                if ( var_538[var_531] != '0'
                    && (var_538[var_531] != '_' || ! isDIGIT_A(var_538[var_531+1])))
                {
                    break;
                }
            }


            lookup_name[var_533++] = var_538[var_531];
        }
    }






    if ( ( UNLIKELY(memEQs(lookup_name, var_533, "l"))
           || UNLIKELY(memEQs(lookup_name, var_533, "gc=l")))
        && UNLIKELY(var_538[var_538-1] == '_'))
    {
        lookup_name[var_533++] = '&';
    }



    if ( var_538 + var_538 > 2
        && var_538[var_538+0] == 'I'
        && (var_538[var_538+1] == 'n' || var_538[var_538+1] == 's'))
    {
        var_533 = TRUE;
    }
    else {
        var_533 = FALSE;
    }

    if (var_533) {
        CV* user_sub;







        bool var_533 = FALSE;



        user_sub = get_cvn_flags(var_538, var_538, 0);
        if (user_sub) {
            const char insecure[] = "Insecure user-defined property";



            dSP;
            SV * user_sub_sv = MUTABLE_SV(user_sub);
            SV * error;
            SV * var_533;

            SV * placeholder;
            SV ** saved_user_prop_ptr;



            PERL_INT_FAST8_T var_533 = 10;

                                          ;


            *user_defined_ptr = TRUE;



            if (var_538) {
                if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                sv_catpvn(msg, insecure, sizeof(insecure) - 1);
                goto append_name_to_msg;
            }

            var_533 = newSVpvn(((var_538) ? "1" : "0"), 1);
            fq_name = S_get_fq_name(aTHX_ var_538, var_538, var_538,
                                          var_538 != 0);
            sv_catsv(var_533, fq_name);
            sv_2mortal(var_533);

          re_fetch:
            USER_PROP_MUTEX_LOCK;



            saved_user_prop_ptr = hv_fetch(PL_user_def_props,
                                                   SvPVX(var_533), SvCUR(var_533), 0);
            if (saved_user_prop_ptr) {



                if (is_invlist(*saved_user_prop_ptr)) {
                    prop_definition = *saved_user_prop_ptr;



                    USER_PROP_MUTEX_UNLOCK;


                    return prop_definition;
                }




                if (SvPOK(*saved_user_prop_ptr)) {
                    if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                    sv_catsv(msg, *saved_user_prop_ptr);



                    USER_PROP_MUTEX_UNLOCK;

                    return NULL;
                }

                assert(SvIOK(*saved_user_prop_ptr));





                if (SvIV(*saved_user_prop_ptr) != PTR2IV(NULL)) {




                    USER_PROP_MUTEX_UNLOCK;


                    if (var_533-- > 0) {
                        PerlProc_sleep(1);
                        goto re_fetch;
                    }

                    if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                    sv_catpvs(msg, "Timeout waiting for another thread to "
                                   "define");
                    goto append_name_to_msg;
                }


                USER_PROP_MUTEX_UNLOCK;

                if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                sv_catpvs(msg,
                          "Infinite recursion in user-defined property");
                goto append_name_to_msg;
            }





            PUSHSTACKi(PERLSI_MAGIC);
            ENTER;



            NOOP;
            placeholder= newSVuv(PTR2IV(NULL));
            (void) hv_store_ent(PL_user_def_props, var_533, placeholder, 0);
            NOOP;



            USER_PROP_MUTEX_UNLOCK;


            SAVEDESTRUCTOR_X(S_delete_recursion_entry, SvPVX(var_533));

            PUSHMARK(SP);
            SAVETMPS;




            XPUSHs(boolSV(var_538));
            PUTBACK;




            SAVEHINTS();
            save_re_context();



            save_item(PL_subname);

            (void) call_sv(user_sub_sv, G_EVAL|G_SCALAR);

            SPAGAIN;

            error = var_533;
            if (var_538 || SvTRUE(error)) {
                if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                if (SvTRUE(error)) {
                    sv_catpvs(msg, "Error \"");
                    sv_catsv(msg, error);
                    sv_catpvs(msg, "\"");
                }
                if (var_538) {
                    if (SvTRUE(error)) sv_catpvs(msg, "; ");
                    sv_catpvn(msg, insecure, sizeof(insecure) - 1);
                }

                if (var_538 > 0) {
                    sv_catpvs(msg, " in expansion of ");
                    Perl_sv_catpvf(aTHX_ msg, "%" UTF8f, fn_538(is_utf8,
                                                                  name_len,
                                                                  name));
                }

                (void) var_533;
                prop_definition = NULL;
            }
            else {
                SV * contents = var_533;





                if ( var_538
                    && (! SvPOK(contents) || SvCUR(contents) == 0))
                {
                        var_533 = TRUE;
                }
                else {


                    prop_definition = handle_user_defined_property(
                                                    var_538, var_538,
                                                    var_538, var_538, var_538,
                                                    var_538,
                                                    contents, user_defined_ptr,
                                                    msg,
                                                    var_538);
                }
            }






            USER_PROP_MUTEX_LOCK;

            S_delete_recursion_entry(aTHX_ SvPVX(key));

            if ( ! var_533
                && (! prop_definition || is_invlist(prop_definition)))
            {


                NOOP;
                (void) hv_store_ent(PL_user_def_props,
                                    var_533,
                                    ((prop_definition)
                                     ? newSVsv(prop_definition)
                                     : newSVsv(msg)),
                                    0);
                NOOP;
            }



            USER_PROP_MUTEX_UNLOCK;

            FREETMPS;
            LEAVE;
            POPSTACK;

            if (var_533) {
                goto definition_deferred;
            }

            if (prop_definition) {




                if (! is_invlist(prop_definition)) {
                    SvREFCNT_dec_NN(prop_definition);
                    goto definition_deferred;
                }

                sv_2mortal(prop_definition);
            }


            return prop_definition;

        }
    }




    lookup_len = var_533;



    var_538 = match_uniprop((U8 *) lookup_name, lookup_len);


    if (var_538 == 0) {


        if (var_533) {
            lookup_name += 2;
            lookup_len -= 2;
            var_537 -= 2;
            var_537 -= 2;

            var_538 = match_uniprop((U8 *) lookup_name, lookup_len);
        }

        if (var_538 == 0) {
            char * canonical;



            if (! var_533) {
                if (! var_533) {
                    goto failed;
                }





                if (! var_538) {
                    if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                    sv_catpvs(msg, "Unknown user-defined property name");
                    goto append_name_to_msg;
                }

                goto definition_deferred;
            }





            if (var_537 < 0) {





                NV var_533;
                SSize_t var_533 = lookup_len - var_537;


                if ( var_533 <= 0
                    || my_atof3(lookup_name + var_537, &var_533,
                                var_533)
                          != lookup_name + lookup_len)
                {
                    goto failed;
                }



                if (Perl_ceil(var_533) == var_533) {
                    canonical = Perl_form(aTHX_ "%.*s%.0" NVff,
                                            var_537, lookup_name, var_533);
                }
                else {
                    char * exp_ptr;

                    canonical = Perl_form(aTHX_ "%.*s%.*" NVef,
                                                var_537, lookup_name,
                                                PL_E_FORMAT_PRECISION, var_533);





                    exp_ptr = strchr(canonical + var_537, 'e');
                    if (exp_ptr) {
                        char * cur_ptr = exp_ptr + 2;
                        SSize_t var_536 = strlen(cur_ptr) - 2;

                        assert(*(cur_ptr - 1) == '-' || *(cur_ptr - 1) == '+');

                        if (var_536 > 0) {
                            SSize_t var_536 = strspn(cur_ptr, "0");
                            SSize_t var_536
                                    = MIN(var_536, var_536);
                            if (var_536 > 0) {
                                Move(cur_ptr + var_536,
                                     cur_ptr,
                                     strlen(cur_ptr) - var_536
                                       + 1,
                                     char);
                            }
                        }
                    }
                }
            }
            else {
                UV numerator, denominator, gcd, var_537;
                const char * end_ptr;
                const char * sign = "";

                const char * this_lookup_name = lookup_name + var_537;
                lookup_len -= var_537;
                var_537 -= var_537;


                if (this_lookup_name[0] == '-') {
                    sign = "-";
                    this_lookup_name++;
                    lookup_len--;
                    var_537--;
                }


                end_ptr = this_lookup_name + var_537;
                if (! grok_atoUV(this_lookup_name, &numerator, &end_ptr)) {
                    goto failed;
                }


                if (*end_ptr != '/') {
                    goto failed;
                }


                this_lookup_name += var_537;
                lookup_len -= var_537;
                end_ptr = this_lookup_name + lookup_len;


                if (! grok_atoUV(this_lookup_name, &denominator, &end_ptr)) {
                    goto failed;
                }



                if ( end_ptr != this_lookup_name + lookup_len
                    || denominator == 0)
                {
                    goto failed;
                }



                gcd = numerator;
                var_537 = denominator;
                while (var_537 != 0) {
                    UV var_537 = var_537;
                    var_537 = gcd % var_537;
                    gcd = var_537;
                }



                if (gcd == 1) {
                    goto failed;
                }



                numerator /= gcd;
                denominator /= gcd;

                canonical = Perl_form(aTHX_ "%.*s%s%" UVuf "/%" UVuf,
                        var_537, lookup_name, sign, numerator, denominator);
            }


            var_538 = match_uniprop((U8 *) canonical, strlen(canonical));
            if (var_538 == 0) {
                goto failed;
            }
        }
    }




    if (var_538 < 0) {
        var_538 = TRUE;
        var_538 = -var_538;
    }





    if (var_538 > MAX_UNI_KEYWORD_INDEX) {
        Size_t var_538 = var_538 / MAX_UNI_KEYWORD_INDEX;
        var_538 %= MAX_UNI_KEYWORD_INDEX;
        Perl_ck_warner_d(aTHX_ fn_538(WARN_DEPRECATED),
                "Use of '%.*s' in \\p{} or \\P{} is deprecated because: %s",
                (int) var_538, var_538, deprecated_property_msgs[var_538]);
    }



    if (var_538) {
        if ( var_538 == UNI_XPOSIXUPPER
            || var_538 == UNI_XPOSIXLOWER
            || var_538 == UNI_TITLE)
        {
            var_538 = UNI_CASED;
        }
        else if ( var_538 == UNI_UPPERCASELETTER
                 || var_538 == UNI_LOWERCASELETTER



        ) {
            var_538 = UNI_CASEDLETTER;
        }
        else if ( var_538 == UNI_POSIXUPPER
                || var_538 == UNI_POSIXLOWER)
        {
            var_538 = UNI_POSIXALPHA;
        }
    }


    prop_definition =_new_invlist_C_array(uni_prop_ptrs[var_538]);
    sv_2mortal(prop_definition);



    {
        COPHH * hinthash = (IN_PERL_COMPILETIME)
                           ? CopHINTHASH_get(&PL_compiling)
                           : CopHINTHASH_get(PL_curcop);
 SV * pu_overrides = cophh_fetch_pv(hinthash, "private_use", 0, 0);

        if (UNLIKELY(pu_overrides && SvPOK(pu_overrides))) {


            SV * pu_lookup = Perl_newSVpvf(aTHX_ "%d=", var_538);
            const char * var_538 = strstr(SvPVX(pu_overrides), SvPVX(pu_lookup));

            if (var_538) {
                bool dummy;
                SV * pu_definition;
                SV * pu_invlist;
                SV * expanded_prop_definition =
                            sv_2mortal(invlist_clone(prop_definition, NULL));




                var_538 += SvCUR(pu_lookup);
                pu_definition = newSVpvn(var_538, strchr(var_538, '\a') - var_538);
                pu_invlist = handle_user_defined_property(lookup_name,
                                                          lookup_len,
                                                          0,
                                                          0,
                                                          var_538,
                                                          var_538,
                                                          pu_definition,
                                                          &dummy,
                                                          msg,
                                                          var_538);
                if (var_538) {
                    if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
                    sv_catpvs(msg, "Insecure private-use override");
                    goto append_name_to_msg;
                }



                _invlist_intersection(pu_invlist, PL_Private_Use, &pu_invlist);


                _invlist_union(prop_definition, pu_invlist,
                               &expanded_prop_definition);
                prop_definition = expanded_prop_definition;
                Perl_ck_warner_d(aTHX_ fn_538(WARN_EXPERIMENTAL__PRIVATE_USE), "The private_use feature is experimental");
            }
        }
    }

    if (var_538) {
        _invlist_invert(prop_definition);
    }
    return prop_definition;


  failed:
    if (var_538 != 0) {
        if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
        sv_catpvs(msg, "Illegal user-defined property name");
    }
    else {
        if (SvCUR(msg) > 0) sv_catpvs(msg, "; ");
        sv_catpvs(msg, "Can't find Unicode property definition");
    }


  append_name_to_msg:
    {
        const char * prefix = (var_538 && var_538 == 0) ? " \\p{" : " \"";
        const char * suffix = (var_538 && var_538 == 0) ? "}" : "\"";

        sv_catpv(msg, prefix);
        Perl_sv_catpvf(aTHX_ msg, "%" UTF8f, fn_538(is_utf8, name_len, name));
        sv_catpv(msg, suffix);
    }

    return NULL;

  definition_deferred:




    if (! fq_name) {
        fq_name = S_get_fq_name(aTHX_ var_538, var_538, var_538,
                                      var_538 != 0
                               );
    }
    sv_catpvs(fq_name, "\n");

    *user_defined_ptr = TRUE;
    return fq_name;
}
