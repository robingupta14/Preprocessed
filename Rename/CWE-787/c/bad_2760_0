







static int fn_0(int var_62)
{
    int l;
    for (l = 0; var_62 > 1; l++) {
        var_62 >>= 1;
    }
    return l;
}


void fn_2(opj_image_comp_t* component, OPJ_UINT32 var_11)
{
    OPJ_SIZE_T i;
    OPJ_SIZE_T len;
    OPJ_UINT32 var_7 = (OPJ_UINT32)((OPJ_INT32) - 1);

    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;
    if (var_11 < 32) {
        var_7 = (1U << var_11) - 1U;
    }

    if (component->sgnd) {
        OPJ_INT32* l_data = component->data;
        OPJ_INT32 var_89 = (OPJ_INT32)(var_7 / 2U);
        OPJ_INT32 var_7 = -var_89 - 1;
        for (i = 0; i < len; ++i) {
            if (l_data[i] > var_89) {
                l_data[i] = var_89;
            } else if (l_data[i] < var_7) {
                l_data[i] = var_7;
            }
        }
    } else {
        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;
        for (i = 0; i < len; ++i) {
            if (l_data[i] > var_7) {
                l_data[i] = var_7;
            }
        }
    }
    component->prec = var_11;
}


static void fn_7(opj_image_comp_t* component,
                               OPJ_UINT32 var_11)
{
    OPJ_SIZE_T i, len;

    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;
    if (component->sgnd) {
        OPJ_INT64 var_10 = (OPJ_INT64)(1U << (var_11 - 1));
        OPJ_INT64 var_10 = (OPJ_INT64)(1U << (component->prec - 1));
        OPJ_INT32* l_data = component->data;
        for (i = 0; i < len; ++i) {
            l_data[i] = (OPJ_INT32)(((OPJ_INT64)l_data[i] * var_10) / var_10);
        }
    } else {
        OPJ_UINT64 var_10 = (OPJ_UINT64)((1U << var_11) - 1U);
        OPJ_UINT64 var_10 = (OPJ_UINT64)((1U << component->prec) - 1U);
        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;
        for (i = 0; i < len; ++i) {
            l_data[i] = (OPJ_UINT32)(((OPJ_UINT64)l_data[i] * var_10) / var_10);
        }
    }
    component->prec = var_11;
    component->bpp = var_11;
}
void fn_10(opj_image_comp_t* component, OPJ_UINT32 var_11)
{
    int shift;
    OPJ_SIZE_T i, len;

    if (component->prec == var_11) {
        return;
    }
    if (component->prec < var_11) {
        scale_component_up(component, var_11);
        return;
    }
    shift = (int)(component->prec - var_11);
    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;
    if (component->sgnd) {
        OPJ_INT32* l_data = component->data;
        for (i = 0; i < len; ++i) {
            l_data[i] >>= shift;
        }
    } else {
        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;
        for (i = 0; i < len; ++i) {
            l_data[i] >>= shift;
        }
    }
    component->bpp = var_11;
    component->prec = var_11;
}




static void fn_11(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,
                             OPJ_SIZE_T var_43)
{
    memcpy(pDst[0], pSrc, var_43 * sizeof(OPJ_INT32));
}
static void fn_13(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,
                             OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    OPJ_INT32* pDst0 = pDst[0];
    OPJ_INT32* pDst1 = pDst[1];

    for (i = 0; i < var_43; i++) {
        pDst0[i] = pSrc[2 * i + 0];
        pDst1[i] = pSrc[2 * i + 1];
    }
}
static void fn_14(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,
                             OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    OPJ_INT32* pDst0 = pDst[0];
    OPJ_INT32* pDst1 = pDst[1];
    OPJ_INT32* pDst2 = pDst[2];

    for (i = 0; i < var_43; i++) {
        pDst0[i] = pSrc[3 * i + 0];
        pDst1[i] = pSrc[3 * i + 1];
        pDst2[i] = pSrc[3 * i + 2];
    }
}
static void fn_15(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,
                             OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    OPJ_INT32* pDst0 = pDst[0];
    OPJ_INT32* pDst1 = pDst[1];
    OPJ_INT32* pDst2 = pDst[2];
    OPJ_INT32* pDst3 = pDst[3];

    for (i = 0; i < var_43; i++) {
        pDst0[i] = pSrc[4 * i + 0];
        pDst1[i] = pSrc[4 * i + 1];
        pDst2[i] = pSrc[4 * i + 2];
        pDst3[i] = pSrc[4 * i + 3];
    }
}
const convert_32s_CXPX convert_32s_CXPX_LUT[5] = {
    NULL,
    convert_32s_C1P1,
    convert_32s_C2P2,
    convert_32s_C3P3,
    convert_32s_C4P4
};

static void fn_16(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,
                             OPJ_SIZE_T var_43, OPJ_INT32 var_21)
{
    OPJ_SIZE_T i;
    const OPJ_INT32* pSrc0 = pSrc[0];

    for (i = 0; i < var_43; i++) {
        pDst[i] = pSrc0[i] + var_21;
    }
}
static void fn_18(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,
                             OPJ_SIZE_T var_43, OPJ_INT32 var_21)
{
    OPJ_SIZE_T i;
    const OPJ_INT32* pSrc0 = pSrc[0];
    const OPJ_INT32* pSrc1 = pSrc[1];

    for (i = 0; i < var_43; i++) {
        pDst[2 * i + 0] = pSrc0[i] + var_21;
        pDst[2 * i + 1] = pSrc1[i] + var_21;
    }
}
static void fn_19(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,
                             OPJ_SIZE_T var_43, OPJ_INT32 var_21)
{
    OPJ_SIZE_T i;
    const OPJ_INT32* pSrc0 = pSrc[0];
    const OPJ_INT32* pSrc1 = pSrc[1];
    const OPJ_INT32* pSrc2 = pSrc[2];

    for (i = 0; i < var_43; i++) {
        pDst[3 * i + 0] = pSrc0[i] + var_21;
        pDst[3 * i + 1] = pSrc1[i] + var_21;
        pDst[3 * i + 2] = pSrc2[i] + var_21;
    }
}
static void fn_20(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,
                             OPJ_SIZE_T var_43, OPJ_INT32 var_21)
{
    OPJ_SIZE_T i;
    const OPJ_INT32* pSrc0 = pSrc[0];
    const OPJ_INT32* pSrc1 = pSrc[1];
    const OPJ_INT32* pSrc2 = pSrc[2];
    const OPJ_INT32* pSrc3 = pSrc[3];

    for (i = 0; i < var_43; i++) {
        pDst[4 * i + 0] = pSrc0[i] + var_21;
        pDst[4 * i + 1] = pSrc1[i] + var_21;
        pDst[4 * i + 2] = pSrc2[i] + var_21;
        pDst[4 * i + 3] = pSrc3[i] + var_21;
    }
}
const convert_32s_PXCX convert_32s_PXCX_LUT[5] = {
    NULL,
    convert_32s_P1C1,
    convert_32s_P2C2,
    convert_32s_P3C3,
    convert_32s_P4C4
};



static void fn_21(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < (var_43 & ~(OPJ_SIZE_T)7U); i += 8U) {
        OPJ_UINT32 var_85 = *pSrc++;
        pDst[i + 0] = (OPJ_INT32)(var_85 >> 7);
        pDst[i + 1] = (OPJ_INT32)((var_85 >> 6) & 0x1U);
        pDst[i + 2] = (OPJ_INT32)((var_85 >> 5) & 0x1U);
        pDst[i + 3] = (OPJ_INT32)((var_85 >> 4) & 0x1U);
        pDst[i + 4] = (OPJ_INT32)((var_85 >> 3) & 0x1U);
        pDst[i + 5] = (OPJ_INT32)((var_85 >> 2) & 0x1U);
        pDst[i + 6] = (OPJ_INT32)((var_85 >> 1) & 0x1U);
        pDst[i + 7] = (OPJ_INT32)(var_85 & 0x1U);
    }
    if (var_43 & 7U) {
        OPJ_UINT32 var_85 = *pSrc++;
        var_43 = var_43 & 7U;
        pDst[i + 0] = (OPJ_INT32)(var_85 >> 7);

        if (var_43 > 1U) {
            pDst[i + 1] = (OPJ_INT32)((var_85 >> 6) & 0x1U);
            if (var_43 > 2U) {
                pDst[i + 2] = (OPJ_INT32)((var_85 >> 5) & 0x1U);
                if (var_43 > 3U) {
                    pDst[i + 3] = (OPJ_INT32)((var_85 >> 4) & 0x1U);
                    if (var_43 > 4U) {
                        pDst[i + 4] = (OPJ_INT32)((var_85 >> 3) & 0x1U);
                        if (var_43 > 5U) {
                            pDst[i + 5] = (OPJ_INT32)((var_85 >> 2) & 0x1U);
                            if (var_43 > 6U) {
                                pDst[i + 6] = (OPJ_INT32)((var_85 >> 1) & 0x1U);
                            }
                        }
                    }
                }
            }
        }
    }
}
static void fn_23(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < (var_43 & ~(OPJ_SIZE_T)3U); i += 4U) {
        OPJ_UINT32 var_85 = *pSrc++;
        pDst[i + 0] = (OPJ_INT32)(var_85 >> 6);
        pDst[i + 1] = (OPJ_INT32)((var_85 >> 4) & 0x3U);
        pDst[i + 2] = (OPJ_INT32)((var_85 >> 2) & 0x3U);
        pDst[i + 3] = (OPJ_INT32)(var_85 & 0x3U);
    }
    if (var_43 & 3U) {
        OPJ_UINT32 var_85 = *pSrc++;
        var_43 = var_43 & 3U;
        pDst[i + 0] = (OPJ_INT32)(var_85 >> 6);

        if (var_43 > 1U) {
            pDst[i + 1] = (OPJ_INT32)((var_85 >> 4) & 0x3U);
            if (var_43 > 2U) {
                pDst[i + 2] = (OPJ_INT32)((var_85 >> 2) & 0x3U);

            }
        }
    }
}
static void fn_24(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < (var_43 & ~(OPJ_SIZE_T)1U); i += 2U) {
        OPJ_UINT32 var_85 = *pSrc++;
        pDst[i + 0] = (OPJ_INT32)(var_85 >> 4);
        pDst[i + 1] = (OPJ_INT32)(var_85 & 0xFU);
    }
    if (var_43 & 1U) {
        OPJ_UINT8 var_85 = *pSrc++;
        pDst[i + 0] = (OPJ_INT32)(var_85 >> 4);
    }
}
static void fn_25(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < (var_43 & ~(OPJ_SIZE_T)3U); i += 4U) {
        OPJ_UINT32 var_29 = *pSrc++;
        OPJ_UINT32 var_29 = *pSrc++;
        OPJ_UINT32 var_29 = *pSrc++;
        pDst[i + 0] = (OPJ_INT32)(var_29 >> 2);
        pDst[i + 1] = (OPJ_INT32)(((var_29 & 0x3U) << 4) | (var_29 >> 4));
        pDst[i + 2] = (OPJ_INT32)(((var_29 & 0xFU) << 2) | (var_29 >> 6));
        pDst[i + 3] = (OPJ_INT32)(var_29 & 0x3FU);

    }
    if (var_43 & 3U) {
        OPJ_UINT32 var_29 = *pSrc++;
        var_43 = var_43 & 3U;
        pDst[i + 0] = (OPJ_INT32)(var_29 >> 2);

        if (var_43 > 1U) {
            OPJ_UINT32 var_29 = *pSrc++;
            pDst[i + 1] = (OPJ_INT32)(((var_29 & 0x3U) << 4) | (var_29 >> 4));
            if (var_43 > 2U) {
                OPJ_UINT32 var_29 = *pSrc++;
                pDst[i + 2] = (OPJ_INT32)(((var_29 & 0xFU) << 2) | (var_29 >> 6));
            }
        }
    }
}
static void fn_29(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < var_43; i++) {
        pDst[i] = pSrc[i];
    }
}
const convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9] = {
    NULL,
    convert_1u32s_C1R,
    convert_2u32s_C1R,
    NULL,
    convert_4u32s_C1R,
    NULL,
    convert_6u32s_C1R,
    NULL,
    convert_8u32s_C1R
};


static void fn_30(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < (var_43 & ~(OPJ_SIZE_T)7U); i += 8U) {
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 0];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 1];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 2];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 3];
        OPJ_UINT32 var_39 = (OPJ_UINT32)pSrc[i + 4];
        OPJ_UINT32 var_39 = (OPJ_UINT32)pSrc[i + 5];
        OPJ_UINT32 var_39 = (OPJ_UINT32)pSrc[i + 6];
        OPJ_UINT32 var_39 = (OPJ_UINT32)pSrc[i + 7];

        *pDst++ = (OPJ_BYTE)((var_42 << 7) | (var_42 << 6) | (var_42 << 5) | (var_42 << 4) |
                             (var_39 << 3) | (var_39 << 2) | (var_39 << 1) | var_39);
    }

    if (var_43 & 7U) {
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 0];
        OPJ_UINT32 var_42 = 0U;
        OPJ_UINT32 var_42 = 0U;
        OPJ_UINT32 var_42 = 0U;
        OPJ_UINT32 var_39 = 0U;
        OPJ_UINT32 var_39 = 0U;
        OPJ_UINT32 var_39 = 0U;
        var_43 = var_43 & 7U;

        if (var_43 > 1U) {
            var_42 = (OPJ_UINT32)pSrc[i + 1];
            if (var_43 > 2U) {
                var_42 = (OPJ_UINT32)pSrc[i + 2];
                if (var_43 > 3U) {
                    var_42 = (OPJ_UINT32)pSrc[i + 3];
                    if (var_43 > 4U) {
                        var_39 = (OPJ_UINT32)pSrc[i + 4];
                        if (var_43 > 5U) {
                            var_39 = (OPJ_UINT32)pSrc[i + 5];
                            if (var_43 > 6U) {
                                var_39 = (OPJ_UINT32)pSrc[i + 6];
                            }
                        }
                    }
                }
            }
        }
        *pDst++ = (OPJ_BYTE)((var_42 << 7) | (var_42 << 6) | (var_42 << 5) | (var_42 << 4) |
                             (var_39 << 3) | (var_39 << 2) | (var_39 << 1));
    }
}

static void fn_39(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < (var_43 & ~(OPJ_SIZE_T)3U); i += 4U) {
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 0];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 1];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 2];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 3];

        *pDst++ = (OPJ_BYTE)((var_42 << 6) | (var_42 << 4) | (var_42 << 2) | var_42);
    }

    if (var_43 & 3U) {
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 0];
        OPJ_UINT32 var_42 = 0U;
        OPJ_UINT32 var_42 = 0U;
        var_43 = var_43 & 3U;

        if (var_43 > 1U) {
            var_42 = (OPJ_UINT32)pSrc[i + 1];
            if (var_43 > 2U) {
                var_42 = (OPJ_UINT32)pSrc[i + 2];
            }
        }
        *pDst++ = (OPJ_BYTE)((var_42 << 6) | (var_42 << 4) | (var_42 << 2));
    }
}

static void fn_40(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < (var_43 & ~(OPJ_SIZE_T)1U); i += 2U) {
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 0];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 1];

        *pDst++ = (OPJ_BYTE)((var_42 << 4) | var_42);
    }

    if (var_43 & 1U) {
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 0];
        *pDst++ = (OPJ_BYTE)((var_42 << 4));
    }
}

static void fn_41(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < (var_43 & ~(OPJ_SIZE_T)3U); i += 4U) {
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 0];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 1];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 2];
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 3];

        *pDst++ = (OPJ_BYTE)((var_42 << 2) | (var_42 >> 4));
        *pDst++ = (OPJ_BYTE)(((var_42 & 0xFU) << 4) | (var_42 >> 2));
        *pDst++ = (OPJ_BYTE)(((var_42 & 0x3U) << 6) | var_42);
    }

    if (var_43 & 3U) {
        OPJ_UINT32 var_42 = (OPJ_UINT32)pSrc[i + 0];
        OPJ_UINT32 var_42 = 0U;
        OPJ_UINT32 var_42 = 0U;
        var_43 = var_43 & 3U;

        if (var_43 > 1U) {
            var_42 = (OPJ_UINT32)pSrc[i + 1];
            if (var_43 > 2U) {
                var_42 = (OPJ_UINT32)pSrc[i + 2];
            }
        }
        *pDst++ = (OPJ_BYTE)((var_42 << 2) | (var_42 >> 4));
        if (var_43 > 1U) {
            *pDst++ = (OPJ_BYTE)(((var_42 & 0xFU) << 4) | (var_42 >> 2));
            if (var_43 > 2U) {
                *pDst++ = (OPJ_BYTE)(((var_42 & 0x3U) << 6));
            }
        }
    }
}
static void fn_42(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,
                              OPJ_SIZE_T var_43)
{
    OPJ_SIZE_T i;
    for (i = 0; i < var_43; ++i) {
        pDst[i] = (OPJ_BYTE)pSrc[i];
    }
}
const convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9] = {
    NULL,
    convert_32s1u_C1R,
    convert_32s2u_C1R,
    NULL,
    convert_32s4u_C1R,
    NULL,
    convert_32s6u_C1R,
    NULL,
    convert_32s8u_C1R
};

static unsigned short fn_43(const unsigned char *data)
{
    return (unsigned short)(data[0] | (data[1] << 8));
}



static int fn_44(FILE *fp, unsigned int *var_50,
                          unsigned int *var_62, unsigned int *var_62, int *var_56)
{
    int palette_size;
    unsigned char tga[18];
    unsigned char id_len, image_type;
    unsigned char pixel_depth, image_desc;
    unsigned short cmap_len, cmap_entry_size;
    unsigned short image_w, image_h;

    if (!var_50 || !var_62 || !var_62 || !var_56) {
        return 0;
    }

    if (fread(tga, 18, 1, fp) != 1) {
        fprintf(stderr,
                "\nError: fread return a number of element different from the expected.\n");
        return 0 ;
    }
    id_len = tga[0];

    image_type = tga[2];

    cmap_len = get_tga_ushort(&tga[5]);
    cmap_entry_size = tga[7];






    image_w = get_tga_ushort(&tga[12]);
    image_h = get_tga_ushort(&tga[14]);
    pixel_depth = tga[16];
    image_desc = tga[17];

    *var_50 = (unsigned int)pixel_depth;
    *var_62 = (unsigned int)image_w;
    *var_62 = (unsigned int)image_h;


    if (id_len) {
        unsigned char *id = (unsigned char *) malloc(id_len);
        if (id == 0) {
            fprintf(stderr, "tga_readheader: memory out\n");
            return 0;
        }
        if (!fread(id, id_len, 1, fp)) {
            fprintf(stderr,
                    "\nError: fread return a number of element different from the expected.\n");
            free(id);
            return 0 ;
        }
        free(id);
    }




    if (image_type > 8) {
        fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
        return 0 ;
    }

    *var_56 = !(image_desc & 32);


    palette_size = cmap_len * (cmap_entry_size / 8);

    if (palette_size > 0) {
        fprintf(stderr, "File contains a palette - not yet supported.");
        fseek(fp, palette_size, SEEK_CUR);
    }
    return 1;
}

static int fn_49(FILE *fp, int var_50, int var_62, int var_62,
                           OPJ_BOOL var_56)
{
    OPJ_UINT16 image_w, image_h, us0;
    unsigned char uc0, image_type;
    unsigned char pixel_depth, image_desc;

    if (!var_50 || !var_62 || !var_62) {
        return 0;
    }

    pixel_depth = 0;

    if (var_50 < 256) {
        pixel_depth = (unsigned char)var_50;
    } else {
        fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_header");
        return 0;
    }
    uc0 = 0;

    if (fwrite(&uc0, 1, 1, fp) != 1) {
        goto fails;
    }
    if (fwrite(&uc0, 1, 1, fp) != 1) {
        goto fails;
    }

    image_type = 2;
    if (fwrite(&image_type, 1, 1, fp) != 1) {
        goto fails;
    }

    us0 = 0;
    if (fwrite(&us0, 2, 1, fp) != 1) {
        goto fails;
    }
    if (fwrite(&us0, 2, 1, fp) != 1) {
        goto fails;
    }
    if (fwrite(&uc0, 1, 1, fp) != 1) {
        goto fails;
    }

    if (fwrite(&us0, 2, 1, fp) != 1) {
        goto fails;
    }
    if (fwrite(&us0, 2, 1, fp) != 1) {
        goto fails;
    }

    image_w = (unsigned short)var_62;
    image_h = (unsigned short) var_62;


    if (fwrite(&image_w, 2, 1, fp) != 1) {
        goto fails;
    }
    if (fwrite(&image_h, 2, 1, fp) != 1) {
        goto fails;
    }

    if (fwrite(&pixel_depth, 1, 1, fp) != 1) {
        goto fails;
    }

    image_desc = 8;

    if (var_56) {
        image_desc |= 32;
    }
    if (fwrite(&image_desc, 1, 1, fp) != 1) {
        goto fails;
    }

    return 1;

fails:
    fputs("\nwrite_tgaheader: write ERROR\n", stderr);
    return 0;
}

opj_image_t* fn_50(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f;
    opj_image_t *image;
    unsigned int image_width, image_height, pixel_bit_depth;
    unsigned int x, y;
    int var_56 = 0;
    opj_image_cmptparm_t cmptparm[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space;
    OPJ_BOOL mono ;
    OPJ_BOOL save_alpha;
    int var_91, var_91;
    int i;

    f = fopen(filename, "rb");
    if (!f) {
        fprintf(stderr, "Failed to open %s for reading !!\n", filename);
        return 0;
    }

    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height,
                        &var_56)) {
        fclose(f);
        return NULL;
    }


    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {
        fclose(f);
        return NULL;
    }


    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));

    mono = (pixel_bit_depth == 8) ||
           (pixel_bit_depth == 16);
    save_alpha = (pixel_bit_depth == 16) ||
                 (pixel_bit_depth == 32);

    if (mono) {
        color_space = OPJ_CLRSPC_GRAY;
        numcomps = save_alpha ? 2 : 1;
    } else {
        numcomps = save_alpha ? 4 : 3;
        color_space = OPJ_CLRSPC_SRGB;
    }



    if (image_height != 0 &&
            image_width > 10000000U / image_height / (OPJ_UINT32)numcomps) {
        char ch;
        OPJ_UINT64 var_55 =
            (OPJ_UINT64)image_width * image_height * (OPJ_UINT32)numcomps;
        long var_55 = ftell(f);
        if (var_55 > (OPJ_UINT64)INT_MAX) {
            var_55 = (OPJ_UINT64)INT_MAX;
        }
        fseek(f, (long)var_55 - 1, SEEK_SET);
        if (fread(&ch, 1, 1, f) != 1) {
            fclose(f);
            return NULL;
        }
        fseek(f, var_55, SEEK_SET);
    }

    var_91 = parameters->subsampling_dx;
    var_91 = parameters->subsampling_dy;

    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = 8;
        cmptparm[i].bpp = 8;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = (OPJ_UINT32)var_91;
        cmptparm[i].dy = (OPJ_UINT32)var_91;
        cmptparm[i].w = image_width;
        cmptparm[i].h = image_height;
    }


    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);

    if (!image) {
        fclose(f);
        return NULL;
    }



    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;
    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;
    image->x1 = !image->x0 ? (OPJ_UINT32)(image_width - 1) *
                (OPJ_UINT32)var_91 + 1 : image->x0 + (OPJ_UINT32)(image_width - 1) *
                (OPJ_UINT32)var_91 + 1;
    image->y1 = !image->y0 ? (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)var_91 + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) *
                (OPJ_UINT32)var_91 + 1;


    for (y = 0; y < image_height; y++) {
        int var_86;

        if (var_56) {
            var_86 = (int)((image_height - y - 1) * image_width);
        } else {
            var_86 = (int)(y * image_width);
        }

        if (numcomps == 3) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b;

                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            "\nError: fread return a number of element different from the expected.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            "\nError: fread return a number of element different from the expected.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            "\nError: fread return a number of element different from the expected.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[var_86] = r;
                image->comps[1].data[var_86] = g;
                image->comps[2].data[var_86] = b;
                var_86++;
            }
        } else if (numcomps == 4) {
            for (x = 0; x < image_width; x++) {
                unsigned char r, g, b, var_62;
                if (!fread(&b, 1, 1, f)) {
                    fprintf(stderr,
                            "\nError: fread return a number of element different from the expected.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&g, 1, 1, f)) {
                    fprintf(stderr,
                            "\nError: fread return a number of element different from the expected.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&r, 1, 1, f)) {
                    fprintf(stderr,
                            "\nError: fread return a number of element different from the expected.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&var_62, 1, 1, f)) {
                    fprintf(stderr,
                            "\nError: fread return a number of element different from the expected.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }

                image->comps[0].data[var_86] = r;
                image->comps[1].data[var_86] = g;
                image->comps[2].data[var_86] = b;
                image->comps[3].data[var_86] = var_62;
                var_86++;
            }
        } else {
            fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
        }
    }
    fclose(f);
    return image;
}

int fn_56(opj_image_t * image, const char *var_97)
{
    int var_62, var_62, bpp, x, y;
    OPJ_BOOL write_alpha;
    unsigned int i;
    int adjustR, var_89 = 0, var_89 = 0, var_95;
    unsigned int alpha_channel;
    float r, g, b, var_62;
    unsigned char var_92;
    float scale;
    FILE *fdest;
    size_t res;
    var_95 = 1;

    fdest = fopen(var_97, "wb");
    if (!fdest) {
        fprintf(stderr, "ERROR -> failed to open %s for writing\n", var_97);
        return 1;
    }

    for (i = 0; i < image->numcomps - 1; i++) {
        if ((image->comps[0].dx != image->comps[i + 1].dx)
                || (image->comps[0].dy != image->comps[i + 1].dy)
                || (image->comps[0].prec != image->comps[i + 1].prec)
                || (image->comps[0].sgnd != image->comps[i + 1].sgnd)) {
            fclose(fdest);
            fprintf(stderr,
                    "Unable to create a tga file with such J2K image charateristics.\n");
            return 1;
        }
    }

    var_62 = (int)image->comps[0].w;
    var_62 = (int)image->comps[0].h;


    write_alpha = (image->numcomps == 2) || (image->numcomps == 4);


    bpp = write_alpha ? 32 : 24;

    if (!tga_writeheader(fdest, bpp, var_62, var_62, OPJ_TRUE)) {
        goto fin;
    }

    alpha_channel = image->numcomps - 1;

    scale = 255.0f / (float)((1 << image->comps[0].prec) - 1);

    adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
    if (image->numcomps >= 3) {
        var_89 = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
        var_89 = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
    }

    for (y = 0; y < var_62; y++) {
        unsigned int var_86 = (unsigned int)(y * var_62);

        for (x = 0; x < var_62; x++, var_86++) {
            r = (float)(image->comps[0].data[var_86] + adjustR);

            if (image->numcomps > 2) {
                g = (float)(image->comps[1].data[var_86] + var_89);
                b = (float)(image->comps[2].data[var_86] + var_89);
            } else {

                g = r;
                b = r;
            }


            if (b > 255.) {
                b = 255.;
            } else if (b < 0.) {
                b = 0.;
            }
            var_92 = (unsigned char)(b * scale);
            res = fwrite(&var_92, 1, 1, fdest);

            if (res < 1) {
                fprintf(stderr, "failed to write 1 byte for %s\n", var_97);
                goto fin;
            }
            if (g > 255.) {
                g = 255.;
            } else if (g < 0.) {
                g = 0.;
            }
            var_92 = (unsigned char)(g * scale);
            res = fwrite(&var_92, 1, 1, fdest);

            if (res < 1) {
                fprintf(stderr, "failed to write 1 byte for %s\n", var_97);
                goto fin;
            }
            if (r > 255.) {
                r = 255.;
            } else if (r < 0.) {
                r = 0.;
            }
            var_92 = (unsigned char)(r * scale);
            res = fwrite(&var_92, 1, 1, fdest);

            if (res < 1) {
                fprintf(stderr, "failed to write 1 byte for %s\n", var_97);
                goto fin;
            }

            if (write_alpha) {
                var_62 = (float)(image->comps[alpha_channel].data[var_86]);
                if (var_62 > 255.) {
                    var_62 = 255.;
                } else if (var_62 < 0.) {
                    var_62 = 0.;
                }
                var_92 = (unsigned char)(var_62 * scale);
                res = fwrite(&var_92, 1, 1, fdest);

                if (res < 1) {
                    fprintf(stderr, "failed to write 1 byte for %s\n", var_97);
                    goto fin;
                }
            }
        }
    }
    var_95 = 0;
fin:
    fclose(fdest);

    return var_95;
}

static unsigned char fn_62(FILE * f)
{
    unsigned char c1;
    if (!fread(&c1, 1, 1, f)) {
        fprintf(stderr,
                "\nError: fread return a number of element different from the expected.\n");
        return 0;
    }
    return c1;
}

static unsigned short fn_63(FILE * f, int var_69)
{
    unsigned char c1, c2;
    if (!fread(&c1, 1, 1, f)) {
        fprintf(stderr,
                "\nError: fread return a number of element different from the expected.\n");
        return 0;
    }
    if (!fread(&c2, 1, 1, f)) {
        fprintf(stderr,
                "\nError: fread return a number of element different from the expected.\n");
        return 0;
    }
    if (var_69) {
        return (unsigned short)((c1 << 8) + c2);
    } else {
        return (unsigned short)((c2 << 8) + c1);
    }
}

static unsigned int fn_65(FILE * f, int var_69)
{
    unsigned char c1, c2, c3, c4;
    if (!fread(&c1, 1, 1, f)) {
        fprintf(stderr,
                "\nError: fread return a number of element different from the expected.\n");
        return 0;
    }
    if (!fread(&c2, 1, 1, f)) {
        fprintf(stderr,
                "\nError: fread return a number of element different from the expected.\n");
        return 0;
    }
    if (!fread(&c3, 1, 1, f)) {
        fprintf(stderr,
                "\nError: fread return a number of element different from the expected.\n");
        return 0;
    }
    if (!fread(&c4, 1, 1, f)) {
        fprintf(stderr,
                "\nError: fread return a number of element different from the expected.\n");
        return 0;
    }
    if (var_69) {
        return (unsigned int)(c1 << 24) + (unsigned int)(c2 << 16) + (unsigned int)(
                   c3 << 8) + c4;
    } else {
        return (unsigned int)(c4 << 24) + (unsigned int)(c3 << 16) + (unsigned int)(
                   c2 << 8) + c1;
    }
}

opj_image_t* fn_66(const char *filename, opj_cparameters_t *parameters)
{
    FILE *f = NULL;
    int w, h, var_89;
    int i, numcomps, var_89;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t cmptparm;
    opj_image_t * image = NULL;
    int adjustS, ushift, dshift, force8;

    char endian1, endian2, sign;
    char signtmp[32];

    char temp[32];
    int var_69;
    opj_image_comp_t *comp = NULL;

    numcomps = 1;
    color_space = OPJ_CLRSPC_GRAY;

    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));

    var_89 = 0;

    f = fopen(filename, "rb");
    if (!f) {
        fprintf(stderr, "Failed to open %s for reading !\n", filename);
        return NULL;
    }

    fseek(f, 0, SEEK_SET);
    if (fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d", temp, &endian1,
               &endian2, signtmp, &var_89, temp, &w, temp, &h) != 9) {
        fclose(f);
        fprintf(stderr,
                "ERROR: Failed to read the right number of element from the fscanf() function!\n");
        return NULL;
    }

    i = 0;
    sign = '+';
    while (signtmp[i] != '\0') {
        if (signtmp[i] == '-') {
            sign = '-';
        }
        i++;
    }

    fgetc(f);
    if (endian1 == 'M' && endian2 == 'L') {
        var_69 = 1;
    } else if (endian2 == 'M' && endian1 == 'L') {
        var_69 = 0;
    } else {
        fclose(f);
        fprintf(stderr, "Bad pgx header, please check input file\n");
        return NULL;
    }



    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;
    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;
    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +
                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx
                 + 1;
    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +
                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy
                 + 1;

    if (sign == '-') {
        cmptparm.sgnd = 1;
    } else {
        cmptparm.sgnd = 0;
    }
    if (var_89 < 8) {
        force8 = 1;
        ushift = 8 - var_89;
        dshift = var_89 - ushift;
        if (cmptparm.sgnd) {
            adjustS = (1 << (var_89 - 1));
        } else {
            adjustS = 0;
        }
        cmptparm.sgnd = 0;
        var_89 = 8;
    } else {
        ushift = dshift = force8 = adjustS = 0;
    }

    cmptparm.prec = (OPJ_UINT32)var_89;
    cmptparm.bpp = (OPJ_UINT32)var_89;
    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;
    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;


    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);
    if (!image) {
        fclose(f);
        return NULL;
    }

    image->x0 = cmptparm.x0;
    image->y0 = cmptparm.x0;
    image->x1 = cmptparm.w;
    image->y1 = cmptparm.h;



    comp = &image->comps[0];

    for (i = 0; i < w * h; i++) {
        int var_89;
        if (force8) {
            var_89 = readuchar(f) + adjustS;
            var_89 = (var_89 << ushift) + (var_89 >> dshift);
            comp->data[i] = (unsigned char)var_89;

            if (var_89 > var_89) {
                var_89 = var_89;
            }

            continue;
        }
        if (comp->prec == 8) {
            if (!comp->sgnd) {
                var_89 = readuchar(f);
            } else {
                var_89 = (char) readuchar(f);
            }
        } else if (comp->prec <= 16) {
            if (!comp->sgnd) {
                var_89 = readushort(f, var_69);
            } else {
                var_89 = (short) readushort(f, var_69);
            }
        } else {
            if (!comp->sgnd) {
                var_89 = (int)readuint(f, var_69);
            } else {
                var_89 = (int) readuint(f, var_69);
            }
        }
        if (var_89 > var_89) {
            var_89 = var_89;
        }
        comp->data[i] = var_89;
    }
    fclose(f);
    comp->bpp = (OPJ_UINT32)int_floorlog2(var_89) + 1;

    return image;
}



static INLINE int fn_69(const int var_92, const int var_89, const int var_71)
{
    if (var_71) {
        if (var_89 <= 8) {
            return var_92 < -128 ? -128 : (var_92 > 127 ? 127 : var_92);
        } else if (var_89 <= 16) {
            return var_92 < -32768 ? -32768 : (var_92 > 32767 ? 32767 : var_92);
        } else {
            return var_92 < -2147483648 ? -2147483648 : (var_92 > 2147483647 ? 2147483647 : var_92);
        }
    } else {
        if (var_89 <= 8) {
            return var_92 < 0 ? 0 : (var_92 > 255 ? 255 : var_92);
        } else if (var_89 <= 16) {
            return var_92 < 0 ? 0 : (var_92 > 65535 ? 65535 : var_92);
        } else {
            return var_92;
        }
    }
}

int fn_71(opj_image_t * image, const char *var_97)
{
    int w, h;
    int i, j, var_95 = 1;
    unsigned int compno;
    FILE *fdest = NULL;

    for (compno = 0; compno < image->numcomps; compno++) {
        opj_image_comp_t *comp = &image->comps[compno];
        char var_73[256];
        char *name = var_73;
        int var_77 = 0;
        size_t res;
        const size_t var_89 = strlen(var_97);
        const size_t var_89 = var_89 - 4;
        const size_t var_78 = var_89 + 1 + 1 + 4;

        if (var_97[var_89] != '.') {

            fprintf(stderr, "ERROR -> Impossible happen.");
            goto fin;
        }
        if (var_78 > 256) {
            name = (char*)malloc(var_78 + 1);
            if (name == NULL) {
                fprintf(stderr, "imagetopgx: memory out\n");
                goto fin;
            }
        }
        strncpy(name, var_97, var_89);
        sprintf(name + var_89, "_%u.pgx", compno);
        fdest = fopen(name, "wb");


        if (!fdest) {

            fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
            if (var_78 > 256) {
                free(name);
            }
            goto fin;
        }

        w = (int)image->comps[compno].w;
        h = (int)image->comps[compno].h;

        fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec,
                w, h);

        if (comp->prec <= 8) {
            var_77 = 1;
        } else if (comp->prec <= 16) {
            var_77 = 2;
        } else {
            var_77 = 4;
        }

        for (i = 0; i < w * h; i++) {

            const int var_85 = clamp(image->comps[compno].data[i],
                                  (int)comp->prec, (int)comp->sgnd);

            for (j = var_77 - 1; j >= 0; j--) {
                int var_89 = (int)(var_85 >> (j * 8));
                unsigned char var_78 = (unsigned char)var_89;
                res = fwrite(&var_78, 1, 1, fdest);

                if (res < 1) {
                    fprintf(stderr, "failed to write 1 byte for %s\n", name);
                    if (var_78 > 256) {
                        free(name);
                    }
                    goto fin;
                }
            }
        }
        if (var_78 > 256) {
            free(name);
        }
        fclose(fdest);
        fdest = NULL;
    }
    var_95 = 0;
fin:
    if (fdest) {
        fclose(fdest);
    }

    return var_95;
}







struct struct_86 {
    int width, height, maxval, depth, format;
    char rgb, rgba, gray, graya, bw;
    char ok;
};

static char *fn_79(char *s)
{
    if (s != NULL) {
        while (*s) {
            if (*s == '\n' || *s == '\r') {
                return NULL;
            }
            if (isspace(*s)) {
                ++s;
                continue;
            }
            return s;
        }
    }
    return NULL;
}

static char *fn_80(char *start, int *out_n)
{
    char *s;
    char c;

    *out_n = 0;

    s = skip_white(start);
    if (s == NULL) {
        return NULL;
    }
    start = s;

    while (*s) {
        if (!isdigit(*s)) {
            break;
        }
        ++s;
    }
    c = *s;
    *s = 0;
    *out_n = atoi(start);
    *s = c;
    return s;
}

static char *fn_81(char *start, char out_idf[256])
{
    char *s;
    char c;

    s = skip_white(start);
    if (s == NULL) {
        return NULL;
    }
    start = s;

    while (*s) {
        if (isalpha(*s) || *s == '_') {
            ++s;
            continue;
        }
        break;
    }
    c = *s;
    *s = 0;
    strncpy(out_idf, start, 255);
    *s = c;
    return s;
}

static void fn_82(FILE *reader, struct struct_86 *ph)
{
    int format, end, ttype;
    char idf[256], type[256];
    char line[256];

    if (fgets(line, 250, reader) == NULL) {
        fprintf(stderr, "\nWARNING: fgets return a NULL value");
        return;
    }

    if (line[0] != 'P') {
        fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
        return;
    }
    format = atoi(line + 1);
    if (format < 1 || format > 7) {
        fprintf(stderr, "read_pnm_header:magic format %d invalid\n", format);
        return;
    }
    ph->format = format;
    ttype = end = 0;

    while (fgets(line, 250, reader)) {
        char *s;
        int var_84 = 0;

        if (*line == '#') {
            continue;
        }

        s = line;

        if (format == 7) {
            s = skip_idf(s, idf);

            if (s == NULL || *s == 0) {
                return;
            }

            if (strcmp(idf, "ENDHDR") == 0) {
                end = 1;
                break;
            }
            if (strcmp(idf, "WIDTH") == 0) {
                s = skip_int(s, &ph->width);
                if (s == NULL || *s == 0) {
                    return;
                }

                continue;
            }
            if (strcmp(idf, "HEIGHT") == 0) {
                s = skip_int(s, &ph->height);
                if (s == NULL || *s == 0) {
                    return;
                }

                continue;
            }
            if (strcmp(idf, "DEPTH") == 0) {
                s = skip_int(s, &ph->depth);
                if (s == NULL || *s == 0) {
                    return;
                }

                continue;
            }
            if (strcmp(idf, "MAXVAL") == 0) {
                s = skip_int(s, &ph->maxval);
                if (s == NULL || *s == 0) {
                    return;
                }

                continue;
            }
            if (strcmp(idf, "TUPLTYPE") == 0) {
                s = skip_idf(s, type);
                if (s == NULL || *s == 0) {
                    return;
                }

                if (strcmp(type, "BLACKANDWHITE") == 0) {
                    ph->bw = 1;
                    ttype = 1;
                    continue;
                }
                if (strcmp(type, "GRAYSCALE") == 0) {
                    ph->gray = 1;
                    ttype = 1;
                    continue;
                }
                if (strcmp(type, "GRAYSCALE_ALPHA") == 0) {
                    ph->graya = 1;
                    ttype = 1;
                    continue;
                }
                if (strcmp(type, "RGB") == 0) {
                    ph->rgb = 1;
                    ttype = 1;
                    continue;
                }
                if (strcmp(type, "RGB_ALPHA") == 0) {
                    ph->rgba = 1;
                    ttype = 1;
                    continue;
                }
                fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", type);
                return;
            }
            fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n", idf);
            return;
        }


        if (ph->width == 0) {
            s = skip_int(s, &ph->width);
            if ((s == NULL) || (*s == 0) || (ph->width < 1)) {
                return;
            }
            var_84 = 1;
        }
        if (ph->height == 0) {
            s = skip_int(s, &ph->height);
            if ((s == NULL) && var_84) {
                continue;
            }
            if ((s == NULL) || (*s == 0) || (ph->height < 1)) {
                return;
            }
            if (format == 1 || format == 4) {
                break;
            }
            var_84 = 1;
        }

        s = skip_int(s, &ph->maxval);
        if ((s == NULL) && var_84) {
            continue;
        }
        if ((s == NULL) || (*s == 0)) {
            return;
        }
        break;
    }
    if (format == 2 || format == 3 || format > 4) {
        if (ph->maxval < 1 || ph->maxval > 65535) {
            return;
        }
    }
    if (ph->width < 1 || ph->height < 1) {
        return;
    }

    if (format == 7) {
        if (!end) {
            fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
            return;
        }
        if (ph->depth < 1 || ph->depth > 4) {
            return;
        }

        if (ttype) {
            ph->ok = 1;
        }
    } else {
        ph->ok = 1;
        if (format == 1 || format == 4) {
            ph->maxval = 255;
        }
    }
}

static int fn_84(int var_85)
{
    if (var_85 < 2) {
        return 1;
    }
    if (var_85 < 4) {
        return 2;
    }
    if (var_85 < 8) {
        return 3;
    }
    if (var_85 < 16) {
        return 4;
    }
    if (var_85 < 32) {
        return 5;
    }
    if (var_85 < 64) {
        return 6;
    }
    if (var_85 < 128) {
        return 7;
    }
    if (var_85 < 256) {
        return 8;
    }
    if (var_85 < 512) {
        return 9;
    }
    if (var_85 < 1024) {
        return 10;
    }
    if (var_85 < 2048) {
        return 11;
    }
    if (var_85 < 4096) {
        return 12;
    }
    if (var_85 < 8192) {
        return 13;
    }
    if (var_85 < 16384) {
        return 14;
    }
    if (var_85 < 32768) {
        return 15;
    }
    return 16;
}

opj_image_t* fn_85(const char *filename, opj_cparameters_t *parameters)
{
    int var_91 = parameters->subsampling_dx;
    int var_91 = parameters->subsampling_dy;

    FILE *fp = NULL;
    int i, compno, numcomps, w, h, var_89, format;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t cmptparm[4];
    opj_image_t * image = NULL;
    struct struct_86 header_info;

    if ((fp = fopen(filename, "rb")) == NULL) {
        fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename);
        return NULL;
    }
    memset(&header_info, 0, sizeof(struct struct_86));

    read_pnm_header(fp, &header_info);

    if (!header_info.ok) {
        fclose(fp);
        return NULL;
    }


    if (header_info.height != 0 &&
            header_info.width > INT_MAX / header_info.height) {
        fprintf(stderr, "pnmtoimage:Image %dx%d too big!\n",
                header_info.width, header_info.height);
        fclose(fp);
        return NULL;
    }

    format = header_info.format;

    switch (format) {
    case 1:
    case 4:
        numcomps = 1;
        break;

    case 2:
    case 5:
        numcomps = 1;
        break;

    case 3:
    case 6:
        numcomps = 3;
        break;

    case 7:
        numcomps = header_info.depth;
        break;

    default:
        fclose(fp);
        return NULL;
    }
    if (numcomps < 3) {
        color_space = OPJ_CLRSPC_GRAY;
    } else {
        color_space = OPJ_CLRSPC_SRGB;
    }

    var_89 = has_prec(header_info.maxval);

    if (var_89 < 8) {
        var_89 = 8;
    }

    w = header_info.width;
    h = header_info.height;
    var_91 = parameters->subsampling_dx;
    var_91 = parameters->subsampling_dy;

    memset(&cmptparm[0], 0, (size_t)numcomps * sizeof(opj_image_cmptparm_t));

    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = (OPJ_UINT32)var_89;
        cmptparm[i].bpp = (OPJ_UINT32)var_89;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = (OPJ_UINT32)var_91;
        cmptparm[i].dy = (OPJ_UINT32)var_91;
        cmptparm[i].w = (OPJ_UINT32)w;
        cmptparm[i].h = (OPJ_UINT32)h;
    }
    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);

    if (!image) {
        fclose(fp);
        return NULL;
    }


    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;
    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;
    image->x1 = (OPJ_UINT32)(parameters->image_offset_x0 + (w - 1) * var_91
                             + 1);
    image->y1 = (OPJ_UINT32)(parameters->image_offset_y0 + (h - 1) * var_91
                             + 1);

    if ((format == 2) || (format == 3)) {
        unsigned int var_86;

        for (i = 0; i < w * h; i++) {
            for (compno = 0; compno < numcomps; compno++) {
                var_86 = 0;
                if (fscanf(fp, "%u", &var_86) != 1) {
                    fprintf(stderr,
                            "\nWARNING: fscanf return a number of element different from the expected.\n");
                }

                image->comps[compno].data[i] = (OPJ_INT32)(var_86 * 255) / header_info.maxval;
            }
        }
    } else if ((format == 5)
               || (format == 6)
               || ((format == 7)
                   && (header_info.gray || header_info.graya
                       || header_info.rgb || header_info.rgba))) {
        unsigned char c0, c1, one;

        one = (var_89 < 9);

        for (i = 0; i < w * h; i++) {
            for (compno = 0; compno < numcomps; compno++) {
                if (!fread(&c0, 1, 1, fp)) {
                    fprintf(stderr,
                            "\nError: fread return a number of element different from the expected.\n");
                    opj_image_destroy(image);
                    fclose(fp);
                    return NULL;
                }
                if (one) {
                    image->comps[compno].data[i] = c0;
                } else {
                    if (!fread(&c1, 1, 1, fp)) {
                        fprintf(stderr,
                                "\nError: fread return a number of element different from the expected.\n");
                    }

                    image->comps[compno].data[i] = ((c0 << 8) | c1);
                }
            }
        }
    } else if (format == 1) {
        for (i = 0; i < w * h; i++) {
            unsigned int var_86;

            if (fscanf(fp, "%u", &var_86) != 1) {
                fprintf(stderr,
                        "\nWARNING: fscanf return a number of element different from the expected.\n");
            }

            image->comps[0].data[i] = (var_86 ? 0 : 255);
        }
    } else if (format == 4) {
        int x, y, bit;
        unsigned char uc;

        i = 0;
        for (y = 0; y < h; ++y) {
            bit = -1;
            uc = 0;

            for (x = 0; x < w; ++x) {
                if (bit == -1) {
                    bit = 7;
                    uc = (unsigned char)getc(fp);
                }
                image->comps[0].data[i] = (((uc >> bit) & 1) ? 0 : 255);
                --bit;
                ++i;
            }
        }
    } else if ((format == 7 && header_info.bw)) {
        unsigned char uc;

        for (i = 0; i < w * h; ++i) {
            if (!fread(&uc, 1, 1, fp)) {
                fprintf(stderr,
                        "\nError: fread return a number of element different from the expected.\n");
            }
            image->comps[0].data[i] = (uc & 1) ? 0 : 255;
        }
    }
    fclose(fp);

    return image;
}

static int fn_86(opj_image_t * image)
{
    unsigned int i;
    for (i = 1; i < image->numcomps; i++) {
        if (image->comps[0].dx != image->comps[i].dx ||
                image->comps[0].dy != image->comps[i].dy ||
                (i <= 2 &&
                 (image->comps[0].prec != image->comps[i].prec ||
                  image->comps[0].sgnd != image->comps[i].sgnd))) {
            return OPJ_FALSE;
        }
    }
    return OPJ_TRUE;
}


int fn_87(opj_image_t * image, const char *var_97, int var_89)
{
    int *red, *green, *blue, *alpha;
    int wr, hr, var_89;
    int i;
    unsigned int compno, ncomp;
    int adjustR, var_89, var_89, adjustA;
    int var_95, two, want_gray, has_alpha, triple;
    int var_89, var_89;
    FILE *fdest = NULL;
    const char *tmp = var_97;
    char *destname;

    alpha = NULL;

    if ((var_89 = (int)image->comps[0].prec) > 16) {
        fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16"
                "\n\t: refused.\n", "/tmp/tmphsimen5q.c", 1953, var_89);
        return 1;
    }
    two = has_alpha = 0;
    var_95 = 1;
    ncomp = image->numcomps;

    while (*tmp) {
        ++tmp;
    }
    tmp -= 2;
    want_gray = (*tmp == 'g' || *tmp == 'G');
    ncomp = image->numcomps;

    if (want_gray) {
        ncomp = 1;
    }

    if ((var_89 == 0) && ncomp >= 2 &&
            are_comps_similar(image)) {
        fdest = fopen(var_97, "wb");

        if (!fdest) {
            fprintf(stderr, "ERROR -> failed to open %s for writing\n", var_97);
            return var_95;
        }
        two = (var_89 > 8);
        triple = (ncomp > 2);
        wr = (int)image->comps[0].w;
        hr = (int)image->comps[0].h;
        var_89 = (1 << var_89) - 1;
        has_alpha = (ncomp == 4 || ncomp == 2);

        red = image->comps[0].data;

        if (triple) {
            green = image->comps[1].data;
            blue = image->comps[2].data;
        } else {
            green = blue = NULL;
        }

        if (has_alpha) {
            const char *tt = (triple ? "RGB_ALPHA" : "GRAYSCALE_ALPHA");

            fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %u\n"
                    "MAXVAL %d\nTUPLTYPE %s\nENDHDR\n", opj_version(),
                    wr, hr, ncomp, var_89, tt);
            alpha = image->comps[ncomp - 1].data;
            adjustA = (image->comps[ncomp - 1].sgnd ?
                       1 << (image->comps[ncomp - 1].prec - 1) : 0);
        } else {
            fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\n",
                    opj_version(), wr, hr, var_89);
            adjustA = 0;
        }
        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);

        if (triple) {
            var_89 = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
            var_89 = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
        } else {
            var_89 = var_89 = 0;
        }

        for (i = 0; i < wr * hr; ++i) {
            if (two) {
                var_89 = *red + adjustR;
                ++red;
                if (var_89 > 65535) {
                    var_89 = 65535;
                } else if (var_89 < 0) {
                    var_89 = 0;
                }


                fprintf(fdest, "%c%c", (unsigned char)(var_89 >> 8), (unsigned char)var_89);

                if (triple) {
                    var_89 = *green + var_89;
                    ++green;
                    if (var_89 > 65535) {
                        var_89 = 65535;
                    } else if (var_89 < 0) {
                        var_89 = 0;
                    }


                    fprintf(fdest, "%c%c", (unsigned char)(var_89 >> 8), (unsigned char)var_89);

                    var_89 = *blue + var_89;
                    ++blue;
                    if (var_89 > 65535) {
                        var_89 = 65535;
                    } else if (var_89 < 0) {
                        var_89 = 0;
                    }


                    fprintf(fdest, "%c%c", (unsigned char)(var_89 >> 8), (unsigned char)var_89);

                }

                if (has_alpha) {
                    var_89 = *alpha + adjustA;
                    ++alpha;
                    if (var_89 > 65535) {
                        var_89 = 65535;
                    } else if (var_89 < 0) {
                        var_89 = 0;
                    }


                    fprintf(fdest, "%c%c", (unsigned char)(var_89 >> 8), (unsigned char)var_89);
                }
                continue;

            }


            var_89 = *red++;
            if (var_89 > 255) {
                var_89 = 255;
            } else if (var_89 < 0) {
                var_89 = 0;
            }

            fprintf(fdest, "%c", (unsigned char)var_89);
            if (triple) {
                var_89 = *green++;
                if (var_89 > 255) {
                    var_89 = 255;
                } else if (var_89 < 0) {
                    var_89 = 0;
                }

                fprintf(fdest, "%c", (unsigned char)var_89);
                var_89 = *blue++;
                if (var_89 > 255) {
                    var_89 = 255;
                } else if (var_89 < 0) {
                    var_89 = 0;
                }

                fprintf(fdest, "%c", (unsigned char)var_89);
            }
            if (has_alpha) {
                var_89 = *alpha++;
                if (var_89 > 255) {
                    var_89 = 255;
                } else if (var_89 < 0) {
                    var_89 = 0;
                }

                fprintf(fdest, "%c", (unsigned char)var_89);
            }
        }

        fclose(fdest);
        return 0;
    }



    if (image->numcomps > ncomp) {
        fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
        fprintf(stderr, "           is written to the file\n");
    }
    destname = (char*)malloc(strlen(var_97) + 8);
    if (destname == NULL) {
        fprintf(stderr, "imagetopnm: memory out\n");
        return 1;
    }
    for (compno = 0; compno < ncomp; compno++) {
        if (ncomp > 1) {

            const size_t var_89 = strlen(var_97);
            const size_t var_89 = var_89 - 4;

            strncpy(destname, var_97, var_89);
            sprintf(destname + var_89, "_%u.pgm", compno);
        } else {
            sprintf(destname, "%s", var_97);
        }

        fdest = fopen(destname, "wb");
        if (!fdest) {
            fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
            free(destname);
            return 1;
        }
        wr = (int)image->comps[compno].w;
        hr = (int)image->comps[compno].h;
        var_89 = (int)image->comps[compno].prec;
        var_89 = (1 << var_89) - 1;

        fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n",
                opj_version(), wr, hr, var_89);

        red = image->comps[compno].data;
        adjustR =
            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);

        if (var_89 > 8) {
            for (i = 0; i < wr * hr; i++) {
                var_89 = *red + adjustR;
                ++red;
                if (var_89 > 65535) {
                    var_89 = 65535;
                } else if (var_89 < 0) {
                    var_89 = 0;
                }


                fprintf(fdest, "%c%c", (unsigned char)(var_89 >> 8), (unsigned char)var_89);

                if (has_alpha) {
                    var_89 = *alpha++;
                    if (var_89 > 65535) {
                        var_89 = 65535;
                    } else if (var_89 < 0) {
                        var_89 = 0;
                    }


                    fprintf(fdest, "%c%c", (unsigned char)(var_89 >> 8), (unsigned char)var_89);
                }
            }
        } else {
            for (i = 0; i < wr * hr; ++i) {
                var_89 = *red + adjustR;
                ++red;
                if (var_89 > 255) {
                    var_89 = 255;
                } else if (var_89 < 0) {
                    var_89 = 0;
                }

                fprintf(fdest, "%c", (unsigned char)var_89);
            }
        }
        fclose(fdest);
    }
    free(destname);

    return 0;
}






static opj_image_t* fn_89(const char *filename,
                                      opj_cparameters_t *parameters, raw_cparameters_t *raw_cp, OPJ_BOOL var_95)
{
    int var_91 = parameters->subsampling_dx;
    int var_91 = parameters->subsampling_dy;

    FILE *f = NULL;
    int i, compno, numcomps, w, h;
    OPJ_COLOR_SPACE color_space;
    opj_image_cmptparm_t *cmptparm;
    opj_image_t * image = NULL;
    unsigned short ch;

    if ((!(raw_cp->rawWidth & raw_cp->rawHeight & raw_cp->rawComp &
            raw_cp->rawBitDepth)) == 0) {
        fprintf(stderr, "\nError: invalid raw image parameters\n");
        fprintf(stderr, "Please use the Format option -F:\n");
        fprintf(stderr,
                "-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\n");
        fprintf(stderr,
                "If subsampling is omitted, 1x1 is assumed for all components\n");
        fprintf(stderr,
                "Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\n");
        fprintf(stderr, "         for raw 512x512 image with 4:2:0 subsampling\n");
        fprintf(stderr, "Aborting.\n");
        return NULL;
    }

    f = fopen(filename, "rb");
    if (!f) {
        fprintf(stderr, "Failed to open %s for reading !!\n", filename);
        fprintf(stderr, "Aborting\n");
        return NULL;
    }
    numcomps = raw_cp->rawComp;


    if (numcomps == 1) {
        color_space = OPJ_CLRSPC_GRAY;
    } else if ((numcomps >= 3) && (parameters->tcp_mct == 0)) {
        color_space = OPJ_CLRSPC_SYCC;
    } else if ((numcomps >= 3) && (parameters->tcp_mct != 2)) {
        color_space = OPJ_CLRSPC_SRGB;
    } else {
        color_space = OPJ_CLRSPC_UNKNOWN;
    }
    w = raw_cp->rawWidth;
    h = raw_cp->rawHeight;
    cmptparm = (opj_image_cmptparm_t*) calloc((OPJ_UINT32)numcomps,
               sizeof(opj_image_cmptparm_t));
    if (!cmptparm) {
        fprintf(stderr, "Failed to allocate image components parameters !!\n");
        fprintf(stderr, "Aborting\n");
        fclose(f);
        return NULL;
    }

    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = (OPJ_UINT32)raw_cp->rawBitDepth;
        cmptparm[i].bpp = (OPJ_UINT32)raw_cp->rawBitDepth;
        cmptparm[i].sgnd = (OPJ_UINT32)raw_cp->rawSigned;
        cmptparm[i].dx = (OPJ_UINT32)(var_91 * raw_cp->rawComps[i].dx);
        cmptparm[i].dy = (OPJ_UINT32)(var_91 * raw_cp->rawComps[i].dy);
        cmptparm[i].w = (OPJ_UINT32)w;
        cmptparm[i].h = (OPJ_UINT32)h;
    }

    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);
    free(cmptparm);
    if (!image) {
        fclose(f);
        return NULL;
    }

    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;
    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;
    image->x1 = (OPJ_UINT32)parameters->image_offset_x0 + (OPJ_UINT32)(w - 1) *
                (OPJ_UINT32)var_91 + 1;
    image->y1 = (OPJ_UINT32)parameters->image_offset_y0 + (OPJ_UINT32)(h - 1) *
                (OPJ_UINT32)var_91 + 1;

    if (raw_cp->rawBitDepth <= 8) {
        unsigned char var_92 = 0;
        for (compno = 0; compno < numcomps; compno++) {
            int var_92 = (w * h) / (raw_cp->rawComps[compno].dx *
                                   raw_cp->rawComps[compno].dy);
            for (i = 0; i < var_92; i++) {
                if (!fread(&var_92, 1, 1, f)) {
                    fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                image->comps[compno].data[i] = raw_cp->rawSigned ? (char)var_92 : var_92;
            }
        }
    } else if (raw_cp->rawBitDepth <= 16) {
        unsigned short var_92;
        for (compno = 0; compno < numcomps; compno++) {
            int var_92 = (w * h) / (raw_cp->rawComps[compno].dx *
                                   raw_cp->rawComps[compno].dy);
            for (i = 0; i < var_92; i++) {
                unsigned char temp1;
                unsigned char temp2;
                if (!fread(&temp1, 1, 1, f)) {
                    fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (!fread(&temp2, 1, 1, f)) {
                    fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
                    opj_image_destroy(image);
                    fclose(f);
                    return NULL;
                }
                if (var_95) {
                    var_92 = (unsigned short)((temp1 << 8) + temp2);
                } else {
                    var_92 = (unsigned short)((temp2 << 8) + temp1);
                }
                image->comps[compno].data[i] = raw_cp->rawSigned ? (short)var_92 : var_92;
            }
        }
    } else {
        fprintf(stderr,
                "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\n");
        opj_image_destroy(image);
        fclose(f);
        return NULL;
    }

    if (fread(&ch, 1, 1, f)) {
        fprintf(stderr, "Warning. End of raw file not reached... processing anyway\n");
    }
    fclose(f);

    return image;
}

opj_image_t* fn_92(const char *filename, opj_cparameters_t *parameters,
                         raw_cparameters_t *raw_cp)
{
    return rawtoimage_common(filename, parameters, raw_cp, OPJ_FALSE);
}

opj_image_t* fn_93(const char *filename, opj_cparameters_t *parameters,
                        raw_cparameters_t *raw_cp)
{
    return rawtoimage_common(filename, parameters, raw_cp, OPJ_TRUE);
}

static int fn_94(opj_image_t * image, const char *var_97,
                             OPJ_BOOL var_95)
{
    FILE *rawFile = NULL;
    size_t res;
    unsigned int compno, numcomps;
    int w, h, var_95;
    int line, row, curr, mask;
    int *ptr;
    unsigned char uc;
    (void)var_95;

    if ((image->numcomps * image->x1 * image->y1) == 0) {
        fprintf(stderr, "\nError: invalid raw image parameters\n");
        return 1;
    }

    numcomps = image->numcomps;

    if (numcomps > 4) {
        numcomps = 4;
    }

    for (compno = 1; compno < numcomps; ++compno) {
        if (image->comps[0].dx != image->comps[compno].dx) {
            break;
        }
        if (image->comps[0].dy != image->comps[compno].dy) {
            break;
        }
        if (image->comps[0].prec != image->comps[compno].prec) {
            break;
        }
        if (image->comps[0].sgnd != image->comps[compno].sgnd) {
            break;
        }
    }
    if (compno != numcomps) {
        fprintf(stderr,
                "imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\n");
        fprintf(stderr, "\tAborting\n");
        return 1;
    }

    rawFile = fopen(var_97, "wb");
    if (!rawFile) {
        fprintf(stderr, "Failed to open %s for writing !!\n", var_97);
        return 1;
    }

    var_95 = 1;
    fprintf(stdout, "Raw image characteristics: %d components\n", image->numcomps);

    for (compno = 0; compno < image->numcomps; compno++) {
        fprintf(stdout, "Component %u characteristics: %dx%dx%d %s\n", compno,
                image->comps[compno].w,
                image->comps[compno].h, image->comps[compno].prec,
                image->comps[compno].sgnd == 1 ? "signed" : "unsigned");

        w = (int)image->comps[compno].w;
        h = (int)image->comps[compno].h;

        if (image->comps[compno].prec <= 8) {
            if (image->comps[compno].sgnd == 1) {
                mask = (1 << image->comps[compno].prec) - 1;
                ptr = image->comps[compno].data;
                for (line = 0; line < h; line++) {
                    for (row = 0; row < w; row++) {
                        curr = *ptr;
                        if (curr > 127) {
                            curr = 127;
                        } else if (curr < -128) {
                            curr = -128;
                        }
                        uc = (unsigned char)(curr & mask);
                        res = fwrite(&uc, 1, 1, rawFile);
                        if (res < 1) {
                            fprintf(stderr, "failed to write 1 byte for %s\n", var_97);
                            goto fin;
                        }
                        ptr++;
                    }
                }
            } else if (image->comps[compno].sgnd == 0) {
                mask = (1 << image->comps[compno].prec) - 1;
                ptr = image->comps[compno].data;
                for (line = 0; line < h; line++) {
                    for (row = 0; row < w; row++) {
                        curr = *ptr;
                        if (curr > 255) {
                            curr = 255;
                        } else if (curr < 0) {
                            curr = 0;
                        }
                        uc = (unsigned char)(curr & mask);
                        res = fwrite(&uc, 1, 1, rawFile);
                        if (res < 1) {
                            fprintf(stderr, "failed to write 1 byte for %s\n", var_97);
                            goto fin;
                        }
                        ptr++;
                    }
                }
            }
        } else if (image->comps[compno].prec <= 16) {
            if (image->comps[compno].sgnd == 1) {
                union {
                    signed short val;
                    signed char vals[2];
                } uc16;
                mask = (1 << image->comps[compno].prec) - 1;
                ptr = image->comps[compno].data;
                for (line = 0; line < h; line++) {
                    for (row = 0; row < w; row++) {
                        curr = *ptr;
                        if (curr > 32767) {
                            curr = 32767;
                        } else if (curr < -32768) {
                            curr = -32768;
                        }
                        uc16.val = (signed short)(curr & mask);
                        res = fwrite(uc16.vals, 1, 2, rawFile);
                        if (res < 2) {
                            fprintf(stderr, "failed to write 2 byte for %s\n", var_97);
                            goto fin;
                        }
                        ptr++;
                    }
                }
            } else if (image->comps[compno].sgnd == 0) {
                union {
                    unsigned short val;
                    unsigned char vals[2];
                } uc16;
                mask = (1 << image->comps[compno].prec) - 1;
                ptr = image->comps[compno].data;
                for (line = 0; line < h; line++) {
                    for (row = 0; row < w; row++) {
                        curr = *ptr;
                        if (curr > 65535) {
                            curr = 65535;
                        } else if (curr < 0) {
                            curr = 0;
                        }
                        uc16.val = (unsigned short)(curr & mask);
                        res = fwrite(uc16.vals, 1, 2, rawFile);
                        if (res < 2) {
                            fprintf(stderr, "failed to write 2 byte for %s\n", var_97);
                            goto fin;
                        }
                        ptr++;
                    }
                }
            }
        } else if (image->comps[compno].prec <= 32) {
            fprintf(stderr, "More than 16 bits per component not handled yet\n");
            goto fin;
        } else {
            fprintf(stderr, "Error: invalid precision: %d\n", image->comps[compno].prec);
            goto fin;
        }
    }
    var_95 = 0;
fin:
    fclose(rawFile);
    return var_95;
}

int fn_95(opj_image_t * image, const char *var_97)
{
    return imagetoraw_common(image, var_97, OPJ_TRUE);
}

int fn_96(opj_image_t * image, const char *var_97)
{
    return imagetoraw_common(image, var_97, OPJ_FALSE);
}
