







static size_t fn_0(int var_3, size_t var_52)
{
 return ((var_3*var_52+31)/32)*4;
}

struct struct_45 {
 struct struct_87 *iodescr;
 struct struct_87 *ctx;
 struct struct_87 *img;
 int bmpversion;
 int width, height;
 int topdown;
 int has_fileheader;
 unsigned int bitcount;
 unsigned int compression;
 int uses_bitfields;
 int has_alpha_channel;
 int bitfields_set;
 int need_16bit;
 unsigned int palette_entries;
 size_t fileheader_size;
 size_t infoheader_size;
 size_t bitfields_nbytes;
 size_t palette_nbytes;
 size_t bfOffBits;
 struct struct_80 palette;


 unsigned int bf_mask[4];
 int bf_high_bit[4];
 int bf_low_bit[4];
 int bf_bits_count[4];

 struct struct_46 csdescr;
};

static int fn_9(struct struct_45 *rctx,
  iw_byte *buf, size_t var_12)
{
 int ret;
 size_t var_12 = 0;

 ret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,
  buf,var_12,&var_12);
 if(!ret || var_12!=var_12) {
  return 0;
 }
 return 1;
}

static int fn_12(struct struct_45 *rctx, size_t var_71)
{
 iw_byte buf[1024];
 size_t still_to_read;
 size_t num_to_read;

 still_to_read = var_71;
 while(still_to_read>0) {
  num_to_read = still_to_read;
  if(num_to_read>1024) num_to_read=1024;
  if(!iwbmp_read(rctx,buf,num_to_read)) {
   return 0;
  }
  still_to_read -= num_to_read;
 }
 return 1;
}

static int fn_14(struct struct_45 *rctx)
{
 iw_byte buf[14];

 if(!iwbmp_read(rctx,buf,14)) return 0;
 rctx->fileheader_size = 14;

 if(buf[0]=='B' && buf[1]=='A') {


  if(!iwbmp_read(rctx,buf,14)) return 0;
  rctx->fileheader_size += 14;
 }

 if(buf[0]=='B' && buf[1]=='M') {
  ;
 }
 else if((buf[0]=='C' && buf[1]=='I') ||
    (buf[0]=='C' && buf[1]=='P') ||
    (buf[0]=='I' && buf[1]=='C') ||
    (buf[0]=='P' && buf[1]=='T'))
 {
  iw_set_error(rctx->ctx,"This type of BMP file is not supported");
  return 0;
 }
 else {
  iw_set_error(rctx->ctx,"Not a BMP file");
  return 0;
 }

 rctx->bfOffBits = iw_get_ui32le(&buf[10]);
 return 1;
}


static int fn_15(struct struct_45 *rctx, const iw_byte *buf)
{
 unsigned int nplanes;

 rctx->width = iw_get_ui16le(&buf[4]);
 rctx->height = iw_get_ui16le(&buf[6]);
 nplanes = iw_get_ui16le(&buf[8]);
 if(nplanes!=1) return 0;
 rctx->bitcount = iw_get_ui16le(&buf[10]);
 if(rctx->bitcount!=1 && rctx->bitcount!=4 &&
  rctx->bitcount!=8 && rctx->bitcount!=24)
 {
  return 0;
 }
 if(rctx->bitcount<=8) {
  size_t palette_start, palette_end;

  rctx->palette_entries = 1<<rctx->bitcount;
  rctx->palette_nbytes = 3*rctx->palette_entries;




  palette_start = rctx->fileheader_size + rctx->infoheader_size;
  palette_end = palette_start + rctx->palette_nbytes;
  if(rctx->bfOffBits >= palette_start+3 && rctx->bfOffBits < palette_end) {
   rctx->palette_entries = (unsigned int)((rctx->bfOffBits - palette_start)/3);
   rctx->palette_nbytes = 3*rctx->palette_entries;
  }
 }
 return 1;
}


static int fn_16(struct struct_45 *rctx, const iw_byte *buf)
{
 unsigned int nplanes;
 int biXPelsPerMeter, biYPelsPerMeter;
 unsigned int var_18 = 0;


 rctx->width = iw_get_i32le(&buf[4]);
 rctx->height = iw_get_i32le(&buf[8]);
 if(rctx->height<0) {
  rctx->height = -rctx->height;
  rctx->topdown = 1;
 }

 nplanes = iw_get_ui16le(&buf[12]);
 if(nplanes!=1) return 0;

 rctx->bitcount = iw_get_ui16le(&buf[14]);

 if(rctx->bitcount!=1 && rctx->bitcount!=2 && rctx->bitcount!=4 &&
  rctx->bitcount!=8 && rctx->bitcount!=16 && rctx->bitcount!=24 &&
  rctx->bitcount!=32)
 {
  iw_set_errorf(rctx->ctx,"Bad or unsupported bit count (%d)",(int)rctx->bitcount);
  return 0;
 }

 if(rctx->infoheader_size<=16) {
  goto infoheaderdone;
 }

 rctx->compression = iw_get_ui32le(&buf[16]);
 if(rctx->compression==3) {
  if(rctx->bitcount==1) {
   iw_set_error(rctx->ctx,"Huffman 1D compression not supported");
   return 0;
  }
  else if(rctx->bitcount!=16 && rctx->bitcount!=32) {
   iw_set_error(rctx->ctx,"Bad or unsupported image type");
   return 0;
  }



  rctx->uses_bitfields = 1;

  if(rctx->bmpversion==3) {
   rctx->bitfields_nbytes = 12;
  }

  rctx->compression=0;
 }


 biXPelsPerMeter = iw_get_i32le(&buf[24]);
 biYPelsPerMeter = iw_get_i32le(&buf[28]);

 rctx->img->density_code = IW_DENSITY_UNITS_PER_METER;
 rctx->img->density_x = (double)biXPelsPerMeter;
 rctx->img->density_y = (double)biYPelsPerMeter;
 if(!iw_is_valid_density(rctx->img->density_x,rctx->img->density_y,rctx->img->density_code)) {
  rctx->img->density_code=IW_DENSITY_UNKNOWN;
 }

 var_18 = iw_get_ui32le(&buf[32]);
 if(var_18>100000) return 0;

infoheaderdone:





 if(var_18==0 && rctx->bitcount<=8) {
  rctx->palette_entries = 1<<rctx->bitcount;
 }
 else {
  rctx->palette_entries = var_18;
 }
 rctx->palette_nbytes = 4*rctx->palette_entries;
 return 1;
}

static int fn_27(struct struct_45 *rctx, int var_62);


static int fn_20(struct struct_45 *rctx, const iw_byte *buf)
{
 int var_62;
 unsigned int cstype;

 if(rctx->uses_bitfields) {

  for(var_62=0;var_62<4;var_62++) {
   rctx->bf_mask[var_62] = 0;
  }
  for(var_62=0;var_62<4;var_62++) {
   if(rctx->infoheader_size < (size_t)(40+var_62*4+4)) break;
   rctx->bf_mask[var_62] = iw_get_ui32le(&buf[40+var_62*4]);
   if(!process_bf_mask(rctx,var_62)) return 0;
  }
  rctx->bitfields_set=1;

  if(rctx->bf_mask[3]!=0) {

   rctx->has_alpha_channel = 1;
  }
 }

 if(rctx->infoheader_size < 108) return 1;

 cstype = iw_get_ui32le(&buf[56]);
 switch(cstype) {
 case 0:


  break;

 case 1:
 case 0x73524742:
 case 0x57696e20:
  break;

 case 0x4c494e4b:
 case 0x4d424544:
  if(rctx->bmpversion<5) {
   iw_warning(rctx->ctx,"Invalid colorspace type for BMPv4");
  }
  break;

 default:
  iw_warningf(rctx->ctx,"Unrecognized or unsupported colorspace type (0x%x)",cstype);
 }


 if(cstype==0) {
  unsigned int bmpgamma;
  double gamma[3];
  double avggamma;

  for(var_62=0;var_62<3;var_62++) {
   bmpgamma = iw_get_ui32le(&buf[96+var_62*4]);
   gamma[var_62] = ((double)bmpgamma)/65536.0;
  }
  avggamma = (gamma[0] + gamma[1] + gamma[2])/3.0;

  if(avggamma>=0.1 && avggamma<=10.0) {
   iw_make_gamma_csdescr(&rctx->csdescr,1.0/avggamma);
  }
 }

 return 1;
}


static int fn_21(struct struct_45 *rctx, const iw_byte *buf)
{
 unsigned int intent_bmp_style;
 int intent_iw_style;

 intent_bmp_style = iw_get_ui32le(&buf[108]);
 intent_iw_style = IW_INTENT_UNKNOWN;
 switch(intent_bmp_style) {
  case 1: intent_iw_style = IW_INTENT_SATURATION; break;
  case 2: intent_iw_style = IW_INTENT_RELATIVE; break;
  case 4: intent_iw_style = IW_INTENT_PERCEPTUAL; break;
  case 8: intent_iw_style = IW_INTENT_ABSOLUTE; break;
 }
 rctx->img->rendering_intent = intent_iw_style;

 return 1;
}

static int fn_22(struct struct_45 *rctx)
{
 iw_byte buf[124];
 int var_87 = 0;
 size_t var_71;



 if(!iwbmp_read(rctx,buf,4)) goto done;
 rctx->infoheader_size = iw_get_ui32le(&buf[0]);
 if(rctx->infoheader_size<12) goto done;


 var_71 = rctx->infoheader_size;
 if(var_71>sizeof(buf)) var_71=sizeof(buf);
 if(!iwbmp_read(rctx,&buf[4],var_71-4)) goto done;

 if(rctx->infoheader_size==12) {

  rctx->bmpversion=2;
  if(!decode_v2_header(rctx,buf)) goto done;
 }
 else if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {



  rctx->bmpversion=3;
  if(!decode_v3_header_fields(rctx,buf)) goto done;
 }
 else if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {




  rctx->bmpversion=4;
  if(!decode_v3_header_fields(rctx,buf)) goto done;
  if(!decode_v4_header_fields(rctx,buf)) goto done;
 }
 else if(rctx->infoheader_size==124) {
  rctx->bmpversion=5;
  if(!decode_v3_header_fields(rctx,buf)) goto done;
  if(!decode_v4_header_fields(rctx,buf)) goto done;
  if(!decode_v5_header_fields(rctx,buf)) goto done;
 }
 else {
  iw_set_error(rctx->ctx,"Unsupported BMP version");
  goto done;
 }

 if(!iw_check_image_dimensions(rctx->ctx,rctx->width,rctx->height)) {
  goto done;
 }

 var_87 = 1;

done:
 return var_87;
}


static int fn_24(unsigned int var_86)
{
 int i;
 for(i=31;i>=0;i--) {
  if(var_86&(1U<<(unsigned int)i)) return i;
 }
 return 0;
}
static int fn_26(unsigned int var_86)
{
 int i;
 for(i=0;i<=31;i++) {
  if(var_86&(1U<<(unsigned int)i)) return i;
 }
 return 0;
}


static int fn_27(struct struct_45 *rctx, int var_62)
{


 rctx->bf_high_bit[var_62] = find_high_bit(rctx->bf_mask[var_62]);
 rctx->bf_low_bit[var_62] = find_low_bit(rctx->bf_mask[var_62]);
 rctx->bf_bits_count[var_62] = 1+rctx->bf_high_bit[var_62]-rctx->bf_low_bit[var_62];


 if(rctx->bf_high_bit[var_62] > (int)(rctx->bitcount-1)) return 0;

 if(rctx->bf_bits_count[var_62]>16) {

  rctx->bf_low_bit[var_62] = rctx->bf_high_bit[var_62]-15;
  rctx->bf_bits_count[var_62] = 16;
 }

 if(rctx->bf_bits_count[var_62]>8) {
  rctx->need_16bit = 1;
 }

 return 1;
}

static int fn_27(struct struct_45 *rctx)
{
 iw_byte buf[12];
 int var_62;

 if(!iwbmp_read(rctx,buf,12)) return 0;

 for(var_62=0;var_62<3;var_62++) {
  rctx->bf_mask[var_62] = iw_get_ui32le(&buf[var_62*4]);
  if(rctx->bf_mask[var_62]==0) return 0;


  if(!process_bf_mask(rctx,var_62)) return 0;
 }

 return 1;
}

static void fn_28(struct struct_45 *rctx)
{
 int var_62;

 if(rctx->bitfields_set) return;

 if(rctx->bitcount==16) {

  rctx->bf_mask[0]=0x7c00;
  rctx->bf_mask[1]=0x03e0;
  rctx->bf_mask[2]=0x001f;
 }
 else if(rctx->bitcount==32) {
  rctx->bf_mask[0]=0x00ff0000;
  rctx->bf_mask[1]=0x0000ff00;
  rctx->bf_mask[2]=0x000000ff;
 }
 else {
  return;
 }

 for(var_62=0;var_62<3;var_62++) {
  process_bf_mask(rctx,var_62);
 }
}

static int fn_29(struct struct_45 *rctx)
{
 size_t i;
 iw_byte buf[1024];
 size_t b;
 unsigned int valid_palette_entries;
 size_t valid_palette_nbytes;

 b = (rctx->bmpversion==2) ? 3 : 4;

 if(rctx->infoheader_size==64) {



  if(rctx->fileheader_size + rctx->infoheader_size + rctx->palette_entries*3 ==
   rctx->bfOffBits)
  {
   iw_warning(rctx->ctx,"BMP bitmap overlaps colormap; assuming colormap uses 3 bytes per entry instead of 4");
   b = 3;
   rctx->palette_nbytes = 3*rctx->palette_entries;
  }
 }


 valid_palette_entries = (rctx->palette_entries<=256) ? rctx->palette_entries : 256;
 valid_palette_nbytes = valid_palette_entries * b;


 if(!iwbmp_read(rctx,buf,valid_palette_nbytes)) return 0;
 rctx->palette.num_entries = valid_palette_entries;
 for(i=0;i<valid_palette_entries;i++) {
  rctx->palette.entry[i].b = buf[i*b+0];
  rctx->palette.entry[i].g = buf[i*b+1];
  rctx->palette.entry[i].r = buf[i*b+2];
  rctx->palette.entry[i].a = 255;
 }


 if(rctx->palette_nbytes > valid_palette_nbytes) {
  iwbmp_skip_bytes(rctx, rctx->palette_nbytes - valid_palette_nbytes);
 }
 return 1;
}

static void fn_30(struct struct_45 *rctx, const iw_byte *src, size_t var_37)
{
 int i,var_62;
 unsigned int v,var_86;
 int numchannels;

 numchannels = rctx->has_alpha_channel ? 4 : 3;

 for(i=0;i<rctx->width;i++) {
  if(rctx->bitcount==32) {
   var_86 = ((unsigned int)src[i*4+0]) | ((unsigned int)src[i*4+1])<<8 |
    ((unsigned int)src[i*4+2])<<16 | ((unsigned int)src[i*4+3])<<24;
  }
  else {
   var_86 = ((unsigned int)src[i*2+0]) | ((unsigned int)src[i*2+1])<<8;
  }
  v = 0;
  for(var_62=0;var_62<numchannels;var_62++) {
   v = var_86 & rctx->bf_mask[var_62];
   if(rctx->bf_low_bit[var_62]>0)
    v >>= rctx->bf_low_bit[var_62];
   if(rctx->img->bit_depth==16) {
    rctx->img->pixels[var_37*rctx->img->bpr + i*numchannels*2 + var_62*2+0] = (iw_byte)(v>>8);
    rctx->img->pixels[var_37*rctx->img->bpr + i*numchannels*2 + var_62*2+1] = (iw_byte)(v&0xff);
   }
   else {
    rctx->img->pixels[var_37*rctx->img->bpr + i*numchannels + var_62] = (iw_byte)v;
   }
  }
 }
}

static void fn_32(struct struct_45 *rctx,const iw_byte *src, size_t var_37)
{
 int i;
 for(i=0;i<rctx->width;i++) {
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 0] = src[i*3+2];
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 1] = src[i*3+1];
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 2] = src[i*3+0];
 }
}

static void fn_33(struct struct_45 *rctx,const iw_byte *src, size_t var_37)
{
 int i;
 for(i=0;i<rctx->width;i++) {
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[src[i]].r;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[src[i]].g;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[src[i]].b;
 }
}

static void fn_34(struct struct_45 *rctx,const iw_byte *src, size_t var_37)
{
 int i;
 int pal_index;

 for(i=0;i<rctx->width;i++) {
  pal_index = (i&0x1) ? src[i/2]&0x0f : src[i/2]>>4;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;
 }
}

static void fn_35(struct struct_45 *rctx,const iw_byte *src, size_t var_37)
{
 int i;
 int pal_index;

 for(i=0;i<rctx->width;i++) {
  pal_index = (src[i/4]>>(2*(3-i%4)))&0x03;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;
 }
}

static void fn_36(struct struct_45 *rctx,const iw_byte *src, size_t var_37)
{
 int i;
 int pal_index;

 for(i=0;i<rctx->width;i++) {
  pal_index = (src[i/8] & (1<<(7-i%8))) ? 1 : 0;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;
  rctx->img->pixels[var_37*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;
 }
}

static int fn_37(struct struct_45 *rctx)
{
 iw_byte *rowbuf = NULL;
 size_t bmp_bpr;
 int j;
 int var_87 = 0;

 if(rctx->has_alpha_channel) {
  rctx->img->imgtype = IW_IMGTYPE_RGBA;

  rctx->img->bit_depth = rctx->need_16bit ? 16 : 8;
  rctx->img->bpr = iw_calc_bytesperrow(rctx->width,4*rctx->img->bit_depth);
 }
 else {
  rctx->img->imgtype = IW_IMGTYPE_RGB;
  rctx->img->bit_depth = rctx->need_16bit ? 16 : 8;
  rctx->img->bpr = iw_calc_bytesperrow(rctx->width,3*rctx->img->bit_depth);
 }

 bmp_bpr = iwbmp_calc_bpr(rctx->bitcount,rctx->width);

 rctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);
 if(!rctx->img->pixels) goto done;

 rowbuf = iw_malloc(rctx->ctx,bmp_bpr);

 for(j=0;j<rctx->img->height;j++) {

  if(!iwbmp_read(rctx,rowbuf,bmp_bpr)) {
   goto done;
  }
  switch(rctx->bitcount) {
  case 32:
  case 16:
   bmpr_convert_row_32_16(rctx,rowbuf,j);
   break;
  case 24:
   bmpr_convert_row_24(rctx,rowbuf,j);
   break;
  case 8:
   bmpr_convert_row_8(rctx,rowbuf,j);
   break;
  case 4:
   bmpr_convert_row_4(rctx,rowbuf,j);
   break;
  case 2:
   bmpr_convert_row_2(rctx,rowbuf,j);
   break;
  case 1:
   bmpr_convert_row_1(rctx,rowbuf,j);
   break;
  }
 }

 var_87 = 1;
done:
 if(rowbuf) iw_free(rctx->ctx,rowbuf);
 return var_87;
}



static int fn_38(struct struct_45 *rctx)
{
 int var_87 = 0;
 int pos_x, pos_y;
 iw_byte buf[255];
 size_t n_pix;
 size_t n_bytes;
 size_t i;
 size_t pal_index;



 pos_x = 0;
 pos_y = 0;



 iw_zeromem(rctx->img->pixels,rctx->img->bpr*rctx->img->height);

 while1 {

  if(pos_y>rctx->img->height-1) break;
  if(pos_y==rctx->img->height-1 && pos_x>=rctx->img->width) break;

  if(!iwbmp_read(rctx,buf,2)) goto done;
  if(buf[0]==0) {
   if(buf[1]==0) {

    pos_y++;
    pos_x=0;
   }
   else if(buf[1]==1) {

    break;
   }
   else if(buf[1]==2) {





    if(!iwbmp_read(rctx,buf,2)) goto done;

    if(pos_x<rctx->img->width) pos_x += buf[0];
    pos_y += buf[1];
   }
   else {

    n_pix = (size_t)buf[1];
    if(rctx->compression==2) {
     n_bytes = ((n_pix+3)/4)*2;
    }
    else {
     n_bytes = ((n_pix+1)/2)*2;
    }
    if(!iwbmp_read(rctx,buf,n_bytes)) goto done;
    for(i=0;i<n_pix;i++) {
     if(pos_x<rctx->img->width) {
      if(rctx->compression==2) {
       pal_index = (i%2) ? buf[i/2]&0x0f : buf[i/2]>>4;
      }
      else {
       pal_index = buf[i];
      }
      rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 0] = rctx->palette.entry[pal_index].r;
      rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 1] = rctx->palette.entry[pal_index].g;
      rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 2] = rctx->palette.entry[pal_index].b;
      rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 3] = 255;
      pos_x++;
     }
    }
   }
  }
  else {

   n_pix = (size_t)buf[0];
   for(i=0;i<n_pix;i++) {
    if(pos_x<rctx->img->width) {
     if(rctx->compression==2) {
      pal_index = (i%2) ? buf[1]&0x0f : buf[1]>>4;
     }
     else {
      pal_index = buf[1];
     }
     rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 0] = rctx->palette.entry[pal_index].r;
     rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 1] = rctx->palette.entry[pal_index].g;
     rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 2] = rctx->palette.entry[pal_index].b;
     rctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 3] = 255;
     pos_x++;
    }
   }
  }
 }

 var_87 = 1;
done:
 return var_87;
}

static int fn_39(struct struct_87 *img)
{
 int i,j;

 if(img->imgtype!=IW_IMGTYPE_RGBA) return 0;

 for(j=0;j<img->height;j++) {
  for(i=0;i<img->width;i++) {
   if(img->pixels[j*img->bpr + i*4 + 3] != 255)
    return 1;
  }
 }
 return 0;
}




static void fn_40(struct struct_87 *img)
{
 int i,j;
 size_t oldbpr;

 img->imgtype = IW_IMGTYPE_RGB;
 oldbpr = img->bpr;
 img->bpr = iw_calc_bytesperrow(img->width,24);

 for(j=0;j<img->height;j++) {
  for(i=0;i<img->width;i++) {
   img->pixels[j*img->bpr + i*3 + 0] = img->pixels[j*oldbpr + i*4 + 0];
   img->pixels[j*img->bpr + i*3 + 1] = img->pixels[j*oldbpr + i*4 + 1];
   img->pixels[j*img->bpr + i*3 + 2] = img->pixels[j*oldbpr + i*4 + 2];
  }
 }
}

static int fn_41(struct struct_45 *rctx)
{
 int var_87 = 0;

 if(!(rctx->compression==1 && rctx->bitcount==8) &&
  !(rctx->compression==2 && rctx->bitcount==4))
 {
  iw_set_error(rctx->ctx,"Compression type incompatible with image type");
 }

 if(rctx->topdown) {

  iw_set_error(rctx->ctx,"Compression not allowed with top-down images");
 }







 rctx->img->imgtype = IW_IMGTYPE_RGBA;
 rctx->img->bit_depth = 8;
 rctx->img->bpr = iw_calc_bytesperrow(rctx->width,32);

 rctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);
 if(!rctx->img->pixels) goto done;

 if(!bmpr_read_rle_internal(rctx)) goto done;

 if(!bmpr_has_transparency(rctx->img)) {
  bmpr_strip_alpha(rctx->img);
 }

 var_87 = 1;
done:
 return var_87;
}

static int fn_42(struct struct_45 *rctx)
{
 int var_87 = 0;

 rctx->img->width = rctx->width;
 rctx->img->height = rctx->height;



 if(rctx->fileheader_size>0) {
  size_t expected_offbits;

  expected_offbits = rctx->fileheader_size + rctx->infoheader_size +
   rctx->bitfields_nbytes + rctx->palette_nbytes;

  if(rctx->bfOffBits==expected_offbits) {
   ;
  }
  else if(rctx->bfOffBits>expected_offbits && rctx->bfOffBits<1000000) {


   if(!iwbmp_skip_bytes(rctx, rctx->bfOffBits - expected_offbits)) goto done;
  }
  else {
   iw_set_error(rctx->ctx,"Invalid BMP bits offset");
   goto done;
  }
 }

 if(rctx->compression==0) {
  if(!bmpr_read_uncompressed(rctx)) goto done;
 }
 else if(rctx->compression==1 || rctx->compression==2) {
  if(!bmpr_read_rle(rctx)) goto done;
 }
 else {
  iw_set_errorf(rctx->ctx,"Unsupported BMP compression or image type (%d)",(int)rctx->compression);
  goto done;
 }

 var_87 = 1;
done:
 return var_87;
}

static void fn_43(struct struct_87 *ctx, struct struct_45 *rctx)
{

 if(!rctx->topdown) {
  iw_reorient_image(ctx,IW_REORIENT_FLIP_V);
 }


 iw_set_input_colorspace(ctx,&rctx->csdescr);


 if(rctx->bitcount==16 || rctx->bitcount==32) {
  if(rctx->bf_bits_count[0]!=8 || rctx->bf_bits_count[1]!=8 || rctx->bf_bits_count[2]!=8 ||
   (IW_IMGTYPE_HAS_ALPHA(rctx->img->imgtype) && rctx->bf_bits_count[3]!=8))
  {
   iw_set_input_max_color_code(ctx,0, (1 << rctx->bf_bits_count[0])-1 );
   iw_set_input_max_color_code(ctx,1, (1 << rctx->bf_bits_count[1])-1 );
   iw_set_input_max_color_code(ctx,2, (1 << rctx->bf_bits_count[2])-1 );
   if(IW_IMGTYPE_HAS_ALPHA(rctx->img->imgtype)) {
    iw_set_input_max_color_code(ctx,3, (1 << rctx->bf_bits_count[3])-1 );
   }
  }
 }
}

IW_IMPL(int) fn_44(struct struct_87 *ctx, struct struct_87 *iodescr)
{
 struct struct_45 rctx;
 struct struct_87 img;
 int var_87 = 0;

 iw_zeromem(&rctx,sizeof(struct struct_45));
 iw_zeromem(&img,sizeof(struct struct_87));

 rctx.ctx = ctx;
 rctx.img = &img;
 rctx.iodescr = iodescr;


 iw_make_srgb_csdescr_2(&rctx.csdescr);

 rctx.has_fileheader = !iw_get_value(ctx,IW_VAL_BMP_NO_FILEHEADER);
 if(rctx.has_fileheader) {
  if(!iwbmp_read_file_header(&rctx)) goto done;
 }
 if(!iwbmp_read_info_header(&rctx)) goto done;

 iwbmp_set_default_bitfields(&rctx);
 if(rctx.bitfields_nbytes>0) {
  if(!iwbmp_read_bitfields(&rctx)) goto done;
 }

 if(rctx.palette_entries>0) {
  if(!iwbmp_read_palette(&rctx)) goto done;
 }
 if(!iwbmp_read_bits(&rctx)) goto done;

 iw_set_input_image(ctx, &img);

 iwbmpr_misc_config(ctx, &rctx);

 var_87 = 1;
done:
 if(!var_87) {
  iw_set_error(ctx,"BMP read failed");


  iw_free(ctx, img.pixels);
 }
 return var_87;
}

struct struct_87 {
 int bmpversion;
 int include_file_header;
 int bitcount;
 int palentries;
 int compressed;
 int uses_bitfields;
 size_t header_size;
 size_t bitfields_size;
 size_t palsize;
 size_t unc_dst_bpr;
 size_t unc_bitssize;
 struct struct_87 *iodescr;
 struct struct_87 *ctx;
 struct struct_87 *img;
 const struct struct_80 *pal;
 size_t total_written;
 int bf_amt_to_shift[4];
 unsigned int bf_mask[4];
 unsigned int maxcolor[4];
 struct struct_46 csdescr;
 int no_cslabel;
};

static void fn_46(struct struct_87 *wctx, const void *buf, size_t var_71)
{
 (*wctx->iodescr->write_fn)(wctx->ctx,wctx->iodescr,buf,var_71);
 wctx->total_written+=var_71;
}

static void fn_47(const iw_byte *srcrow, iw_byte *dstrow, int var_52)
{
 int i;
 int m;

 for(i=0;i<var_52;i++) {
  m = i%8;
  if(m==0)
   dstrow[i/8] = srcrow[i]<<7;
  else
   dstrow[i/8] |= srcrow[i]<<(7-m);
 }
}

static void fn_48(const iw_byte *srcrow, iw_byte *dstrow, int var_52)
{
 int i;

 for(i=0;i<var_52;i++) {
  if(i%2==0)
   dstrow[i/2] = srcrow[i]<<4;
  else
   dstrow[i/2] |= srcrow[i];
 }
}

static void fn_49(const iw_byte *srcrow, iw_byte *dstrow, int var_52)
{
 memcpy(dstrow,srcrow,var_52);
}

static void fn_50(struct struct_87 *wctx, const iw_byte *srcrow,
 iw_byte *dstrow, int var_52)
{
 int i,var_62;
 unsigned int v;
 int num_src_samples;
 unsigned int src_sample[4];

 for(var_62=0;var_62<4;var_62++) src_sample[var_62]=0;

 num_src_samples = iw_imgtype_num_channels(wctx->img->imgtype);

 for(i=0;i<var_52;i++) {


  for(var_62=0;var_62<num_src_samples;var_62++) {
   if(wctx->img->bit_depth==16) {
    src_sample[var_62] = (srcrow[num_src_samples*2*i + var_62*2]<<8) | srcrow[num_src_samples*2*i + var_62*2 +1];
   }
   else {
    src_sample[var_62] = srcrow[num_src_samples*i + var_62];
   }
  }


  switch(wctx->img->imgtype) {
  case IW_IMGTYPE_GRAY:
   v = src_sample[0] << wctx->bf_amt_to_shift[0];
   v |= src_sample[0] << wctx->bf_amt_to_shift[1];
   v |= src_sample[0] << wctx->bf_amt_to_shift[2];
   break;
  case IW_IMGTYPE_RGBA:
   v = src_sample[0] << wctx->bf_amt_to_shift[0];
   v |= src_sample[1] << wctx->bf_amt_to_shift[1];
   v |= src_sample[2] << wctx->bf_amt_to_shift[2];
   v |= src_sample[3] << wctx->bf_amt_to_shift[3];
   break;
  case IW_IMGTYPE_GRAYA:
   v = src_sample[0] << wctx->bf_amt_to_shift[0];
   v |= src_sample[0] << wctx->bf_amt_to_shift[1];
   v |= src_sample[0] << wctx->bf_amt_to_shift[2];
   v |= src_sample[1] << wctx->bf_amt_to_shift[3];
   break;
  default:
   v = src_sample[0] << wctx->bf_amt_to_shift[0];
   v |= src_sample[1] << wctx->bf_amt_to_shift[1];
   v |= src_sample[2] << wctx->bf_amt_to_shift[2];
  }


  if(wctx->bitcount==32) {
   dstrow[i*4+0] = (iw_byte)(v&0xff);
   dstrow[i*4+1] = (iw_byte)((v&0x0000ff00)>>8);
   dstrow[i*4+2] = (iw_byte)((v&0x00ff0000)>>16);
   dstrow[i*4+3] = (iw_byte)((v&0xff000000)>>24);
  }
  else {
   dstrow[i*2+0] = (iw_byte)(v&0xff);
   dstrow[i*2+1] = (iw_byte)(v>>8);
  }
 }
}

static void fn_51(struct struct_87 *wctx, const iw_byte *srcrow,
 iw_byte *dstrow, int var_52)
{
 int i;

 if(wctx->img->imgtype==IW_IMGTYPE_GRAY) {
  for(i=0;i<var_52;i++) {
   dstrow[i*3+0] = srcrow[i];
   dstrow[i*3+1] = srcrow[i];
   dstrow[i*3+2] = srcrow[i];
  }
 }
 else {
  for(i=0;i<var_52;i++) {
   dstrow[i*3+0] = srcrow[i*3+2];
   dstrow[i*3+1] = srcrow[i*3+1];
   dstrow[i*3+2] = srcrow[i*3+0];
  }
 }
}

static void fn_52(struct struct_87 *wctx)
{
 iw_byte fileheader[14];

 if(!wctx->include_file_header) return;

 iw_zeromem(fileheader,sizeof(fileheader));
 fileheader[0] = 66;
 fileheader[1] = 77;


 iw_set_ui32le(&fileheader[ 2], (unsigned int)(14+wctx->header_size+
  wctx->bitfields_size+wctx->palsize+wctx->unc_bitssize));
 iw_set_ui32le(&fileheader[10],(unsigned int)(14+wctx->header_size+
  wctx->bitfields_size+wctx->palsize));
 iwbmp_write(wctx,fileheader,14);
}

static int fn_53(struct struct_87 *wctx)
{
 iw_byte header[12];

 if(wctx->img->width>65535 || wctx->img->height>65535) {
  iw_set_error(wctx->ctx,"Output image is too large for this BMP version");
  return 0;
 }

 iw_zeromem(header,sizeof(header));
 iw_set_ui32le(&header[ 0],12);
 iw_set_ui16le(&header[ 4],wctx->img->width);
 iw_set_ui16le(&header[ 6],wctx->img->height);
 iw_set_ui16le(&header[ 8],1);
 iw_set_ui16le(&header[10],wctx->bitcount);

 iwbmp_write(wctx,header,12);
 return 1;
}

static int fn_54(struct struct_87 *wctx)
{
 unsigned int dens_x, dens_y;
 unsigned int cmpr;
 iw_byte header[40];

 iw_zeromem(header,sizeof(header));

 iw_set_ui32le(&header[ 0],(unsigned int)wctx->header_size);
 iw_set_ui32le(&header[ 4],wctx->img->width);
 iw_set_ui32le(&header[ 8],wctx->img->height);
 iw_set_ui16le(&header[12],1);
 iw_set_ui16le(&header[14],wctx->bitcount);

 cmpr = 0;
 if(wctx->compressed) {
  if(wctx->bitcount==8) cmpr = 1;
  else if(wctx->bitcount==4) cmpr = 2;
 }
 else if(wctx->uses_bitfields) {
  cmpr = 3;
 }
 iw_set_ui32le(&header[16],cmpr);

 iw_set_ui32le(&header[20],(unsigned int)wctx->unc_bitssize);

 if(wctx->img->density_code==IW_DENSITY_UNITS_PER_METER) {
  dens_x = (unsigned int)(0.5+wctx->img->density_x);
  dens_y = (unsigned int)(0.5+wctx->img->density_y);
 }
 else {
  dens_x = dens_y = 2835;
 }
 iw_set_ui32le(&header[24],dens_x);
 iw_set_ui32le(&header[28],dens_y);

 iw_set_ui32le(&header[32],wctx->palentries);

 iwbmp_write(wctx,header,40);
 return 1;
}

static int fn_55(struct struct_87 *wctx)
{
 iw_byte header[124];
 unsigned int intent_bmp_style;

 iw_zeromem(header,sizeof(header));

 if(wctx->uses_bitfields) {
  iw_set_ui32le(&header[40],wctx->bf_mask[0]);
  iw_set_ui32le(&header[44],wctx->bf_mask[1]);
  iw_set_ui32le(&header[48],wctx->bf_mask[2]);
  iw_set_ui32le(&header[52],wctx->bf_mask[3]);
 }




 if(wctx->csdescr.cstype==IW_CSTYPE_SRGB && !wctx->no_cslabel)
  iw_set_ui32le(&header[56],0x73524742);
 else
  iw_set_ui32le(&header[56],1);




 switch(wctx->img->rendering_intent) {
 case IW_INTENT_PERCEPTUAL: intent_bmp_style = 4; break;
 case IW_INTENT_RELATIVE: intent_bmp_style = 2; break;
 case IW_INTENT_SATURATION: intent_bmp_style = 1; break;
 case IW_INTENT_ABSOLUTE: intent_bmp_style = 8; break;
 default: intent_bmp_style = 4;
 }

 iw_set_ui32le(&header[108],intent_bmp_style);

 iwbmp_write(wctx,&header[40],84);
 return 1;
}

static int fn_56(struct struct_87 *wctx)
{
 if(wctx->bmpversion==2) {
  return iwbmp_write_bmp_v2header(wctx);
 }
 else if(wctx->bmpversion==5) {
  if(!iwbmp_write_bmp_v3header(wctx)) return 0;
  return iwbmp_write_bmp_v45header_fields(wctx);
 }
 return iwbmp_write_bmp_v3header(wctx);
}



static int fn_57(struct struct_87 *wctx, int var_60)
{
 int var_62;
 int bits[4];
 int var_60 = 0;

 for(var_62=0;var_62<var_60;var_62++) {
  bits[var_62] = iw_max_color_to_bitdepth(wctx->maxcolor[var_62]);
  var_60 += bits[var_62];
 }

 if(var_60 > 32) {
  iw_set_error(wctx->ctx,"Cannot write a BMP image in this color format");
  return 0;
 }

 wctx->bitcount = (var_60>16) ? 32 : 16;

 wctx->bf_amt_to_shift[0] = bits[1] + bits[2];
 wctx->bf_amt_to_shift[1] = bits[2];
 wctx->bf_amt_to_shift[2] = 0;
 if(var_60>3) wctx->bf_amt_to_shift[3] = bits[0] + bits[1] + bits[2];

 for(var_62=0;var_62<var_60;var_62++) {
  wctx->bf_mask[var_62] = wctx->maxcolor[var_62] << wctx->bf_amt_to_shift[var_62];
 }

 return 1;
}


static int fn_60(struct struct_87 *wctx)
{
 iw_byte buf[12];
 int var_62;

 if(wctx->bitcount!=16 && wctx->bitcount!=32) return 0;

 for(var_62=0;var_62<3;var_62++) {
  iw_set_ui32le(&buf[4*var_62],wctx->bf_mask[var_62]);
 }
 iwbmp_write(wctx,buf,12);
 return 1;
}

static void fn_61(struct struct_87 *wctx)
{
 int i,var_62;
 iw_byte buf[4];

 if(wctx->palentries<1) return;

 buf[3] = 0;

 for(i=0;i<wctx->palentries;i++) {
  if(i<wctx->pal->num_entries) {
   if(wctx->pal->entry[i].a == 0) {







    if(wctx->img->has_bkgdlabel) {
     for(var_62=0;var_62<3;var_62++) {
      buf[var_62] = (iw_byte)iw_color_get_int_sample(&wctx->img->bkgdlabel,2-var_62,255);
     }
    }
    else {
     buf[0] = 255;
     buf[1] = 0;
     buf[2] = 255;
    }
   }
   else {
    buf[0] = wctx->pal->entry[i].b;
    buf[1] = wctx->pal->entry[i].g;
    buf[2] = wctx->pal->entry[i].r;
   }
  }
  else {
   buf[0] = buf[1] = buf[2] = 0;
  }
  if(wctx->bmpversion==2)
   iwbmp_write(wctx,buf,3);
  else
   iwbmp_write(wctx,buf,4);
 }
}

struct struct_78 {
 struct struct_87 *ctx;
 struct struct_87 *wctx;
 const iw_byte *srcrow;

 size_t img_width;
 int cur_row;



 size_t pending_data_start;



 size_t unc_len;



 size_t run_len;



 iw_byte run_byte;

 size_t total_bytes_written;
};







static void fn_63(struct struct_78 *rlectx)
{
 size_t i;
 iw_byte dstbuf[2];

 if(rlectx->unc_len<1) return;
 if(rlectx->unc_len>=3 && (rlectx->unc_len&1)) {
  iw_set_error(rlectx->ctx,"Internal: RLE encode error 4");
  return;
 }
 if(rlectx->unc_len>254) {
  iw_set_error(rlectx->ctx,"Internal: RLE encode error 5");
  return;
 }

 if(rlectx->unc_len<3) {


  for(i=0;i<rlectx->unc_len;i++) {
   dstbuf[0] = 0x01;
   dstbuf[1] = rlectx->srcrow[i+rlectx->pending_data_start];
   iwbmp_write(rlectx->wctx,dstbuf,2);
   rlectx->total_bytes_written+=2;
  }
 }
 else {
  dstbuf[0] = 0x00;
  dstbuf[1] = (iw_byte)rlectx->unc_len;
  iwbmp_write(rlectx->wctx,dstbuf,2);
  rlectx->total_bytes_written+=2;
  iwbmp_write(rlectx->wctx,&rlectx->srcrow[rlectx->pending_data_start],rlectx->unc_len);
  rlectx->total_bytes_written+=rlectx->unc_len;
  if(rlectx->unc_len&0x1) {


   dstbuf[0] = 0x00;
   iwbmp_write(rlectx->wctx,dstbuf,1);
   rlectx->total_bytes_written+=1;
  }
 }

 rlectx->pending_data_start+=rlectx->unc_len;
 rlectx->unc_len=0;
}

static void fn_64(struct struct_78 *rlectx)
{
 iw_byte dstbuf[2];

 rle8_write_unc(rlectx);

 if(rlectx->run_len<1) {
  return;
 }
 if(rlectx->run_len>255) {
  iw_set_error(rlectx->ctx,"Internal: RLE encode error 6");
  return;
 }

 dstbuf[0] = (iw_byte)rlectx->run_len;
 dstbuf[1] = rlectx->run_byte;
 iwbmp_write(rlectx->wctx,dstbuf,2);
 rlectx->total_bytes_written+=2;

 rlectx->pending_data_start+=rlectx->run_len;
 rlectx->run_len=0;
}

static void fn_65(struct struct_78 *rlectx, int var_75)
{
 iw_byte dstbuf[4];
 int var_68 = var_75;
 int num_to_write;

 while(var_68>0) {
  num_to_write = var_68;
  if(num_to_write>255) num_to_write=255;
  dstbuf[0]=0x00;
  dstbuf[1]=0x02;
  dstbuf[2]=(iw_byte)num_to_write;
  dstbuf[3]=0x00;
  iwbmp_write(rlectx->wctx,dstbuf,4);
  rlectx->total_bytes_written+=4;
  var_68 -= num_to_write;
 }
 rlectx->pending_data_start += var_75;
}

static int fn_68(struct struct_78 *rlectx)
{
 size_t i;
 iw_byte dstbuf[2];
 iw_byte next_byte;
 int next_pix_is_trns;
 int var_75 = 0;
 int var_87 = 0;

 rlectx->pending_data_start=0;
 rlectx->unc_len=0;
 rlectx->run_len=0;

 for(i=0;i<rlectx->img_width;i++) {


  next_byte = rlectx->srcrow[i];

  next_pix_is_trns = (rlectx->wctx->pal->entry[next_byte].a==0);

  if(var_75>0 && !next_pix_is_trns) {
   rle_write_trns(rlectx,var_75);
   var_75=0;
  }
  else if(next_pix_is_trns) {
   if (rlectx->unc_len>0 || rlectx->run_len>0) {
    rle8_write_unc_and_run(rlectx);
   }
   var_75++;
   continue;
  }




  if(rlectx->run_len>0 && next_byte==rlectx->run_byte) {

   rlectx->run_len++;
  }
  else if(rlectx->run_len==0) {

   rlectx->run_len = 1;
   rlectx->run_byte = next_byte;
  }
  else if(rlectx->unc_len==0 && rlectx->run_len==1) {


   rlectx->unc_len++;
   rlectx->run_byte = next_byte;
  }
  else if(rlectx->unc_len>0 && rlectx->run_len<(rlectx->unc_len==1 ? 3U : 4U)) {




   rlectx->unc_len += rlectx->run_len;
   rlectx->run_len = 0;


   if(rlectx->unc_len>=3 && (rlectx->unc_len&0x1)) {
    rlectx->unc_len++;
   }
   else {
    rlectx->run_len = 1;
    rlectx->run_byte = next_byte;
   }
  }
  else {

   rle8_write_unc_and_run(rlectx);
   rlectx->run_len = 1;
   rlectx->run_byte = next_byte;
  }




  if(rlectx->unc_len>=254) {

   rle8_write_unc(rlectx);
  }
  else if(rlectx->unc_len>0 && (rlectx->unc_len+rlectx->run_len)>254) {


   rle8_write_unc(rlectx);
  }
  else if(rlectx->run_len>=255) {

   rle8_write_unc_and_run(rlectx);
  }

  if((rlectx->unc_len&0x1) && rlectx->unc_len!=1) {
   iw_set_errorf(rlectx->ctx,"Internal: BMP RLE encode error 1");
   goto done;
  }



  if(rlectx->unc_len>252) {
   iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 2");
   goto done;
  }



  if(rlectx->run_len>254) {
   iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 3");
   goto done;
  }
 }


 rle8_write_unc_and_run(rlectx);



 dstbuf[0]=0x00;
 dstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;
 iwbmp_write(rlectx->wctx,dstbuf,2);
 rlectx->total_bytes_written+=2;

 var_87 = 1;

done:
 return var_87;
}






static size_t fn_69(size_t var_71)
{

 if(var_71<=255) return var_71;

 if(var_71==257 || var_71==510 || var_71==765) return 255;

 return 252;
}







static int fn_70(struct struct_78 *rlectx)
{
 int var_71;
 int m;

 var_71 = (int)rlectx->unc_len;

 if(var_71==2 || var_71==255 || var_71==257 || var_71==507 || var_71==510) return 2;
 if(var_71==256 || var_71==508) return 0;

 if(var_71>=759) {
  m = var_71%252;
  if(m==3 || m==6 || m==9) return 2;
  if(m==4 || m==8) return 0;
 }

 return (var_71%4)?0:2;
}

static void fn_71(struct struct_78 *rlectx)
{
 iw_byte dstbuf[128];
 size_t pixels_to_write;
 size_t bytes_to_write;

 if(rlectx->unc_len<1) return;




 while(rlectx->unc_len>0) {
  pixels_to_write = rle4_get_best_unc_split(rlectx->unc_len);

  if(pixels_to_write<3) {


   dstbuf[0] = (iw_byte)pixels_to_write;
   dstbuf[1] = (rlectx->srcrow[rlectx->pending_data_start]<<4);
   if(pixels_to_write>1)
    dstbuf[1] |= (rlectx->srcrow[rlectx->pending_data_start+1]);



   bytes_to_write = 2;
  }
  else {
   size_t i;


   dstbuf[0] = 0x00;
   dstbuf[1] = (iw_byte)pixels_to_write;
   iwbmp_write(rlectx->wctx,dstbuf,2);
   rlectx->total_bytes_written+=2;


   bytes_to_write = 2*((pixels_to_write+3)/4);
   iw_zeromem(dstbuf,bytes_to_write);

   for(i=0;i<pixels_to_write;i++) {
    if(i&0x1) dstbuf[i/2] |= rlectx->srcrow[rlectx->pending_data_start+i];
    else dstbuf[i/2] = rlectx->srcrow[rlectx->pending_data_start+i]<<4;
   }
  }

  iwbmp_write(rlectx->wctx,dstbuf,bytes_to_write);
  rlectx->total_bytes_written += bytes_to_write;
  rlectx->unc_len -= pixels_to_write;
  rlectx->pending_data_start += pixels_to_write;
 }
}

static void fn_72(struct struct_78 *rlectx)
{
 iw_byte dstbuf[2];

 rle4_write_unc(rlectx);

 if(rlectx->run_len<1) {
  return;
 }
 if(rlectx->run_len>255) {
  iw_set_error(rlectx->ctx,"Internal: RLE encode error 6");
  return;
 }

 dstbuf[0] = (iw_byte)rlectx->run_len;
 dstbuf[1] = rlectx->run_byte;
 iwbmp_write(rlectx->wctx,dstbuf,2);
 rlectx->total_bytes_written+=2;

 rlectx->pending_data_start+=rlectx->run_len;
 rlectx->run_len=0;
}




static int fn_73(struct struct_78 *rlectx)
{






 if(rlectx->unc_len==0) {
  return (rlectx->run_len<4);
 }
 else if(rlectx->unc_len<=2) {
  return (rlectx->run_len<6);
 }
 else {
  return (rlectx->run_len<8);
 }
 return 0;
}

static int fn_74(struct struct_78 *rlectx)
{
 size_t i;
 iw_byte dstbuf[2];
 iw_byte next_pix;
 int next_pix_is_trns;
 int var_75 = 0;
 int var_87 = 0;
 iw_byte tmpb;

 rlectx->pending_data_start=0;
 rlectx->unc_len=0;
 rlectx->run_len=0;

 for(i=0;i<rlectx->img_width;i++) {


  next_pix = rlectx->srcrow[i];

  next_pix_is_trns = (rlectx->wctx->pal->entry[next_pix].a==0);
  if(var_75>0 && !next_pix_is_trns) {
   rle_write_trns(rlectx,var_75);
   var_75=0;
  }
  else if(next_pix_is_trns) {
   if (rlectx->unc_len>0 || rlectx->run_len>0) {
    rle4_write_unc_and_run(rlectx);
   }
   var_75++;
   continue;
  }




  if(rlectx->run_len==0) {

   rlectx->run_len = 1;
   rlectx->run_byte = next_pix<<4;
  }
  else if(rlectx->run_len==1) {

   rlectx->run_byte |= next_pix;
   rlectx->run_len++;
  }
  else if(rlectx->run_len>=2 && (rlectx->run_len&1)==0 && next_pix==(rlectx->run_byte>>4)) {

   rlectx->run_len++;
  }
  else if(rlectx->run_len>=3 && (rlectx->run_len&1) && next_pix==(rlectx->run_byte&0x0f)) {

   rlectx->run_len++;
  }
  else if(rlectx->unc_len==0 && rlectx->run_len==2) {


   rlectx->unc_len+=rlectx->run_len;
   rlectx->run_byte = next_pix<<4;
   rlectx->run_len = 1;
  }
  else if(ok_to_move_to_unc(rlectx)) {



   rlectx->unc_len += rlectx->run_len-1;

   if((rlectx->run_len&1)==0)
    rlectx->run_byte = (rlectx->run_byte&0x0f)<<4;
   else
    rlectx->run_byte = (rlectx->run_byte&0xf0);


   rlectx->run_len = 2;
   rlectx->run_byte |= next_pix;
  }
  else {

   rle4_write_unc_and_run(rlectx);
   rlectx->run_len = 1;
   rlectx->run_byte = next_pix<<4;
  }



  while(rlectx->unc_len>0 && rlectx->run_len>0 && rle4_get_incr_unc_cost(rlectx)==0) {
   rlectx->unc_len++;
   rlectx->run_len--;
   tmpb = rlectx->run_byte;

   rlectx->run_byte = (tmpb>>4) | ((tmpb&0x0f)<<4);
   if(rlectx->run_len==1) rlectx->run_byte &= 0xf0;
  }




  if(rlectx->run_len>=255) {

   rle4_write_unc_and_run(rlectx);
  }







  if(rlectx->run_len>255) {
   iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 3");
   goto done;
  }
 }


 rle4_write_unc_and_run(rlectx);



 dstbuf[0]=0x00;
 dstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;
 iwbmp_write(rlectx->wctx,dstbuf,2);
 rlectx->total_bytes_written+=2;

 var_87 = 1;

done:
 return var_87;
}




static int fn_75(struct struct_87 *wctx,size_t var_77)
{
 iw_byte buf[4];
 size_t fileheader_size;
 int ret;

 if(!wctx->iodescr->seek_fn) {
  iw_set_error(wctx->ctx,"Writing compressed BMP requires a seek function");
  return 0;
 }

 if(wctx->include_file_header) {

  ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
  if(!ret) return 0;
  iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+var_77));
  iwbmp_write(wctx,buf,4);
  fileheader_size = 14;
 }
 else {
  fileheader_size = 0;
 }


 ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
 if(!ret) return 0;
 iw_set_ui32le(buf,(unsigned int)var_77);
 iwbmp_write(wctx,buf,4);

 (*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
 return 1;
}

static int fn_77(struct struct_87 *wctx,
 struct struct_87 *img)
{
 struct struct_78 rlectx;
 int j;
 int var_87 = 0;

 iw_zeromem(&rlectx,sizeof(struct struct_78));

 rlectx.ctx = wctx->ctx;
 rlectx.wctx = wctx;
 rlectx.total_bytes_written = 0;
 rlectx.img_width = img->width;

 for(j=img->height-1;j>=0;j--) {

  rlectx.srcrow = &img->pixels[j*img->bpr];
  rlectx.cur_row = j;

  if(wctx->bitcount==4) {
   if(!rle4_compress_row(&rlectx)) goto done;
  }
  else if(wctx->bitcount==8) {
   if(!rle8_compress_row(&rlectx)) goto done;
  }
  else {
   goto done;
  }
 }


 if(!rle_patch_file_size(wctx,rlectx.total_bytes_written)) goto done;

 var_87 = 1;
done:
 return var_87;
}

static void fn_78(struct struct_87 *wctx,
 struct struct_87 *img)
{
 int j;
 iw_byte *dstrow = NULL;
 const iw_byte *srcrow;

 dstrow = iw_mallocz(wctx->ctx,wctx->unc_dst_bpr);
 if(!dstrow) goto done;

 for(j=img->height-1;j>=0;j--) {
  srcrow = &img->pixels[j*img->bpr];
  switch(wctx->bitcount) {
  case 32: bmpw_convert_row_16_32(wctx,srcrow,dstrow,img->width); break;
  case 24: bmpw_convert_row_24(wctx,srcrow,dstrow,img->width); break;
  case 16: bmpw_convert_row_16_32(wctx,srcrow,dstrow,img->width); break;
  case 8: bmpw_convert_row_8(srcrow,dstrow,img->width); break;
  case 4: bmpw_convert_row_4(srcrow,dstrow,img->width); break;
  case 1: bmpw_convert_row_1(srcrow,dstrow,img->width); break;
  }
  iwbmp_write(wctx,dstrow,wctx->unc_dst_bpr);
 }

done:
 if(dstrow) iw_free(wctx->ctx,dstrow);
 return;
}




static int fn_79(const struct struct_80 *p)
{
 int i;
 int var_87 = 0;

 for(i=0;i<p->num_entries;i++) {
  if(p->entry[i].a!=255) var_87=1;
  if(p->entry[i].a!=255 && p->entry[i].a!=0) return 2;
 }
 return var_87;
}


static int fn_80(struct struct_87 *wctx,
 int var_85, int var_85, int var_85, int var_85)
{
 int has_alpha;

 has_alpha = IW_IMGTYPE_HAS_ALPHA(wctx->img->imgtype);

 if(wctx->bmpversion<3) {
  iw_set_errorf(wctx->ctx,"Bit depth incompatible with BMP version %d",
   wctx->bmpversion);
  return 0;
 }

 if(has_alpha && wctx->bmpversion<5) {
  iw_set_error(wctx->ctx,"Internal: Attempt to write v3 16- or 32-bit image with transparency");
  return 0;
 }



 wctx->maxcolor[0] = var_85;
 wctx->maxcolor[1] = var_85;
 wctx->maxcolor[2] = var_85;
 if(has_alpha) wctx->maxcolor[3] = var_85;

 if(!iwbmp_calc_bitfields_masks(wctx,has_alpha?4:3)) return 0;

 if(var_85==31 && var_85==31 && var_85==31 && !has_alpha) {



  wctx->bitfields_size = 0;
 }
 else {
  wctx->uses_bitfields = 1;
  wctx->bitfields_size = (wctx->bmpversion==3) ? 12 : 0;
 }
 return 1;
}

static int fn_85(struct struct_87 *wctx)
{
 struct struct_87 *img;
 int cmpr_req;
 int var_87 = 0;
 int var_86;
 const char *optv;

 img = wctx->img;

 wctx->bmpversion = 0;
 optv = iw_get_option(wctx->ctx, "bmp:version");
 if(optv) {
  wctx->bmpversion = iw_parse_int(optv);
 }

 if(wctx->bmpversion==0) wctx->bmpversion=3;
 if(wctx->bmpversion==4) {
  iw_warning(wctx->ctx,"Writing BMP v4 is not supported; using v3 instead");
  wctx->bmpversion=3;
 }
 if(wctx->bmpversion!=2 && wctx->bmpversion!=3 && wctx->bmpversion!=5) {
  iw_set_errorf(wctx->ctx,"Unsupported BMP version: %d",wctx->bmpversion);
  goto done;
 }

 if(wctx->bmpversion>=3)
  cmpr_req = iw_get_value(wctx->ctx,IW_VAL_COMPRESSION);
 else
  cmpr_req = IW_COMPRESSION_NONE;

 if(wctx->bmpversion==2)
  wctx->header_size = 12;
 else if(wctx->bmpversion==5)
  wctx->header_size = 124;
 else
  wctx->header_size = 40;

 wctx->no_cslabel = iw_get_value(wctx->ctx,IW_VAL_NO_CSLABEL);


 if(cmpr_req==IW_COMPRESSION_AUTO || cmpr_req==IW_COMPRESSION_NONE)
  cmpr_req = IW_COMPRESSION_NONE;
 else
  cmpr_req = IW_COMPRESSION_RLE;

 if(img->imgtype==IW_IMGTYPE_RGB) {
  if(img->reduced_maxcolors) {
   if(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],
    img->maxcolorcode[IW_CHANNELTYPE_GREEN],
    img->maxcolorcode[IW_CHANNELTYPE_BLUE],0))
   {
    goto done;
   }
  }
  else {
   wctx->bitcount=24;
  }
 }
 else if(img->imgtype==IW_IMGTYPE_PALETTE) {
  if(!wctx->pal) goto done;

  var_86 = check_palette_transparency(wctx->pal);

  if(var_86!=0 && wctx->bmpversion<3) {
   iw_set_error(wctx->ctx,"Cannot save as a transparent BMP: Incompatible BMP version");
   goto done;
  }
  else if(var_86==2) {
   iw_set_error(wctx->ctx,"Cannot save this image as a transparent BMP: Has partial transparency");
   goto done;
  }
  else if(var_86!=0 && cmpr_req!=IW_COMPRESSION_RLE) {
   iw_set_error(wctx->ctx,"Cannot save as a transparent BMP: RLE compression required");
   goto done;
  }

  if(wctx->pal->num_entries<=2 && cmpr_req!=IW_COMPRESSION_RLE)
   wctx->bitcount=1;
  else if(wctx->pal->num_entries<=16)
   wctx->bitcount=4;
  else
   wctx->bitcount=8;
 }
 else if(img->imgtype==IW_IMGTYPE_RGBA) {
  if(img->reduced_maxcolors) {
   if(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],
    img->maxcolorcode[IW_CHANNELTYPE_GREEN],
    img->maxcolorcode[IW_CHANNELTYPE_BLUE],
    img->maxcolorcode[IW_CHANNELTYPE_ALPHA]))
   {
    goto done;
   }
  }
  else {
   if(!setup_16_32bit(wctx,255,255,255,255)) {
    goto done;
   }
  }
 }
 else if(img->imgtype==IW_IMGTYPE_GRAYA) {
  if(img->reduced_maxcolors) {
   if(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],
    img->maxcolorcode[IW_CHANNELTYPE_GRAY],
    img->maxcolorcode[IW_CHANNELTYPE_GRAY],
    img->maxcolorcode[IW_CHANNELTYPE_ALPHA]))
   {
    goto done;
   }
  }
  else {
   if(!setup_16_32bit(wctx,255,255,255,255)) {
    goto done;
   }
  }
 }
 else if(img->imgtype==IW_IMGTYPE_GRAY) {
  if(img->reduced_maxcolors) {
   if(img->maxcolorcode[IW_CHANNELTYPE_GRAY]<=1023) {
    if(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],
     img->maxcolorcode[IW_CHANNELTYPE_GRAY],
     img->maxcolorcode[IW_CHANNELTYPE_GRAY],0))
    {
     goto done;
    }
   }
   else {
    iw_set_error(wctx->ctx,"Cannot write grayscale BMP at this bit depth");
    goto done;
   }
  }
  else {



   wctx->bitcount=24;
  }
 }
 else {
  iw_set_error(wctx->ctx,"Internal: Bad image type for BMP");
  goto done;
 }

 if(cmpr_req==IW_COMPRESSION_RLE && (wctx->bitcount==4 || wctx->bitcount==8)) {
  wctx->compressed = 1;
 }

 wctx->unc_dst_bpr = iwbmp_calc_bpr(wctx->bitcount,img->width);
 wctx->unc_bitssize = wctx->unc_dst_bpr * img->height;
 wctx->palentries = 0;

 if(wctx->pal) {
  if(wctx->bmpversion==2) {
   wctx->palentries = 1<<wctx->bitcount;
   wctx->palsize = wctx->palentries*3;
  }
  else {
   if(wctx->bitcount==1) {


    wctx->palentries=2;
   }
   else {
    wctx->palentries = wctx->pal->num_entries;
   }
   wctx->palsize = wctx->palentries*4;
  }
 }


 iwbmp_write_file_header(wctx);


 if(!iwbmp_write_bmp_header(wctx)) {
  goto done;
 }

 if(wctx->bitfields_size>0) {
  if(!iwbmp_write_bitfields(wctx)) goto done;
 }


 iwbmp_write_palette(wctx);


 if(wctx->compressed) {
  if(!iwbmp_write_pixels_compressed(wctx,img)) goto done;
 }
 else {
  iwbmp_write_pixels_uncompressed(wctx,img);
 }

 var_87 = 1;
done:
 return var_87;
}

IW_IMPL(int) fn_86(struct struct_87 *ctx, struct struct_87 *iodescr)
{
 struct struct_87 wctx;
 int var_87=0;
 struct struct_87 img1;

 iw_zeromem(&img1,sizeof(struct struct_87));

 iw_zeromem(&wctx,sizeof(struct struct_87));

 wctx.ctx = ctx;
 wctx.include_file_header = 1;

 wctx.iodescr=iodescr;

 iw_get_output_image(ctx,&img1);
 wctx.img = &img1;

 if(wctx.img->imgtype==IW_IMGTYPE_PALETTE) {
  wctx.pal = iw_get_output_palette(ctx);
  if(!wctx.pal) goto done;
 }

 iw_get_output_colorspace(ctx,&wctx.csdescr);

 if(!iwbmp_write_main(&wctx)) {
  iw_set_error(ctx,"BMP write failed");
  goto done;
 }

 var_87=1;

done:
 return var_87;
}
