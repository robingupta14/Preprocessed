







static char tiffcrop_version_id[] = "2.4";
static char tiffcrop_rev_date[] = "12-13-2010";

extern int fn_0(int var_155, char * const argv[], const char *optstring);

struct struct_190 {
  uint32 tmargin;
  uint32 lmargin;
  uint32 bmargin;
  uint32 rmargin;
  uint32 crop_width;
  uint32 crop_length;
  uint32 startx;
  uint32 endx;
  uint32 starty;
  uint32 endy;
};







struct struct_208 {
  uint32 size;
  unsigned char *buffer;
};

struct struct_9 {
  int position;
  int total;
  };

struct struct_202 {
  uint32 x1;
  uint32 x2;
  uint32 y1;
  uint32 y2;
  int position;
  int total;
  uint32 buffsize;
};

struct struct_9 {
  double X1;
  double X2;
  double Y1;
  double Y2;
};

struct struct_9 {
  uint32 x1;
  uint32 x2;
  uint32 y1;
  uint32 y2;
  uint32 width;
  uint32 length;
  uint32 buffsize;
  unsigned char *buffptr;
};





struct struct_209 {
  double width;
  double length;
  double margins[4];
  float xres;
  float yres;
  uint32 combined_width;
  uint32 combined_length;
  uint32 bufftotal;
  uint16 img_mode;
  uint16 exp_mode;
  uint16 crop_mode;
  uint16 res_unit;
  uint16 edge_ref;
  uint16 rotation;
  uint16 mirror;
  uint16 invert;
  uint16 photometric;
  uint16 selections;
  uint16 regions;
  struct struct_9 regionlist[8];
  uint16 zones;
  struct struct_9 zonelist[8];
  struct struct_9 corners[8];
};

struct struct_10 {
  char name[15];
  double width;
  double length;
  double asratio;
  };




struct struct_10 PaperTable[49] = {
  {"default", 8.500, 14.000, 0.607},
  {"pa4", 8.264, 11.000, 0.751},
  {"letter", 8.500, 11.000, 0.773},
  {"legal", 8.500, 14.000, 0.607},
  {"half-letter", 8.500, 5.514, 1.542},
  {"executive", 7.264, 10.528, 0.690},
  {"tabloid", 11.000, 17.000, 0.647},
  {"11x17", 11.000, 17.000, 0.647},
  {"ledger", 17.000, 11.000, 1.545},
  {"archa", 9.000, 12.000, 0.750},
  {"archb", 12.000, 18.000, 0.667},
  {"archc", 18.000, 24.000, 0.750},
  {"archd", 24.000, 36.000, 0.667},
  {"arche", 36.000, 48.000, 0.750},
  {"csheet", 17.000, 22.000, 0.773},
  {"dsheet", 22.000, 34.000, 0.647},
  {"esheet", 34.000, 44.000, 0.773},
  {"superb", 11.708, 17.042, 0.687},
  {"commercial", 4.139, 9.528, 0.434},
  {"monarch", 3.889, 7.528, 0.517},
  {"envelope-dl", 4.333, 8.681, 0.499},
  {"envelope-c5", 6.389, 9.028, 0.708},
  {"europostcard", 4.139, 5.833, 0.710},
  {"a0", 33.110, 46.811, 0.707},
  {"a1", 23.386, 33.110, 0.706},
  {"a2", 16.535, 23.386, 0.707},
  {"a3", 11.693, 16.535, 0.707},
  {"a4", 8.268, 11.693, 0.707},
  {"a5", 5.827, 8.268, 0.705},
  {"a6", 4.134, 5.827, 0.709},
  {"a7", 2.913, 4.134, 0.705},
  {"a8", 2.047, 2.913, 0.703},
  {"a9", 1.457, 2.047, 0.712},
  {"a10", 1.024, 1.457, 0.703},
  {"b0", 39.370, 55.669, 0.707},
  {"b1", 27.835, 39.370, 0.707},
  {"b2", 19.685, 27.835, 0.707},
  {"b3", 13.898, 19.685, 0.706},
  {"b4", 9.843, 13.898, 0.708},
  {"b5", 6.929, 9.843, 0.704},
  {"b6", 4.921, 6.929, 0.710},
  {"c0", 36.102, 51.063, 0.707},
  {"c1", 25.512, 36.102, 0.707},
  {"c2", 18.031, 25.512, 0.707},
  {"c3", 12.756, 18.031, 0.707},
  {"c4", 9.016, 12.756, 0.707},
  {"c5", 6.378, 9.016, 0.707},
  {"c6", 4.488, 6.378, 0.704},
  {"", 0.000, 0.000, 1.000}
};


struct struct_210 {
  float xres;
  float yres;
  uint32 width;
  uint32 length;
  uint16 res_unit;
  uint16 bps;
  uint16 spp;
  uint16 planar;
  uint16 photometric;
  uint16 orientation;
  uint16 compression;
  uint16 adjustments;
};


struct struct_202 {
  char name[16];
  double width;
  double length;
  double hmargin;
  double vmargin;
  double hres;
  double vres;
  uint32 mode;
  uint16 res_unit;
  unsigned int rows;
  unsigned int cols;
  unsigned int orient;
};

struct struct_209 {
  int debug;
  int format;
  int level;
  char mode[4];
  char infilename[1025];
  char outfilename[1025];
  FILE *infile;
  FILE *outfile;
  };


static int var_210 = -1;
static uint32 var_210 = 0;
static uint32 var_210 = 0;

static uint16 var_210 = 0;
static uint16 var_210 = 0;
static uint16 var_210 = 0;
static uint16 var_210 = 0;
static uint32 var_210 = 0;
static uint32 var_210 = 0;
static int var_186 = 0;
static uint32 var_155 = (uint32) -1;
static int var_210 = 100;

static int var_210 = var_210;
static uint16 var_155 = (uint16) -1;
static uint16 var_155 = (uint16) -1;
static int var_207 = 0;
static int var_213 = 1;


static int fn_178 (TIFF*, uint8*);
static int fn_183 (TIFF*, uint8*, uint32, uint32, tsample_t, struct struct_209 *);
static int fn_103 (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);
static int fn_121 (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);
static int fn_122 (TIFF*, uint8*, uint32);
static int fn_130 (TIFF*, uint8*, uint32, uint32, tsample_t, struct struct_209 *);
static int fn_125 (TIFF*, uint8*, uint32, uint32, tsample_t, struct struct_209 *);
static int fn_130 (TIFF*, uint8*, uint32, uint32, tsample_t, struct struct_209 *);
static int fn_177 (uint8 *, uint8 *, uint32, uint32, tsample_t,
                                         uint16, uint16, struct struct_209 *);
static int fn_131(char*);
static void fn_131(void);


static void fn_186 (struct struct_210 *);
static void fn_186 (struct struct_209 *);
static void fn_186 (struct struct_202 *, struct struct_202 *, struct struct_208 []);
static void fn_186(struct struct_209 *);


void fn_135 (int, char *[], char *, char *, uint32 *,
                     uint16 *, uint16 *, uint32 *, uint32 *, uint32 *,
              struct struct_209 *, struct struct_202 *,
                            struct struct_209 *,
                            unsigned int *, unsigned int *);
static int fn_146 (TIFF **, char *, int, char *, unsigned int *);



static int fn_186 (char *, struct struct_202*);
static int fn_186(struct struct_209 *, struct struct_210 *,
                                     struct struct_190 *);
static int fn_190 (struct struct_209 *, struct struct_210 *,
           struct struct_202 *, struct struct_202 *,
                                       struct struct_209 *);
static int fn_190(TIFF *, struct struct_210 *, struct struct_209 *, unsigned char **);
static int fn_199(struct struct_210 *, unsigned char **);
static int fn_189(struct struct_210 *, struct struct_209 *, struct struct_209 *);
static int fn_208(struct struct_210 *, struct struct_209 *,
                                  unsigned char **, struct struct_208 []);
static int fn_202(TIFF *, TIFF **, struct struct_209 *, struct struct_210 *,
                            struct struct_209 *, struct struct_208 [],
                            char *, char *, unsigned int*, unsigned int);


static int fn_207(uint32, unsigned char **);
static int fn_202(struct struct_210 *, struct struct_202 *,
                                unsigned char *, unsigned char *);
static int fn_205(TIFF *, TIFF *, struct struct_210 *,
                               struct struct_209 *, uint32, uint32,
          double, double, unsigned char *);
static int fn_202(TIFF *, TIFF *, struct struct_210 *,
                               struct struct_202 *, struct struct_202 *,
                               struct struct_209 *, unsigned char *,
                               unsigned char **);

static int fn_209(struct struct_210 *, struct struct_209 *,
                               unsigned char **, unsigned char **);
static int fn_209(TIFF *, TIFF *, struct struct_210 *image,
                              struct struct_209 * dump,
                              uint32, uint32, unsigned char *, int, int);


static int fn_210(uint16, uint16, uint16, uint32,
                                    uint32, uint32, uint8 *, uint8 *);
static int fn_210(uint16, uint16, uint16, uint32,
                                     uint32, uint32, uint8 *, uint8 *);
static int fn_210(uint16, uint16, uint16, uint32,
                                     uint32, uint32, uint8 *, uint8 *);
static int fn_210(uint16, uint16, uint16, uint32,
                                     uint32, uint32, uint8 *, uint8 *);
static int fn_210(uint16, struct struct_210 *, uint32 *, uint32 *,
          unsigned char **);
static int fn_213(uint16, uint16, uint16, uint32, uint32,
         unsigned char *);
static int fn_213(uint16, uint16, uint16, uint32, uint32,
         unsigned char *);


static int fn_210 (uint16, uint16, uint32, uint8 *, uint8 *);
static int fn_212 (uint16, uint16, uint32, uint8 *, uint8 *);
static int fn_213 (uint16, uint16, uint32, uint8 *, uint8 *);
static int fn_213 (uint16, uint16, uint32, uint8 *, uint8 *);
static int fn_213 (uint16, uint16, uint32, uint8 *, uint8 *);


static int fn_201(struct struct_210 *, struct struct_209 *,
      unsigned char *, unsigned char *, int);
static int fn_201(struct struct_210 *, struct struct_209 *,
       unsigned char *, unsigned char *);
static int fn_162 (uint8 *, uint8 *, uint32,
                               tsample_t, uint16, uint16,
                                     tsample_t, uint32, uint32);
static int fn_168 (uint8 *, uint8 *, uint32,
                                tsample_t, uint16, uint16,
                                      tsample_t, uint32, uint32);
static int fn_169 (uint8 *, uint8 *, uint32,
                                tsample_t, uint16, uint16,
                                      tsample_t, uint32, uint32);
static int fn_171 (uint8 *, uint8 *, uint32,
                               tsample_t, uint16, uint16,
                                      tsample_t, uint32, uint32);
static int fn_158 (uint8 *, uint8 *, uint32,
                                      tsample_t, uint16, uint16,
          tsample_t, uint32, uint32);
static int fn_176 (uint8 *, uint8 *, uint32,
                                       tsample_t, uint16, uint16,
                                             tsample_t, uint32, uint32,
                                             int);
static int fn_177 (uint8 *, uint8 *, uint32,
                                        tsample_t, uint16, uint16,
                  tsample_t, uint32, uint32,
                                              int);
static int fn_177 (uint8 *, uint8 *, uint32,
                                        tsample_t, uint16, uint16,
                  tsample_t, uint32, uint32,
                                              int);
static int fn_177 (uint8 *, uint8 *, uint32,
                                       tsample_t, uint16, uint16,
                  tsample_t, uint32, uint32,
                                              int);
static int fn_178(uint8 *, uint8 *, uint32, uint32,
                                       uint32, uint32, tsample_t, uint16,
         uint16, uint16, struct struct_209 *);


static int fn_183 (uint8 *[], uint8 *, uint32, uint32,
                                        uint16, uint16, FILE *, int, int);
static int fn_183 (uint8 *[], uint8 *, uint32, uint32,
                                         uint16, uint16, FILE *, int, int);
static int fn_183 (uint8 *[], uint8 *, uint32, uint32,
                                         uint16, uint16, FILE *, int, int);
static int fn_183 (uint8 *[], uint8 *, uint32, uint32,
                                         uint16, uint16, FILE *, int, int);
static int fn_182 (unsigned char *[], unsigned char *,
     uint32, uint32, tsample_t, uint16,
                                        FILE *, int, int);

static int fn_183 (uint8 *[], uint8 *, uint32, uint32,
                                            uint32, uint32, uint16, uint16,
                                            FILE *, int, int);
static int fn_183 (uint8 *[], uint8 *, uint32, uint32,
                                             uint32, uint32, uint16, uint16,
                                             FILE *, int, int);
static int fn_183 (uint8 *[], uint8 *, uint32, uint32,
                                             uint32, uint32, uint16, uint16,
                                             FILE *, int, int);
static int fn_183 (uint8 *[], uint8 *, uint32, uint32,
                                             uint32, uint32, uint16, uint16,
                                             FILE *, int, int);
static int fn_183 (unsigned char *[], unsigned char *,
           uint32, uint32, uint32, uint32,
                                            tsample_t, uint16, FILE *, int, int);


static void fn_157 (FILE *, int, char *, char *, ...);
static int fn_155 (FILE *, int, char *, unsigned char *, uint32);
static int fn_157 (FILE *, int, char *, unsigned char);
static int fn_157 (FILE *, int, char *, uint16);
static int fn_157 (FILE *, int, char *, uint32);
static int fn_157 (FILE *, int, char *, uint64);
static int fn_157 (FILE *, int, uint32, uint32, uint32, unsigned char *);





static char* usage_info[] = {
"usage: tiffcrop [options] source1 ... sourceN  destination",
"where options are:",
" -h		Print this syntax listing",
" -v		Print tiffcrop version identifier and last revision date",
" ",
" -a		Append to output instead of overwriting",
" -d offset	Set initial directory offset, counting first image as one, not zero",
" -p contig	Pack samples contiguously (e.g. RGBRGB...)",
" -p separate	Store samples separately (e.g. RRR...GGG...BBB...)",
" -s		Write output in strips",
" -t		Write output in tiles",
" -i		Ignore read errors",
" ",
" -r #		Make each strip have no more than # rows",
" -w #		Set output tile width (pixels)",
" -l #		Set output tile length (pixels)",
" ",
" -f lsb2msb	Force lsb-to-msb FillOrder for output",
" -f msb2lsb	Force msb-to-lsb FillOrder for output",
"",
" -c lzw[:opts]	 Compress output with Lempel-Ziv & Welch encoding",
" -c zip[:opts]	 Compress output with deflate encoding",
" -c jpeg[:opts] Compress output with JPEG encoding",
" -c packbits	 Compress output with packbits encoding",
" -c g3[:opts]	 Compress output with CCITT Group 3 encoding",
" -c g4		 Compress output with CCITT Group 4 encoding",
" -c none	 Use no compression algorithm on output",
" ",
"Group 3 options:",
" 1d		Use default CCITT Group 3 1D-encoding",
" 2d		Use optional CCITT Group 3 2D-encoding",
" fill		Byte-align EOL codes",
"For example, -c g3:2d:fill to get G3-2D-encoded data with byte-aligned EOLs",
" ",
"JPEG options:",
" #		Set compression quality level (0-100, default 100)",
" raw		Output color image as raw YCbCr",
" rgb		Output color image as RGB",
"For example, -c jpeg:rgb:50 to get JPEG-encoded RGB data with 50% comp. quality",
" ",
"LZW and deflate options:",
" #		Set predictor value",
"For example, -c lzw:2 to get LZW-encoded data with horizontal differencing",
" ",
"Page and selection options:",
" -N odd|even|#,#-#,#|last         sequences and ranges of images within file to process",
"             The words odd or even may be used to specify all odd or even numbered images.",
"             The word last may be used in place of a number in the sequence to indicate.",
"             The final image in the file without knowing how many images there are.",
"             Numbers are counted from one even though TIFF IFDs are counted from zero.",
" ",
" -E t|l|r|b  edge to use as origin for width and length of crop region",
" -U units    [in, cm, px ] inches, centimeters or pixels",
" ",
" -m #,#,#,#  margins from edges for selection: top, left, bottom, right separated by commas",
" -X #        horizontal dimension of region to extract expressed in current units",
" -Y #        vertical dimension of region to extract expressed in current units",
" -Z #:#,#:#  zones of the image designated as position X of Y,",
"             eg 1:3 would be first of three equal portions measured from reference edge",
" -z x1,y1,x2,y2:...:xN,yN,xN+1,yN+1",
"             regions of the image designated by upper left and lower right coordinates",
"",
"Export grouping options:",
" -e c|d|i|m|s    export mode for images and selections from input images.",
"                 When exporting a composite image from multiple zones or regions",
"                 (combined and image modes), the selections must have equal sizes",
"                 for the axis perpendicular to the edge specified with -E.",
"    c|combined   All images and selections are written to a single file (default).",
"                 with multiple selections from one image combined into a single image.",
"    d|divided    All images and selections are written to a single file",
"                 with each selection from one image written to a new image.",
"    i|image      Each input image is written to a new file (numeric filename sequence)",
"                 with multiple selections from the image combined into one image.",
"    m|multiple   Each input image is written to a new file (numeric filename sequence)",
"                 with each selection from the image written to a new image.",
"    s|separated  Individual selections from each image are written to separate files.",
"",
"Output options:",
" -H #        Set horizontal resolution of output images to #",
" -V #        Set vertical resolution of output images to #",
" -J #        Set horizontal margin of output page to # expressed in current units",
"             when sectioning image into columns x rows using the -S cols:rows option",
" -K #        Set verticalal margin of output page to # expressed in current units",
"             when sectioning image into columns x rows using the -S cols:rows option",
" ",
" -O orient    orientation for output image, portrait, landscape, auto",
" -P page      page size for output image segments, eg letter, legal, tabloid, etc",
"              use #.#x#.# to specify a custom page size in the currently defined units",
"              where #.# represents the width and length",
" -S cols:rows Divide the image into equal sized segments using cols across and rows down.",
" ",
" -F hor|vert|both",
"             flip (mirror) image or region horizontally, vertically, or both",
" -R #        [90,180,or 270] degrees clockwise rotation of image or extracted region",
" -I [black|white|data|both]",
"             invert color space, eg dark to light for bilevel and grayscale images",
"             If argument is white or black, set the PHOTOMETRIC_INTERPRETATION ",
"             tag to MinIsBlack or MinIsWhite without altering the image data",
"             If the argument is data or both, the image data are modified:",
"             both inverts the data and the PHOTOMETRIC_INTERPRETATION tag,",
"             data inverts the data but not the PHOTOMETRIC_INTERPRETATION tag",
" ",
"-D opt1:value1,opt2:value2,opt3:value3:opt4:value4",
"             Debug/dump program progress and/or data to non-TIFF files.",
"             Options include the following and must be joined as a comma",
"             separate list. The use of this option is generally limited to",
"             program debugging and development of future options.",
" ",
"   debug:N   Display limited program progress indicators where larger N",
"             increase the level of detail. Note: Tiffcrop may be compiled with",
"             -DDEVELMODE to enable additional very low level debug reporting.",
"",
"   Format:txt|raw  Format any logged data as ASCII text or raw binary ",
"             values. ASCII text dumps include strings of ones and zeroes",
"             representing the binary values in the image data plus identifying headers.",
" ",
"   level:N   Specify the level of detail presented in the dump files.",
"             This can vary from dumps of the entire input or output image data to dumps",
"             of data processed by specific functions. Current range of levels is 1 to 3.",
" ",
"   input:full-path-to-directory/input-dumpname",
" ",
"   output:full-path-to-directory/output-dumpnaem",
" ",
"             When dump files are being written, each image will be written to a separate",
"             file with the name built by adding a numeric sequence value to the dumpname",
"             and an extension of .txt for ASCII dumps or .bin for binary dumps.",
" ",
"             The four debug/dump options are independent, though it makes little sense to",
"             specify a dump file without specifying a detail level.",
" ",
NULL
};






static int fn_103 (TIFF* var_210, uint8* var_178,
                                      uint32 var_130,
                                      uint32 var_183,
                                      uint32 var_199, uint32 var_199,
                                      tsample_t var_214, uint16 var_214)
  {
  int var_122 = 1;
  tsample_t var_213 = 0;
  tsample_t var_202 = var_214;
  uint32 var_214, var_214, trow;
  uint32 nrow, ncol;
  uint32 dst_rowsize, shift_width;
  uint32 bytes_per_sample, bytes_per_pixel;
  uint32 trailing_bits, var_202;
  uint32 var_199 = TIFFTileRowSize(var_210);
  uint32 src_offset, dst_offset;
  uint32 row_offset, col_offset;
  uint8 *bufp = (uint8*) var_178;
  unsigned char *src = NULL;
  unsigned char *dst = NULL;
  tsize_t var_122 = 0, var_130 = 0;
  tsize_t var_130 = TIFFTileSize(var_210);
  unsigned char *tilebuf = NULL;

  bytes_per_sample = (var_214 + 7) / 8;
  bytes_per_pixel = ((var_214 * var_214) + 7) / 8;

  if ((var_214 % 8) == 0)
    shift_width = 0;
  else
    {
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }

  var_130 = var_130;
  if (var_130 == 0 || var_199 == 0)
  {
     TIFFError("readContigTilesIntoBuffer", "Tile size or tile rowsize is zero");
     exit(-1);
  }

  if (var_130 < (tsize_t)(var_199 * var_199))
    {





    var_130 = var_199 * var_199;
    if (var_199 != (var_130 / var_199))
    {
     TIFFError("readContigTilesIntoBuffer", "Integer overflow when calculating buffer size.");
        exit(-1);
    }
    }

  tilebuf = _TIFFmalloc(var_130);
  if (tilebuf == 0)
    return 0;

  dst_rowsize = ((var_183 * var_214 * var_214) + 7) / 8;
  for (var_214 = 0; var_214 < var_130; var_214 += var_199)
    {
    nrow = (var_214 + var_199 > var_130) ? var_130 - var_214 : var_199;
    for (var_214 = 0; var_214 < var_183; var_214 += var_199)
      {
      var_122 = TIFFReadTile(var_210, tilebuf, var_214, var_214, 0, 0);
      if (var_122 < var_130 && !var_186)
        {
 TIFFError(TIFFFileName(var_210),
    "Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu",
    (unsigned long) var_214, (unsigned long) var_214, (unsigned long)var_122,
                  (unsigned long)var_130);
    var_122 = 0;
                  _TIFFfree(tilebuf);
    return var_122;
 }

      row_offset = var_214 * dst_rowsize;
      col_offset = ((var_214 * var_214 * var_214) + 7)/ 8;
      bufp = var_178 + row_offset + col_offset;

      if (var_214 + var_199 > var_183)
 ncol = var_183 - var_214;
      else
        ncol = var_199;







      if (((var_214 % 8) == 0) && (var_202 == var_214))
        {
 for (trow = 0; trow < nrow; trow++)
          {
   src_offset = trow * var_199;
   _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * var_214 * var_214) / 8);
          bufp += (var_183 * var_214 * var_214) / 8;
   }
        }
      else
        {

        var_202 = trailing_bits = 0;
        trailing_bits = (ncol * var_214 * var_214) % 8;


 for (trow = 0; trow < nrow; trow++)
          {
   src_offset = trow * var_199;
          src = tilebuf + src_offset;
   dst_offset = (var_214 + trow) * dst_rowsize;
          dst = var_178 + dst_offset + col_offset;
          switch (shift_width)
            {
            case 0: if (extractContigSamplesBytes (src, dst, ncol, var_213,
                                                   var_214, var_214, var_202, 0, ncol))
                      {
        TIFFError("readContigTilesIntoBuffer",
                                "Unable to extract row %d from tile %lu",
    var_214, (unsigned long)TIFFCurrentTile(var_210));
        return 1;
        }
      break;
            case 1: if (var_214 == 1)
                      {
                      if (extractContigSamplesShifted8bits (src, dst, ncol,
                                                            var_213, var_214,
                                                            var_214, var_202,
                                                            0, ncol,
                                                            var_202))
                        {
          TIFFError("readContigTilesIntoBuffer",
                                  "Unable to extract row %d from tile %lu",
      var_214, (unsigned long)TIFFCurrentTile(var_210));
          return 1;
          }
        break;
        }
                    else
                      if (extractContigSamplesShifted16bits (src, dst, ncol,
                                                             var_213, var_214,
                                                             var_214, var_202,
                                                             0, ncol,
                                                             var_202))
                        {
          TIFFError("readContigTilesIntoBuffer",
                                  "Unable to extract row %d from tile %lu",
        var_214, (unsigned long)TIFFCurrentTile(var_210));
          return 1;
          }
             break;
            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,
                                                           var_213, var_214,
                                                           var_214, var_202,
                                                           0, ncol,
                                                           var_202))
                      {
        TIFFError("readContigTilesIntoBuffer",
                                "Unable to extract row %d from tile %lu",
             var_214, (unsigned long)TIFFCurrentTile(var_210));
        return 1;
        }
      break;
            case 3:
            case 4:
            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,
                                                           var_213, var_214,
                                                           var_214, var_202,
                                                           0, ncol,
                                                           var_202))
                      {
        TIFFError("readContigTilesIntoBuffer",
                                "Unable to extract row %d from tile %lu",
           var_214, (unsigned long)TIFFCurrentTile(var_210));
        return 1;
        }
      break;
            default: TIFFError("readContigTilesIntoBuffer", "Unsupported bit depth %d", var_214);
       return 1;
     }
          }
        var_202 += trailing_bits;


 }
      }
    }

  _TIFFfree(tilebuf);
  return var_122;
  }

static int fn_121 (TIFF* var_210, uint8 *var_186,
      uint32 var_130, uint32 var_183,
                                         uint32 var_199, uint32 var_199,
                                         uint16 var_214, uint16 var_214)
  {
  int i, var_122 = 1, var_213;
  int shift_width, bytes_per_pixel;
  uint16 bytes_per_sample;
  uint32 var_214, var_214;
  uint32 nrow, ncol;
  uint32 row_offset, col_offset;
  tsize_t var_122 = 0, var_130 = TIFFTileSize(var_210);
  tsample_t s;
  uint8* bufp = (uint8*)var_186;
  unsigned char *srcbuffs[8];
  unsigned char *tbuff = NULL;

  bytes_per_sample = (var_214 + 7) / 8;

  for (var_213 = 0; (var_213 < var_214) && (var_213 < 8); var_213++)
    {
    srcbuffs[var_213] = NULL;
    tbuff = (unsigned char *)_TIFFmalloc(var_130 + 8);
    if (!tbuff)
      {
      TIFFError ("readSeparateTilesIntoBuffer",
                 "Unable to allocate tile read buffer for sample %d", var_213);
      for (i = 0; i < var_213; i++)
        _TIFFfree (srcbuffs[i]);
      return 0;
      }
    srcbuffs[var_213] = tbuff;
    }



  for (var_214 = 0; var_214 < var_130; var_214 += var_199)
    {
    nrow = (var_214 + var_199 > var_130) ? var_130 - var_214 : var_199;
    for (var_214 = 0; var_214 < var_183; var_214 += var_199)
      {
      for (s = 0; s < var_214 && s < 8; s++)
        {
 var_122 = TIFFReadTile(var_210, srcbuffs[s], var_214, var_214, 0, s);
        if (var_122 < 0 && !var_186)
          {
   TIFFError(TIFFFileName(var_210),
                 "Error, can't read tile for row %lu col %lu, "
   "sample %lu",
   (unsigned long) var_214, (unsigned long) var_214,
   (unsigned long) s);
   var_122 = 0;
          for (var_213 = 0; (var_213 < var_214) && (var_213 < 8); var_213++)
            {
            tbuff = srcbuffs[var_213];
            if (tbuff != NULL)
              _TIFFfree(tbuff);
            }
          return var_122;
   }
 }




      if (var_214 + var_199 > var_183)
        ncol = var_183 - var_214;
      else
        ncol = var_199;

      row_offset = var_214 * (((var_183 * var_214 * var_214) + 7) / 8);
      col_offset = ((var_214 * var_214 * var_214) + 7) / 8;
      bufp = var_186 + row_offset + col_offset;

      if ((var_214 % 8) == 0)
        {
        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, var_183,
         var_199, var_214, var_214, NULL, 0, 0))
   {
          var_122 = 0;
          break;
         }
 }
      else
        {
        bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
        if (bytes_per_pixel < (bytes_per_sample + 1))
          shift_width = bytes_per_pixel;
        else
          shift_width = bytes_per_sample + 1;

        switch (shift_width)
          {
          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,
                                                       var_183, var_199, var_214, var_214,
             NULL, 0, 0))
             {
                    var_122 = 0;
                    break;
                   }
           break;
          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,
                                                       var_183, var_199, var_214, var_214,
             NULL, 0, 0))
             {
                    var_122 = 0;
                    break;
      }
           break;
          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,
                                                       var_183, var_199, var_214, var_214,
             NULL, 0, 0))
             {
                    var_122 = 0;
                    break;
                    }
                  break;
          case 4:
          case 5:
          case 6:
          case 7:
          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,
                                                       var_183, var_199, var_214, var_214,
             NULL, 0, 0))
             {
                    var_122 = 0;
                    break;
      }
           break;
          default: TIFFError ("readSeparateTilesIntoBuffer", "Unsupported bit depth: %d", var_214);
                  var_122 = 0;
                  break;
          }
        }
      }
    }

  for (var_213 = 0; (var_213 < var_214) && (var_213 < 8); var_213++)
    {
    tbuff = srcbuffs[var_213];
    if (tbuff != NULL)
      _TIFFfree(tbuff);
    }

  return var_122;
  }

static int fn_122(TIFF* var_210, uint8* var_178, uint32 var_130)
  {
  uint32 var_214, nrows, var_210;
  tstrip_t var_186 = 0;
  tsize_t var_186;

  TIFFGetFieldDefaulted(var_210, TIFFTAG_ROWSPERSTRIP, &var_210);
  for (var_214 = 0; var_214 < var_130; var_214 += var_210)
    {
    nrows = (var_214 + var_210 > var_130) ?
      var_130 - var_214 : var_210;
    var_186 = TIFFVStripSize(var_210, nrows);
    if (TIFFWriteEncodedStrip(var_210, var_186++, var_178, var_186) < 0)
      {
      TIFFError(TIFFFileName(var_210), "Error, can't write strip %u", var_186 - 1);
      return 1;
      }
    var_178 += var_186;
    }

  return 0;
  }

static int
fn_125 (TIFF* var_210, uint8* var_178,
        uint32 var_214, uint32 var_214, uint16 var_214,
        struct struct_209 *dump)
  {
  uint8 *src;
  uint16 var_214;
  uint32 var_214, nrows, var_213, var_210;
  uint32 bytes_per_sample;
  tsample_t s;
  tstrip_t var_186 = 0;
  tsize_t var_186 = TIFFStripSize(var_210);
  tsize_t rowstripsize, var_199 = TIFFScanlineSize(var_210);
  tsize_t var_130 = 0;
  tdata_t var_186;

  (void) TIFFGetFieldDefaulted(var_210, TIFFTAG_ROWSPERSTRIP, &var_210);
  (void) TIFFGetField(var_210, TIFFTAG_BITSPERSAMPLE, &var_214);
  bytes_per_sample = (var_214 + 7) / 8;
  var_213 = ((var_214 * var_214 * var_214) + 7) / 8;
  rowstripsize = var_210 * bytes_per_sample * (var_214 + 1);

  var_186 = _TIFFmalloc (rowstripsize);
  if (var_186 == NULL)
    return 1;

  for (s = 0; s < var_214; s++)
    {
    for (var_214 = 0; var_214 < var_214; var_214 += var_210)
      {
      nrows = (var_214 + var_210 > var_214) ? var_214 - var_214 : var_210;

      var_186 = TIFFVStripSize(var_210, nrows);
      src = var_178 + (var_214 * var_213);
      var_130 += var_186;
      memset (var_186, '\0', rowstripsize);
      if (extractContigSamplesToBuffer(var_186, src, nrows, var_214, s, var_214, var_214, dump))
        {
        _TIFFfree(var_186);
        return 1;
 }
      if ((dump->outfile != NULL) && (dump->level == 1))
        {
        dump_info(dump->outfile, dump->format,"",
                  "Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d",
                  s + 1, var_186 + 1, var_186, var_214 + 1, var_199, src - var_178);
        dump_buffer(dump->outfile, dump->format, nrows, var_199, var_214, var_186);
 }

      if (TIFFWriteEncodedStrip(var_210, var_186++, var_186, var_186) < 0)
        {
 TIFFError(TIFFFileName(var_210), "Error, can't write strip %u", var_186 - 1);
 _TIFFfree(var_186);
 return 1;
 }
      }
    }

  _TIFFfree(var_186);
  return 0;
}




static int fn_130 (TIFF* var_210, uint8* var_178, uint32 var_130,
           uint32 var_183, tsample_t var_214,
                                       struct struct_209* dump)
  {
  uint16 var_214;
  uint32 var_199, var_199;
  uint32 var_214, var_214, nrow, ncol;
  uint32 src_rowsize, col_offset;
  uint32 var_199 = TIFFTileRowSize(var_210);
  uint8* bufp = (uint8*) var_178;
  tsize_t var_130 = 0;
  tsize_t var_130 = TIFFTileSize(var_210);
  unsigned char *tilebuf = NULL;

  if( !TIFFGetField(var_210, TIFFTAG_TILELENGTH, &var_199) ||
      !TIFFGetField(var_210, TIFFTAG_TILEWIDTH, &var_199) ||
      !TIFFGetField(var_210, TIFFTAG_BITSPERSAMPLE, &var_214) )
      return 1;

  if (var_130 == 0 || var_199 == 0 || var_199 == 0 || var_199 == 0)
  {
    TIFFError("writeBufferToContigTiles", "Tile size, tile row size, tile width, or tile length is zero");
    exit(-1);
  }

  var_130 = var_130;
  if (var_130 < (tsize_t)(var_199 * var_199))
    {





    var_130 = var_199 * var_199;
    if (var_199 != var_130 / var_199)
    {
 TIFFError("writeBufferToContigTiles", "Integer overflow when calculating buffer size");
 exit(-1);
    }
    }

  tilebuf = _TIFFmalloc(var_130);
  if (tilebuf == 0)
    return 1;

  src_rowsize = ((var_183 * var_214 * var_214) + 7) / 8;
  for (var_214 = 0; var_214 < var_130; var_214 += var_199)
    {
    nrow = (var_214 + var_199 > var_130) ? var_130 - var_214 : var_199;
    for (var_214 = 0; var_214 < var_183; var_214 += var_199)
      {

      if (var_214 + var_199 > var_183)
 ncol = var_183 - var_214;
      else
        ncol = var_199;

      col_offset = (((var_214 * var_214 * var_214) + 7) / 8);
      bufp = var_178 + (var_214 * src_rowsize) + col_offset;
      if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, var_183,
        var_199, 0, var_214, var_214, var_214, dump) > 0)
        {
 TIFFError("writeBufferToContigTiles",
                  "Unable to extract data to tile for row %lu, col %lu",
                  (unsigned long) var_214, (unsigned long)var_214);
 _TIFFfree(tilebuf);
 return 1;
        }

      if (TIFFWriteTile(var_210, tilebuf, var_214, var_214, 0, 0) < 0)
        {
 TIFFError("writeBufferToContigTiles",
           "Cannot write tile at %lu %lu",
           (unsigned long) var_214, (unsigned long) var_214);
  _TIFFfree(tilebuf);
 return 1;
 }
      }
    }
  _TIFFfree(tilebuf);

  return 0;
  }




static int fn_130 (TIFF* var_210, uint8* var_178, uint32 var_130,
           uint32 var_183, tsample_t var_214,
                                       struct struct_209 * dump)
  {
  tdata_t var_186 = _TIFFmalloc(TIFFTileSize(var_210));
  uint32 var_199, var_199;
  uint32 var_214, var_214, nrow, ncol;
  uint32 src_rowsize, col_offset;
  uint16 var_214;
  tsample_t s;
  uint8* bufp = (uint8*) var_178;

  if (var_186 == NULL)
    return 1;

  TIFFGetField(var_210, TIFFTAG_TILELENGTH, &var_199);
  TIFFGetField(var_210, TIFFTAG_TILEWIDTH, &var_199);
  TIFFGetField(var_210, TIFFTAG_BITSPERSAMPLE, &var_214);
  src_rowsize = ((var_183 * var_214 * var_214) + 7) / 8;

  for (var_214 = 0; var_214 < var_130; var_214 += var_199)
    {
    nrow = (var_214 + var_199 > var_130) ? var_130 - var_214 : var_199;
    for (var_214 = 0; var_214 < var_183; var_214 += var_199)
      {

      if (var_214 + var_199 > var_183)
 ncol = var_183 - var_214;
      else
        ncol = var_199;

      col_offset = (((var_214 * var_214 * var_214) + 7) / 8);
      bufp = var_178 + (var_214 * src_rowsize) + col_offset;

      for (s = 0; s < var_214; s++)
        {
 if (extractContigSamplesToTileBuffer(var_186, bufp, nrow, ncol, var_183,
          var_199, s, 1, var_214, var_214, dump) > 0)
          {
   TIFFError("writeBufferToSeparateTiles",
                    "Unable to extract data to tile for row %lu, col %lu sample %d",
                    (unsigned long) var_214, (unsigned long)var_214, (int)s);
   _TIFFfree(var_186);
   return 1;
          }

 if (TIFFWriteTile(var_210, var_186, var_214, var_214, 0, s) < 0)
          {
    TIFFError("writeBufferToseparateTiles",
              "Cannot write tile at %lu %lu sample %lu",
              (unsigned long) var_214, (unsigned long) var_214,
              (unsigned long) s);
    _TIFFfree(var_186);
    return 1;
   }
 }
      }
    }
  _TIFFfree(var_186);

  return 0;
  }

static void
fn_130(char* cp)
{
 if( (cp = strchr(cp, ':')) ) {
  if (var_155 == (uint32) -1)
   var_155 = 0;
  do {
   cp++;
   if ((strncmp((cp),("1d"),2) == 0))
    var_155 &= ~GROUP3OPT_2DENCODING;
   else if ((strncmp((cp),("2d"),2) == 0))
    var_155 |= GROUP3OPT_2DENCODING;
   else if ((strncmp((cp),("fill"),4) == 0))
    var_155 |= GROUP3OPT_FILLBITS;
   else
    usage();
  } while( (cp = strchr(cp, ':')) );
 }
}

static int
fn_131(char* opt)
  {
  char* cp = NULL;

  if ((strncmp((opt),("none"),4) == 0))
    {
    var_155 = COMPRESSION_NONE;
    }
  else if ((strcmp((opt),("packbits")) == 0))
    {
    var_155 = COMPRESSION_PACKBITS;
    }
  else if ((strncmp((opt),("jpeg"),4) == 0))
    {
    cp = strchr(opt, ':');
    var_155 = COMPRESSION_JPEG;

    while (cp)
      {
      if (isdigit((int)cp[1]))
 var_210 = atoi(cp + 1);
      else if ((strncmp((cp + 1),("raw"),3) == 0))
 var_210 = JPEGCOLORMODE_RAW;
      else if ((strncmp((cp + 1),("rgb"),3) == 0))
 var_210 = var_210;
      else
 usage();
      cp = strchr(cp + 1, ':');
      }
    }
  else if ((strncmp((opt),("g3"),2) == 0))
    {
    processG3Options(opt);
    var_155 = COMPRESSION_CCITTFAX3;
    }
  else if ((strcmp((opt),("g4")) == 0))
    {
    var_155 = COMPRESSION_CCITTFAX4;
    }
  else if ((strncmp((opt),("lzw"),3) == 0))
    {
    cp = strchr(opt, ':');
    if (cp)
      var_155 = atoi(cp+1);
    var_155 = COMPRESSION_LZW;
    }
  else if ((strncmp((opt),("zip"),3) == 0))
    {
    cp = strchr(opt, ':');
    if (cp)
      var_155 = atoi(cp+1);
    var_155 = COMPRESSION_ADOBE_DEFLATE;
   }
  else
    return 0;

  return 1;
  }

static void
fn_131(void)
  {
  int i;

  fprintf(stderr, "\n%s\n", TIFFGetVersion());
  for (i = 0; usage_info[i] != NULL; i++)
    fprintf(stderr, "%s\n", usage_info[i]);
  exit(-1);
  }

static void
fn_131(TIFF* var_210, TIFF* var_210, uint16 var_134, uint16 var_202, TIFFDataType var_134)
{
 switch (var_134) {
 case TIFF_SHORT:
  if (var_202 == 1) {
   uint16 shortv;
   if (TIFFGetField(var_210, var_134, &shortv)) TIFFSetField(var_210, var_134, shortv);
  } else if (var_202 == 2) {
   uint16 shortv1, shortv2;
   if (TIFFGetField(var_210, var_134, &shortv1, &shortv2)) TIFFSetField(var_210, var_134, shortv1, shortv2);
  } else if (var_202 == 4) {
   uint16 *tr, *tg, *tb, *ta;
   if (TIFFGetField(var_210, var_134, &tr, &tg, &tb, &ta)) TIFFSetField(var_210, var_134, tr, tg, tb, ta);
  } else if (var_202 == (uint16) -1) {
   uint16 shortv1;
   uint16* shortav;
   if (TIFFGetField(var_210, var_134, &shortv1, &shortav)) TIFFSetField(var_210, var_134, shortv1, shortav);
  }
  break;
 case TIFF_LONG:
  { uint32 longv;
    if (TIFFGetField(var_210, var_134, &longv)) TIFFSetField(var_210, var_134, longv);
  }
  break;
 case TIFF_RATIONAL:
  if (var_202 == 1) {
   float floatv;
   if (TIFFGetField(var_210, var_134, &floatv)) TIFFSetField(var_210, var_134, floatv);
  } else if (var_202 == (uint16) -1) {
   float* floatav;
   if (TIFFGetField(var_210, var_134, &floatav)) TIFFSetField(var_210, var_134, floatav);
  }
  break;
 case TIFF_ASCII:
  { char* stringv;
    if (TIFFGetField(var_210, var_134, &stringv)) TIFFSetField(var_210, var_134, stringv);
  }
  break;
 case TIFF_DOUBLE:
  if (var_202 == 1) {
   double doublev;
   if (TIFFGetField(var_210, var_134, &doublev)) TIFFSetField(var_210, var_134, doublev);
  } else if (var_202 == (uint16) -1) {
   double* doubleav;
   if (TIFFGetField(var_210, var_134, &doubleav)) TIFFSetField(var_210, var_134, doubleav);
  }
  break;
          default:
                TIFFError(TIFFFileName(var_210),
                          "Data type %d is not supported, tag %d skipped",
                          var_134, var_134);
 }
}

static struct struct_210 {
 uint16 tag;
 uint16 count;
 TIFFDataType type;
} tags[] = {
 { TIFFTAG_SUBFILETYPE, 1, TIFF_LONG },
 { TIFFTAG_THRESHHOLDING, 1, TIFF_SHORT },
 { TIFFTAG_DOCUMENTNAME, 1, TIFF_ASCII },
 { TIFFTAG_IMAGEDESCRIPTION, 1, TIFF_ASCII },
 { TIFFTAG_MAKE, 1, TIFF_ASCII },
 { TIFFTAG_MODEL, 1, TIFF_ASCII },
 { TIFFTAG_MINSAMPLEVALUE, 1, TIFF_SHORT },
 { TIFFTAG_MAXSAMPLEVALUE, 1, TIFF_SHORT },
 { TIFFTAG_XRESOLUTION, 1, TIFF_RATIONAL },
 { TIFFTAG_YRESOLUTION, 1, TIFF_RATIONAL },
 { TIFFTAG_PAGENAME, 1, TIFF_ASCII },
 { TIFFTAG_XPOSITION, 1, TIFF_RATIONAL },
 { TIFFTAG_YPOSITION, 1, TIFF_RATIONAL },
 { TIFFTAG_RESOLUTIONUNIT, 1, TIFF_SHORT },
 { TIFFTAG_SOFTWARE, 1, TIFF_ASCII },
 { TIFFTAG_DATETIME, 1, TIFF_ASCII },
 { TIFFTAG_ARTIST, 1, TIFF_ASCII },
 { TIFFTAG_HOSTCOMPUTER, 1, TIFF_ASCII },
 { TIFFTAG_WHITEPOINT, (uint16) -1, TIFF_RATIONAL },
 { TIFFTAG_PRIMARYCHROMATICITIES,(uint16) -1,TIFF_RATIONAL },
 { TIFFTAG_HALFTONEHINTS, 2, TIFF_SHORT },
 { TIFFTAG_INKSET, 1, TIFF_SHORT },
 { TIFFTAG_DOTRANGE, 2, TIFF_SHORT },
 { TIFFTAG_TARGETPRINTER, 1, TIFF_ASCII },
 { TIFFTAG_SAMPLEFORMAT, 1, TIFF_SHORT },
 { TIFFTAG_YCBCRCOEFFICIENTS, (uint16) -1,TIFF_RATIONAL },
 { TIFFTAG_YCBCRSUBSAMPLING, 2, TIFF_SHORT },
 { TIFFTAG_YCBCRPOSITIONING, 1, TIFF_SHORT },
 { TIFFTAG_REFERENCEBLACKWHITE, (uint16) -1,TIFF_RATIONAL },
 { TIFFTAG_EXTRASAMPLES, (uint16) -1, TIFF_SHORT },
 { TIFFTAG_SMINSAMPLEVALUE, 1, TIFF_DOUBLE },
 { TIFFTAG_SMAXSAMPLEVALUE, 1, TIFF_DOUBLE },
 { TIFFTAG_STONITS, 1, TIFF_DOUBLE },
};





void fn_135 (int var_155, char *argv[], char *mp, char *var_155, uint32 *var_155,
                     uint16 *var_155, uint16 *var_155, uint32 *var_155,
                            uint32 *var_155, uint32 *var_155,
              struct struct_209 *crop_data, struct struct_202 *page,
                            struct struct_209 *dump,
                            unsigned int *imagelist, unsigned int *var_155 )
    {
    int c, var_146 = 0;
    char *opt_offset = NULL;
    char *opt_ptr = NULL;
    char *sep = NULL;
    unsigned int i, j, var_177, var_177;

    extern int optind;
    extern char* optarg;


    *mp++ = 'w';
    *mp = '\0';
    while ((c = getopt(var_155, argv,
       "ac:d:e:f:hil:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:")) != -1)
      {
    var_146++;
    switch (c) {
      case 'a': var_155[0] = 'a';
  break;
      case 'c': if (!processCompressOptions(optarg))
    {
    TIFFError ("Unknown compression option", "%s", optarg);
                  TIFFError ("For valid options type", "tiffcrop -h");
                  exit (-1);
                  }
  break;
      case 'd': var_177 = strtoul(optarg, NULL, 0);
         if (var_177 == 0)
                  {
    TIFFError ("","Directory offset must be greater than zero");
    TIFFError ("For valid options type", "tiffcrop -h");
                  exit (-1);
    }
         *var_155 = var_177 - 1;
  break;
      case 'e': switch (tolower((int) optarg[0]))
                  {
    case 'c': crop_data->exp_mode = 0;
               crop_data->img_mode = 0;
              break;
    case 'd': crop_data->exp_mode = 1;
               crop_data->img_mode = 1;
              break;
    case 'i': crop_data->exp_mode = 2;
               crop_data->img_mode = 0;
              break;
    case 'm': crop_data->exp_mode = 3;
               crop_data->img_mode = 1;
              break;
    case 's': crop_data->exp_mode = 4;
               crop_data->img_mode = 1;
              break;
    default: TIFFError ("Unknown export mode","%s", optarg);
                            TIFFError ("For valid options type", "tiffcrop -h");
                            exit (-1);
                  }
         break;
      case 'f': if ((strcmp((optarg),("lsb2msb")) == 0))
    *var_155 = FILLORDER_LSB2MSB;
  else if ((strcmp((optarg),("msb2lsb")) == 0))
    *var_155 = FILLORDER_MSB2LSB;
  else
    {
    TIFFError ("Unknown fill order", "%s", optarg);
                  TIFFError ("For valid options type", "tiffcrop -h");
                  exit (-1);
                  }
  break;
      case 'h': usage();
  break;
      case 'i': var_186 = 1;
  break;
      case 'l': var_210 = 1;
  *var_155 = atoi(optarg);
  break;
      case 'p':
  if ((strcmp((optarg),("separate")) == 0))
    *var_155 = PLANARCONFIG_SEPARATE;
  else if ((strcmp((optarg),("contig")) == 0))
    *var_155 = PLANARCONFIG_CONTIG;
  else
    {
    TIFFError ("Unkown planar configuration", "%s", optarg);
                  TIFFError ("For valid options type", "tiffcrop -h");
                  exit (-1);
                  }
  break;
      case 'r':
  *var_155 = atol(optarg);
  break;
      case 's':
  var_210 = 0;
  break;
      case 't':
  var_210 = 1;
  break;
      case 'v': TIFFError("Library Release", "%s", TIFFGetVersion());
                TIFFError ("Tiffcrop version", "%s, last updated: %s",
      tiffcrop_version_id, tiffcrop_rev_date);
          TIFFError ("Tiffcp code", "Copyright (c) 1988-1997 Sam Leffler");
  TIFFError ("           ", "Copyright (c) 1991-1997 Silicon Graphics, Inc");
                TIFFError ("Tiffcrop additions", "Copyright (c) 2007-2010 Richard Nolde");
         exit (0);
  break;
      case 'w':
  var_210 = 1;
  *var_155 = atoi(optarg);
  break;
      case 'z':
         crop_data->crop_mode |= 16;
  for (i = 0, opt_ptr = strtok (optarg, ":");
                   ((opt_ptr != NULL) && (i < 8));
                    (opt_ptr = strtok (NULL, ":")), i++)
                    {
      crop_data->regions++;
                    if (sscanf(opt_ptr, "%lf,%lf,%lf,%lf",
          &crop_data->corners[i].X1, &crop_data->corners[i].Y1,
          &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)
                      {
                      TIFFError ("Unable to parse coordinates for region", "%d %s", i, optarg);
        TIFFError ("For valid options type", "tiffcrop -h");
                      exit (-1);
        }
                    }

                if ((opt_ptr != NULL) && (i >= 8))
                  {
    TIFFError ("Region list exceeds limit of", "%d regions %s", 8, optarg);
    TIFFError ("For valid options type", "tiffcrop -h");
                  exit (-1);;
                  }
  break;

      case 'B': *mp++ = 'b'; *mp = '\0';
  break;
      case 'L': *mp++ = 'l'; *mp = '\0';
  break;
      case 'M': *mp++ = 'm'; *mp = '\0';
  break;
      case 'C': *mp++ = 'c'; *mp = '\0';
  break;

      case 'D': for (i = 0, opt_ptr = strtok (optarg, ",");
                    (opt_ptr != NULL);
                    (opt_ptr = strtok (NULL, ",")), i++)
                    {
      opt_offset = strpbrk(opt_ptr, ":=");
                    if (opt_offset == NULL)
                      {
                      TIFFError("Invalid dump option", "%s", optarg);
                      TIFFError ("For valid options type", "tiffcrop -h");
                      exit (-1);
        }

                    *opt_offset = '\0';

                    var_177 = strlen (opt_ptr);
                    for (i = 0; i < var_177; i++)
                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));

                    if (strncmp(opt_ptr, "for", 3) == 0)
                      {

                      var_177 = strlen (opt_offset + 1);
                      for (i = 1; i <= var_177; i++)
                        *(opt_offset + i) = tolower((int) *(opt_offset + i));

        if (strncmp (opt_offset + 1, "txt", 3) == 0)
                        {
                        dump->format = 1;
                        strcpy (dump->mode, "w");
                        }
                      else
                        {
          if (strncmp(opt_offset + 1, "raw", 3) == 0)
                          {
                          dump->format = 2;
                          strcpy (dump->mode, "wb");
                          }
                        else
                          {
                          TIFFError("parse_command_opts", "Unknown dump format %s", opt_offset + 1);
                          TIFFError ("For valid options type", "tiffcrop -h");
                          exit (-1);
            }
   }
                      }
      else
                      {
                      if (strncmp (opt_ptr, "lev", 3) == 0)
                        dump->level = atoi(opt_offset + 1);

                      if (strncmp (opt_ptr, "in", 2) == 0)
          {
                        strncpy (dump->infilename, opt_offset + 1, 1004);
                        dump->infilename[1004] = '\0';
                        }

                      if (strncmp (opt_ptr, "out", 3) == 0)
   {
                        strncpy (dump->outfilename, opt_offset + 1, 1004);
                        dump->outfilename[1004] = '\0';
                        }
                      if (strncmp (opt_ptr, "deb", 3) == 0)
   dump->debug = atoi(opt_offset + 1);
        }
                    }
         if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))
                  {
    if (dump->level == 1)
                    TIFFError("","Defaulting to dump level 1, no data.");
           if (dump->format == 0)
                    {
      TIFFError("", "You must specify a dump format for dump files");
      TIFFError ("For valid options type", "tiffcrop -h");
      exit (-1);
      }
                  }
         break;


      case 'm':

  crop_data->crop_mode |= 1;
                for (i = 0, opt_ptr = strtok (optarg, ",:");
                    ((opt_ptr != NULL) && (i < 4));
                     (opt_ptr = strtok (NULL, ",:")), i++)
                    {
      crop_data->margins[i] = atof(opt_ptr);
                    }
  break;
      case 'E':
  switch (tolower((int) optarg[0]))
                  {
    case 't': crop_data->edge_ref = 1;
                            break;
                  case 'b': crop_data->edge_ref = 3;
                             break;
                  case 'l': crop_data->edge_ref = 2;
                            break;
                  case 'r': crop_data->edge_ref = 4;
                            break;
    default: TIFFError ("Edge reference must be top, bottom, left, or right", "%s", optarg);
       TIFFError ("For valid options type", "tiffcrop -h");
                            exit (-1);
    }
  break;
      case 'F':
  crop_data->crop_mode |= 64;
  switch (tolower((int) optarg[0]))
                  {
    case 'h': crop_data->mirror = 1;
                             break;
                  case 'v': crop_data->mirror = 2;
                             break;
                  case 'b': crop_data->mirror = 3;
                             break;
    default: TIFFError ("Flip mode must be horiz, vert, or both", "%s", optarg);
        TIFFError ("For valid options type", "tiffcrop -h");
                             exit (-1);
    }
  break;
      case 'H':
  page->hres = atof (optarg);
                page->mode |= 1;
  break;
      case 'I':
  crop_data->crop_mode |= 128;

                if ((strcmp((optarg),("black")) == 0))
                  {
    crop_data->photometric = PHOTOMETRIC_MINISBLACK;
    continue;
                  }
                if ((strcmp((optarg),("white")) == 0))
                  {
    crop_data->photometric = PHOTOMETRIC_MINISWHITE;
                  continue;
                  }
                if ((strcmp((optarg),("data")) == 0))
                  {
    crop_data->photometric = 10;
                  continue;
                  }
                if ((strcmp((optarg),("both")) == 0))
                  {
    crop_data->photometric = 11;
                  continue;
                  }

  TIFFError("Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION", "%s", optarg);
  TIFFError ("For valid options type", "tiffcrop -h");
                exit (-1);
  break;
      case 'J':
  page->hmargin = atof(optarg);
                page->mode |= 4;
  break;
      case 'K':
                page->vmargin = atof(optarg);
                page->mode |= 4;
  break;
      case 'N':
                for (i = 0, opt_ptr = strtok (optarg, ",");
                    ((opt_ptr != NULL) && (i < 2048));
                     (opt_ptr = strtok (NULL, ",")))
                     {





       if ((strcmp((opt_ptr),("odd")) == 0))
                       {
         for (j = 1; j <= 2048; j += 2)
    imagelist[i++] = j;
                       *var_155 = 1023;
                       break;
         }
       else
                       {
         if ((strcmp((opt_ptr),("even")) == 0))
                         {
    for (j = 2; j <= 2048; j += 2)
      imagelist[i++] = j;
                         *var_155 = 1024;
                         break;
    }
         else
                         {
    if ((strcmp((opt_ptr),("last")) == 0))
      imagelist[i++] = 2048;
    else
      {
      sep = strpbrk(opt_ptr, ":-");
      if (!sep)
        imagelist[i++] = atoi(opt_ptr);
                           else
                             {
        *sep = '\0';
                             var_177 = atoi (opt_ptr);
                             if (!strcmp((sep + 1), "last"))
          var_177 = 2048;
                             else
                               var_177 = atoi (sep + 1);
                             for (j = var_177; j <= var_177 && j - var_177 + i < 2048; j++)
          imagelist[i++] = j;
        }
      }
    }
        }
      }
                *var_155 = i;
  break;
      case 'O':
  switch (tolower((int) optarg[0]))
                  {
    case 'a': page->orient = 16;
                             break;
    case 'p': page->orient = 1;
                             break;
    case 'l': page->orient = 2;
                             break;
    default: TIFFError ("Orientation must be portrait, landscape, or auto.", "%s", optarg);
       TIFFError ("For valid options type", "tiffcrop -h");
                            exit (-1);
    }
  break;
      case 'P':
         if (sscanf(optarg, "%lfx%lf", &page->width, &page->length) == 2)
                  {
                  strcpy (page->name, "Custom");
                  page->mode |= 2;
                  break;
                  }
                if (get_page_geometry (optarg, page))
                  {
    if (!strcmp(optarg, "list"))
                    {
      TIFFError("", "Name            Width   Length (in inches)");
                    for (i = 0; i < 48; i++)
                      TIFFError ("", "%-15.15s %5.2f   %5.2f",
          PaperTable[i].name, PaperTable[i].width,
                               PaperTable[i].length);
      exit (-1);
                    }

    TIFFError ("Invalid paper size", "%s", optarg);
                  TIFFError ("", "Select one of:");
    TIFFError("", "Name            Width   Length (in inches)");
                  for (i = 0; i < 48; i++)
                    TIFFError ("", "%-15.15s %5.2f   %5.2f",
          PaperTable[i].name, PaperTable[i].width,
                               PaperTable[i].length);
    exit (-1);
    }
  else
                  {
                  page->mode |= 2;
    }
  break;
      case 'R':
  crop_data->crop_mode |= 32;
  switch (strtoul(optarg, NULL, 0))
                  {
    case 90: crop_data->rotation = (uint16)90;
                             break;
                  case 180: crop_data->rotation = (uint16)180;
                             break;
                  case 270: crop_data->rotation = (uint16)270;
                             break;
    default: TIFFError ("Rotation must be 90, 180, or 270 degrees clockwise", "%s", optarg);
        TIFFError ("For valid options type", "tiffcrop -h");
                             exit (-1);
    }
  break;
      case 'S':
  sep = strpbrk(optarg, ",:");
  if (sep)
                  {
                  *sep = '\0';
                  page->cols = atoi(optarg);
                  page->rows = atoi(sep +1);
    }
                else
                  {
                  page->cols = atoi(optarg);
                  page->rows = atoi(optarg);
    }
                if ((page->cols * page->rows) > 32)
                  {
    TIFFError ("Limit for subdivisions, ie rows x columns, exceeded", "%d", 32);
    exit (-1);
                  }
                page->mode |= 8;
  break;
      case 'U':
  if ((strcmp((optarg),("in")) == 0))
                  {
    crop_data->res_unit = RESUNIT_INCH;
    page->res_unit = RESUNIT_INCH;
    }
  else if ((strcmp((optarg),("cm")) == 0))
    {
    crop_data->res_unit = RESUNIT_CENTIMETER;
    page->res_unit = RESUNIT_CENTIMETER;
    }
  else if ((strcmp((optarg),("px")) == 0))
    {
    crop_data->res_unit = RESUNIT_NONE;
    page->res_unit = RESUNIT_NONE;
    }
  else
                  {
    TIFFError ("Illegal unit of measure","%s", optarg);
    TIFFError ("For valid options type", "tiffcrop -h");
                  exit (-1);
    }
  break;
      case 'V':
  page->vres = atof (optarg);
                page->mode |= 1;
  break;
      case 'X':
  crop_data->crop_mode |= 2;
  crop_data->width = atof(optarg);
  break;
      case 'Y':
  crop_data->crop_mode |= 4;
  crop_data->length = atof(optarg);
  break;
      case 'Z':
  crop_data->crop_mode |= 8;
  for (i = 0, opt_ptr = strtok (optarg, ",");
                   ((opt_ptr != NULL) && (i < 8));
                    (opt_ptr = strtok (NULL, ",")), i++)
                    {
      crop_data->zones++;
      opt_offset = strchr(opt_ptr, ':');
      if (!opt_offset) {
   TIFFError("Wrong parameter syntax for -Z", "tiffcrop -h");
   exit(-1);
      }
                    *opt_offset = '\0';
                    crop_data->zonelist[i].position = atoi(opt_ptr);
                    crop_data->zonelist[i].total = atoi(opt_offset + 1);
                    }

                if ((opt_ptr != NULL) && (i >= 8))
                  {
    TIFFError("Zone list exceeds region limit", "%d", 8);
    exit (-1);
                  }
  break;
    case '?': TIFFError ("For valid options type", "tiffcrop -h");
                exit (-1);

      }
    }
  }





static int
fn_146 (TIFF **tiffout, char *var_155, int var_202,
                    char *outname, unsigned int *page)
  {
  static int var_148 = 0;
  char *sep;
  char filenum[16];
  char export_ext[16];
  char exportname[1024];

  if (var_202 && (*tiffout != NULL))
    {

    TIFFClose (*tiffout);
    *tiffout = NULL;
    }

  strcpy (export_ext, ".tiff");
  memset (exportname, '\0', 1024);


  strncpy (exportname, outname, 1008);
  if (*tiffout == NULL)
    {
    if (var_202)
      {
      var_148++;
      if ((sep = strstr(exportname, ".tif")) || (sep = strstr(exportname, ".TIF")))
        {
        strncpy (export_ext, sep, 5);
        *sep = '\0';
        }
      else
        strncpy (export_ext, ".tiff", 5);
      export_ext[5] = '\0';


      if (var_148 > 999999)
 {
 TIFFError("update_output_file", "Maximum of %d pages per file exceeded", 999999);
        return 1;
        }

      snprintf(filenum, sizeof(filenum), "-%03d%s", var_148, export_ext);
      filenum[14] = '\0';
      strncat (exportname, filenum, 15);
      }
    exportname[1023] = '\0';

    *tiffout = TIFFOpen(exportname, var_155);
    if (*tiffout == NULL)
      {
      TIFFError("update_output_file", "Unable to open output file %s", exportname);
      return 1;
      }
    *page = 0;

    return 0;
    }
  else
    (*page)++;

  return 0;
  }


int
fn_148(int var_155, char* argv[])
  {


  extern int optind;

  uint16 var_155 = (uint16) -1;
  uint16 var_155 = 0;
  uint32 var_155 = (uint32) 0;
  uint32 var_155 = (uint32) 0;
  uint32 var_155 = (uint32) 0;
  uint32 var_155 = 0;

  TIFF *var_210 = NULL;
  TIFF *var_210 = NULL;
  char var_155[10];
  char *mp = var_155;


  struct struct_210 image;
  struct struct_209 crop;
  struct struct_202 page;
  struct struct_202 sections[32];
  struct struct_208 seg_buffs[32];
  struct struct_209 dump;
  unsigned char *read_buff = NULL;
  unsigned char *crop_buff = NULL;
  unsigned char *sect_buff = NULL;
  unsigned char *sect_src = NULL;
  unsigned int imagelist[2049];
  unsigned int var_155 = 0;
  unsigned int var_155 = 0;
  unsigned int var_155 = 0;
  unsigned int var_155 = 0;
  unsigned int var_210 = 0;
  unsigned int var_155 = 0;
  unsigned int var_155 = 0;
  int seg, var_214;
  char temp_filename[1025];

  var_213 = *((unsigned char *)&var_213) & '1';

  initImageData(&image);
  initCropMasks(&crop);
  initPageSetup(&page, sections, seg_buffs);
  initDumpOptions(&dump);

  process_command_opts (var_155, argv, mp, var_155, &var_155, &var_155,
                        &var_155, &var_155, &var_155, &var_155,
                 &crop, &page, &dump, imagelist, &var_155);

  if (var_155 - optind < 2)
    usage();

  if ((var_155 - optind) == 2)
    var_207 = -1;
  else
    var_155 = 0;

  while (optind < var_155 - 1)
    {
    var_210 = TIFFOpen (argv[optind], "r");
    if (var_210 == NULL)
      return -3;


    var_155 = TIFFNumberOfDirectories(var_210);
    if (var_155 == 0)
      {
      var_155 = 0;
      var_210 = var_155;
      }
    else
      {
      var_155 = (tdir_t)(imagelist[var_155] - 1);
      var_155++;




      if (var_155 > var_155)
 var_155 = var_155;

      var_210 = var_155;
      }


    if (var_155 == 2047)
      var_155 = var_155 - 1;

    if (var_155 > (var_155))
      {
      TIFFError (TIFFFileName(var_210),
      "Invalid image number %d, File contains only %d images",
   (int)var_155 + 1, var_155);
      if (var_210 != NULL)
        (void) TIFFClose(var_210);
      return 1;
      }

    if (var_155 != 0 && !TIFFSetDirectory(var_210, (tdir_t)var_155))
      {
      TIFFError(TIFFFileName(var_210),"Error, setting subdirectory at %d", var_155);
      if (var_210 != NULL)
        (void) TIFFClose(var_210);
      return 1;
      }

    var_155 = 0;
    while (var_155 == 0)
      {
      var_210 = var_155;
      var_210 = var_155;
      var_210 = var_155;
      var_210 = var_155;
      var_210 = var_155;
      var_210 = var_155;
      var_210 = var_155;
      var_210 = var_155;

      if (dump.format != 0)
        {

 var_155++;
        var_214 = strlen(dump.infilename);
        if (var_214 > 0)
          {
          if (dump.infile != NULL)
            fclose (dump.infile);



          snprintf(temp_filename, sizeof(temp_filename), "%s-read-%03d.%s",
     dump.infilename, var_155,
                  (dump.format == 1) ? "txt" : "raw");
          if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL)
            {
     TIFFError ("Unable to open dump file for writing", "%s", temp_filename);
     exit (-1);
            }
          dump_info(dump.infile, dump.format, "Reading image","%d from %s",
                    var_155, TIFFFileName(var_210));
          }
        var_214 = strlen(dump.outfilename);
        if (var_214 > 0)
          {
          if (dump.outfile != NULL)
            fclose (dump.outfile);



          snprintf(temp_filename, sizeof(temp_filename), "%s-write-%03d.%s",
     dump.outfilename, var_155,
                  (dump.format == 1) ? "txt" : "raw");
          if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL)
            {
       TIFFError ("Unable to open dump file for writing", "%s", temp_filename);
     exit (-1);
            }
          dump_info(dump.outfile, dump.format, "Writing image","%d from %s",
                    var_155, TIFFFileName(var_210));
          }
        }

      if (dump.debug)
         TIFFError("main", "Reading image %4d of %4d total pages.", var_155 + 1, var_210);

      if (loadImage(var_210, &image, &dump, &read_buff))
        {
        TIFFError("main", "Unable to load source image");
        exit (-1);
        }



      if (image.adjustments != 0)
        {
 if (correct_orientation(&image, &read_buff))
     TIFFError("main", "Unable to correct image orientation");
        }

      if (getCropOffsets(&image, &crop, &dump))
        {
        TIFFError("main", "Unable to define crop regions");
        exit (-1);
 }

      if (crop.selections > 0)
        {
        if (processCropSelections(&image, &crop, &read_buff, seg_buffs))
          {
          TIFFError("main", "Unable to process image selections");
          exit (-1);
   }
 }
      else
        {
        if (createCroppedImage(&image, &crop, &read_buff, &crop_buff))
          {
          TIFFError("main", "Unable to create output image");
          exit (-1);
   }
 }
      if (page.mode == 0)
        {
        if (crop.selections > 0)
          {
   writeSelections(var_210, &var_210, &crop, &image, &dump, seg_buffs,
                          mp, argv[var_155 - 1], &var_155, var_210);
          }
 else
          {
   if (update_output_file (&var_210, mp, crop.exp_mode, argv[var_155 - 1],
                                  &var_155))
             exit (1);
          if (writeCroppedImage(var_210, var_210, &image, &dump,crop.combined_width,
                                crop.combined_length, crop_buff, var_155, var_210))
            {
             TIFFError("main", "Unable to write new image");
             exit (-1);
     }
          }
 }
      else
        {



 if (crop_buff != NULL)
   sect_src = crop_buff;
        else
          sect_src = read_buff;

        if (computeOutputPixelOffsets(&crop, &image, &page, sections, &dump))
          {
          TIFFError("main", "Unable to compute output section data");
          exit (-1);
   }



 if (update_output_file (&var_210, mp, crop.exp_mode, argv[var_155 - 1], &var_155))
          exit (1);

 if (writeImageSections(var_210, var_210, &image, &page, sections, &dump, sect_src, &sect_buff))
          {
          TIFFError("main", "Unable to write image sections");
          exit (-1);
   }
        }


      if (var_155 == 0)
        var_155++;
      else
        {
 var_155 = (tdir_t)(imagelist[var_155] - 1);
        var_155++;
        }

      if (var_155 == 2047)
        var_155 = TIFFNumberOfDirectories(var_210) - 1;

      if (!TIFFSetDirectory(var_210, (tdir_t)var_155))
        var_155 = 1;
      }
    TIFFClose(var_210);
    optind++;
    }


  if (read_buff)
    _TIFFfree(read_buff);

  if (crop_buff)
    _TIFFfree(crop_buff);

  if (sect_buff)
    _TIFFfree(sect_buff);


  for (seg = 0; seg < crop.selections; seg++)
    _TIFFfree (seg_buffs[seg].buffer);

  if (dump.format != 0)
    {
    if (dump.infile != NULL)
     fclose (dump.infile);

    if (dump.outfile != NULL)
      {
      dump_info (dump.outfile, dump.format, "", "Completed run for %s", TIFFFileName(var_210));
      fclose (dump.outfile);
      }
    }

  TIFFClose(var_210);

  return 0;
  }



static int fn_155 (FILE *dumpfile, int var_183, char *dump_tag, unsigned char *var_210, uint32 var_202)
  {
  int j, k;
  uint32 i;
  char dump_array[10];
  unsigned char bitset;

  if (dumpfile == NULL)
    {
    TIFFError ("", "Invalid FILE pointer for dump file");
    return 1;
    }

  if (var_183 == 1)
    {
    fprintf (dumpfile," %s  ", dump_tag);
    for (i = 0; i < var_202; i++)
      {
      for (j = 0, k = 7; j < 8; j++, k--)
        {
 bitset = (*(var_210 + i)) & (((unsigned char)1 << k)) ? 1 : 0;
        sprintf(&dump_array[j], (bitset) ? "1" : "0");
        }
      dump_array[8] = '\0';
      fprintf (dumpfile," %s", dump_array);
      }
    fprintf (dumpfile,"\n");
    }
  else
    {
    if ((fwrite (var_210, 1, var_202, dumpfile)) != var_202)
      {
      TIFFError ("", "Unable to write binary data to dump file");
      return 1;
      }
    }

  return 0;
  }

static int fn_157 (FILE *dumpfile, int var_183, char *dump_tag, unsigned char var_210)
  {
  int j, k;
  char dump_array[10];
  unsigned char bitset;

  if (dumpfile == NULL)
    {
    TIFFError ("", "Invalid FILE pointer for dump file");
    return 1;
    }

  if (var_183 == 1)
    {
    fprintf (dumpfile," %s  ", dump_tag);
    for (j = 0, k = 7; j < 8; j++, k--)
      {
      bitset = var_210 & (((unsigned char)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? "1" : "0");
      }
    dump_array[8] = '\0';
    fprintf (dumpfile," %s\n", dump_array);
    }
  else
    {
    if ((fwrite (&var_210, 1, 1, dumpfile)) != 1)
      {
      TIFFError ("", "Unable to write binary data to dump file");
      return 1;
      }
    }

  return 0;
  }

static int fn_157 (FILE *dumpfile, int var_183, char *dump_tag, uint16 var_210)
  {
  int j, k;
  char dump_array[20];
  unsigned char bitset;

  if (dumpfile == NULL)
    {
    TIFFError ("", "Invalid FILE pointer for dump file");
    return 1;
    }

  if (var_183 == 1)
    {
    fprintf (dumpfile," %s  ", dump_tag);
    for (j = 0, k = 15; k >= 0; j++, k--)
      {
      bitset = var_210 & (((unsigned char)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? "1" : "0");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], " ");
      }
    dump_array[17] = '\0';
    fprintf (dumpfile," %s\n", dump_array);
    }
  else
    {
    if ((fwrite (&var_210, 2, 1, dumpfile)) != 2)
      {
      TIFFError ("", "Unable to write binary data to dump file");
      return 1;
      }
    }

  return 0;
  }

static int fn_157 (FILE *dumpfile, int var_183, char *dump_tag, uint32 var_210)
  {
  int j, k;
  char dump_array[40];
  unsigned char bitset;

  if (dumpfile == NULL)
    {
    TIFFError ("", "Invalid FILE pointer for dump file");
    return 1;
    }

  if (var_183 == 1)
    {
    fprintf (dumpfile," %s  ", dump_tag);
    for (j = 0, k = 31; k >= 0; j++, k--)
      {
      bitset = var_210 & (((uint32)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? "1" : "0");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], " ");
      }
    dump_array[35] = '\0';
    fprintf (dumpfile," %s\n", dump_array);
    }
  else
    {
    if ((fwrite (&var_210, 4, 1, dumpfile)) != 4)
      {
      TIFFError ("", "Unable to write binary data to dump file");
      return 1;
      }
    }
  return 0;
  }

static int fn_157 (FILE *dumpfile, int var_183, char *dump_tag, uint64 var_210)
  {
  int j, k;
  char dump_array[80];
  unsigned char bitset;

  if (dumpfile == NULL)
    {
    TIFFError ("", "Invalid FILE pointer for dump file");
    return 1;
    }

  if (var_183 == 1)
    {
    fprintf (dumpfile," %s  ", dump_tag);
    for (j = 0, k = 63; k >= 0; j++, k--)
      {
      bitset = var_210 & (((uint64)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? "1" : "0");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], " ");
      }
    dump_array[71] = '\0';
    fprintf (dumpfile," %s\n", dump_array);
    }
  else
    {
    if ((fwrite (&var_210, 8, 1, dumpfile)) != 8)
      {
      TIFFError ("", "Unable to write binary data to dump file");
      return 1;
      }
    }

  return 0;
  }

static void fn_157(FILE *dumpfile, int var_183, char *prefix, char *msg, ...)
  {
  if (var_183 == 1)
    {
    va_list ap;
    va_start(ap, msg);
    fprintf(dumpfile, "%s ", prefix);
    vfprintf(dumpfile, msg, ap);
    fprintf(dumpfile, "\n");
    va_end(ap);
    }
  }

static int fn_157 (FILE* dumpfile, int var_183, uint32 var_183, uint32 var_214,
                 uint32 var_214, unsigned char *buff)
  {
  int j, k;
  uint32 i;
  unsigned char * dump_ptr;

  if (dumpfile == NULL)
    {
    TIFFError ("", "Invalid FILE pointer for dump file");
    return 1;
    }

  for (i = 0; i < var_183; i++)
    {
    dump_ptr = buff + (i * var_214);
    if (var_183 == 1)
      dump_info (dumpfile, var_183, "",
                 "Row %4d, %d bytes at offset %d",
          var_214 + i + 1, var_214, var_214 * var_214);

    for (j = 0, k = var_214; k >= 10; j += 10, k -= 10, dump_ptr += 10)
      dump_data (dumpfile, var_183, "", dump_ptr, 10);
    if (k > 0)
      dump_data (dumpfile, var_183, "", dump_ptr, k);
    }
  return 0;
  }







static int
fn_158 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                           tsample_t var_213, uint16 var_214, uint16 var_214,
                           tsample_t var_202, uint32 var_177, uint32 var_177)
  {
  int i, bytes_per_sample, var_177;
  uint32 var_214, dst_rowsize, var_213;
  uint32 var_213 ;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("extractContigSamplesBytes","Invalid input or output buffer");
    return 1;
    }

  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesBytes",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesBytes",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }

  dst_rowsize = (var_214 * (var_177 - var_177) * var_202) / 8;

  bytes_per_sample = (var_214 + 7) / 8;

  if (var_202 == var_214)
    {
    src = var_210 + (var_177 * var_214 * bytes_per_sample);
    _TIFFmemcpy (dst, src, dst_rowsize);
    }
  else
    {
    for (var_214 = var_177; var_214 < var_177; var_214++)
      {
      for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
        {
        var_213 = var_214 * var_214 * var_214;
        if (var_177 == 0)
          {
          var_213 = var_213 / 8;

          }
        else
          {
          var_213 = (var_213 + (var_177 * var_214)) / 8;

          }
        src = var_210 + var_213;
        for (i = 0; i < bytes_per_sample; i++)
            *dst++ = *src++;
        }
      }
    }

  return 0;
  }

static int
fn_162 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                           tsample_t var_213, uint16 var_214, uint16 var_214,
                           tsample_t var_202, uint32 var_177, uint32 var_177)
  {
  int var_213 = 0, var_177 = 0;
  uint32 var_214, var_213, var_212, var_213;
  uint8 var_210 = 0, var_210 = 0;
  uint8 var_213 = 0, var_213 = 0;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("extractContigSamples8bits","Invalid input or output buffer");
    return 1;
    }

  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamples8bits",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamples8bits",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }

  var_213 = 0;
  var_210 = (uint8)-1 >> ( 8 - var_214);
  var_213 = var_213 = 0;
  for (var_214 = var_177; var_214 < var_177; var_214++)
    {
    var_213 = var_214 * var_214 * var_214;
    for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
      {
      if (var_177 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_177 * var_214)) / 8;
        var_212 = (var_213 + (var_177 * var_214)) % 8;
        }

      src = var_210 + var_213;
      var_210 = var_210 << (8 - var_212 - var_214);
      var_213 = ((*src) & var_210) << (var_212);


      if (var_213 >= 8)
        {
        *dst++ = var_213;
        var_213 = var_213;
        var_213 -= 8;
        }
      else
        var_213 = (var_213 | (var_213 >> var_213));
      var_213 += var_214;
      }
    }

  while (var_213 > 0)
    {
    var_213 = (var_213 & ((unsigned int)255 << (8 - var_213)));
    *dst++ = var_213;
    var_213 -= 8;
    }

  return 0;
  }

static int
fn_168 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                            tsample_t var_213, uint16 var_214, uint16 var_214,
                            tsample_t var_202, uint32 var_177, uint32 var_177)
  {
  int var_213 = 0, var_177 = 0;
  uint32 var_214, var_213, var_212, var_213;
  uint16 var_210 = 0, var_210 = 0;
  uint16 var_213 = 0, var_213 = 0;
  uint8 var_213 = 0;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("extractContigSamples16bits","Invalid input or output buffer");
    return 1;
    }

  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamples16bits",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamples16bits",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }

  var_213 = 0;
  var_210 = (uint16)-1 >> (16 - var_214);

  for (var_214 = var_177; var_214 < var_177; var_214++)
    {
    var_213 = var_214 * var_214 * var_214;
    for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
      {
      if (var_177 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_177 * var_214)) / 8;
        var_212 = (var_213 + (var_177 * var_214)) % 8;
        }

      src = var_210 + var_213;
      var_210 = var_210 << (16 - var_212 - var_214);

      if (var_213)
        var_213 = (src[0] << 8) | src[1];
      else
        var_213 = (src[1] << 8) | src[0];

      var_213 = (var_213 & var_210) << (var_212);
      if (var_213 < 8)
        {
        var_213 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      else
        {
        var_213 = (var_213 >> 8);
        *dst++ = var_213;
        var_213 -= 8;

        var_213 = ((var_213 << 8) | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }


  while (var_213 > 0)
    {
    var_213 = (var_213 >> 8);
    *dst++ = var_213;
    var_213 -= 8;
    }

  return 0;
  }


static int
fn_169 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                      tsample_t var_213, uint16 var_214, uint16 var_214,
                            tsample_t var_202, uint32 var_177, uint32 var_177)
  {
  int var_213 = 0, var_177 = 0;
  uint32 var_214, var_213, var_212, var_213;
  uint32 var_210 = 0, var_210 = 0;
  uint32 var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((var_210 == NULL) || (var_210 == NULL))
    {
    TIFFError("extractContigSamples24bits","Invalid input or output buffer");
    return 1;
    }

  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamples24bits",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamples24bits",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }

  var_213 = 0;
  var_210 = (uint32)-1 >> ( 32 - var_214);
  for (var_214 = var_177; var_214 < var_177; var_214++)
    {

    var_213 = var_214 * var_214 * var_214;
    for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
      {
      if (var_177 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_177 * var_214)) / 8;
        var_212 = (var_213 + (var_177 * var_214)) % 8;
        }

      src = var_210 + var_213;
      var_210 = var_210 << (32 - var_212 - var_214);
      if (var_213)
 var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
      else
 var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
      var_213 = (var_213 & var_210) << (var_212);

      if (var_213 < 16)
        {
        var_214 = var_214 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      else
        {
        var_214 = (var_213 >> 24);
        *dst++ = var_214;
        var_214 = (var_213 >> 16);
        *dst++ = var_214;
        var_213 -= 16;


        var_213 = ((var_213 << 16) | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }


  while (var_213 > 0)
    {
    var_214 = (var_213 >> 24);
    *dst++ = var_214;

    var_213 = (var_213 << 8);
    var_214 = var_214;
    var_213 -= 8;
    }

  return 0;
  }

static int
fn_171 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                            tsample_t var_213, uint16 var_214, uint16 var_214,
        tsample_t var_202, uint32 var_177, uint32 var_177)
  {
  int var_213 = 0, var_177 = 0 ;
  uint32 var_214, var_213, var_212, var_213;
  uint32 var_213 = 0, var_213 = 0;
  uint64 var_210 = 0, var_210 = 0;
  uint64 var_213 = 0, var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0, var_214 = 0, var_214 = 0;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((var_210 == NULL) || (var_210 == NULL))
    {
    TIFFError("extractContigSamples32bits","Invalid input or output buffer");
    return 1;
    }


  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamples32bits",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamples32bits",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }


  var_213 = 0;
  var_210 = (uint64)-1 >> ( 64 - var_214);
  for (var_214 = var_177; var_214 < var_177; var_214++)
    {

    var_213 = var_214 * var_214 * var_214;
    for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
      {
      if (var_177 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_177 * var_214)) / 8;
        var_212 = (var_213 + (var_177 * var_214)) % 8;
        }

      src = var_210 + var_213;
      var_210 = var_210 << (64 - var_212 - var_214);
      if (var_213)
        {
 var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
 var_213 = var_213;
        }
      else
        {
 var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
 var_213 = var_213;
 }

      var_213 = ((uint64)var_213 << 32) | var_213;
      var_213 = (var_213 & var_210) << (var_212);


      if (var_213 >= 32)
        {
        var_214 = (var_213 >> 56);
        *dst++ = var_214;
        var_214 = (var_213 >> 48);
        *dst++ = var_214;
        var_214 = (var_213 >> 40);
        *dst++ = var_214;
        var_214 = (var_213 >> 32);
        *dst++ = var_214;
        var_213 -= 32;


        var_213 = ((var_213 << 32) | (var_213 >> var_213));
        }
      else
        {
        var_214 = var_214 = var_214 = var_214 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }
  while (var_213 > 0)
    {
    var_214 = (var_213 >> 56);
    *dst++ = var_214;
    var_213 = (var_213 << 8);
    var_213 -= 8;
    }

  return 0;
  }

static int
fn_176 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                                  tsample_t var_213, uint16 var_214, uint16 var_214,
             tsample_t var_202, uint32 var_177, uint32 var_177,
                            int var_177)
  {
  int var_213 = 0, var_177 = 0;
  uint32 var_214, var_213, var_212, var_213;
  uint8 var_210 = 0, var_210 = 0;
  uint8 var_213 = 0, var_213 = 0;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("extractContigSamplesShifted8bits","Invalid input or output buffer");
    return 1;
    }

  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesShifted8bits",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesShifted8bits",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }

  var_213 = var_177;
  var_210 = (uint8)-1 >> ( 8 - var_214);
  var_213 = var_213 = 0;
  for (var_214 = var_177; var_214 < var_177; var_214++)
    {
    var_213 = var_214 * var_214 * var_214;
    for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
      {
      if (var_177 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_177 * var_214)) / 8;
        var_212 = (var_213 + (var_177 * var_214)) % 8;
        }

      src = var_210 + var_213;
      var_210 = var_210 << (8 - var_212 - var_214);
      var_213 = ((*src) & var_210) << (var_212);
      if ((var_214 == var_177) && (var_177 == var_213))
        var_213 = *src & ((uint8)-1) << (var_177);


      if (var_213 >= 8)
        {
        *dst++ |= var_213;
        var_213 = var_213;
        var_213 -= 8;
        }
      else
 var_213 = var_213 | (var_213 >> var_213);
      var_213 += var_214;
      }
    }

  while (var_213 > 0)
    {
    var_213 = (var_213 & ((unsigned int)255 << (8 - var_213)));
    *dst++ = var_213;
    var_213 -= 8;
    }

  return 0;
  }

static int
fn_177 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                                   tsample_t var_213, uint16 var_214, uint16 var_214,
                tsample_t var_202, uint32 var_177, uint32 var_177,
                             int var_177)
  {
  int var_213 = 0, var_177 = 0;
  uint32 var_214, var_213, var_212, var_213;
  uint16 var_210 = 0, var_210 = 0;
  uint16 var_213 = 0, var_213 = 0;
  uint8 var_213 = 0;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("extractContigSamplesShifted16bits","Invalid input or output buffer");
    return 1;
    }

  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesShifted16bits",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesShifted16bits",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }

  var_213 = var_177;
  var_210 = (uint16)-1 >> (16 - var_214);
  for (var_214 = var_177; var_214 < var_177; var_214++)
    {
    var_213 = var_214 * var_214 * var_214;
    for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
      {
      if (var_177 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_177 * var_214)) / 8;
        var_212 = (var_213 + (var_177 * var_214)) % 8;
        }

      src = var_210 + var_213;
      var_210 = var_210 << (16 - var_212 - var_214);
      if (var_213)
        var_213 = (src[0] << 8) | src[1];
      else
        var_213 = (src[1] << 8) | src[0];

      if ((var_214 == var_177) && (var_177 == var_213))
        var_213 = var_213 & ((uint16)-1) << (8 - var_177);

      var_213 = (var_213 & var_210) << (var_212);

      if (var_213 < 8)
        var_213 = var_213 | (var_213 >> var_213);
      else
        {
        var_213 = (var_213 >> 8);
        *dst++ = var_213;
        var_213 -= 8;

        var_213 = ((var_213 << 8) | (var_213 >> var_213));
        }

      var_213 += var_214;
      }
    }


  while (var_213 > 0)
    {
    var_213 = (var_213 >> 8);
    *dst++ = var_213;
    var_213 -= 8;
    }

  return 0;
  }


static int
fn_177 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                             tsample_t var_213, uint16 var_214, uint16 var_214,
                                   tsample_t var_202, uint32 var_177, uint32 var_177,
                            int var_177)
  {
  int var_213 = 0, var_177 = 0;
  uint32 var_214, var_213, var_212, var_213;
  uint32 var_210 = 0, var_210 = 0;
  uint32 var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((var_210 == NULL) || (var_210 == NULL))
    {
    TIFFError("extractContigSamplesShifted24bits","Invalid input or output buffer");
    return 1;
    }

  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesShifted24bits",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesShifted24bits",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }

  var_213 = var_177;
  var_210 = (uint32)-1 >> ( 32 - var_214);
  for (var_214 = var_177; var_214 < var_177; var_214++)
    {

    var_213 = var_214 * var_214 * var_214;
    for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
      {
      if (var_177 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_177 * var_214)) / 8;
        var_212 = (var_213 + (var_177 * var_214)) % 8;
        }

      src = var_210 + var_213;
      var_210 = var_210 << (32 - var_212 - var_214);
      if (var_213)
 var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
      else
 var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];

      if ((var_214 == var_177) && (var_177 == var_213))
        var_213 = var_213 & ((uint32)-1) << (16 - var_177);

      var_213 = (var_213 & var_210) << (var_212);

      if (var_213 < 16)
        {
        var_214 = var_214 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      else
        {
        var_214 = (var_213 >> 24);
        *dst++ = var_214;
        var_214 = (var_213 >> 16);
        *dst++ = var_214;
        var_213 -= 16;


        var_213 = ((var_213 << 16) | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }


  while (var_213 > 0)
    {
    var_214 = (var_213 >> 24);
    *dst++ = var_214;

    var_213 = (var_213 << 8);
    var_214 = var_214;
    var_213 -= 8;
    }

  return 0;
  }

static int
fn_177 (uint8 *var_210, uint8 *var_210, uint32 var_183,
                                   tsample_t var_213, uint16 var_214, uint16 var_214,
               tsample_t var_202, uint32 var_177, uint32 var_177,
                            int var_177)
  {
  int var_213 = 0, var_177 = 0 ;
  uint32 var_214, var_213, var_212, var_213;
  uint32 var_213 = 0, var_213 = 0;
  uint64 var_210 = 0, var_210 = 0;
  uint64 var_213 = 0, var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0, var_214 = 0, var_214 = 0;
  uint8 *src = var_210;
  uint8 *dst = var_210;

  if ((var_210 == NULL) || (var_210 == NULL))
    {
    TIFFError("extractContigSamplesShifted32bits","Invalid input or output buffer");
    return 1;
    }


  if ((var_177 > var_177) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesShifted32bits",
               "Invalid start column value %d ignored", var_177);
    var_177 = 0;
    }
  if ((var_177 == 0) || (var_177 > var_183))
    {
    TIFFError ("extractContigSamplesShifted32bits",
               "Invalid end column value %d ignored", var_177);
    var_177 = var_183;
    }


  var_213 = var_177;
  var_210 = (uint64)-1 >> ( 64 - var_214);
  for (var_214 = var_177; var_214 < var_177; var_214++)
    {

    var_213 = var_214 * var_214 * var_214;
    for (var_177 = var_213; (var_177 < var_214) && (var_177 < (var_213 + var_202)); var_177++)
      {
      if (var_177 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_177 * var_214)) / 8;
        var_212 = (var_213 + (var_177 * var_214)) % 8;
        }

      src = var_210 + var_213;
      var_210 = var_210 << (64 - var_212 - var_214);
      if (var_213)
        {
 var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
 var_213 = var_213;
        }
      else
        {
 var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
 var_213 = var_213;
 }

      var_213 = ((uint64)var_213 << 32) | var_213;
      if ((var_214 == var_177) && (var_177 == var_213))
        var_213 = var_213 & ((uint64)-1) << (32 - var_177);

      var_213 = (var_213 & var_210) << (var_212);

      if (var_213 < 32)
        {
        var_214 = var_214 = var_214 = var_214 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      else
        {
        var_214 = (var_213 >> 56);
        *dst++ = var_214;
        var_214 = (var_213 >> 48);
        *dst++ = var_214;
        var_214 = (var_213 >> 40);
        *dst++ = var_214;
        var_214 = (var_213 >> 32);
        *dst++ = var_214;
        var_213 -= 32;


        var_213 = ((var_213 << 32) | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }
  while (var_213 > 0)
    {
    var_214 = (var_213 >> 56);
    *dst++ = var_214;
    var_213 = (var_213 << 8);
    var_213 -= 8;
    }

  return 0;
  }

static int
fn_177(uint8 *var_210, uint8 *var_210, uint32 var_183, uint32 var_183,
                        tsample_t var_213, uint16 var_214, uint16 var_214,
                             struct struct_209 *dump)
  {
  int shift_width, bytes_per_sample, bytes_per_pixel;
  uint32 src_rowsize, src_offset, var_214, var_202 = 0;
  uint32 dst_rowsize, dst_offset;
  tsample_t var_202 = 1;
  uint8 *src, *dst;

  bytes_per_sample = (var_214 + 7) / 8;
  bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
  if ((var_214 % 8) == 0)
    shift_width = 0;
  else
    {
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }
  src_rowsize = ((var_214 * var_214 * var_183) + 7) / 8;
  dst_rowsize = ((var_214 * var_183) + 7) / 8;

  if ((dump->outfile != NULL) && (dump->level == 4))
    {
    dump_info (dump->outfile, dump->format, "extractContigSamplesToBuffer",
                "Sample %d, %d rows", var_213 + 1, var_183 + 1);
    }
  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    src_offset = var_214 * src_rowsize;
    dst_offset = var_214 * dst_rowsize;
    src = var_210 + src_offset;
    dst = var_210 + dst_offset;


    switch (shift_width)
      {
      case 0: if (extractContigSamplesBytes (src, dst, var_183, var_213,
                                             var_214, var_214, var_202, var_202, var_183))
                return 1;
        break;
      case 1: if (var_214 == 1)
                {
                if (extractContigSamples8bits (src, dst, var_183, var_213,
                                               var_214, var_214, var_202, var_202, var_183))
           return 1;
         break;
  }
       else
                 if (extractContigSamples16bits (src, dst, var_183, var_213,
                                                 var_214, var_214, var_202, var_202, var_183))
          return 1;
       break;
      case 2: if (extractContigSamples24bits (src, dst, var_183, var_213,
                                              var_214, var_214, var_202, var_202, var_183))
          return 1;
       break;
      case 3:
      case 4:
      case 5: if (extractContigSamples32bits (src, dst, var_183, var_213,
                                              var_214, var_214, var_202, var_202, var_183))
          return 1;
       break;
      default: TIFFError ("extractContigSamplesToBuffer", "Unsupported bit depth: %d", var_214);
        return 1;
      }
    if ((dump->outfile != NULL) && (dump->level == 4))
      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, var_214, dst);
    }

  return 0;
  }

static int
fn_178(uint8 *var_210, uint8 *var_210, uint32 var_183, uint32 var_183,
                            uint32 var_183, uint32 var_210, tsample_t var_213,
     uint16 var_202, uint16 var_214, uint16 var_214, struct struct_209 *dump)
  {
  int shift_width, bytes_per_sample, bytes_per_pixel;
  uint32 src_rowsize, src_offset, var_214;
  uint32 dst_rowsize, dst_offset;
  uint8 *src, *dst;

  bytes_per_sample = (var_214 + 7) / 8;
  bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
  if ((var_214 % 8) == 0)
    shift_width = 0;
  else
    {
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }

  if ((dump->outfile != NULL) && (dump->level == 4))
    {
    dump_info (dump->outfile, dump->format, "extractContigSamplesToTileBuffer",
                "Sample %d, %d rows", var_213 + 1, var_183 + 1);
    }

  src_rowsize = ((var_214 * var_214 * var_183) + 7) / 8;
  dst_rowsize = ((var_214 * var_210 * var_202) + 7) / 8;

  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    src_offset = var_214 * src_rowsize;
    dst_offset = var_214 * dst_rowsize;
    src = var_210 + src_offset;
    dst = var_210 + dst_offset;


    switch (shift_width)
      {
      case 0: if (extractContigSamplesBytes (src, dst, var_183, var_213,
                                             var_214, var_214, var_202, 0, var_183))
                return 1;
        break;
      case 1: if (var_214 == 1)
                {
                if (extractContigSamples8bits (src, dst, var_183, var_213,
                                               var_214, var_214, var_202, 0, var_183))
           return 1;
         break;
  }
       else
                 if (extractContigSamples16bits (src, dst, var_183, var_213,
                                                 var_214, var_214, var_202, 0, var_183))
          return 1;
       break;
      case 2: if (extractContigSamples24bits (src, dst, var_183, var_213,
                                              var_214, var_214, var_202, 0, var_183))
          return 1;
       break;
      case 3:
      case 4:
      case 5: if (extractContigSamples32bits (src, dst, var_183, var_213,
                                              var_214, var_214, var_202, 0, var_183))
          return 1;
       break;
      default: TIFFError ("extractContigSamplesToTileBuffer", "Unsupported bit depth: %d", var_214);
        return 1;
      }
    if ((dump->outfile != NULL) && (dump->level == 4))
      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, var_214, dst);
    }

  return 0;
  }

static int fn_178 (TIFF* var_210, uint8* var_178)
{
        uint8* bufp = var_178;
        int32 var_186 = 0;
        uint16 var_186, var_199 = TIFFNumberOfStrips(var_210);
        uint32 var_186 = TIFFStripSize(var_210);
        uint32 var_183 = 0;
        uint32 var_186 = TIFFGetFieldDefaulted(var_210, TIFFTAG_ROWSPERSTRIP, &var_186);
        tsize_t var_182 = TIFFScanlineSize(var_210);

        if (var_182 == 0) {
                TIFFError("", "TIFF scanline size is zero!");
                return 0;
        }

        for (var_186 = 0; var_186 < var_199; var_186++) {
                var_186 = TIFFReadEncodedStrip (var_210, var_186, bufp, -1);
                var_183 = var_186 / var_182;
                if ((var_186 < (var_199 - 1)) && (var_186 != (int32)var_186))
                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
                                  (int)var_186 + 1, (unsigned long) var_186,
                                  (unsigned long)var_186);

                if (var_186 < 0 && !var_186) {
                        TIFFError("", "Error reading strip %lu after %lu rows",
                                  (unsigned long) var_186, (unsigned long)var_183);
                        return 0;
                }
                bufp += var_186;
        }

        return 1;
}

static int
fn_182 (unsigned char *srcbuffs[], unsigned char *var_210,
                             uint32 var_183, uint32 var_183, uint16 var_214, uint16 var_214,
                             FILE *dumpfile, int var_183, int var_183)
  {
  int i, bytes_per_sample;
  uint32 var_214, var_214, col_offset, src_rowsize, dst_rowsize, row_offset;
  unsigned char *src;
  unsigned char *dst;
  tsample_t s;

  src = srcbuffs[0];
  dst = var_210;
  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateSamplesBytes","Invalid buffer address");
    return 1;
    }

  bytes_per_sample = (var_214 + 7) / 8;

  src_rowsize = ((var_214 * var_183) + 7) / 8;
  dst_rowsize = ((var_214 * var_214 * var_183) + 7) / 8;
  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    if ((dumpfile != NULL) && (var_183 == 2))
      {
      for (s = 0; s < var_214; s++)
        {
        dump_info (dumpfile, var_183, "combineSeparateSamplesBytes","Input data, Sample %d", s);
        dump_buffer(dumpfile, var_183, 1, var_183, var_214, srcbuffs[s] + (var_214 * src_rowsize));
        }
      }
    dst = var_210 + (var_214 * dst_rowsize);
    row_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {
      col_offset = row_offset + (var_214 * (var_214 / 8));
      for (s = 0; (s < var_214) && (s < 8); s++)
        {
        src = srcbuffs[s] + col_offset;
        for (i = 0; i < bytes_per_sample; i++)
          *(dst + i) = *(src + i);
        src += bytes_per_sample;
        dst += bytes_per_sample;
        }
      }

    if ((dumpfile != NULL) && (var_183 == 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateSamplesBytes","Output data, combined samples");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210 + (var_214 * dst_rowsize));
      }
    }

  return 0;
  }

static int
fn_183 (uint8 *var_210[], uint8 *var_210, uint32 var_183,
                            uint32 var_183, uint16 var_214, uint16 var_214,
                      FILE *dumpfile, int var_183, int var_183)
  {
  int var_213 = 0;

  uint32 src_rowsize, dst_rowsize, src_offset;
  uint32 var_213;
  uint32 var_214, var_214, var_213 = 0, var_212 = 0;
  uint8 var_210 = 0, var_210 = 0;
  uint8 var_213 = 0, var_213 = 0;
  tsample_t s;
  unsigned char *src = var_210[0];
  unsigned char *dst = var_210;
  char action[32];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateSamples8bits","Invalid input or output buffer");
    return 1;
    }


  src_rowsize = ((var_214 * var_183) + 7) / 8;
  dst_rowsize = ((var_214 * var_183 * var_214) + 7) / 8;
  var_210 = (uint8)-1 >> ( 8 - var_214);

  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    var_213 = 0;
    var_213 = var_213 = 0;
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {

      var_213 = var_214 * var_214;
      var_213 = var_213 / 8;
      var_212 = var_213 % 8;

      var_210 = var_210 << (8 - var_212 - var_214);

      for (s = 0; (s < var_214) && (s < 8); s++)
        {
 src = var_210[s] + src_offset + var_213;
        var_213 = ((*src) & var_210) << (var_212);


        if (var_213 >= 8)
          {
          *dst++ = var_213;
          var_213 = var_213;
          var_213 -= 8;
          strcpy (action, "Flush");
          }
        else
          {
          var_213 = (var_213 | (var_213 >> var_213));
          strcpy (action, "Update");
          }
        var_213 += var_214;

        if ((dumpfile != NULL) && (var_183 == 3))
          {
          dump_info (dumpfile, var_183, "",
                   "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
     var_214 + 1, var_214 + 1, s, var_213, var_212, dst - var_210);
          dump_byte (dumpfile, var_183, "Match bits", var_210);
          dump_byte (dumpfile, var_183, "Src   bits", *src);
          dump_byte (dumpfile, var_183, "Buff1 bits", var_213);
          dump_byte (dumpfile, var_183, "Buff2 bits", var_213);
          dump_info (dumpfile, var_183, "","%s", action);
   }
        }
      }

    if (var_213 > 0)
      {
      var_213 = (var_213 & ((unsigned int)255 << (8 - var_213)));
      *dst++ = var_213;
      if ((dumpfile != NULL) && (var_183 == 3))
        {
        dump_info (dumpfile, var_183, "",
          "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
          var_214 + 1, var_214 + 1, var_213, var_212, dst - var_210);
                 dump_byte (dumpfile, var_183, "Final bits", var_213);
        }
      }

    if ((dumpfile != NULL) && (var_183 >= 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateSamples8bits","Output data");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210 + (var_214 * dst_rowsize));
      }
    }

  return 0;
  }

static int
fn_183 (uint8 *var_210[], uint8 *var_210, uint32 var_183,
                              uint32 var_183, uint16 var_214, uint16 var_214,
                        FILE *dumpfile, int var_183, int var_183)
  {
  int var_213 = 0 ;
  uint32 src_rowsize, dst_rowsize;
  uint32 var_213, src_offset;
  uint32 var_214, var_214, var_213 = 0, var_212 = 0;
  uint16 var_210 = 0, var_210 = 0;
  uint16 var_213 = 0, var_213 = 0;
  uint8 var_213 = 0;
  tsample_t s;
  unsigned char *src = var_210[0];
  unsigned char *dst = var_210;
  char action[8];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateSamples16bits","Invalid input or output buffer");
    return 1;
    }


  src_rowsize = ((var_214 * var_183) + 7) / 8;
  dst_rowsize = ((var_214 * var_183 * var_214) + 7) / 8;
  var_210 = (uint16)-1 >> (16 - var_214);

  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    var_213 = 0;
    var_213 = var_213 = 0;
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {

      var_213 = var_214 * var_214;
      var_213 = var_213 / 8;
      var_212 = var_213 % 8;

      var_210 = var_210 << (16 - var_212 - var_214);
      for (s = 0; (s < var_214) && (s < 8); s++)
        {
 src = var_210[s] + src_offset + var_213;
        if (var_213)
          var_213 = (src[0] << 8) | src[1];
        else
          var_213 = (src[1] << 8) | src[0];

 var_213 = (var_213 & var_210) << (var_212);


 if (var_213 >= 8)
   {
     var_213 = (var_213 >> 8);
     *dst++ = var_213;
     var_213 -= 8;

     var_213 = ((var_213 << 8) | (var_213 >> var_213));
     strcpy (action, "Flush");
   }
 else
   {
     var_213 = 0;
     var_213 = (var_213 | (var_213 >> var_213));
     strcpy (action, "Update");
   }
 var_213 += var_214;

 if ((dumpfile != NULL) && (var_183 == 3))
   {
   dump_info (dumpfile, var_183, "",
         "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         var_214 + 1, var_214 + 1, s, var_213, var_212, dst - var_210);

   dump_short (dumpfile, var_183, "Match bits", var_210);
   dump_data (dumpfile, var_183, "Src   bits", src, 2);
   dump_short (dumpfile, var_183, "Buff1 bits", var_213);
   dump_short (dumpfile, var_183, "Buff2 bits", var_213);
   dump_byte (dumpfile, var_183, "Write byte", var_213);
   dump_info (dumpfile, var_183, "","Ready bits:  %d, %s", var_213, action);
   }
 }
      }


    if (var_213 > 0)
      {
      var_213 = (var_213 >> 8);
      *dst++ = var_213;
      if ((dumpfile != NULL) && (var_183 == 3))
 {
 dump_info (dumpfile, var_183, "",
         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         var_214 + 1, var_214 + 1, var_213, var_212, dst - var_210);
 dump_byte (dumpfile, var_183, "Final bits", var_213);
 }
      }

    if ((dumpfile != NULL) && (var_183 == 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateSamples16bits","Output data");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210 + (var_214 * dst_rowsize));
      }
    }

  return 0;
  }

static int
fn_183 (uint8 *var_210[], uint8 *var_210, uint32 var_183,
                              uint32 var_183, uint16 var_214, uint16 var_214,
                       FILE *dumpfile, int var_183, int var_183)
  {
  int var_213 = 0 ;
  uint32 src_rowsize, dst_rowsize;
  uint32 var_213, src_offset;
  uint32 var_214, var_214, var_213 = 0, var_212 = 0;
  uint32 var_210 = 0, var_210 = 0;
  uint32 var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0;
  tsample_t s;
  unsigned char *src = var_210[0];
  unsigned char *dst = var_210;
  char action[8];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateSamples24bits","Invalid input or output buffer");
    return 1;
    }


  src_rowsize = ((var_214 * var_183) + 7) / 8;
  dst_rowsize = ((var_214 * var_183 * var_214) + 7) / 8;
  var_210 = (uint32)-1 >> ( 32 - var_214);

  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    var_213 = 0;
    var_213 = var_213 = 0;
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {

      var_213 = var_214 * var_214;
      var_213 = var_213 / 8;
      var_212 = var_213 % 8;

      var_210 = var_210 << (32 - var_212 - var_214);
      for (s = 0; (s < var_214) && (s < 8); s++)
        {
 src = var_210[s] + src_offset + var_213;
        if (var_213)
   var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
        else
   var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
 var_213 = (var_213 & var_210) << (var_212);


 if (var_213 >= 16)
   {
     var_214 = (var_213 >> 24);
     *dst++ = var_214;
     var_214 = (var_213 >> 16);
     *dst++ = var_214;
     var_213 -= 16;


     var_213 = ((var_213 << 16) | (var_213 >> var_213));
     strcpy (action, "Flush");
   }
 else
   {
     var_214 = var_214 = 0;
     var_213 = (var_213 | (var_213 >> var_213));
     strcpy (action, "Update");
   }
 var_213 += var_214;

 if ((dumpfile != NULL) && (var_183 == 3))
   {
   dump_info (dumpfile, var_183, "",
         "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         var_214 + 1, var_214 + 1, s, var_213, var_212, dst - var_210);
   dump_long (dumpfile, var_183, "Match bits ", var_210);
   dump_data (dumpfile, var_183, "Src   bits ", src, 4);
   dump_long (dumpfile, var_183, "Buff1 bits ", var_213);
   dump_long (dumpfile, var_183, "Buff2 bits ", var_213);
   dump_byte (dumpfile, var_183, "Write bits1", var_214);
   dump_byte (dumpfile, var_183, "Write bits2", var_214);
   dump_info (dumpfile, var_183, "","Ready bits:   %d, %s", var_213, action);
   }
 }
      }


    while (var_213 > 0)
      {
 var_214 = (var_213 >> 24);
 *dst++ = var_214;

 var_213 = (var_213 << 8);
 var_214 = var_214;
 var_213 -= 8;
      }

    if ((dumpfile != NULL) && (var_183 == 3))
      {
      dump_info (dumpfile, var_183, "",
     "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
     var_214 + 1, var_214 + 1, var_213, var_212, dst - var_210);

      dump_long (dumpfile, var_183, "Match bits ", var_210);
      dump_data (dumpfile, var_183, "Src   bits ", src, 4);
      dump_long (dumpfile, var_183, "Buff1 bits ", var_213);
      dump_long (dumpfile, var_183, "Buff2 bits ", var_213);
      dump_byte (dumpfile, var_183, "Write bits1", var_214);
      dump_byte (dumpfile, var_183, "Write bits2", var_214);
      dump_info (dumpfile, var_183, "", "Ready bits:  %2d", var_213);
      }

    if ((dumpfile != NULL) && (var_183 == 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateSamples24bits","Output data");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210 + (var_214 * dst_rowsize));
      }
    }

  return 0;
  }

static int
fn_183 (uint8 *var_210[], uint8 *var_210, uint32 var_183,
                              uint32 var_183, uint16 var_214, uint16 var_214,
                       FILE *dumpfile, int var_183, int var_183)
  {
  int var_213 = 0 ;
  uint32 src_rowsize, dst_rowsize, var_213, src_offset;
  uint32 var_213 = 0, var_212 = 0;
  uint32 var_214, var_214;
  uint32 var_213 = 0, var_213 = 0;
  uint64 var_210 = 0, var_210 = 0;
  uint64 var_213 = 0, var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0, var_214 = 0, var_214 = 0;
  tsample_t s;
  unsigned char *src = var_210[0];
  unsigned char *dst = var_210;
  char action[8];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateSamples32bits","Invalid input or output buffer");
    return 1;
    }


  src_rowsize = ((var_214 * var_183) + 7) / 8;
  dst_rowsize = ((var_214 * var_183 * var_214) + 7) / 8;
  var_210 = (uint64)-1 >> ( 64 - var_214);


  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    var_213 = 0;
    var_213 = var_213 = 0;
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {

      var_213 = var_214 * var_214;
      var_213 = var_213 / 8;
      var_212 = var_213 % 8;

      var_210 = var_210 << (64 - var_212 - var_214);
      for (s = 0; (s < var_214) && (s < 8); s++)
 {
 src = var_210[s] + src_offset + var_213;
 if (var_213)
   {
   var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
          var_213 = var_213;
   }
 else
   {
   var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
          var_213 = var_213;
   }
 var_213 = ((uint64)var_213 << 32) | var_213;
 var_213 = (var_213 & var_210) << (var_212);


 if (var_213 >= 32)
   {
   var_214 = (var_213 >> 56);
   *dst++ = var_214;
   var_214 = (var_213 >> 48);
   *dst++ = var_214;
   var_214 = (var_213 >> 40);
   *dst++ = var_214;
   var_214 = (var_213 >> 32);
   *dst++ = var_214;
   var_213 -= 32;


   var_213 = ((var_213 << 32) | (var_213 >> var_213));
   strcpy (action, "Flush");
   }
 else
   {
   var_214 = var_214 = var_214 = var_214 = 0;
   var_213 = (var_213 | (var_213 >> var_213));
   strcpy (action, "Update");
   }
 var_213 += var_214;

 if ((dumpfile != NULL) && (var_183 == 3))
   {
   dump_info (dumpfile, var_183, "",
       "Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
       var_214 + 1, var_214 + 1, s, var_213, var_212, dst - var_210);
   dump_wide (dumpfile, var_183, "Match bits ", var_210);
   dump_data (dumpfile, var_183, "Src   bits ", src, 8);
   dump_wide (dumpfile, var_183, "Buff1 bits ", var_213);
   dump_wide (dumpfile, var_183, "Buff2 bits ", var_213);
   dump_info (dumpfile, var_183, "", "Ready bits:   %d, %s", var_213, action);
   }
 }
      }
    while (var_213 > 0)
      {
      var_214 = (var_213 >> 56);
      *dst++ = var_214;
      var_213 = (var_213 << 8);
      var_213 -= 8;
      }

    if ((dumpfile != NULL) && (var_183 == 3))
      {
      dump_info (dumpfile, var_183, "",
          "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
   var_214 + 1, var_214 + 1, var_213, var_212, dst - var_210);

      dump_long (dumpfile, var_183, "Match bits ", var_210);
      dump_data (dumpfile, var_183, "Src   bits ", src, 4);
      dump_long (dumpfile, var_183, "Buff1 bits ", var_213);
      dump_long (dumpfile, var_183, "Buff2 bits ", var_213);
      dump_byte (dumpfile, var_183, "Write bits1", var_214);
      dump_byte (dumpfile, var_183, "Write bits2", var_214);
      dump_info (dumpfile, var_183, "", "Ready bits:  %2d", var_213);
      }

    if ((dumpfile != NULL) && (var_183 == 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateSamples32bits","Output data");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210);
      }
    }

  return 0;
  }

static int
fn_183 (unsigned char *srcbuffs[], unsigned char *var_210,
                                 uint32 var_183, uint32 var_183, uint32 var_183,
                                 uint32 var_199, uint16 var_214, uint16 var_214,
                                 FILE *dumpfile, int var_183, int var_183)
  {
  int i, bytes_per_sample;
  uint32 var_214, var_214, col_offset, src_rowsize, dst_rowsize, src_offset;
  unsigned char *src;
  unsigned char *dst;
  tsample_t s;

  src = srcbuffs[0];
  dst = var_210;
  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateTileSamplesBytes","Invalid buffer address");
    return 1;
    }

  bytes_per_sample = (var_214 + 7) / 8;
  src_rowsize = ((var_214 * var_199) + 7) / 8;
  dst_rowsize = var_183 * bytes_per_sample * var_214;
  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    if ((dumpfile != NULL) && (var_183 == 2))
      {
      for (s = 0; s < var_214; s++)
        {
        dump_info (dumpfile, var_183, "combineSeparateTileSamplesBytes","Input data, Sample %d", s);
        dump_buffer(dumpfile, var_183, 1, var_183, var_214, srcbuffs[s] + (var_214 * src_rowsize));
        }
      }
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;




    for (var_214 = 0; var_214 < var_183; var_214++)
      {
      col_offset = src_offset + (var_214 * (var_214 / 8));
      for (s = 0; (s < var_214) && (s < 8); s++)
        {
        src = srcbuffs[s] + col_offset;
        for (i = 0; i < bytes_per_sample; i++)
          *(dst + i) = *(src + i);
        dst += bytes_per_sample;
        }
      }

    if ((dumpfile != NULL) && (var_183 == 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateTileSamplesBytes","Output data, combined samples");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210 + (var_214 * dst_rowsize));
      }
    }

  return 0;
  }

static int
fn_183 (uint8 *var_210[], uint8 *var_210, uint32 var_183,
                                 uint32 var_183, uint32 var_183,
                                 uint32 var_199, uint16 var_214, uint16 var_214,
                           FILE *dumpfile, int var_183, int var_183)
  {
  int var_213 = 0;
  uint32 src_rowsize, dst_rowsize, src_offset;
  uint32 var_213;
  uint32 var_214, var_214, var_213 = 0, var_212 = 0;
  uint8 var_210 = 0, var_210 = 0;
  uint8 var_213 = 0, var_213 = 0;
  tsample_t s;
  unsigned char *src = var_210[0];
  unsigned char *dst = var_210;
  char action[32];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateTileSamples8bits","Invalid input or output buffer");
    return 1;
    }

  src_rowsize = ((var_214 * var_199) + 7) / 8;
  dst_rowsize = ((var_183 * var_214 * var_214) + 7) / 8;
  var_210 = (uint8)-1 >> ( 8 - var_214);

  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    var_213 = 0;
    var_213 = var_213 = 0;
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {

      var_213 = var_214 * var_214;
      var_213 = var_213 / 8;
      var_212 = var_213 % 8;

      var_210 = var_210 << (8 - var_212 - var_214);

      for (s = 0; (s < var_214) && (s < 8); s++)
        {
 src = var_210[s] + src_offset + var_213;
        var_213 = ((*src) & var_210) << (var_212);


        if (var_213 >= 8)
          {
          *dst++ = var_213;
          var_213 = var_213;
          var_213 -= 8;
          strcpy (action, "Flush");
          }
        else
          {
          var_213 = (var_213 | (var_213 >> var_213));
          strcpy (action, "Update");
          }
        var_213 += var_214;

        if ((dumpfile != NULL) && (var_183 == 3))
          {
          dump_info (dumpfile, var_183, "",
                   "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
     var_214 + 1, var_214 + 1, s, var_213, var_212, dst - var_210);
          dump_byte (dumpfile, var_183, "Match bits", var_210);
          dump_byte (dumpfile, var_183, "Src   bits", *src);
          dump_byte (dumpfile, var_183, "Buff1 bits", var_213);
          dump_byte (dumpfile, var_183, "Buff2 bits", var_213);
          dump_info (dumpfile, var_183, "","%s", action);
   }
        }
      }

    if (var_213 > 0)
      {
      var_213 = (var_213 & ((unsigned int)255 << (8 - var_213)));
      *dst++ = var_213;
      if ((dumpfile != NULL) && (var_183 == 3))
        {
        dump_info (dumpfile, var_183, "",
          "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
          var_214 + 1, var_214 + 1, var_213, var_212, dst - var_210);
                 dump_byte (dumpfile, var_183, "Final bits", var_213);
        }
      }

    if ((dumpfile != NULL) && (var_183 >= 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateTileSamples8bits","Output data");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210 + (var_214 * dst_rowsize));
      }
    }

  return 0;
  }

static int
fn_183 (uint8 *var_210[], uint8 *var_210, uint32 var_183,
                                  uint32 var_183, uint32 var_183,
                                  uint32 var_199, uint16 var_214, uint16 var_214,
                            FILE *dumpfile, int var_183, int var_183)
  {
  int var_213 = 0;
  uint32 src_rowsize, dst_rowsize;
  uint32 var_213, src_offset;
  uint32 var_214, var_214, var_213 = 0, var_212 = 0;
  uint16 var_210 = 0, var_210 = 0;
  uint16 var_213 = 0, var_213 = 0;
  uint8 var_213 = 0;
  tsample_t s;
  unsigned char *src = var_210[0];
  unsigned char *dst = var_210;
  char action[8];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateTileSamples16bits","Invalid input or output buffer");
    return 1;
    }

  src_rowsize = ((var_214 * var_199) + 7) / 8;
  dst_rowsize = ((var_183 * var_214 * var_214) + 7) / 8;
  var_210 = (uint16)-1 >> (16 - var_214);

  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    var_213 = 0;
    var_213 = var_213 = 0;
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {

      var_213 = var_214 * var_214;
      var_213 = var_213 / 8;
      var_212 = var_213 % 8;

      var_210 = var_210 << (16 - var_212 - var_214);
      for (s = 0; (s < var_214) && (s < 8); s++)
        {
 src = var_210[s] + src_offset + var_213;
        if (var_213)
          var_213 = (src[0] << 8) | src[1];
        else
          var_213 = (src[1] << 8) | src[0];
 var_213 = (var_213 & var_210) << (var_212);


 if (var_213 >= 8)
   {
     var_213 = (var_213 >> 8);
     *dst++ = var_213;
     var_213 -= 8;

     var_213 = ((var_213 << 8) | (var_213 >> var_213));
     strcpy (action, "Flush");
   }
 else
   {
     var_213 = 0;
     var_213 = (var_213 | (var_213 >> var_213));
     strcpy (action, "Update");
   }
 var_213 += var_214;

 if ((dumpfile != NULL) && (var_183 == 3))
   {
   dump_info (dumpfile, var_183, "",
         "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         var_214 + 1, var_214 + 1, s, var_213, var_212, dst - var_210);

   dump_short (dumpfile, var_183, "Match bits", var_210);
   dump_data (dumpfile, var_183, "Src   bits", src, 2);
   dump_short (dumpfile, var_183, "Buff1 bits", var_213);
   dump_short (dumpfile, var_183, "Buff2 bits", var_213);
   dump_byte (dumpfile, var_183, "Write byte", var_213);
   dump_info (dumpfile, var_183, "","Ready bits:  %d, %s", var_213, action);
   }
 }
      }


    if (var_213 > 0)
      {
      var_213 = (var_213 >> 8);
      *dst++ = var_213;
      if ((dumpfile != NULL) && (var_183 == 3))
 {
 dump_info (dumpfile, var_183, "",
         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         var_214 + 1, var_214 + 1, var_213, var_212, dst - var_210);
 dump_byte (dumpfile, var_183, "Final bits", var_213);
 }
      }

    if ((dumpfile != NULL) && (var_183 == 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateTileSamples16bits","Output data");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210 + (var_214 * dst_rowsize));
      }
    }

  return 0;
  }

static int
fn_183 (uint8 *var_210[], uint8 *var_210, uint32 var_183,
                                  uint32 var_183, uint32 var_183,
                                  uint32 var_199, uint16 var_214, uint16 var_214,
                            FILE *dumpfile, int var_183, int var_183)
  {
  int var_213 = 0;
  uint32 src_rowsize, dst_rowsize;
  uint32 var_213, src_offset;
  uint32 var_214, var_214, var_213 = 0, var_212 = 0;
  uint32 var_210 = 0, var_210 = 0;
  uint32 var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0;
  tsample_t s;
  unsigned char *src = var_210[0];
  unsigned char *dst = var_210;
  char action[8];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateTileSamples24bits","Invalid input or output buffer");
    return 1;
    }

  src_rowsize = ((var_214 * var_199) + 7) / 8;
  dst_rowsize = ((var_183 * var_214 * var_214) + 7) / 8;
  var_210 = (uint32)-1 >> ( 32 - var_214);

  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    var_213 = 0;
    var_213 = var_213 = 0;
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {

      var_213 = var_214 * var_214;
      var_213 = var_213 / 8;
      var_212 = var_213 % 8;

      var_210 = var_210 << (32 - var_212 - var_214);
      for (s = 0; (s < var_214) && (s < 8); s++)
        {
 src = var_210[s] + src_offset + var_213;
        if (var_213)
   var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
        else
   var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
 var_213 = (var_213 & var_210) << (var_212);


 if (var_213 >= 16)
   {
     var_214 = (var_213 >> 24);
     *dst++ = var_214;
     var_214 = (var_213 >> 16);
     *dst++ = var_214;
     var_213 -= 16;


     var_213 = ((var_213 << 16) | (var_213 >> var_213));
     strcpy (action, "Flush");
   }
 else
   {
     var_214 = var_214 = 0;
     var_213 = (var_213 | (var_213 >> var_213));
     strcpy (action, "Update");
   }
 var_213 += var_214;

 if ((dumpfile != NULL) && (var_183 == 3))
   {
   dump_info (dumpfile, var_183, "",
         "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         var_214 + 1, var_214 + 1, s, var_213, var_212, dst - var_210);
   dump_long (dumpfile, var_183, "Match bits ", var_210);
   dump_data (dumpfile, var_183, "Src   bits ", src, 4);
   dump_long (dumpfile, var_183, "Buff1 bits ", var_213);
   dump_long (dumpfile, var_183, "Buff2 bits ", var_213);
   dump_byte (dumpfile, var_183, "Write bits1", var_214);
   dump_byte (dumpfile, var_183, "Write bits2", var_214);
   dump_info (dumpfile, var_183, "","Ready bits:   %d, %s", var_213, action);
   }
 }
      }


    while (var_213 > 0)
      {
 var_214 = (var_213 >> 24);
 *dst++ = var_214;

 var_213 = (var_213 << 8);
 var_214 = var_214;
 var_213 -= 8;
      }

    if ((dumpfile != NULL) && (var_183 == 3))
      {
      dump_info (dumpfile, var_183, "",
     "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
     var_214 + 1, var_214 + 1, var_213, var_212, dst - var_210);

      dump_long (dumpfile, var_183, "Match bits ", var_210);
      dump_data (dumpfile, var_183, "Src   bits ", src, 4);
      dump_long (dumpfile, var_183, "Buff1 bits ", var_213);
      dump_long (dumpfile, var_183, "Buff2 bits ", var_213);
      dump_byte (dumpfile, var_183, "Write bits1", var_214);
      dump_byte (dumpfile, var_183, "Write bits2", var_214);
      dump_info (dumpfile, var_183, "", "Ready bits:  %2d", var_213);
      }

    if ((dumpfile != NULL) && (var_183 == 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateTileSamples24bits","Output data");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210 + (var_214 * dst_rowsize));
      }
    }

  return 0;
  }

static int
fn_183 (uint8 *var_210[], uint8 *var_210, uint32 var_183,
                                  uint32 var_183, uint32 var_183,
                                  uint32 var_199, uint16 var_214, uint16 var_214,
                            FILE *dumpfile, int var_183, int var_183)
  {
  int var_213 = 0 ;
  uint32 src_rowsize, dst_rowsize, var_213, src_offset;
  uint32 var_213 = 0, var_212 = 0;
  uint32 var_214, var_214;
  uint32 var_213 = 0, var_213 = 0;
  uint64 var_210 = 0, var_210 = 0;
  uint64 var_213 = 0, var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0, var_214 = 0, var_214 = 0;
  tsample_t s;
  unsigned char *src = var_210[0];
  unsigned char *dst = var_210;
  char action[8];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("combineSeparateTileSamples32bits","Invalid input or output buffer");
    return 1;
    }

  src_rowsize = ((var_214 * var_199) + 7) / 8;
  dst_rowsize = ((var_183 * var_214 * var_214) + 7) / 8;
  var_210 = (uint64)-1 >> ( 64 - var_214);


  for (var_214 = 0; var_214 < var_183; var_214++)
    {
    var_213 = 0;
    var_213 = var_213 = 0;
    dst = var_210 + (var_214 * dst_rowsize);
    src_offset = var_214 * src_rowsize;
    for (var_214 = 0; var_214 < var_183; var_214++)
      {

      var_213 = var_214 * var_214;
      var_213 = var_213 / 8;
      var_212 = var_213 % 8;

      var_210 = var_210 << (64 - var_212 - var_214);
      for (s = 0; (s < var_214) && (s < 8); s++)
 {
 src = var_210[s] + src_offset + var_213;
 if (var_213)
   {
   var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
   var_213 = var_213;
   }
 else
   {
   var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
          var_213 = var_213;
   }

 var_213 = ((uint64)var_213 << 32) | var_213;
 var_213 = (var_213 & var_210) << (var_212);


 if (var_213 >= 32)
   {
   var_214 = (var_213 >> 56);
   *dst++ = var_214;
   var_214 = (var_213 >> 48);
   *dst++ = var_214;
   var_214 = (var_213 >> 40);
   *dst++ = var_214;
   var_214 = (var_213 >> 32);
   *dst++ = var_214;
   var_213 -= 32;


   var_213 = ((var_213 << 32) | (var_213 >> var_213));
   strcpy (action, "Flush");
   }
 else
   {
   var_214 = var_214 = var_214 = var_214 = 0;
   var_213 = (var_213 | (var_213 >> var_213));
   strcpy (action, "Update");
   }
 var_213 += var_214;

 if ((dumpfile != NULL) && (var_183 == 3))
   {
   dump_info (dumpfile, var_183, "",
       "Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
       var_214 + 1, var_214 + 1, s, var_213, var_212, dst - var_210);
   dump_wide (dumpfile, var_183, "Match bits ", var_210);
   dump_data (dumpfile, var_183, "Src   bits ", src, 8);
   dump_wide (dumpfile, var_183, "Buff1 bits ", var_213);
   dump_wide (dumpfile, var_183, "Buff2 bits ", var_213);
   dump_info (dumpfile, var_183, "", "Ready bits:   %d, %s", var_213, action);
   }
 }
      }
    while (var_213 > 0)
      {
      var_214 = (var_213 >> 56);
      *dst++ = var_214;
      var_213 = (var_213 << 8);
      var_213 -= 8;
      }

    if ((dumpfile != NULL) && (var_183 == 3))
      {
      dump_info (dumpfile, var_183, "",
          "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
   var_214 + 1, var_214 + 1, var_213, var_212, dst - var_210);

      dump_long (dumpfile, var_183, "Match bits ", var_210);
      dump_data (dumpfile, var_183, "Src   bits ", src, 4);
      dump_long (dumpfile, var_183, "Buff1 bits ", var_213);
      dump_long (dumpfile, var_183, "Buff2 bits ", var_213);
      dump_byte (dumpfile, var_183, "Write bits1", var_214);
      dump_byte (dumpfile, var_183, "Write bits2", var_214);
      dump_info (dumpfile, var_183, "", "Ready bits:  %2d", var_213);
      }

    if ((dumpfile != NULL) && (var_183 == 2))
      {
      dump_info (dumpfile, var_183, "combineSeparateTileSamples32bits","Output data");
      dump_buffer(dumpfile, var_183, 1, dst_rowsize, var_214, var_210);
      }
    }

  return 0;
  }


static int fn_183 (TIFF *var_210, uint8 *var_186, uint32 var_214,
                                         uint32 var_214, uint16 var_214,
                                         struct struct_209 *dump)
  {
  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, var_186 = 1;
  int32 var_186 = 0;
  uint16 var_214, var_199, var_199, strips_per_sample;
  uint32 src_rowsize, dst_rowsize, rows_processed, var_186;
  uint32 var_186 = 0;
  tsample_t s;
  tstrip_t var_186;
  tsize_t var_199 = TIFFScanlineSize(var_210);
  tsize_t var_186 = TIFFStripSize(var_210);
  unsigned char *srcbuffs[8];
  unsigned char *buff = NULL;
  unsigned char *dst = NULL;

  if (var_186 == NULL)
    {
    TIFFError("readSeparateStripsIntoBuffer","Invalid buffer argument");
    return 0;
    }

  memset (srcbuffs, '\0', sizeof(srcbuffs));
  TIFFGetField(var_210, TIFFTAG_BITSPERSAMPLE, &var_214);
  TIFFGetFieldDefaulted(var_210, TIFFTAG_PLANARCONFIG, &var_199);
  TIFFGetFieldDefaulted(var_210, TIFFTAG_ROWSPERSTRIP, &var_186);
  if (var_186 > var_214)
    var_186 = var_214;

  bytes_per_sample = (var_214 + 7) / 8;
  bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
  if (bytes_per_pixel < (bytes_per_sample + 1))
    shift_width = bytes_per_pixel;
  else
    shift_width = bytes_per_sample + 1;

  src_rowsize = ((var_214 * var_214) + 7) / 8;
  dst_rowsize = ((var_214 * var_214 * var_214) + 7) / 8;
  dst = var_186;

  if ((dump->infile != NULL) && (dump->level == 3))
    {
    dump_info (dump->infile, dump->format, "",
                "Image width %d, length %d, Scanline size, %4d bytes",
                var_214, var_214, var_199);
    dump_info (dump->infile, dump->format, "",
                "Bits per sample %d, Samples per pixel %d, Shift width %d",
  var_214, var_214, shift_width);
    }






  var_199 = TIFFNumberOfStrips(var_210);
  strips_per_sample = var_199 /var_214;

  for (s = 0; (s < var_214) && (s < 8); s++)
    {
    srcbuffs[s] = NULL;
    buff = _TIFFmalloc(var_186);
    if (!buff)
      {
      TIFFError ("readSeparateStripsIntoBuffer",
                 "Unable to allocate strip read buffer for sample %d", s);
      for (i = 0; i < s; i++)
        _TIFFfree (srcbuffs[i]);
      return 0;
      }
    srcbuffs[s] = buff;
    }

  rows_processed = 0;
  for (j = 0; (j < strips_per_sample) && (var_186 == 1); j++)
    {
    for (s = 0; (s < var_214) && (s < 8); s++)
      {
      buff = srcbuffs[s];
      var_186 = (s * strips_per_sample) + j;
      var_186 = TIFFReadEncodedStrip (var_210, var_186, buff, var_186);
      var_186 = var_186 / src_rowsize;
      if (var_186 < 0 && !var_186)
        {
        TIFFError(TIFFFileName(var_210),
           "Error, can't read strip %lu for sample %d",
             (unsigned long) var_186, s + 1);
        var_186 = 0;
        break;
        }




      }

    if (var_186 > var_186)
      var_186 = var_186;
    dst = var_186 + (dst_rowsize * rows_processed);
    if ((var_214 % 8) == 0)
      {
      if (combineSeparateSamplesBytes (srcbuffs, dst, var_214, var_186,
                                       var_214, var_214, dump->infile,
                                       dump->format, dump->level))
        {
        var_186 = 0;
        break;
 }
      }
    else
      {
      switch (shift_width)
        {
        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, var_214, var_186,
                                                 var_214, var_214, dump->infile,
                                                 dump->format, dump->level))
           {
                  var_186 = 0;
                  break;
                 }
         break;
        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, var_214, var_186,
                                                  var_214, var_214, dump->infile,
                                                  dump->format, dump->level))
           {
                  var_186 = 0;
                  break;
    }
         break;
        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, var_214, var_186,
                                                  var_214, var_214, dump->infile,
                                                  dump->format, dump->level))
           {
                  var_186 = 0;
                  break;
                  }
                break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, var_214, var_186,
                                                  var_214, var_214, dump->infile,
                                                  dump->format, dump->level))
           {
                  var_186 = 0;
                  break;
    }
         break;
        default: TIFFError ("readSeparateStripsIntoBuffer", "Unsupported bit depth: %d", var_214);
                  var_186 = 0;
                  break;
        }
      }

    if ((rows_processed + var_186) > var_214)
      {
      rows_processed = var_214;
      var_186 = var_214 - rows_processed;
      }
    else
      rows_processed += var_186;
    }




  for (s = 0; (s < var_214) && (s < 8); s++)
    {
    buff = srcbuffs[s];
    if (buff != NULL)
      _TIFFfree(buff);
    }

  return (var_186);
  }

static int
fn_186 (char *name, struct struct_202 *page)
    {
    char *ptr;
    int n;

    for (ptr = name; *ptr; ptr++)
      *ptr = (char)tolower((int)*ptr);

    for (n = 0; n < 49; n++)
      {
      if (strcmp(name, PaperTable[n].name) == 0)
        {
 page->width = PaperTable[n].width;
 page->length = PaperTable[n].length;
        strncpy (page->name, PaperTable[n].name, 15);
        page->name[15] = '\0';
        return 0;
        }
      }

  return 1;
  }


static void
fn_186 (struct struct_202 *page, struct struct_202 *pagelist,
               struct struct_208 seg_buffs[])
   {
   int i;

   strcpy (page->name, "");
   page->mode = 0;
   page->res_unit = RESUNIT_NONE;
   page->hres = 0.0;
   page->vres = 0.0;
   page->width = 0.0;
   page->length = 0.0;
   page->hmargin = 0.0;
   page->vmargin = 0.0;
   page->rows = 0;
   page->cols = 0;
   page->orient = 0;

   for (i = 0; i < 32; i++)
     {
     pagelist[i].x1 = (uint32)0;
     pagelist[i].x2 = (uint32)0;
     pagelist[i].y1 = (uint32)0;
     pagelist[i].y2 = (uint32)0;
     pagelist[i].buffsize = (uint32)0;
     pagelist[i].position = 0;
     pagelist[i].total = 0;
     }

   for (i = 0; i < 8; i++)
     {
     seg_buffs[i].size = 0;
     seg_buffs[i].buffer = NULL;
     }
   }

static void
fn_186 (struct struct_210 *image)
  {
  image->xres = 0.0;
  image->yres = 0.0;
  image->width = 0;
  image->length = 0;
  image->res_unit = RESUNIT_NONE;
  image->bps = 0;
  image->spp = 0;
  image->planar = 0;
  image->photometric = 0;
  image->orientation = 0;
  image->compression = COMPRESSION_NONE;
  image->adjustments = 0;
  }

static void
fn_186 (struct struct_209 *cps)
   {
   int i;

   cps->crop_mode = 0;
   cps->res_unit = RESUNIT_NONE;
   cps->edge_ref = 1;
   cps->width = 0;
   cps->length = 0;
   for (i = 0; i < 4; i++)
     cps->margins[i] = 0.0;
   cps->bufftotal = (uint32)0;
   cps->combined_width = (uint32)0;
   cps->combined_length = (uint32)0;
   cps->rotation = (uint16)0;
   cps->photometric = 11;
   cps->mirror = (uint16)0;
   cps->invert = (uint16)0;
   cps->zones = (uint32)0;
   cps->regions = (uint32)0;
   for (i = 0; i < 8; i++)
     {
     cps->corners[i].X1 = 0.0;
     cps->corners[i].X2 = 0.0;
     cps->corners[i].Y1 = 0.0;
     cps->corners[i].Y2 = 0.0;
     cps->regionlist[i].x1 = 0;
     cps->regionlist[i].x2 = 0;
     cps->regionlist[i].y1 = 0;
     cps->regionlist[i].y2 = 0;
     cps->regionlist[i].width = 0;
     cps->regionlist[i].length = 0;
     cps->regionlist[i].buffsize = 0;
     cps->regionlist[i].buffptr = NULL;
     cps->zonelist[i].position = 0;
     cps->zonelist[i].total = 0;
     }
   cps->exp_mode = 0;
   cps->img_mode = 0;
   }

static void fn_186(struct struct_209 *dump)
  {
  dump->debug = 0;
  dump->format = 0;
  dump->level = 1;
  sprintf (dump->mode, "w");
  memset (dump->infilename, '\0', 1025);
  memset (dump->outfilename, '\0',1025);
  dump->infile = NULL;
  dump->outfile = NULL;
  }


static int
fn_186(struct struct_209 *crop, struct struct_210 *image,
                         struct struct_190 *off)
  {
  double scale;
  float var_199, var_199;


  uint32 tmargin, bmargin, lmargin, rmargin;
  uint32 startx, endx;
  uint32 starty, endy;
  uint32 var_214, var_214, crop_width, crop_length;
  uint32 i, max_width, max_length, zwidth, zlength, var_210;
  uint32 x1, x2, y1, y2;

  if (image->res_unit != RESUNIT_INCH && image->res_unit != RESUNIT_CENTIMETER)
    {
    var_199 = 1.0;
    var_199 = 1.0;
    }
  else
    {
    if (((image->xres == 0) || (image->yres == 0)) &&
         (crop->res_unit != RESUNIT_NONE) &&
 ((crop->crop_mode & 16) || (crop->crop_mode & 1) ||
   (crop->crop_mode & 4) || (crop->crop_mode & 2)))
      {
      TIFFError("computeInputPixelOffsets", "Cannot compute margins or fixed size sections without image resolution");
      TIFFError("computeInputPixelOffsets", "Specify units in pixels and try again");
      return -1;
      }
    var_199 = image->xres;
    var_199 = image->yres;
    }


  scale = 1.0;
  switch (crop->res_unit) {
    case RESUNIT_CENTIMETER:
         if (image->res_unit == RESUNIT_INCH)
    scale = 1.0/2.54;
  break;
    case RESUNIT_INCH:
  if (image->res_unit == RESUNIT_CENTIMETER)
      scale = 2.54;
  break;
    case RESUNIT_NONE:
    default:
    break;
    }

  if (crop->crop_mode & 16)
    {
    max_width = max_length = 0;
    for (i = 0; i < crop->regions; i++)
      {
      if ((crop->res_unit == RESUNIT_INCH) || (crop->res_unit == RESUNIT_CENTIMETER))
        {
 x1 = (uint32) (crop->corners[i].X1 * scale * var_199);
 x2 = (uint32) (crop->corners[i].X2 * scale * var_199);
 y1 = (uint32) (crop->corners[i].Y1 * scale * var_199);
 y2 = (uint32) (crop->corners[i].Y2 * scale * var_199);
        }
      else
        {
 x1 = (uint32) (crop->corners[i].X1);
 x2 = (uint32) (crop->corners[i].X2);
 y1 = (uint32) (crop->corners[i].Y1);
 y2 = (uint32) (crop->corners[i].Y2);
 }
      if (x1 < 1)
        crop->regionlist[i].x1 = 0;
      else
        crop->regionlist[i].x1 = (uint32) (x1 - 1);

      if (x2 > image->width - 1)
        crop->regionlist[i].x2 = image->width - 1;
      else
        crop->regionlist[i].x2 = (uint32) (x2 - 1);
      zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;

      if (y1 < 1)
        crop->regionlist[i].y1 = 0;
      else
        crop->regionlist[i].y1 = (uint32) (y1 - 1);

      if (y2 > image->length - 1)
        crop->regionlist[i].y2 = image->length - 1;
      else
        crop->regionlist[i].y2 = (uint32) (y2 - 1);

      zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;

      if (zwidth > max_width)
        max_width = zwidth;
      if (zlength > max_length)
        max_length = zlength;

      var_210 = (uint32)
          (((zwidth * image->bps * image->spp + 7 ) / 8) * (zlength + 1));

      crop->regionlist[i].buffsize = var_210;
      crop->bufftotal += var_210;
      if (crop->img_mode == 0)
        {
        switch (crop->edge_ref)
          {
          case 2:
          case 4:
               crop->combined_length = zlength;
               crop->combined_width += zwidth;
               break;
          case 3:
          case 1:
          default:
               crop->combined_width = zwidth;
               crop->combined_length += zlength;
        break;
          }
 }
      }
    return 0;
    }




  if (crop->crop_mode & 1)
    {
    if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)
      {
      tmargin = (uint32)(crop->margins[0]);
      lmargin = (uint32)(crop->margins[1]);
      bmargin = (uint32)(crop->margins[2]);
      rmargin = (uint32)(crop->margins[3]);
      }
    else
      {
      tmargin = (uint32)(crop->margins[0] * scale * var_199);
      lmargin = (uint32)(crop->margins[1] * scale * var_199);
      bmargin = (uint32)(crop->margins[2] * scale * var_199);
      rmargin = (uint32)(crop->margins[3] * scale * var_199);
      }

    if ((lmargin + rmargin) > image->width)
      {
      TIFFError("computeInputPixelOffsets", "Combined left and right margins exceed image width");
      lmargin = (uint32) 0;
      rmargin = (uint32) 0;
      return -1;
      }
    if ((tmargin + bmargin) > image->length)
      {
      TIFFError("computeInputPixelOffsets", "Combined top and bottom margins exceed image length");
      tmargin = (uint32) 0;
      bmargin = (uint32) 0;
      return -1;
      }
    }
  else
    {
    tmargin = (uint32) 0;
    lmargin = (uint32) 0;
    bmargin = (uint32) 0;
    rmargin = (uint32) 0;
    }


  if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)
    {
    if (crop->crop_mode & 2)
      var_214 = (uint32)crop->width;
    else
      var_214 = image->width - lmargin - rmargin;

    if (crop->crop_mode & 4)
      var_214 = (uint32)crop->length;
    else
      var_214 = image->length - tmargin - bmargin;
    }
  else
    {
    if (crop->crop_mode & 2)
      var_214 = (uint32)(crop->width * scale * image->xres);
    else
      var_214 = image->width - lmargin - rmargin;

    if (crop->crop_mode & 4)
      var_214 = (uint32)(crop->length * scale * image->yres);
    else
      var_214 = image->length - tmargin - bmargin;
    }

  off->tmargin = tmargin;
  off->bmargin = bmargin;
  off->lmargin = lmargin;
  off->rmargin = rmargin;




  switch (crop->edge_ref) {
    case 3:
         startx = lmargin;
         if ((startx + var_214) >= (image->width - rmargin))
           endx = image->width - rmargin - 1;
         else
           endx = startx + var_214 - 1;

         endy = image->length - bmargin - 1;
         if ((endy - var_214) <= tmargin)
           starty = tmargin;
         else
           starty = endy - var_214 + 1;
         break;
    case 4:
         endx = image->width - rmargin - 1;
         if ((endx - var_214) <= lmargin)
           startx = lmargin;
         else
           startx = endx - var_214 + 1;

         starty = tmargin;
         if ((starty + var_214) >= (image->length - bmargin))
           endy = image->length - bmargin - 1;
         else
           endy = starty + var_214 - 1;
         break;
    case 1:
    case 2:
    default:
         startx = lmargin;
         if ((startx + var_214) >= (image->width - rmargin))
           endx = image->width - rmargin - 1;
         else
           endx = startx + var_214 - 1;

         starty = tmargin;
         if ((starty + var_214) >= (image->length - bmargin))
           endy = image->length - bmargin - 1;
         else
           endy = starty + var_214 - 1;
         break;
    }
  off->startx = startx;
  off->starty = starty;
  off->endx = endx;
  off->endy = endy;

  crop_width = endx - startx + 1;
  crop_length = endy - starty + 1;

  if (crop_width <= 0)
    {
    TIFFError("computeInputPixelOffsets",
               "Invalid left/right margins and /or image crop width requested");
    return -1;
    }
  if (crop_width > image->width)
    crop_width = image->width;

  if (crop_length <= 0)
    {
    TIFFError("computeInputPixelOffsets",
              "Invalid top/bottom margins and /or image crop length requested");
    return -1;
    }
  if (crop_length > image->length)
    crop_length = image->length;

  off->crop_width = crop_width;
  off->crop_length = crop_length;

  return 0;
  }

static int
fn_189(struct struct_210 *image, struct struct_209 *crop, struct struct_209 *dump)
  {
  struct struct_190 offsets;
  int i;
  int32 test;
  uint32 seg, total, var_190 = 0;
  uint32 var_210;
  uint32 zwidth, zlength;

  memset(&offsets, '\0', sizeof(struct struct_190));
  crop->bufftotal = 0;
  crop->combined_width = (uint32)0;
  crop->combined_length = (uint32)0;
  crop->selections = 0;


  if ((crop->crop_mode & 1) ||
      (crop->crop_mode & 16) ||
      (crop->crop_mode & 4) ||
      (crop->crop_mode & 2))
    {
    if (computeInputPixelOffsets(crop, image, &offsets))
      {
      TIFFError ("getCropOffsets", "Unable to compute crop margins");
      return -1;
      }
    var_190 = 1;
    crop->selections = crop->regions;

    if (crop->crop_mode & 16)
      return 0;
    }
  else
    {
    offsets.tmargin = 0;
    offsets.lmargin = 0;
    offsets.bmargin = 0;
    offsets.rmargin = 0;
    offsets.crop_width = image->width;
    offsets.crop_length = image->length;
    offsets.startx = 0;
    offsets.endx = image->width - 1;
    offsets.starty = 0;
    offsets.endy = image->length - 1;
    var_190 = 0;
    }

  if (dump->outfile != NULL)
    {
    dump_info (dump->outfile, dump->format, "", "Margins: Top: %d  Left: %d  Bottom: %d  Right: %d",
           offsets.tmargin, offsets.lmargin, offsets.bmargin, offsets.rmargin);
    dump_info (dump->outfile, dump->format, "", "Crop region within margins: Adjusted Width:  %6d  Length: %6d",
           offsets.crop_width, offsets.crop_length);
    }

  if (!(crop->crop_mode & 8))
    {
    if (var_190 == 0)
      {
      crop->selections = 0;
      crop->combined_width = image->width;
      crop->combined_length = image->length;
      return 0;
      }
    else
      {



      crop->selections = 1;
      crop->zones = 1;
      crop->zonelist[0].total = 1;
      crop->zonelist[0].position = 1;
      }
    }
  else
    crop->selections = crop->zones;

  for (i = 0; i < crop->zones; i++)
    {
    seg = crop->zonelist[i].position;
    total = crop->zonelist[i].total;

    switch (crop->edge_ref)
      {
      case 2:
           zlength = offsets.crop_length;
    crop->regionlist[i].y1 = offsets.starty;
           crop->regionlist[i].y2 = offsets.endy;

           crop->regionlist[i].x1 = offsets.startx +
                                  (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);
           test = (int32)offsets.startx +
                  (int32)(offsets.crop_width * 1.0 * seg / total);
           if (test < 1 )
             crop->regionlist[i].x2 = 0;
           else
      {
      if (test > (int32)(image->width - 1))
               crop->regionlist[i].x2 = image->width - 1;
             else
        crop->regionlist[i].x2 = test - 1;
             }
           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;


           crop->combined_length = (uint32)zlength;
           if (crop->exp_mode == 0)
             crop->combined_width += (uint32)zwidth;
           else
             crop->combined_width = (uint32)zwidth;
           break;
      case 3:
           zwidth = offsets.crop_width;
    crop->regionlist[i].x1 = offsets.startx;
           crop->regionlist[i].x2 = offsets.endx;

           test = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);
           if (test < 1 )
      crop->regionlist[i].y1 = 0;
           else
      crop->regionlist[i].y1 = test + 1;

           test = offsets.endy - (offsets.crop_length * 1.0 * (seg - 1) / total);
           if (test < 1 )
             crop->regionlist[i].y2 = 0;
           else
      {
             if (test > (int32)(image->length - 1))
               crop->regionlist[i].y2 = image->length - 1;
             else
               crop->regionlist[i].y2 = test;
      }
           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;


           if (crop->exp_mode == 0)
             crop->combined_length += (uint32)zlength;
           else
             crop->combined_length = (uint32)zlength;
           crop->combined_width = (uint32)zwidth;
           break;
      case 4:
           zlength = offsets.crop_length;
    crop->regionlist[i].y1 = offsets.starty;
           crop->regionlist[i].y2 = offsets.endy;

           crop->regionlist[i].x1 = offsets.startx +
                                  (uint32)(offsets.crop_width * (total - seg) * 1.0 / total);
           test = offsets.startx +
           (offsets.crop_width * (total - seg + 1) * 1.0 / total);
           if (test < 1 )
             crop->regionlist[i].x2 = 0;
           else
      {
      if (test > (int32)(image->width - 1))
               crop->regionlist[i].x2 = image->width - 1;
             else
               crop->regionlist[i].x2 = test - 1;
             }
           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;


           crop->combined_length = (uint32)zlength;
           if (crop->exp_mode == 0)
             crop->combined_width += (uint32)zwidth;
           else
             crop->combined_width = (uint32)zwidth;
           break;
      case 1:
      default:
           zwidth = offsets.crop_width;
    crop->regionlist[i].x1 = offsets.startx;
           crop->regionlist[i].x2 = offsets.endx;

           crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);
           test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);
           if (test < 1 )
             crop->regionlist[i].y2 = 0;
           else
      {
      if (test > (int32)(image->length - 1))
        crop->regionlist[i].y2 = image->length - 1;
             else
        crop->regionlist[i].y2 = test - 1;
      }
           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;


           if (crop->exp_mode == 0)
             crop->combined_length += (uint32)zlength;
           else
             crop->combined_length = (uint32)zlength;
           crop->combined_width = (uint32)zwidth;
           break;
      }

    var_210 = (uint32)
          ((((zwidth * image->bps * image->spp) + 7 ) / 8) * (zlength + 1));
    crop->regionlist[i].width = (uint32) zwidth;
    crop->regionlist[i].length = (uint32) zlength;
    crop->regionlist[i].buffsize = var_210;
    crop->bufftotal += var_210;


  if (dump->outfile != NULL)
    dump_info (dump->outfile, dump->format, "", "Zone %d, width: %4d, length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d",
                    i + 1, (uint32)zwidth, (uint32)zlength,
      crop->regionlist[i].x1, crop->regionlist[i].x2,
                    crop->regionlist[i].y1, crop->regionlist[i].y2);
    }

  return 0;
  }


static int
fn_190 (struct struct_209 *crop, struct struct_210 *image,
                           struct struct_202 *page, struct struct_202 *sections,
                           struct struct_209* dump)
  {
  double scale;
  double pwidth, plength;
  uint32 iwidth, ilength;
  uint32 owidth, olength;
  uint32 orows, ocols;
  uint32 hmargin, vmargin;
  uint32 x1, x2, y1, y2, line_bytes;

  uint32 i, j, k;

  scale = 1.0;
  if (page->res_unit == RESUNIT_NONE)
    page->res_unit = image->res_unit;

  switch (image->res_unit) {
    case RESUNIT_CENTIMETER:
         if (page->res_unit == RESUNIT_INCH)
    scale = 1.0/2.54;
  break;
    case RESUNIT_INCH:
  if (page->res_unit == RESUNIT_CENTIMETER)
      scale = 2.54;
  break;
    case RESUNIT_NONE:
    default:
    break;
    }


  if (crop->combined_width > 0)
    iwidth = crop->combined_width;
  else
    iwidth = image->width;
  if (crop->combined_length > 0)
    ilength = crop->combined_length;
  else
    ilength = image->length;

  if (page->hres <= 1.0)
    page->hres = image->xres;
  if (page->vres <= 1.0)
    page->vres = image->yres;

  if ((page->hres < 1.0) || (page->vres < 1.0))
    {
    TIFFError("computeOutputPixelOffsets",
    "Invalid horizontal or vertical resolution specified or read from input image");
    return 1;
    }




  if (page->width <= 0)
    pwidth = iwidth;
  else
    pwidth = page->width;

  if (page->length <= 0)
    plength = ilength;
  else
    plength = page->length;

  if (dump->debug)
    {
    TIFFError("", "Page size: %s, Vres: %3.2f, Hres: %3.2f, "
                   "Hmargin: %3.2f, Vmargin: %3.2f",
      page->name, page->vres, page->hres,
             page->hmargin, page->vmargin);
    TIFFError("", "Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f",
           page->res_unit, scale, pwidth, plength);
    }


  if (page->mode & 4)
    {
    if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER)
      {
      hmargin = (uint32)(page->hmargin * scale * page->hres * ((image->bps + 7)/ 8));
      vmargin = (uint32)(page->vmargin * scale * page->vres * ((image->bps + 7)/ 8));
      }
    else
      {
      hmargin = (uint32)(page->hmargin * scale * ((image->bps + 7)/ 8));
      vmargin = (uint32)(page->vmargin * scale * ((image->bps + 7)/ 8));
      }

    if ((hmargin * 2.0) > (pwidth * page->hres))
      {
      TIFFError("computeOutputPixelOffsets",
                "Combined left and right margins exceed page width");
      hmargin = (uint32) 0;
      return -1;
      }
    if ((vmargin * 2.0) > (plength * page->vres))
      {
      TIFFError("computeOutputPixelOffsets",
                "Combined top and bottom margins exceed page length");
      vmargin = (uint32) 0;
      return -1;
      }
    }
  else
    {
    hmargin = 0;
    vmargin = 0;
    }

  if (page->mode & 8 )
    {

    if (page->mode & 4)
      TIFFError("computeOutputPixelOffsets",
      "Output margins cannot be specified with rows and columns");

    owidth = ((((uint32)(iwidth))+(((uint32)(page->cols))-1))/((uint32)(page->cols)));
    olength = ((((uint32)(ilength))+(((uint32)(page->rows))-1))/((uint32)(page->rows)));
    }
  else
    {
    if (page->mode & 2 )
      {
      owidth = (uint32)((pwidth * page->hres) - (hmargin * 2));
      olength = (uint32)((plength * page->vres) - (vmargin * 2));
      }
    else
      {
      owidth = (uint32)(iwidth - (hmargin * 2 * page->hres));
      olength = (uint32)(ilength - (vmargin * 2 * page->vres));
      }
    }

  if (owidth > iwidth)
    owidth = iwidth;
  if (olength > ilength)
    olength = ilength;


  switch (page->orient)
    {
    case 0:
    case 1:
         ocols = ((((uint32)(iwidth))+(((uint32)(owidth))-1))/((uint32)(owidth)));
         orows = ((((uint32)(ilength))+(((uint32)(olength))-1))/((uint32)(olength)));

         break;

    case 2:
         ocols = ((((uint32)(iwidth))+(((uint32)(olength))-1))/((uint32)(olength)));
         orows = ((((uint32)(ilength))+(((uint32)(owidth))-1))/((uint32)(owidth)));
         x1 = olength;
         olength = owidth;
         owidth = x1;

         break;

    case 16:
    default:
         x1 = ((((uint32)(iwidth))+(((uint32)(owidth))-1))/((uint32)(owidth)));
         x2 = ((((uint32)(ilength))+(((uint32)(olength))-1))/((uint32)(olength)));
         y1 = ((((uint32)(iwidth))+(((uint32)(olength))-1))/((uint32)(olength)));
         y2 = ((((uint32)(ilength))+(((uint32)(owidth))-1))/((uint32)(owidth)));

         if ( (x1 * x2) < (y1 * y2))
           {
           ocols = x1;
           orows = x2;

    }
         else
           {
           ocols = y1;
           orows = y2;
           x1 = olength;
           olength = owidth;
           owidth = x1;

           }
    }

  if (ocols < 1)
    ocols = 1;
  if (orows < 1)
    orows = 1;


  if (page->rows < 1)
    page->rows = orows;
  if (page->cols < 1)
    page->cols = ocols;

  line_bytes = (((owidth * image->bps)&0x07)?((uint32)(owidth * image->bps)>>3)+1:(uint32)(owidth * image->bps)>>3) * image->spp;

  if ((page->rows * page->cols) > 32)
   {
   TIFFError("computeOutputPixelOffsets",
      "Rows and Columns exceed maximum sections\nIncrease resolution or reduce sections");
   return -1;
   }


  for (k = 0, i = 0 && k <= 32; i < orows; i++)
    {
    y1 = (uint32)(olength * i);
    y2 = (uint32)(olength * (i + 1) - 1);
    if (y2 >= ilength)
      y2 = ilength - 1;
    for (j = 0; j < ocols; j++, k++)
      {
      x1 = (uint32)(owidth * j);
      x2 = (uint32)(owidth * (j + 1) - 1);
      if (x2 >= iwidth)
        x2 = iwidth - 1;
      sections[k].x1 = x1;
      sections[k].x2 = x2;
      sections[k].y1 = y1;
      sections[k].y2 = y2;
      sections[k].buffsize = line_bytes * olength;
      sections[k].position = k + 1;
      sections[k].total = orows * ocols;
      }
    }
  return 0;
  }

static int
fn_190(TIFF* var_210, struct struct_210 *image, struct struct_209 *dump, unsigned char **read_ptr)
  {
  uint32 i;
  float var_199 = 0.0, var_199 = 0.0;
  uint32 var_199 = 0, var_199 = 0;
  uint16 var_199 = 0;
  uint16 var_214 = 0, var_214 = 0, var_199 = 0;
  uint16 var_199 = 0;
  uint16 var_210 = 0, var_210 = 0;
  uint16 subsampling_horiz, subsampling_vert;
  uint32 var_214 = 0, var_214 = 0;
  uint32 var_199 = 0, var_199 = 0, var_210 = 0, var_199 = 0;
  uint32 var_199 = 0, var_199 = 0;
  uint32 var_199 = 0;
  unsigned char *read_buff = NULL;
  unsigned char *new_buff = NULL;
  int var_199 = 0;
  static uint32 var_199 = 0;

  TIFFGetFieldDefaulted(var_210, TIFFTAG_BITSPERSAMPLE, &var_214);
  TIFFGetFieldDefaulted(var_210, TIFFTAG_SAMPLESPERPIXEL, &var_214);
  TIFFGetFieldDefaulted(var_210, TIFFTAG_PLANARCONFIG, &var_199);
  TIFFGetFieldDefaulted(var_210, TIFFTAG_ORIENTATION, &var_199);
  if (! TIFFGetFieldDefaulted(var_210, TIFFTAG_PHOTOMETRIC, &var_210))
    TIFFError("loadImage","Image lacks Photometric interpreation tag");
  if (! TIFFGetField(var_210, TIFFTAG_IMAGEWIDTH, &var_214))
    TIFFError("loadimage","Image lacks image width tag");
  if(! TIFFGetField(var_210, TIFFTAG_IMAGELENGTH, &var_214))
    TIFFError("loadimage","Image lacks image length tag");
  TIFFGetFieldDefaulted(var_210, TIFFTAG_XRESOLUTION, &var_199);
  TIFFGetFieldDefaulted(var_210, TIFFTAG_YRESOLUTION, &var_199);
  if (!TIFFGetFieldDefaulted(var_210, TIFFTAG_RESOLUTIONUNIT, &var_199))
    var_199 = RESUNIT_INCH;
  if (!TIFFGetField(var_210, TIFFTAG_COMPRESSION, &var_210))
    var_210 = COMPRESSION_NONE;

  var_199 = TIFFScanlineSize(var_210);
  image->bps = var_214;
  image->spp = var_214;
  image->planar = var_199;
  image->width = var_214;
  image->length = var_214;
  image->xres = var_199;
  image->yres = var_199;
  image->res_unit = var_199;
  image->compression = var_210;
  image->photometric = var_210;

  image->orientation = var_199;
  switch (var_199)
    {
    case 0:
    case ORIENTATION_TOPLEFT:
         image->adjustments = 0;
  break;
    case ORIENTATION_TOPRIGHT:
         image->adjustments = 1;
  break;
    case ORIENTATION_BOTRIGHT:
         image->adjustments = 16;
  break;
    case ORIENTATION_BOTLEFT:
         image->adjustments = 2;
  break;
    case ORIENTATION_LEFTTOP:
         image->adjustments = 10;
  break;
    case ORIENTATION_RIGHTTOP:
         image->adjustments = 8;
  break;
    case ORIENTATION_RIGHTBOT:
         image->adjustments = 34;
  break;
    case ORIENTATION_LEFTBOT:
         image->adjustments = 32;
  break;
    default:
         image->adjustments = 0;
         image->orientation = ORIENTATION_TOPLEFT;
   }

  if ((var_214 == 0) || (var_214 == 0))
    {
    TIFFError("loadImage", "Invalid samples per pixel (%d) or bits per sample (%d)",
        var_214, var_214);
    return -1;
    }

  if (TIFFIsTiled(var_210))
    {
    var_199 = 2;
    var_199 = TIFFTileSize(var_210);
    var_199 = TIFFNumberOfTiles(var_210);
    TIFFGetField(var_210, TIFFTAG_TILEWIDTH, &var_199);
    TIFFGetField(var_210, TIFFTAG_TILELENGTH, &var_199);

    var_199 = TIFFTileRowSize(var_210);
    if (var_199 == 0 || var_199 == 0 || var_199 == 0)
    {
 TIFFError("loadImage", "File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.");
 exit(-1);
    }
    var_210 = var_199 * var_199;
    if (var_199 != (var_210 / var_199))
    {
 TIFFError("loadImage", "Integer overflow when calculating buffer size");
 exit(-1);
    }

    if (var_210 < (uint32)(var_199 * var_199 * var_199))
      {
      var_210 = var_199 * var_199 * var_199;
      if (var_199 != (var_210 / var_199 / var_199))
      {
 TIFFError("loadImage", "Integer overflow when calculating buffer size");
 exit(-1);
      }






      }

    if (dump->infile != NULL)
      dump_info (dump->infile, dump->format, "",
                 "Tilesize: %u, Number of Tiles: %u, Tile row size: %u",
                 var_199, var_199, var_199);
    }
  else
    {
    uint32 buffsize_check;
    var_199 = 1;
    TIFFGetFieldDefaulted(var_210, TIFFTAG_ROWSPERSTRIP, &var_210);
    var_199 = TIFFStripSize(var_210);
    var_199 = TIFFNumberOfStrips(var_210);
    if (var_199 == 0 || var_199 == 0)
    {
 TIFFError("loadImage", "File appears to be striped, but the number of stipes or stripe size is zero.");
 exit(-1);
    }

    var_210 = var_199 * var_199;
    if (var_199 != (var_210 / var_199))
    {
 TIFFError("loadImage", "Integer overflow when calculating buffer size");
 exit(-1);
    }
    buffsize_check = ((var_214 * var_214 * var_214 * var_214) + 7);
    if (var_214 != ((buffsize_check - 7) / var_214 / var_214 / var_214))
    {
 TIFFError("loadImage", "Integer overflow detected.");
 exit(-1);
    }
    if (var_210 < (uint32) (((var_214 * var_214 * var_214 * var_214) + 7) / 8))
      {
      var_210 = ((var_214 * var_214 * var_214 * var_214) + 7) / 8;





      }

    if (dump->infile != NULL)
      dump_info (dump->infile, dump->format, "",
                 "Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u",
   var_199, var_199, var_210, var_199);
    }

  if (var_210 == COMPRESSION_JPEG)
    {
    var_210 = var_210;
    TIFFSetField(var_210, TIFFTAG_JPEGCOLORMODE, var_210);
    }

  else
    {
    if (var_210 == PHOTOMETRIC_YCBCR)
      {
      TIFFGetFieldDefaulted(var_210, TIFFTAG_YCBCRSUBSAMPLING,
              &subsampling_horiz, &subsampling_vert);
      if (subsampling_horiz != 1 || subsampling_vert != 1)
        {
 TIFFError("loadImage",
  "Can't copy/convert subsampled image with subsampling %d horiz %d vert",
                subsampling_horiz, subsampling_vert);
        return -1;
        }
 }
    }

  read_buff = *read_ptr;


  if (!read_buff)
  {
    if( var_210 > 0xFFFFFFFFU - 3 )
    {
        TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
        return -1;
    }
    read_buff = (unsigned char *)_TIFFmalloc(var_210+3);
  }
  else
    {
    if (var_199 < var_210)
    {
      if( var_210 > 0xFFFFFFFFU - 3 )
      {
          TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
          return -1;
      }
      new_buff = _TIFFrealloc(read_buff, var_210+3);
      if (!new_buff)
        {
 free (read_buff);
        read_buff = (unsigned char *)_TIFFmalloc(var_210+3);
        }
      else
        read_buff = new_buff;
      }
    }
  if (!read_buff)
    {
    TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
    return -1;
    }

  read_buff[var_210] = 0;
  read_buff[var_210+1] = 0;
  read_buff[var_210+2] = 0;

  var_199 = var_210;
  *read_ptr = read_buff;





  switch (var_199) {
    case 1:
         if (var_199 == PLANARCONFIG_CONTIG)
           {
      if (!(readContigStripsIntoBuffer(var_210, read_buff)))
      {
      TIFFError("loadImage", "Unable to read contiguous strips into buffer");
      return -1;
             }
           }
         else
           {
    if (!(readSeparateStripsIntoBuffer(var_210, read_buff, var_214, var_214, var_214, dump)))
      {
      TIFFError("loadImage", "Unable to read separate strips into buffer");
      return -1;
             }
           }
         break;

    case 2:
         if (var_199 == PLANARCONFIG_CONTIG)
           {
    if (!(readContigTilesIntoBuffer(var_210, read_buff, var_214, var_214, var_199, var_199, var_214, var_214)))
      {
      TIFFError("loadImage", "Unable to read contiguous tiles into buffer");
      return -1;
             }
           }
         else
           {
    if (!(readSeparateTilesIntoBuffer(var_210, read_buff, var_214, var_214, var_199, var_199, var_214, var_214)))
      {
      TIFFError("loadImage", "Unable to read separate tiles into buffer");
      return -1;
             }
           }
         break;
    default: TIFFError("loadImage", "Unsupported image file format");
          return -1;
          break;
    }
  if ((dump->infile != NULL) && (dump->level == 2))
    {
    dump_info (dump->infile, dump->format, "loadImage",
                "Image width %d, length %d, Raw image data, %4d bytes",
                var_214, var_214, var_210);
    dump_info (dump->infile, dump->format, "",
                "Bits per sample %d, Samples per pixel %d", var_214, var_214);

    for (i = 0; i < var_214; i++)
      dump_buffer(dump->infile, dump->format, 1, var_199,
                  i, read_buff + (i * var_199));
    }
  return 0;
  }

static int fn_199(struct struct_210 *image, unsigned char **work_buff_ptr)
  {
  uint16 var_213, var_210;
  unsigned char *work_buff;

  work_buff = *work_buff_ptr;
  if ((image == NULL) || (work_buff == NULL))
    {
    TIFFError ("correct_orientatin", "Invalid image or buffer pointer");
    return -1;
    }

  if ((image->adjustments & 1) || (image->adjustments & 2))
    {
    var_213 = (uint16)(image->adjustments & 3);
    if (mirrorImage(image->spp, image->bps, var_213,
        image->width, image->length, work_buff))
      {
      TIFFError ("correct_orientation", "Unable to mirror image");
      return -1;
      }
    }

  if (image->adjustments & 56)
    {
    if (image->adjustments & 8)
      var_210 = (uint16) 90;
    else
    if (image->adjustments & 16)
      var_210 = (uint16) 180;
    else
    if (image->adjustments & 32)
      var_210 = (uint16) 270;
    else
      {
      TIFFError ("correct_orientation", "Invalid rotation value: %d",
                  image->adjustments & 56);
      return -1;
      }

    if (rotateImage(var_210, image, &image->width, &image->length, work_buff_ptr))
      {
      TIFFError ("correct_orientation", "Unable to rotate image");
      return -1;
      }
    image->orientation = ORIENTATION_TOPLEFT;
    }

  return 0;
  }



static int
fn_201(struct struct_210 *image, struct struct_209 *crop,
                        unsigned char *read_buff, unsigned char *crop_buff)
  {
  int shift_width, bytes_per_sample, bytes_per_pixel;
  uint32 i, trailing_bits, var_202;
  uint32 var_214, first_row, last_row, var_202, last_col;
  uint32 src_rowsize, dst_rowsize, src_offset, dst_offset;
  uint32 crop_width, crop_length, img_width ;
  uint32 prev_length, prev_width, composite_width;
  uint16 var_214, var_214;
  uint8 *src, *dst;
  tsample_t var_202, var_213 = 0;

  img_width = image->width;

  var_214 = image->bps;
  var_214 = image->spp;
  var_202 = var_214;

  bytes_per_sample = (var_214 + 7) / 8;
  bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
  if ((var_214 % 8) == 0)
    shift_width = 0;
  else
    {
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }
  src = read_buff;
  dst = crop_buff;


  prev_width = prev_length = 0;
  var_202 = trailing_bits = 0;
  composite_width = crop->combined_width;
  crop->combined_width = 0;
  crop->combined_length = 0;

  for (i = 0; i < crop->selections; i++)
    {

    first_row = crop->regionlist[i].y1;
    last_row = crop->regionlist[i].y2;
    var_202 = crop->regionlist[i].x1;
    last_col = crop->regionlist[i].x2;

    crop_width = last_col - var_202 + 1;
    crop_length = last_row - first_row + 1;


    crop->regionlist[i].width = crop_width;
    crop->regionlist[i].length = crop_length;
    crop->regionlist[i].buffptr = crop_buff;

    src_rowsize = ((img_width * var_214 * var_214) + 7) / 8;
    dst_rowsize = (((crop_width * var_214 * var_202) + 7) / 8);

    switch (crop->edge_ref)
      {
      default:
      case 1:
      case 3:
    if ((i > 0) && (crop_width != crop->regionlist[i - 1].width))
             {
      TIFFError ("extractCompositeRegions",
                          "Only equal width regions can be combined for -E top or bottom");
      return 1;
             }

           crop->combined_width = crop_width;
           crop->combined_length += crop_length;

           for (var_214 = first_row; var_214 <= last_row; var_214++)
             {
      src_offset = var_214 * src_rowsize;
      dst_offset = (var_214 - first_row) * dst_rowsize;
             src = read_buff + src_offset;
             dst = crop_buff + dst_offset + (prev_length * dst_rowsize);
             switch (shift_width)
               {
               case 0: if (extractContigSamplesBytes (src, dst, img_width, var_213,
                                                      var_214, var_214, var_202, var_202,
                                                      last_col + 1))
                         {
           TIFFError("extractCompositeRegions",
                                   "Unable to extract row %d", var_214);
           return 1;
           }
         break;
               case 1: if (var_214 == 1)
                         {
                         if (extractContigSamplesShifted8bits (src, dst, img_width,
                                                               var_213, var_214, var_214, var_202,
                                                               var_202, last_col + 1,
                                                               var_202))
                           {
             TIFFError("extractCompositeRegions",
                                     "Unable to extract row %d", var_214);
             return 1;
             }
           break;
    }
                       else
                         if (extractContigSamplesShifted16bits (src, dst, img_width,
                                                                var_213, var_214, var_214, var_202,
                                                                var_202, last_col + 1,
                                                                var_202))
                           {
             TIFFError("extractCompositeRegions",
                                     "Unable to extract row %d", var_214);
             return 1;
             }
          break;
               case 2: if (extractContigSamplesShifted24bits (src, dst, img_width,
                                                               var_213, var_214, var_214, var_202,
                                                               var_202, last_col + 1,
                                                               var_202))
                          {
            TIFFError("extractCompositeRegions",
                                    "Unable to extract row %d", var_214);
            return 1;
            }
          break;
               case 3:
               case 4:
               case 5: if (extractContigSamplesShifted32bits (src, dst, img_width,
                                                               var_213, var_214, var_214, var_202,
                                                               var_202, last_col + 1,
                                                               var_202))
                          {
            TIFFError("extractCompositeRegions",
                                    "Unable to extract row %d", var_214);
            return 1;
            }
          break;
               default: TIFFError("extractCompositeRegions", "Unsupported bit depth %d", var_214);
          return 1;
        }
             }
           prev_length += crop_length;
    break;
      case 2:
      case 4:
    if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))
             {
      TIFFError ("extractCompositeRegions",
                          "Only equal length regions can be combined for -E left or right");
      return 1;
             }
           crop->combined_width += crop_width;
           crop->combined_length = crop_length;
           dst_rowsize = (((composite_width * var_214 * var_202) + 7) / 8);
           trailing_bits = (crop_width * var_214 * var_202) % 8;
           for (var_214 = first_row; var_214 <= last_row; var_214++)
             {
      src_offset = var_214 * src_rowsize;
      dst_offset = (var_214 - first_row) * dst_rowsize;
             src = read_buff + src_offset;
             dst = crop_buff + dst_offset + prev_width;

             switch (shift_width)
               {
               case 0: if (extractContigSamplesBytes (src, dst, img_width,
                                                      var_213, var_214, var_214, var_202,
                                                      var_202, last_col + 1))
                         {
           TIFFError("extractCompositeRegions",
                                   "Unable to extract row %d", var_214);
           return 1;
           }
         break;
               case 1: if (var_214 == 1)
                         {
                         if (extractContigSamplesShifted8bits (src, dst, img_width,
                                                               var_213, var_214, var_214, var_202,
                                                               var_202, last_col + 1,
                                                               var_202))
                           {
             TIFFError("extractCompositeRegions",
                                     "Unable to extract row %d", var_214);
             return 1;
             }
           break;
    }
                       else
                         if (extractContigSamplesShifted16bits (src, dst, img_width,
                                                                var_213, var_214, var_214, var_202,
                                                                var_202, last_col + 1,
                                                                var_202))
                           {
             TIFFError("extractCompositeRegions",
                                     "Unable to extract row %d", var_214);
             return 1;
             }
          break;
              case 2: if (extractContigSamplesShifted24bits (src, dst, img_width,
                                                               var_213, var_214, var_214, var_202,
                                                               var_202, last_col + 1,
                                                               var_202))
                          {
            TIFFError("extractCompositeRegions",
                                    "Unable to extract row %d", var_214);
            return 1;
            }
          break;
               case 3:
               case 4:
               case 5: if (extractContigSamplesShifted32bits (src, dst, img_width,
                                                               var_213, var_214, var_214, var_202,
                                                               var_202, last_col + 1,
                                                               var_202))
                          {
            TIFFError("extractCompositeRegions",
                                    "Unable to extract row %d", var_214);
            return 1;
            }
          break;
               default: TIFFError("extractCompositeRegions", "Unsupported bit depth %d", var_214);
          return 1;
        }
      }
    prev_width += (crop_width * var_214 * var_202) / 8;
           var_202 += trailing_bits;
           if (var_202 > 7)
      var_202-= 8;
    break;
      }
    }
  if (crop->combined_width != composite_width)
    TIFFError("combineSeparateRegions","Combined width does not match composite width");

  return 0;
  }

static int
fn_201(struct struct_210 *image, struct struct_209 *crop,
                      unsigned char *read_buff, unsigned char *crop_buff,
                      int var_202)
  {
  int shift_width, var_202 = 0;
  uint32 bytes_per_sample, bytes_per_pixel;
  uint32 src_rowsize, dst_rowsize;
  uint32 var_214, first_row, last_row, var_202, last_col;
  uint32 src_offset, dst_offset;
  uint32 crop_width, crop_length, img_width ;
  uint16 var_214, var_214;
  uint8 *src, *dst;
  tsample_t var_202, var_213 = 0;

  img_width = image->width;

  var_214 = image->bps;
  var_214 = image->spp;
  var_202 = var_214;

  bytes_per_sample = (var_214 + 7) / 8;
  bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
  if ((var_214 % 8) == 0)
    shift_width = 0;
  else
    {
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }


  first_row = crop->regionlist[var_202].y1;
  last_row = crop->regionlist[var_202].y2;
  var_202 = crop->regionlist[var_202].x1;
  last_col = crop->regionlist[var_202].x2;

  crop_width = last_col - var_202 + 1;
  crop_length = last_row - first_row + 1;

  crop->regionlist[var_202].width = crop_width;
  crop->regionlist[var_202].length = crop_length;
  crop->regionlist[var_202].buffptr = crop_buff;

  src = read_buff;
  dst = crop_buff;
  src_rowsize = ((img_width * var_214 * var_214) + 7) / 8;
  dst_rowsize = (((crop_width * var_214 * var_214) + 7) / 8);

  for (var_214 = first_row; var_214 <= last_row; var_214++)
    {
    src_offset = var_214 * src_rowsize;
    dst_offset = (var_214 - first_row) * dst_rowsize;
    src = read_buff + src_offset;
    dst = crop_buff + dst_offset;

    switch (shift_width)
      {
      case 0: if (extractContigSamplesBytes (src, dst, img_width, var_213,
                                             var_214, var_214, var_202, var_202,
                                             last_col + 1))
                {
         TIFFError("extractSeparateRegion",
                          "Unable to extract row %d", var_214);
         return 1;
         }
       break;
      case 1: if (var_214 == 1)
                {
                if (extractContigSamplesShifted8bits (src, dst, img_width,
                                                      var_213, var_214, var_214, var_202,
                                                      var_202, last_col + 1,
                                                      var_202))
                  {
    TIFFError("extractSeparateRegion",
                            "Unable to extract row %d", var_214);
    return 1;
    }
    break;
  }
              else
                if (extractContigSamplesShifted16bits (src, dst, img_width,
                                                       var_213, var_214, var_214, var_202,
                                                       var_202, last_col + 1,
                                                       var_202))
                  {
    TIFFError("extractSeparateRegion",
                            "Unable to extract row %d", var_214);
    return 1;
    }
       break;
      case 2: if (extractContigSamplesShifted24bits (src, dst, img_width,
                                                     var_213, var_214, var_214, var_202,
                                                     var_202, last_col + 1,
                                                     var_202))
                {
  TIFFError("extractSeparateRegion",
                          "Unable to extract row %d", var_214);
  return 1;
  }
       break;
      case 3:
      case 4:
      case 5: if (extractContigSamplesShifted32bits (src, dst, img_width,
                                                     var_213, var_214, var_214, var_202,
                                                     var_202, last_col + 1,
                                                     var_202))
                {
  TIFFError("extractSeparateRegion",
                          "Unable to extract row %d", var_214);
  return 1;
  }
       break;
      default: TIFFError("extractSeparateRegion", "Unsupported bit depth %d", var_214);
        return 1;
      }
    }

  return 0;
  }

static int
fn_202(struct struct_210 *image, struct struct_202 *section,
                    unsigned char *src_buff, unsigned char *sect_buff)
  {
  unsigned char var_214, var_214;




  uint32 img_width, img_rowsize;



  uint32 j, shift1, shift2, trailing_bits;
  uint32 var_214, first_row, last_row, var_202, last_col;
  uint32 src_offset, dst_offset, row_offset, col_offset;
  uint32 offset1, offset2, full_bytes;
  uint32 sect_width;



  uint16 var_214, var_214;







  img_width = image->width;



  var_214 = image->bps;
  var_214 = image->spp;





  src_offset = 0;
  dst_offset = 0;

  first_row = section->y1;
  last_row = section->y2;
  var_202 = section->x1;
  last_col = section->x2;

  sect_width = last_col - var_202 + 1;



  img_rowsize = ((img_width * var_214 + 7) / 8) * var_214;
  full_bytes = (sect_width * var_214 * var_214) / 8;
  trailing_bits = (sect_width * var_214) % 8;

  if ((var_214 % 8) == 0)
    {
    col_offset = var_202 * var_214 * var_214 / 8;
    for (var_214 = first_row; var_214 <= last_row; var_214++)
      {

      row_offset = var_214 * img_rowsize;
      src_offset = row_offset + col_offset;




      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);
      dst_offset += full_bytes;
      }
    }
  else
    {
    shift1 = var_214 * ((var_202 * var_214) % 8);
    shift2 = var_214 * ((last_col * var_214) % 8);
    for (var_214 = first_row; var_214 <= last_row; var_214++)
      {

      row_offset = var_214 * img_rowsize;
      offset1 = row_offset + (var_202 * var_214 / 8);
      offset2 = row_offset + (last_col * var_214 / 8);

      var_214 = var_214 = 0;
      if (shift1 == 0)
        {
 _TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);

        dst_offset += full_bytes;

        if (trailing_bits != 0)
          {
   var_214 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));
          sect_buff[dst_offset] = var_214;

          dst_offset++;
          }
        }
      else
        {



        for (j = 0; j <= full_bytes; j++)
          {
   var_214 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);
   var_214 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));
          sect_buff[dst_offset + j] = (var_214 << shift1) | (var_214 >> (8 - shift1));
          }

        dst_offset += full_bytes;

        if (trailing_bits != 0)
          {



   if (shift2 > shift1)
            {
     var_214 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));
            var_214 = var_214 & ((unsigned char)255 << shift1);
            sect_buff[dst_offset] = var_214;



            }
          else
            {
     if (shift2 < shift1)
              {
              var_214 = ((unsigned char)255 << (shift1 - shift2 - 1));
       sect_buff[dst_offset] &= var_214;



              }




            }
   }

        dst_offset++;
        }
      }
    }

  return 0;
  }

static int
fn_202(TIFF *var_210, TIFF **var_210, struct struct_209 *crop,
                struct struct_210 *image, struct struct_209 *dump,
                struct struct_208 seg_buffs[], char *mp, char *filename,
                unsigned int *page, unsigned int var_210)
  {
  int i, page_count;
  int var_202 = 0;
  unsigned char *crop_buff = NULL;


  switch (crop->exp_mode)
    {
    case 0:
         var_202 = 0;
         crop_buff = seg_buffs[0].buffer;
         if (update_output_file (var_210, mp, var_202, filename, page))
           return 1;
         page_count = var_210;
         if (writeCroppedImage(var_210, *var_210, image, dump,
                               crop->combined_width,
                               crop->combined_length,
                               crop_buff, *page, var_210))
            {
             TIFFError("writeRegions", "Unable to write new image");
             return -1;
             }
  break;
    case 1:
         var_202 = 0;
         if (update_output_file (var_210, mp, var_202, filename, page))
           return 1;
         page_count = crop->selections * var_210;
         for (i = 0; i < crop->selections; i++)
           {
           crop_buff = seg_buffs[i].buffer;
           if (writeCroppedImage(var_210, *var_210, image, dump,
                                 crop->regionlist[i].width,
                                 crop->regionlist[i].length,
                                 crop_buff, *page, page_count))
             {
             TIFFError("writeRegions", "Unable to write new image");
             return -1;
             }
    }
         break;
    case 2:
         var_202 = 1;
         if (update_output_file (var_210, mp, var_202, filename, page))
           return 1;

         crop_buff = seg_buffs[0].buffer;
         if (writeCroppedImage(var_210, *var_210, image, dump,
                               crop->combined_width,
                               crop->combined_length,
                               crop_buff, *page, var_210))
           {
           TIFFError("writeRegions", "Unable to write new image");
           return -1;
           }
         break;
    case 3:
         var_202 = 1;
         page_count = crop->selections;
         if (update_output_file (var_210, mp, var_202, filename, page))
           return 1;

         for (i = 0; i < crop->selections; i++)
           {
           crop_buff = seg_buffs[i].buffer;

           if (writeCroppedImage(var_210, *var_210, image, dump,
                                 crop->regionlist[i].width,
                                 crop->regionlist[i].length,
                                 crop_buff, *page, page_count))
             {
             TIFFError("writeRegions", "Unable to write new image");
             return -1;
             }
           }
         break;
    case 4:
         var_202 = 1;
  page_count = 1;
         for (i = 0; i < crop->selections; i++)
           {
           if (update_output_file (var_210, mp, var_202, filename, page))
             return 1;

           crop_buff = seg_buffs[i].buffer;

           if (writeCroppedImage(var_210, *var_210, image, dump,
                                 crop->regionlist[i].width,
                                 crop->regionlist[i].length,
                                 crop_buff, *page, page_count))
             {
             TIFFError("writeRegions", "Unable to write new image");
             return -1;
             }
           }
  break;
    default: return 1;
    }

  return 0;
  }

static int
fn_202(TIFF *var_210, TIFF *var_210, struct struct_210 *image,
     struct struct_202 *page, struct struct_202 *sections,
     struct struct_209 * dump, unsigned char *src_buff,
                   unsigned char **sect_buff_ptr)
  {
  double var_207, var_207;
  uint32 i, k, var_214, var_214, var_208;
  unsigned char *sect_buff = *sect_buff_ptr;

  var_207 = page->hres;
  var_207 = page->vres;

  k = page->cols * page->rows;
  if ((k < 1) || (k > 32))
   {
   TIFFError("writeImageSections",
      "%d Rows and Columns exceed maximum sections\nIncrease resolution or reduce sections", k);
   return -1;
   }

  for (i = 0; i < k; i++)
    {
    var_214 = sections[i].x2 - sections[i].x1 + 1;
    var_214 = sections[i].y2 - sections[i].y1 + 1;
    var_208 = (uint32)
     ceil((var_214 * image->bps + 7) / (double)8) * image->spp * var_214;

    if (createImageSection(var_208, sect_buff_ptr))
      {
      TIFFError("writeImageSections", "Unable to allocate section buffer");
      exit (-1);
      }
    sect_buff = *sect_buff_ptr;

    if (extractImageSection (image, &sections[i], src_buff, sect_buff))
      {
      TIFFError("writeImageSections", "Unable to extract image sections");
      exit (-1);
      }


    if (writeSingleSection(var_210, var_210, image, dump, var_214, var_214, var_207, var_207, sect_buff))
      {
      TIFFError("writeImageSections", "Unable to write image section");
      exit (-1);
      }
    }

  return 0;
  }







static int
fn_205(TIFF *var_210, TIFF *var_210, struct struct_210 *image,
                   struct struct_209 *dump, uint32 var_214, uint32 var_214,
                   double var_207, double var_207,
                   unsigned char *sect_buff)
  {
  uint16 var_214, var_214;
  uint16 var_210, var_210;
  uint16 input_planar;
  struct struct_210* p;




  var_210 = image->compression;
  var_210 = image->photometric;

  var_214 = image->spp;
  var_214 = image->bps;
  TIFFSetField(var_210, TIFFTAG_IMAGEWIDTH, var_214);
  TIFFSetField(var_210, TIFFTAG_IMAGELENGTH, var_214);
  TIFFSetField(var_210, TIFFTAG_BITSPERSAMPLE, var_214);
  TIFFSetField(var_210, TIFFTAG_SAMPLESPERPIXEL, var_214);

  if (var_210 != (uint16)-1)
    TIFFSetField(var_210, TIFFTAG_COMPRESSION, var_210);
  else
    {
    if (var_210 == COMPRESSION_OJPEG)
      {
      var_210 = COMPRESSION_JPEG;
      var_210 = JPEGCOLORMODE_RAW;
      TIFFSetField(var_210, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
      }
    else
      if (TIFFGetField(var_210, TIFFTAG_COMPRESSION, &var_210)) TIFFSetField(var_210, TIFFTAG_COMPRESSION, var_210);
    }

  if (var_210 == COMPRESSION_JPEG)
    {
    if ((var_210 == PHOTOMETRIC_PALETTE) ||
        (var_210 == PHOTOMETRIC_MASK))
      {
      TIFFError ("writeSingleSection",
                 "JPEG compression cannot be used with %s image data",
   (var_210 == PHOTOMETRIC_PALETTE) ?
                 "palette" : "mask");
      return -1;
      }
    if ((var_210 == PHOTOMETRIC_RGB) &&
 (var_210 == var_210))
      TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    else
 TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, var_210);
    }
  else
    {
    if (var_210 == COMPRESSION_SGILOG || var_210 == COMPRESSION_SGILOG24)
      TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, var_214 == 1 ?
   PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
    else
      TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, image->photometric);
    }







  if (((var_210 == PHOTOMETRIC_LOGL) ||
       (var_210 == PHOTOMETRIC_LOGLUV)) &&
      ((var_210 != COMPRESSION_SGILOG) &&
       (var_210 != COMPRESSION_SGILOG24)))
    {
    TIFFError("writeSingleSection",
              "LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression");
    return -1;
    }

  if (var_210 != 0)
    TIFFSetField(var_210, TIFFTAG_FILLORDER, var_210);
  else
    cpTag(var_210, var_210, TIFFTAG_FILLORDER, 1, TIFF_SHORT);

  TIFFSetField(var_210, TIFFTAG_ORIENTATION, image->orientation);






  if (var_210 == -1)
    var_210 = TIFFIsTiled(var_210);
  if (var_210) {






    if (var_210 == (uint32) 0)
      TIFFGetField(var_210, TIFFTAG_TILEWIDTH, &var_210);
    if (var_210 == (uint32) 0)
      TIFFGetField(var_210, TIFFTAG_TILELENGTH, &var_210);

    if (var_210 == 0 || var_210 == 0)
      TIFFDefaultTileSize(var_210, &var_210, &var_210);
    TIFFDefaultTileSize(var_210, &var_210, &var_210);
    TIFFSetField(var_210, TIFFTAG_TILEWIDTH, var_210);
    TIFFSetField(var_210, TIFFTAG_TILELENGTH, var_210);
    } else {





 if (var_210 == (uint32) 0)
          {
   if (!TIFFGetField(var_210, TIFFTAG_ROWSPERSTRIP, &var_210))
     var_210 = TIFFDefaultStripSize(var_210, var_210);
          if (var_210 != COMPRESSION_JPEG)
            {
       if (var_210 > var_214)
       var_210 = var_214;
     }
   }
 else
          if (var_210 == (uint32) -1)
     var_210 = var_214;
 TIFFSetField(var_210, TIFFTAG_ROWSPERSTRIP, var_210);
 }

  TIFFGetFieldDefaulted(var_210, TIFFTAG_PLANARCONFIG, &input_planar);
  if (var_210 != (uint16) -1)
    TIFFSetField(var_210, TIFFTAG_PLANARCONFIG, var_210);
  else
    if (TIFFGetField(var_210, TIFFTAG_PLANARCONFIG, &var_210)) TIFFSetField(var_210, TIFFTAG_PLANARCONFIG, var_210);
  if (var_214 <= 4)
    cpTag(var_210, var_210, TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
  cpTag(var_210, var_210, TIFFTAG_COLORMAP, 4, TIFF_SHORT);


  switch (var_210) {



    case COMPRESSION_JPEG:
         if (((var_214 % 8) == 0) || ((var_214 % 12) == 0))
    {
           TIFFSetField(var_210, TIFFTAG_JPEGQUALITY, var_210);
    TIFFSetField(var_210, TIFFTAG_JPEGCOLORMODE, var_210);
           }
         else
           {
    TIFFError("writeSingleSection",
                     "JPEG compression requires 8 or 12 bits per sample");
           return -1;
           }
  break;
   case COMPRESSION_LZW:
   case COMPRESSION_ADOBE_DEFLATE:
   case COMPRESSION_DEFLATE:
 if (var_210 != (uint16)-1)
          TIFFSetField(var_210, TIFFTAG_PREDICTOR, var_210);
 else
   if (TIFFGetField(var_210, TIFFTAG_PREDICTOR, &var_210)) TIFFSetField(var_210, TIFFTAG_PREDICTOR, var_210);
 break;
   case COMPRESSION_CCITTFAX3:
   case COMPRESSION_CCITTFAX4:
 if (var_210 == COMPRESSION_CCITTFAX3) {
          if (var_210 != (uint32) -1)
     TIFFSetField(var_210, TIFFTAG_GROUP3OPTIONS, var_210);
   else
     if (TIFFGetField(var_210, TIFFTAG_GROUP3OPTIONS, &var_210)) TIFFSetField(var_210, TIFFTAG_GROUP3OPTIONS, var_210);
 } else {
     cpTag(var_210, var_210, TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
        }
        cpTag(var_210, var_210, TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
 break;
   }
   { uint32 len32;
     void** var_210;
     if (TIFFGetField(var_210, TIFFTAG_ICCPROFILE, &len32, &var_210))
       TIFFSetField(var_210, TIFFTAG_ICCPROFILE, len32, var_210);
   }
   { uint16 ninks;
     const char* var_210;
     if (TIFFGetField(var_210, TIFFTAG_NUMBEROFINKS, &ninks)) {
       TIFFSetField(var_210, TIFFTAG_NUMBEROFINKS, ninks);
       if (TIFFGetField(var_210, TIFFTAG_INKNAMES, &var_210)) {
  int var_210 = strlen(var_210) + 1;
  const char* cp = var_210;
  while (ninks > 1) {
    cp = strchr(cp, '\0');
    if (cp) {
      cp++;
      var_210 += (strlen(cp) + 1);
    }
    ninks--;
         }
  TIFFSetField(var_210, TIFFTAG_INKNAMES, var_210, var_210);
       }
     }
   }
   {
   unsigned short pg0, pg1;
   if (TIFFGetField(var_210, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
     if (var_207 < 0)
 TIFFSetField(var_210, TIFFTAG_PAGENUMBER, pg0, pg1);
     else
 TIFFSetField(var_210, TIFFTAG_PAGENUMBER, var_207++, 0);
     }
   }

  for (p = tags; p < &tags[(sizeof (tags) / sizeof (tags[0]))]; p++)
  cpTag(var_210, var_210, p->tag, p->count, p->type);


  TIFFSetField(var_210, TIFFTAG_XRESOLUTION, (float)var_207);
  TIFFSetField(var_210, TIFFTAG_YRESOLUTION, (float)var_207);


  if (var_210)
    {
    if (var_210 == PLANARCONFIG_CONTIG)
      writeBufferToContigTiles (var_210, sect_buff, var_214, var_214, var_214, dump);
    else
      writeBufferToSeparateTiles (var_210, sect_buff, var_214, var_214, var_214, dump);
    }
  else
    {
    if (var_210 == PLANARCONFIG_CONTIG)
      writeBufferToContigStrips (var_210, sect_buff, var_214);
    else
      writeBufferToSeparateStrips(var_210, sect_buff, var_214, var_214, var_214, dump);
    }

  if (!TIFFWriteDirectory(var_210))
    {
    TIFFClose(var_210);
    return -1;
    }

  return 0;
  }



static int
fn_207(uint32 var_208, unsigned char **sect_buff_ptr)
  {
  unsigned char *sect_buff = NULL;
  unsigned char *new_buff = NULL;
  static uint32 var_208 = 0;

  sect_buff = *sect_buff_ptr;

  if (!sect_buff)
    {
    sect_buff = (unsigned char *)_TIFFmalloc(var_208);
    *sect_buff_ptr = sect_buff;
    _TIFFmemset(sect_buff, 0, var_208);
    }
  else
    {
    if (var_208 < var_208)
      {
      new_buff = _TIFFrealloc(sect_buff, var_208);
      if (!new_buff)
        {
 free (sect_buff);
        sect_buff = (unsigned char *)_TIFFmalloc(var_208);
        }
      else
        sect_buff = new_buff;

      _TIFFmemset(sect_buff, 0, var_208);
      }
    }

  if (!sect_buff)
    {
    TIFFError("createImageSection", "Unable to allocate/reallocate section buffer");
    return -1;
    }
  var_208 = var_208;
  *sect_buff_ptr = sect_buff;

  return 0;
  }



static int
fn_208(struct struct_210 *image, struct struct_209 *crop,
                      unsigned char **read_buff_ptr, struct struct_208 seg_buffs[])
  {
  int i;
  uint32 var_214, var_214, total_width, total_length;
  tsize_t cropsize;
  unsigned char *crop_buff = NULL;
  unsigned char *read_buff = NULL;
  unsigned char *next_buff = NULL;
  tsize_t var_209 = 0;

  read_buff = *read_buff_ptr;

  if (crop->img_mode == 0)
    {
    cropsize = crop->bufftotal;
    crop_buff = seg_buffs[0].buffer;
    if (!crop_buff)
      crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
    else
      {
      var_209 = seg_buffs[0].size;
      if (var_209 < cropsize)
        {
        next_buff = _TIFFrealloc(crop_buff, cropsize);
        if (! next_buff)
          {
          _TIFFfree (crop_buff);
          crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
          }
        else
          crop_buff = next_buff;
        }
      }

    if (!crop_buff)
      {
      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");
      return -1;
      }

    _TIFFmemset(crop_buff, 0, cropsize);
    seg_buffs[0].buffer = crop_buff;
    seg_buffs[0].size = cropsize;


    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)
      return 1;

    if (crop->crop_mode & 128)
      {
      switch (crop->photometric)
        {

        case PHOTOMETRIC_MINISWHITE:
        case PHOTOMETRIC_MINISBLACK:
      image->photometric = crop->photometric;
      break;
        case 10:
        case 11:
             if (invertImage(image->photometric, image->spp, image->bps,
                             crop->combined_width, crop->combined_length, crop_buff))
               {
               TIFFError("processCropSelections",
                         "Failed to invert colorspace for composite regions");
               return -1;
               }
             if (crop->photometric == 11)
               {
               switch (image->photometric)
                 {
                 case PHOTOMETRIC_MINISWHITE:
                image->photometric = PHOTOMETRIC_MINISBLACK;
               break;
                 case PHOTOMETRIC_MINISBLACK:
                image->photometric = PHOTOMETRIC_MINISWHITE;
               break;
                 default:
               break;
          }
        }
             break;
        default: break;
        }
      }


    if (crop->crop_mode & 64)
      {
      if (mirrorImage(image->spp, image->bps, crop->mirror,
                      crop->combined_width, crop->combined_length, crop_buff))
        {
        TIFFError("processCropSelections", "Failed to mirror composite regions %s",
          (crop->rotation == 1) ? "horizontally" : "vertically");
        return -1;
        }
      }

    if (crop->crop_mode & 32)
      {
      if (rotateImage(crop->rotation, image, &crop->combined_width,
                      &crop->combined_length, &crop_buff))
        {
        TIFFError("processCropSelections",
                  "Failed to rotate composite regions by %d degrees", crop->rotation);
        return -1;
        }
      seg_buffs[0].buffer = crop_buff;
      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)
                            * image->spp) * crop->combined_length;
      }
    }
  else
    {
    total_width = total_length = 0;
    for (i = 0; i < crop->selections; i++)
      {
      cropsize = crop->bufftotal;
      crop_buff = seg_buffs[i].buffer;
      if (!crop_buff)
        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
      else
        {
        var_209 = seg_buffs[0].size;
        if (var_209 < cropsize)
          {
          next_buff = _TIFFrealloc(crop_buff, cropsize);
          if (! next_buff)
            {
            _TIFFfree (crop_buff);
            crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
            }
          else
            crop_buff = next_buff;
          }
        }

      if (!crop_buff)
        {
        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");
        return -1;
        }

      _TIFFmemset(crop_buff, 0, cropsize);
      seg_buffs[i].buffer = crop_buff;
      seg_buffs[i].size = cropsize;

      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))
        {
 TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);
        return -1;
        }

      var_214 = crop->regionlist[i].width;
      var_214 = crop->regionlist[i].length;

      if (crop->crop_mode & 128)
        {
        switch (crop->photometric)
          {

          case PHOTOMETRIC_MINISWHITE:
          case PHOTOMETRIC_MINISBLACK:
        image->photometric = crop->photometric;
        break;
          case 10:
          case 11:
               if (invertImage(image->photometric, image->spp, image->bps,
                               var_214, var_214, crop_buff))
                 {
                 TIFFError("processCropSelections",
                           "Failed to invert colorspace for region");
                 return -1;
                 }
               if (crop->photometric == 11)
                 {
                 switch (image->photometric)
                   {
                   case PHOTOMETRIC_MINISWHITE:
                  image->photometric = PHOTOMETRIC_MINISBLACK;
                 break;
                   case PHOTOMETRIC_MINISBLACK:
                  image->photometric = PHOTOMETRIC_MINISWHITE;
                 break;
                   default:
                 break;
            }
          }
               break;
          default: break;
          }
        }

      if (crop->crop_mode & 64)
        {
        if (mirrorImage(image->spp, image->bps, crop->mirror,
                        var_214, var_214, crop_buff))
          {
          TIFFError("processCropSelections", "Failed to mirror crop region %s",
            (crop->rotation == 1) ? "horizontally" : "vertically");
          return -1;
          }
        }

      if (crop->crop_mode & 32)
        {
 if (rotateImage(crop->rotation, image, &crop->regionlist[i].width,
   &crop->regionlist[i].length, &crop_buff))
          {
          TIFFError("processCropSelections",
                    "Failed to rotate crop region by %d degrees", crop->rotation);
          return -1;
          }
        total_width += crop->regionlist[i].width;
        total_length += crop->regionlist[i].length;
        crop->combined_width = total_width;
        crop->combined_length = total_length;
        seg_buffs[i].buffer = crop_buff;
        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)
                               * image->spp) * crop->regionlist[i].length;
        }
      }
    }
  return 0;
  }

static int
fn_209(struct struct_210 *image, struct struct_209 *crop,
                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)
  {
  tsize_t cropsize;
  unsigned char *read_buff = NULL;
  unsigned char *crop_buff = NULL;
  unsigned char *new_buff = NULL;
  static tsize_t var_209 = 0;

  read_buff = *read_buff_ptr;


  crop_buff = read_buff;
  *crop_buff_ptr = read_buff;
  crop->combined_width = image->width;
  crop->combined_length = image->length;

  cropsize = crop->bufftotal;
  crop_buff = *crop_buff_ptr;
  if (!crop_buff)
    {
    crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
    *crop_buff_ptr = crop_buff;
    _TIFFmemset(crop_buff, 0, cropsize);
    var_209 = cropsize;
    }
  else
    {
    if (var_209 < cropsize)
      {
      new_buff = _TIFFrealloc(crop_buff, cropsize);
      if (!new_buff)
        {
 free (crop_buff);
        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
        }
      else
        crop_buff = new_buff;
      _TIFFmemset(crop_buff, 0, cropsize);
      }
    }

  if (!crop_buff)
    {
    TIFFError("createCroppedImage", "Unable to allocate/reallocate crop buffer");
    return -1;
    }
  *crop_buff_ptr = crop_buff;

  if (crop->crop_mode & 128)
    {
    switch (crop->photometric)
      {

      case PHOTOMETRIC_MINISWHITE:
      case PHOTOMETRIC_MINISBLACK:
    image->photometric = crop->photometric;
    break;
      case 10:
      case 11:
           if (invertImage(image->photometric, image->spp, image->bps,
                           crop->combined_width, crop->combined_length, crop_buff))
             {
             TIFFError("createCroppedImage",
                       "Failed to invert colorspace for image or cropped selection");
             return -1;
             }
           if (crop->photometric == 11)
             {
             switch (image->photometric)
               {
               case PHOTOMETRIC_MINISWHITE:
              image->photometric = PHOTOMETRIC_MINISBLACK;
             break;
               case PHOTOMETRIC_MINISBLACK:
              image->photometric = PHOTOMETRIC_MINISWHITE;
             break;
               default:
             break;
        }
      }
           break;
      default: break;
      }
    }

  if (crop->crop_mode & 64)
    {
    if (mirrorImage(image->spp, image->bps, crop->mirror,
                    crop->combined_width, crop->combined_length, crop_buff))
      {
      TIFFError("createCroppedImage", "Failed to mirror image or cropped selection %s",
        (crop->rotation == 1) ? "horizontally" : "vertically");
      return -1;
      }
    }

  if (crop->crop_mode & 32)
    {
    if (rotateImage(crop->rotation, image, &crop->combined_width,
                    &crop->combined_length, crop_buff_ptr))
      {
      TIFFError("createCroppedImage",
                "Failed to rotate image or cropped selection by %d degrees", crop->rotation);
      return -1;
      }
    }

  if (crop_buff == read_buff)
    *read_buff_ptr = NULL;

  return 0;
  }

static int
fn_209(TIFF *var_210, TIFF *var_210, struct struct_210 *image,
                  struct struct_209 *dump, uint32 var_214, uint32 var_214,
                  unsigned char *crop_buff, int var_210, int var_210)
  {
  uint16 var_214, var_214;
  uint16 var_210, var_210;
  uint16 input_planar;
  struct struct_210* p;

  var_210 = image->compression;
  var_210 = image->photometric;
  var_214 = image->spp;
  var_214 = image->bps;

  TIFFSetField(var_210, TIFFTAG_IMAGEWIDTH, var_214);
  TIFFSetField(var_210, TIFFTAG_IMAGELENGTH, var_214);
  TIFFSetField(var_210, TIFFTAG_BITSPERSAMPLE, var_214);
  TIFFSetField(var_210, TIFFTAG_SAMPLESPERPIXEL, var_214);







  if (var_210 != (uint16)-1)
    TIFFSetField(var_210, TIFFTAG_COMPRESSION, var_210);
  else
    {
    if (var_210 == COMPRESSION_OJPEG)
      {
      var_210 = COMPRESSION_JPEG;
      var_210 = JPEGCOLORMODE_RAW;
      TIFFSetField(var_210, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
      }
    else
      if (TIFFGetField(var_210, TIFFTAG_COMPRESSION, &var_210)) TIFFSetField(var_210, TIFFTAG_COMPRESSION, var_210);
    }

  if (var_210 == COMPRESSION_JPEG)
    {
    if ((var_210 == PHOTOMETRIC_PALETTE) ||
        (var_210 == PHOTOMETRIC_MASK))
      {
      TIFFError ("writeCroppedImage",
                 "JPEG compression cannot be used with %s image data",
               (var_210 == PHOTOMETRIC_PALETTE) ?
                 "palette" : "mask");
      return -1;
      }
    if ((var_210 == PHOTOMETRIC_RGB) &&
 (var_210 == var_210))
      TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    else
 TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, var_210);
    }
  else
    {
    if (var_210 == COMPRESSION_SGILOG || var_210 == COMPRESSION_SGILOG24)
      {
      TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, var_214 == 1 ?
   PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
      }
    else
      {
      if (var_210 == COMPRESSION_SGILOG ||
          var_210 == COMPRESSION_SGILOG24)
        {
        TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, var_214 == 1 ?
     PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
        }
      else
        TIFFSetField(var_210, TIFFTAG_PHOTOMETRIC, image->photometric);
      }
    }

  if (((var_210 == PHOTOMETRIC_LOGL) ||
       (var_210 == PHOTOMETRIC_LOGLUV)) &&
      ((var_210 != COMPRESSION_SGILOG) &&
       (var_210 != COMPRESSION_SGILOG24)))
    {
    TIFFError("writeCroppedImage",
              "LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression");
    return -1;
    }

  if (var_210 != 0)
    TIFFSetField(var_210, TIFFTAG_FILLORDER, var_210);
  else
    cpTag(var_210, var_210, TIFFTAG_FILLORDER, 1, TIFF_SHORT);

  TIFFSetField(var_210, TIFFTAG_ORIENTATION, image->orientation);






  if (var_210 == -1)
    var_210 = TIFFIsTiled(var_210);
  if (var_210) {






    if (var_210 == (uint32) 0)
      TIFFGetField(var_210, TIFFTAG_TILEWIDTH, &var_210);
    if (var_210 == (uint32) 0)
      TIFFGetField(var_210, TIFFTAG_TILELENGTH, &var_210);

    if (var_210 == 0 || var_210 == 0)
      TIFFDefaultTileSize(var_210, &var_210, &var_210);
    TIFFSetField(var_210, TIFFTAG_TILEWIDTH, var_210);
    TIFFSetField(var_210, TIFFTAG_TILELENGTH, var_210);
    } else {





 if (var_210 == (uint32) 0)
          {
   if (!TIFFGetField(var_210, TIFFTAG_ROWSPERSTRIP, &var_210))
     var_210 = TIFFDefaultStripSize(var_210, var_210);
          if (var_210 != COMPRESSION_JPEG)
            {
       if (var_210 > var_214)
       var_210 = var_214;
     }
   }
 else
          if (var_210 == (uint32) -1)
     var_210 = var_214;
 TIFFSetField(var_210, TIFFTAG_ROWSPERSTRIP, var_210);
 }

  TIFFGetFieldDefaulted(var_210, TIFFTAG_PLANARCONFIG, &input_planar);
  if (var_210 != (uint16) -1)
    TIFFSetField(var_210, TIFFTAG_PLANARCONFIG, var_210);
  else
    if (TIFFGetField(var_210, TIFFTAG_PLANARCONFIG, &var_210)) TIFFSetField(var_210, TIFFTAG_PLANARCONFIG, var_210);
  if (var_214 <= 4)
    cpTag(var_210, var_210, TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
  cpTag(var_210, var_210, TIFFTAG_COLORMAP, 4, TIFF_SHORT);


  switch (var_210) {
    case COMPRESSION_JPEG:
         if (((var_214 % 8) == 0) || ((var_214 % 12) == 0))
    {
           TIFFSetField(var_210, TIFFTAG_JPEGQUALITY, var_210);
    TIFFSetField(var_210, TIFFTAG_JPEGCOLORMODE, var_210);
           }
         else
           {
    TIFFError("writeCroppedImage",
                     "JPEG compression requires 8 or 12 bits per sample");
           return -1;
           }
  break;
   case COMPRESSION_LZW:
   case COMPRESSION_ADOBE_DEFLATE:
   case COMPRESSION_DEFLATE:
 if (var_210 != (uint16)-1)
          TIFFSetField(var_210, TIFFTAG_PREDICTOR, var_210);
 else
   if (TIFFGetField(var_210, TIFFTAG_PREDICTOR, &var_210)) TIFFSetField(var_210, TIFFTAG_PREDICTOR, var_210);
 break;
   case COMPRESSION_CCITTFAX3:
   case COMPRESSION_CCITTFAX4:
        if (var_214 != 1)
          {
   TIFFError("writeCroppedImage",
            "Group 3/4 compression is not usable with bps > 1");
          return -1;
   }
 if (var_210 == COMPRESSION_CCITTFAX3) {
          if (var_210 != (uint32) -1)
     TIFFSetField(var_210, TIFFTAG_GROUP3OPTIONS, var_210);
   else
     if (TIFFGetField(var_210, TIFFTAG_GROUP3OPTIONS, &var_210)) TIFFSetField(var_210, TIFFTAG_GROUP3OPTIONS, var_210);
 } else {
     cpTag(var_210, var_210, TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
        }
        cpTag(var_210, var_210, TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
        cpTag(var_210, var_210, TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
        break;
    case COMPRESSION_NONE:
         break;
    default: break;
   }
   { uint32 len32;
     void** var_210;
     if (TIFFGetField(var_210, TIFFTAG_ICCPROFILE, &len32, &var_210))
       TIFFSetField(var_210, TIFFTAG_ICCPROFILE, len32, var_210);
   }
   { uint16 ninks;
     const char* var_210;
     if (TIFFGetField(var_210, TIFFTAG_NUMBEROFINKS, &ninks)) {
       TIFFSetField(var_210, TIFFTAG_NUMBEROFINKS, ninks);
       if (TIFFGetField(var_210, TIFFTAG_INKNAMES, &var_210)) {
  int var_210 = strlen(var_210) + 1;
  const char* cp = var_210;
  while (ninks > 1) {
    cp = strchr(cp, '\0');
    if (cp) {
      cp++;
      var_210 += (strlen(cp) + 1);
    }
    ninks--;
         }
  TIFFSetField(var_210, TIFFTAG_INKNAMES, var_210, var_210);
       }
     }
   }
   {
   unsigned short pg0, pg1;
   if (TIFFGetField(var_210, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
     TIFFSetField(var_210, TIFFTAG_PAGENUMBER, var_210, var_210);
     }
   }

  for (p = tags; p < &tags[(sizeof (tags) / sizeof (tags[0]))]; p++)
  cpTag(var_210, var_210, p->tag, p->count, p->type);


  if (var_210)
    {
    if (var_210 == PLANARCONFIG_CONTIG)
      {
      if (writeBufferToContigTiles (var_210, crop_buff, var_214, var_214, var_214, dump))
        TIFFError("","Unable to write contiguous tile data for page %d", var_210);
      }
    else
      {
      if (writeBufferToSeparateTiles (var_210, crop_buff, var_214, var_214, var_214, dump))
        TIFFError("","Unable to write separate tile data for page %d", var_210);
      }
    }
  else
    {
    if (var_210 == PLANARCONFIG_CONTIG)
      {
      if (writeBufferToContigStrips (var_210, crop_buff, var_214))
        TIFFError("","Unable to write contiguous strip data for page %d", var_210);
      }
    else
      {
      if (writeBufferToSeparateStrips(var_210, crop_buff, var_214, var_214, var_214, dump))
        TIFFError("","Unable to write separate strip data for page %d", var_210);
      }
    }

  if (!TIFFWriteDirectory(var_210))
    {
    TIFFError("","Failed to write IFD for page number %d", var_210);
    TIFFClose(var_210);
    return -1;
    }

  return 0;
  }

static int
fn_210(uint16 var_210, uint16 var_214, uint16 var_214, uint32 var_214,
                         uint32 var_214, uint32 var_214, uint8 *src, uint8 *dst)
  {
  int var_213 = 0;
  uint32 var_213 = 0, var_212 = 0;
  uint32 var_214, var_213 = 0, var_213 = 0;
  uint8 var_210 = 0, var_210 = 0;
  uint8 var_213 = 0, var_213 = 0;
  uint8 *next;
  tsample_t var_213;

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("rotateContigSamples8bits","Invalid src or destination buffer");
    return 1;
    }

  var_213 = ((var_214 * var_214 * var_214) + 7) / 8;
  var_213 = 0;
  var_210 = (uint8)-1 >> ( 8 - var_214);
  var_213 = var_213 = 0;

  for (var_214 = 0; var_214 < var_214 ; var_214++)
    {
    var_213 = var_214 * var_214 * var_214;
    for (var_213 = 0; var_213 < var_214; var_213++)
      {
      if (var_213 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_213 * var_214)) / 8;
        var_212 = (var_213 + (var_213 * var_214)) % 8;
        }

      switch (var_210)
 {
        case 90: next = src + var_213 - (var_214 * var_213);
                  break;
        case 270: next = src + var_213 + (var_214 * var_213);
           break;
 default: TIFFError("rotateContigSamples8bits", "Invalid rotation %d", var_210);
                  return 1;
        }
      var_210 = var_210 << (8 - var_212 - var_214);
      var_213 = ((*next) & var_210) << (var_212);


      if (var_213 >= 8)
        {
        *dst++ = var_213;
        var_213 = var_213;
        var_213 -= 8;
        }
      else
        {
        var_213 = (var_213 | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }

  if (var_213 > 0)
    {
    var_213 = (var_213 & ((unsigned int)255 << (8 - var_213)));
    *dst++ = var_213;
    }

  return 0;
  }


static int
fn_210(uint16 var_210, uint16 var_214, uint16 var_214, uint32 var_214,
                         uint32 var_214, uint32 var_214, uint8 *src, uint8 *dst)
  {
  int var_213 = 0;
  uint32 var_214, var_213, var_213;
  uint32 var_213 = 0, var_212 = 0;
  uint16 var_210 = 0, var_210 = 0;
  uint16 var_213 = 0, var_213 = 0;
  uint8 var_213 = 0;
  uint8 *next;
  tsample_t var_213;

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("rotateContigSamples16bits","Invalid src or destination buffer");
    return 1;
    }

  var_213 = ((var_214 * var_214 * var_214) + 7) / 8;
  var_213 = 0;
  var_210 = (uint16)-1 >> (16 - var_214);
  var_213 = var_213 = 0;
  for (var_214 = 0; var_214 < var_214; var_214++)
    {
    var_213 = var_214 * var_214 * var_214;
    for (var_213 = 0; var_213 < var_214; var_213++)
      {
      if (var_213 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_213 * var_214)) / 8;
        var_212 = (var_213 + (var_213 * var_214)) % 8;
        }

      switch (var_210)
 {
        case 90: next = src + var_213 - (var_214 * var_213);
                  break;
        case 270: next = src + var_213 + (var_214 * var_213);
           break;
 default: TIFFError("rotateContigSamples8bits", "Invalid rotation %d", var_210);
                  return 1;
        }
      var_210 = var_210 << (16 - var_212 - var_214);
      if (var_213)
        var_213 = (next[0] << 8) | next[1];
      else
        var_213 = (next[1] << 8) | next[0];

      var_213 = (var_213 & var_210) << (var_212);


      if (var_213 >= 8)
        {
        var_213 = (var_213 >> 8);
        *dst++ = var_213;
        var_213 -= 8;

        var_213 = ((var_213 << 8) | (var_213 >> var_213));
        }
      else
        {
        var_213 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }

  if (var_213 > 0)
    {
    var_213 = (var_213 >> 8);
    *dst++ = var_213;
    }

  return 0;
  }

static int
fn_210(uint16 var_210, uint16 var_214, uint16 var_214, uint32 var_214,
                          uint32 var_214, uint32 var_214, uint8 *src, uint8 *dst)
  {
  int var_213 = 0;
  uint32 var_214, var_213, var_213;
  uint32 var_213 = 0, var_212 = 0;
  uint32 var_210 = 0, var_210 = 0;
  uint32 var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0;
  uint8 *next;
  tsample_t var_213;


  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("rotateContigSamples24bits","Invalid src or destination buffer");
    return 1;
    }

  var_213 = ((var_214 * var_214 * var_214) + 7) / 8;
  var_213 = 0;
  var_210 = (uint32)-1 >> (32 - var_214);
  var_213 = var_213 = 0;
  for (var_214 = 0; var_214 < var_214; var_214++)
    {
    var_213 = var_214 * var_214 * var_214;
    for (var_213 = 0; var_213 < var_214; var_213++)
      {
      if (var_213 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_213 * var_214)) / 8;
        var_212 = (var_213 + (var_213 * var_214)) % 8;
        }

      switch (var_210)
 {
        case 90: next = src + var_213 - (var_214 * var_213);
                  break;
        case 270: next = src + var_213 + (var_214 * var_213);
           break;
 default: TIFFError("rotateContigSamples8bits", "Invalid rotation %d", var_210);
                  return 1;
        }
      var_210 = var_210 << (32 - var_212 - var_214);
      if (var_213)
 var_213 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];
      else
 var_213 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];
      var_213 = (var_213 & var_210) << (var_212);


      if (var_213 >= 16)
        {
        var_214 = (var_213 >> 24);
        *dst++ = var_214;
        var_214 = (var_213 >> 16);
        *dst++ = var_214;
        var_213 -= 16;


        var_213 = ((var_213 << 16) | (var_213 >> var_213));
        }
      else
        {
        var_214 = var_214 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }


  while (var_213 > 0)
    {
    var_214 = (var_213 >> 24);
    *dst++ = var_214;

    var_213 = (var_213 << 8);
    var_214 = var_214;
    var_213 -= 8;
    }

  return 0;
  }

static int
fn_210(uint16 var_210, uint16 var_214, uint16 var_214, uint32 var_214,
                          uint32 var_214, uint32 var_214, uint8 *src, uint8 *dst)
  {
  int var_213 = 0 ;

  uint32 var_214, var_213, var_213;
  uint32 var_213, var_212;
  uint32 var_213 = 0, var_213 = 0;
  uint64 var_210 = 0, var_210 = 0;
  uint64 var_213 = 0, var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0, var_214 = 0, var_214 = 0;
  uint8 *next;
  tsample_t var_213;


  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("rotateContigSamples24bits","Invalid src or destination buffer");
    return 1;
    }

  var_213 = ((var_214 * var_214 * var_214) + 7) / 8;
  var_213 = 0;
  var_210 = (uint64)-1 >> (64 - var_214);
  var_213 = var_213 = 0;
  for (var_214 = 0; var_214 < var_214; var_214++)
    {
    var_213 = var_214 * var_214 * var_214;
    for (var_213 = 0; var_213 < var_214; var_213++)
      {
      if (var_213 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_213 * var_214)) / 8;
        var_212 = (var_213 + (var_213 * var_214)) % 8;
        }

      switch (var_210)
 {
        case 90: next = src + var_213 - (var_214 * var_213);
                  break;
        case 270: next = src + var_213 + (var_214 * var_213);
           break;
 default: TIFFError("rotateContigSamples8bits", "Invalid rotation %d", var_210);
                  return 1;
        }
      var_210 = var_210 << (64 - var_212 - var_214);
      if (var_213)
        {
 var_213 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];
        var_213 = var_213;
        }
      else
        {
 var_213 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];
        var_213 = var_213;
 }

      var_213 = ((uint64)var_213 << 32) | var_213;
      var_213 = (var_213 & var_210) << (var_212);

      if (var_213 < 32)
        {
        var_214 = var_214 = var_214 = var_214 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      else
        {
        var_214 = (var_213 >> 56);
        *dst++ = var_214;
        var_214 = (var_213 >> 48);
        *dst++ = var_214;
        var_214 = (var_213 >> 40);
        *dst++ = var_214;
        var_214 = (var_213 >> 32);
        *dst++ = var_214;
        var_213 -= 32;


        var_213 = ((var_213 << 32) | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }
  while (var_213 > 0)
    {
    var_214 = (var_213 >> 56);
    *dst++ = var_214;
    var_213 = (var_213 << 8);
    var_213 -= 8;
    }

  return 0;
  }



static int
fn_210(uint16 var_210, struct struct_210 *image, uint32 *img_width,
            uint32 *img_length, unsigned char **ibuff_ptr)
  {
  int shift_width;
  uint32 bytes_per_pixel, bytes_per_sample;
  uint32 var_214, var_213, src_offset, dst_offset;
  uint32 i, var_214, var_214, var_214;
  uint32 colsize, var_210, col_offset, pix_offset;
  unsigned char *ibuff;
  unsigned char *src;
  unsigned char *dst;
  uint16 var_214, var_214;
  float res_temp;
  unsigned char *rbuff = NULL;

  var_214 = *img_width;
  var_214 = *img_length;
  var_214 = image->spp;
  var_214 = image->bps;

  var_213 = ((var_214 * var_214 * var_214) + 7) / 8;
  colsize = ((var_214 * var_214 * var_214) + 7) / 8;
  if ((colsize * var_214) > (var_213 * var_214))
    var_210 = (colsize + 1) * var_214;
  else
    var_210 = (var_213 + 1) * var_214;

  bytes_per_sample = (var_214 + 7) / 8;
  bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
  if (bytes_per_pixel < (bytes_per_sample + 1))
    shift_width = bytes_per_pixel;
  else
    shift_width = bytes_per_sample + 1;

  switch (var_210)
    {
    case 0:
    case 360: return 0;
    case 90:
    case 180:
    case 270: break;
    default: TIFFError("rotateImage", "Invalid rotation angle %d", var_210);
              return -1;
    }

  if (!(rbuff = (unsigned char *)_TIFFmalloc(var_210)))
    {
    TIFFError("rotateImage", "Unable to allocate rotation buffer of %1u bytes", var_210);
    return -1;
    }
  _TIFFmemset(rbuff, '\0', var_210);

  ibuff = *ibuff_ptr;
  switch (var_210)
    {
    case 180: if ((var_214 % 8) == 0)
                {
                src = ibuff;
                pix_offset = (var_214 * var_214) / 8;
                for (var_214 = 0; var_214 < var_214; var_214++)
                   {
     dst_offset = (var_214 - var_214 - 1) * var_213;
                   for (var_214 = 0; var_214 < var_214; var_214++)
                     {
       col_offset = (var_214 - var_214 - 1) * pix_offset;
                     dst = rbuff + dst_offset + col_offset;

       for (i = 0; i < bytes_per_pixel; i++)
         *dst++ = *src++;
                     }
                   }
                }
       else
                {
                for (var_214 = 0; var_214 < var_214; var_214++)
                  {
    src_offset = var_214 * var_213;
    dst_offset = (var_214 - var_214 - 1) * var_213;
    src = ibuff + src_offset;
                  dst = rbuff + dst_offset;
                  switch (shift_width)
                    {
                    case 1: if (var_214 == 1)
         {
                              if (reverseSamples8bits(var_214, var_214, var_214, src, dst))
                                {
                  _TIFFfree(rbuff);
                                return -1;
                                }
                              break;
                              }
                            if (reverseSamples16bits(var_214, var_214, var_214, src, dst))
                              {
                _TIFFfree(rbuff);
                              return -1;
                              }
                             break;
                    case 2: if (reverseSamples24bits(var_214, var_214, var_214, src, dst))
                              {
                _TIFFfree(rbuff);
                              return -1;
                              }
                             break;
                    case 3:
                    case 4:
                    case 5: if (reverseSamples32bits(var_214, var_214, var_214, src, dst))
                              {
                _TIFFfree(rbuff);
                              return -1;
                              }
                             break;
                    default: TIFFError("rotateImage","Unsupported bit depth %d", var_214);
               _TIFFfree(rbuff);
                             return -1;
                    }
    }
  }
              _TIFFfree(ibuff);
              *(ibuff_ptr) = rbuff;
              break;

    case 90: if ((var_214 % 8) == 0)
                {
                for (var_214 = 0; var_214 < var_214; var_214++)
                  {
    src_offset = ((var_214 - 1) * var_213) + (var_214 * bytes_per_pixel);
                  dst_offset = var_214 * colsize;
    src = ibuff + src_offset;
    dst = rbuff + dst_offset;
                  for (var_214 = var_214; var_214 > 0; var_214--)
                    {
                    for (i = 0; i < bytes_per_pixel; i++)
                      *dst++ = *(src + i);
      src -= var_213;
                    }
    }
  }
              else
                {
                for (var_214 = 0; var_214 < var_214; var_214++)
                  {
    src_offset = (var_214 - 1) * var_213;
                  dst_offset = var_214 * colsize;
    src = ibuff + src_offset;
    dst = rbuff + dst_offset;
                  switch (shift_width)
                    {
                    case 1: if (var_214 == 1)
         {
                              if (rotateContigSamples8bits(var_210, var_214, var_214, var_214,
                         var_214, var_214, src, dst))
                                {
                  _TIFFfree(rbuff);
                                return -1;
                                }
                              break;
                              }
                            if (rotateContigSamples16bits(var_210, var_214, var_214, var_214,
                         var_214, var_214, src, dst))
                              {
                       _TIFFfree(rbuff);
                              return -1;
                }
              break;
                    case 2: if (rotateContigSamples24bits(var_210, var_214, var_214, var_214,
                       var_214, var_214, src, dst))
                              {
                _TIFFfree(rbuff);
                              return -1;
                              }
                             break;
                    case 3:
                    case 4:
                    case 5: if (rotateContigSamples32bits(var_210, var_214, var_214, var_214,
                       var_214, var_214, src, dst))
                              {
                _TIFFfree(rbuff);
                              return -1;
                              }
                             break;
                    default: TIFFError("rotateImage","Unsupported bit depth %d", var_214);
               _TIFFfree(rbuff);
                             return -1;
      }
    }
  }
              _TIFFfree(ibuff);
              *(ibuff_ptr) = rbuff;

              *img_width = var_214;
              *img_length = var_214;
              image->width = var_214;
              image->length = var_214;
              res_temp = image->xres;
              image->xres = image->yres;
              image->yres = res_temp;
       break;

    case 270: if ((var_214 % 8) == 0)
                {
                for (var_214 = 0; var_214 < var_214; var_214++)
                  {
    src_offset = var_214 * bytes_per_pixel;
                  dst_offset = (var_214 - var_214 - 1) * colsize;
    src = ibuff + src_offset;
    dst = rbuff + dst_offset;
                  for (var_214 = var_214; var_214 > 0; var_214--)
                    {
                    for (i = 0; i < bytes_per_pixel; i++)
                      *dst++ = *(src + i);
      src += var_213;
                    }
    }
  }
              else
                {
                for (var_214 = 0; var_214 < var_214; var_214++)
                  {
    src_offset = 0;
                  dst_offset = (var_214 - var_214 - 1) * colsize;
    src = ibuff + src_offset;
    dst = rbuff + dst_offset;
                  switch (shift_width)
                    {
                    case 1: if (var_214 == 1)
         {
                              if (rotateContigSamples8bits(var_210, var_214, var_214, var_214,
                         var_214, var_214, src, dst))
                                {
                  _TIFFfree(rbuff);
                                return -1;
                                }
                              break;
                              }
                            if (rotateContigSamples16bits(var_210, var_214, var_214, var_214,
                         var_214, var_214, src, dst))
                              {
                       _TIFFfree(rbuff);
                              return -1;
                }
              break;
                    case 2: if (rotateContigSamples24bits(var_210, var_214, var_214, var_214,
                       var_214, var_214, src, dst))
                              {
                _TIFFfree(rbuff);
                              return -1;
                              }
                             break;
                    case 3:
                    case 4:
                    case 5: if (rotateContigSamples32bits(var_210, var_214, var_214, var_214,
                       var_214, var_214, src, dst))
                              {
                _TIFFfree(rbuff);
                              return -1;
                              }
                             break;
                    default: TIFFError("rotateImage","Unsupported bit depth %d", var_214);
               _TIFFfree(rbuff);
                             return -1;
      }
    }
  }
              _TIFFfree(ibuff);
              *(ibuff_ptr) = rbuff;

              *img_width = var_214;
              *img_length = var_214;
              image->width = var_214;
              image->length = var_214;
              res_temp = image->xres;
              image->xres = image->yres;
              image->yres = res_temp;
              break;
    default:
              break;
    }

  return 0;
  }

static int
fn_210 (uint16 var_214, uint16 var_214, uint32 var_214,
                     uint8 *ibuff, uint8 *obuff)
  {
  int var_213 = 0;
  uint32 var_214;
  uint32 var_213, var_212;
  uint32 var_213 = 0;
  uint8 var_213 = 0, var_213 = 0;
  uint8 var_213 = 0, var_213 = 0;
  unsigned char *src;
  unsigned char *dst;
  tsample_t var_213;

  if ((ibuff == NULL) || (obuff == NULL))
    {
    TIFFError("reverseSamples8bits","Invalid image or work buffer");
    return 1;
    }

  var_213 = 0;
  var_213 = (uint8)-1 >> ( 8 - var_214);
  dst = obuff;
  for (var_214 = var_214; var_214 > 0; var_214--)
    {

    var_213 = (var_214 - 1) * var_214 * var_214;
    for (var_213 = 0; var_213 < var_214; var_213++)
      {
      if (var_213 == 0)
        {
        var_213 = var_213 / 8;
        var_212 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_213 * var_214)) / 8;
        var_212 = (var_213 + (var_213 * var_214)) % 8;
        }

      src = ibuff + var_213;
      var_213 = var_213 << (8 - var_212 - var_214);
      var_213 = ((*src) & var_213) << (var_212);

      if (var_213 < 8)
        var_213 = (var_213 | (var_213 >> var_213));
      else
        {
        *dst++ = var_213;
        var_213 = var_213;
        var_213 -= 8;
        }
      var_213 += var_214;
      }
    }
  if (var_213 > 0)
    {
    var_213 = (var_213 & ((unsigned int)255 << (8 - var_213)));
    *dst++ = var_213;
    }

  return 0;
  }


static int
fn_212 (uint16 var_214, uint16 var_214, uint32 var_214,
                      uint8 *ibuff, uint8 *obuff)
  {
  int var_213 = 0;
  uint32 var_214;
  uint32 var_213 = 0, var_213 = 0;
  uint32 var_213 = 0;
  uint16 var_213 = 0, var_213 = 0;
  uint16 var_213 = 0, var_213 = 0;
  uint8 var_213 = 0;
  unsigned char *src;
  unsigned char *dst;
  tsample_t var_213;

  if ((ibuff == NULL) || (obuff == NULL))
    {
    TIFFError("reverseSample16bits","Invalid image or work buffer");
    return 1;
    }

  var_213 = 0;
  var_213 = (uint16)-1 >> (16 - var_214);
  dst = obuff;
  for (var_214 = var_214; var_214 > 0; var_214--)
    {

    var_213 = (var_214 - 1) * var_214 * var_214;
    for (var_213 = 0; var_213 < var_214; var_213++)
      {
      if (var_213 == 0)
        {
        var_213 = var_213 / 8;
        var_213 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_213 * var_214)) / 8;
        var_213 = (var_213 + (var_213 * var_214)) % 8;
        }

      src = ibuff + var_213;
      var_213 = var_213 << (16 - var_213 - var_214);
      if (var_213)
        var_213 = (src[0] << 8) | src[1];
      else
        var_213 = (src[1] << 8) | src[0];
      var_213 = (var_213 & var_213) << (var_213);

      if (var_213 < 8)
        {
        var_213 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      else
        {
        var_213 = (var_213 >> 8);
        *dst++ = var_213;
        var_213 -= 8;

        var_213 = ((var_213 << 8) | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }

  if (var_213 > 0)
    {
    var_213 = (var_213 >> 8);
    *dst++ = var_213;
    }

  return 0;
  }

static int
fn_213 (uint16 var_214, uint16 var_214, uint32 var_214,
                      uint8 *ibuff, uint8 *obuff)
  {
  int var_213 = 0;
  uint32 var_214;
  uint32 var_213 = 0, var_213 = 0;
  uint32 var_213 = 0;
  uint32 var_213 = 0, var_213 = 0;
  uint32 var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0;
  unsigned char *src;
  unsigned char *dst;
  tsample_t var_213;

  if ((ibuff == NULL) || (obuff == NULL))
    {
    TIFFError("reverseSamples24bits","Invalid image or work buffer");
    return 1;
    }

  var_213 = 0;
  var_213 = (uint32)-1 >> (32 - var_214);
  dst = obuff;
  for (var_214 = var_214; var_214 > 0; var_214--)
    {

    var_213 = (var_214 - 1) * var_214 * var_214;
    for (var_213 = 0; var_213 < var_214; var_213++)
      {
      if (var_213 == 0)
        {
        var_213 = var_213 / 8;
        var_213 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_213 * var_214)) / 8;
        var_213 = (var_213 + (var_213 * var_214)) % 8;
        }

      src = ibuff + var_213;
      var_213 = var_213 << (32 - var_213 - var_214);
      if (var_213)
 var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
      else
 var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
      var_213 = (var_213 & var_213) << (var_213);

      if (var_213 < 16)
        {
        var_214 = var_214 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      else
        {
        var_214 = (var_213 >> 24);
        *dst++ = var_214;
        var_214 = (var_213 >> 16);
        *dst++ = var_214;
        var_213 -= 16;


        var_213 = ((var_213 << 16) | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }


  while (var_213 > 0)
    {
    var_214 = (var_213 >> 24);
    *dst++ = var_214;

    var_213 = (var_213 << 8);
    var_214 = var_214;
    var_213 -= 8;
    }

  return 0;
  }


static int
fn_213 (uint16 var_214, uint16 var_214, uint32 var_214,
                      uint8 *ibuff, uint8 *obuff)
  {
  int var_213 = 0 ;

  uint32 var_213;
  uint32 var_213 = 0, var_213 = 0;
  uint32 var_214;
  uint32 var_213 = 0, var_213 = 0;
  uint64 var_213 = 0, var_213 = 0;
  uint64 var_213 = 0, var_213 = 0, var_213 = 0;
  uint8 var_214 = 0, var_214 = 0, var_214 = 0, var_214 = 0;
  unsigned char *src;
  unsigned char *dst;
  tsample_t var_213;

  if ((ibuff == NULL) || (obuff == NULL))
    {
    TIFFError("reverseSamples32bits","Invalid image or work buffer");
    return 1;
    }

  var_213 = 0;
  var_213 = (uint64)-1 >> (64 - var_214);
  dst = obuff;

  for (var_214 = var_214; var_214 > 0; var_214--)
    {

    var_213 = (var_214 - 1) * var_214 * var_214;
    for (var_213 = 0; var_213 < var_214; var_213++)
      {
      if (var_213 == 0)
        {
        var_213 = var_213 / 8;
        var_213 = var_213 % 8;
        }
      else
        {
        var_213 = (var_213 + (var_213 * var_214)) / 8;
        var_213 = (var_213 + (var_213 * var_214)) % 8;
        }

      src = ibuff + var_213;
      var_213 = var_213 << (64 - var_213 - var_214);
      if (var_213)
        {
 var_213 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
        var_213 = var_213;
        }
      else
        {
 var_213 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
        var_213 = var_213;
 }
      var_213 = ((uint64)var_213 << 32) | var_213;
      var_213 = (var_213 & var_213) << (var_213);

      if (var_213 < 32)
        {
        var_214 = var_214 = var_214 = var_214 = 0;
        var_213 = (var_213 | (var_213 >> var_213));
        }
      else
        {
        var_214 = (var_213 >> 56);
        *dst++ = var_214;
        var_214 = (var_213 >> 48);
        *dst++ = var_214;
        var_214 = (var_213 >> 40);
        *dst++ = var_214;
        var_214 = (var_213 >> 32);
        *dst++ = var_214;
        var_213 -= 32;


        var_213 = ((var_213 << 32) | (var_213 >> var_213));
        }
      var_213 += var_214;
      }
    }
  while (var_213 > 0)
    {
    var_214 = (var_213 >> 56);
    *dst++ = var_214;
    var_213 = (var_213 << 8);
    var_213 -= 8;
    }

  return 0;
  }

static int
fn_213 (uint16 var_214, uint16 var_214, uint32 var_214,
                     uint8 *src, uint8 *dst)
  {
  int i;
  uint32 var_214, bytes_per_pixel, col_offset;
  uint8 var_214;
  unsigned char swapbuff[32];

  if ((src == NULL) || (dst == NULL))
    {
    TIFFError("reverseSamplesBytes","Invalid input or output buffer");
    return 1;
    }

  bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
  if( bytes_per_pixel > sizeof(swapbuff) )
  {
    TIFFError("reverseSamplesBytes","bytes_per_pixel too large");
    return 1;
  }
  switch (var_214 / 8)
     {
     case 8:
     case 4:
     case 3:
     case 2: for (var_214 = 0; var_214 < (var_214 / 2); var_214++)
               {
        col_offset = var_214 * bytes_per_pixel;
        _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);
        _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);
        _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);
               }
      break;
     case 1:
             for (var_214 = 0; var_214 < (var_214 / 2); var_214++)
               {
        for (i = 0; i < var_214; i++)
                  {
    var_214 = *src;
    *src++ = *(dst - var_214 + i);
                  *(dst - var_214 + i) = var_214;
    }
  dst -= var_214;
                }
      break;
     default: TIFFError("reverseSamplesBytes","Unsupported bit depth %d", var_214);
       return 1;
     }
  return 0;
  }



static int
fn_213(uint16 var_214, uint16 var_214, uint16 var_213, uint32 var_214, uint32 var_214, unsigned char *ibuff)
  {
  int shift_width;
  uint32 bytes_per_pixel, bytes_per_sample;
  uint32 var_214, var_213, row_offset;
  unsigned char *line_buff = NULL;
  unsigned char *src;
  unsigned char *dst;

  src = ibuff;
  var_213 = ((var_214 * var_214 * var_214) + 7) / 8;
  switch (var_213)
    {
    case 3:
    case 2:
             line_buff = (unsigned char *)_TIFFmalloc(var_213);
             if (line_buff == NULL)
               {
        TIFFError ("mirrorImage", "Unable to allocate mirror line buffer of %1u bytes", var_213);
               return -1;
               }

             dst = ibuff + (var_213 * (var_214 - 1));
             for (var_214 = 0; var_214 < var_214 / 2; var_214++)
               {
       _TIFFmemcpy(line_buff, src, var_213);
       _TIFFmemcpy(src, dst, var_213);
       _TIFFmemcpy(dst, line_buff, var_213);
               src += (var_213);
               dst -= (var_213);
               }
             if (line_buff)
               _TIFFfree(line_buff);
             if (var_213 == 2)
               break;
    case 1 :
              if ((var_214 % 8) == 0)
                {
                for (var_214 = 0; var_214 < var_214; var_214++)
                  {
    row_offset = var_214 * var_213;
                  src = ibuff + row_offset;
                  dst = ibuff + row_offset + var_213;
                  if (reverseSamplesBytes(var_214, var_214, var_214, src, dst))
                    {
      return -1;
                    }
    }
  }
       else
                {
                if (!(line_buff = (unsigned char *)_TIFFmalloc(var_213 + 1)))
                  {
                  TIFFError("mirrorImage", "Unable to allocate mirror line buffer");
                  return -1;
                  }
                bytes_per_sample = (var_214 + 7) / 8;
                bytes_per_pixel = ((var_214 * var_214) + 7) / 8;
                if (bytes_per_pixel < (bytes_per_sample + 1))
                  shift_width = bytes_per_pixel;
                else
                  shift_width = bytes_per_sample + 1;

                for (var_214 = 0; var_214 < var_214; var_214++)
                  {
    row_offset = var_214 * var_213;
                  src = ibuff + row_offset;
                  _TIFFmemset (line_buff, '\0', var_213);
                  switch (shift_width)
                    {
                    case 1: if (reverseSamples16bits(var_214, var_214, var_214, src, line_buff))
                              {
                _TIFFfree(line_buff);
                              return -1;
                              }
                             _TIFFmemcpy (src, line_buff, var_213);
                             break;
                    case 2: if (reverseSamples24bits(var_214, var_214, var_214, src, line_buff))
                              {
                _TIFFfree(line_buff);
                              return -1;
                              }
                             _TIFFmemcpy (src, line_buff, var_213);
                             break;
                    case 3:
                    case 4:
                    case 5: if (reverseSamples32bits(var_214, var_214, var_214, src, line_buff))
                              {
                _TIFFfree(line_buff);
                              return -1;
                              }
                             _TIFFmemcpy (src, line_buff, var_213);
                             break;
                    default: TIFFError("mirrorImage","Unsupported bit depth %d", var_214);
               _TIFFfree(line_buff);
                             return -1;
                    }
    }
                if (line_buff)
                  _TIFFfree(line_buff);
  }
             break;

    default: TIFFError ("mirrorImage", "Invalid mirror axis %d", var_213);
             return -1;
             break;
    }

  return 0;
  }


static int
fn_213(uint16 var_214, uint16 var_214, uint16 var_214, uint32 var_214, uint32 var_214, unsigned char *work_buff)
  {
  uint32 var_214, var_214;
  unsigned char var_214, var_214, var_214, var_214;
  unsigned char *src;
  uint16 *src_uint16;
  uint32 *src_uint32;

  if (var_214 != 1)
    {
    TIFFError("invertImage", "Image inversion not supported for more than one sample per pixel");
    return -1;
    }

  if (var_214 != PHOTOMETRIC_MINISWHITE && var_214 != PHOTOMETRIC_MINISBLACK)
    {
    TIFFError("invertImage", "Only black and white and grayscale images can be inverted");
    return -1;
    }

  src = work_buff;
  if (src == NULL)
    {
    TIFFError ("invertImage", "Invalid crop buffer passed to invertImage");
    return -1;
    }

  switch (var_214)
    {
    case 32: src_uint32 = (uint32 *)src;
             for (var_214 = 0; var_214 < var_214; var_214++)
               for (var_214 = 0; var_214 < var_214; var_214++)
                 {
   *src_uint32 = (uint32)0xFFFFFFFF - *src_uint32;
                  src_uint32++;
                 }
            break;
    case 16: src_uint16 = (uint16 *)src;
             for (var_214 = 0; var_214 < var_214; var_214++)
               for (var_214 = 0; var_214 < var_214; var_214++)
                 {
   *src_uint16 = (uint16)0xFFFF - *src_uint16;
                  src_uint16++;
                 }
            break;
    case 8: for (var_214 = 0; var_214 < var_214; var_214++)
              for (var_214 = 0; var_214 < var_214; var_214++)
                {
  *src = (uint8)255 - *src;
                 src++;
                }
            break;
    case 4: for (var_214 = 0; var_214 < var_214; var_214++)
              for (var_214 = 0; var_214 < var_214; var_214++)
                {
  var_214 = 16 - (uint8)(*src & 15);
  var_214 = 16 - (*src & 15);
  *src = var_214 << 4 & var_214;
                src++;
                }
            break;
    case 2: for (var_214 = 0; var_214 < var_214; var_214++)
              for (var_214 = 0; var_214 < var_214; var_214++)
                {
  var_214 = 4 - (uint8)(*src & 3);
  var_214 = 4 - (uint8)(*src & 3);
  var_214 = 4 - (uint8)(*src & 3);
  var_214 = 4 - (uint8)(*src & 3);
  *src = (var_214 << 6) || (var_214 << 4) || (var_214 << 2) || var_214;
                src++;
                }
            break;
    case 1: for (var_214 = 0; var_214 < var_214; var_214++)
              for (var_214 = 0; var_214 < var_214; var_214 += 8 /(var_214 * var_214))
                {
                *src = ~(*src);
                src++;
                }
            break;
    default: TIFFError("invertImage", "Unsupported bit depth %d", var_214);
      return -1;
    }

  return 0;
  }
