







extern int fn_0(int, char**, char*);

typedef enum {
 enum_1 = 0x01,
 enum_2 = 0x02,
 enum_3 = 0x04,
 enum_4 = 0x08,
 enum_5 = 0x10,
 enum_6 = 0x1000,
 enum_7 = 0x20,
 enum_8 = 0x40,
 enum_9 = 0x80
} t2p_cs_t;


typedef enum{
 enum_10=0x00

} t2p_compress_t;


typedef enum{
 enum_11=0x01,
 enum_12=0x02
} t2p_transcode_t;


typedef enum{
 enum_13=0x0000,
 enum_14=0x0001,
 enum_15=0x0002,
 enum_16=0x0004,
 enum_17=0x0008,
 enum_18=0x0010,
 enum_19=0x0020,
 enum_20=0x0040,
 enum_21=0x0040,
 enum_22=0x0100
} t2p_sample_t;


typedef enum{
 enum_23 = 0,
 enum_24 = 1
} t2p_err_t;


typedef struct {
 tdir_t page_directory;
 uint32 page_number;
 ttile_t page_tilecount;
 uint32 page_extra;
} T2P_PAGE;


typedef struct {
 float x1;
 float y1;
 float x2;
 float y2;
 float mat[9];
} T2P_BOX;


typedef struct {
 T2P_BOX tile_box;
} T2P_TILE;


typedef struct {
 ttile_t tiles_tilecount;
 uint32 tiles_tilewidth;
 uint32 tiles_tilelength;
 uint32 tiles_tilecountx;
 uint32 tiles_tilecounty;
 uint32 tiles_edgetilewidth;
 uint32 tiles_edgetilelength;
 T2P_TILE* tiles_tiles;
} T2P_TILES;


typedef struct {
 t2p_err_t t2p_error;
 T2P_PAGE* tiff_pages;
 T2P_TILES* tiff_tiles;
 tdir_t tiff_pagecount;
 uint16 tiff_compression;
 uint16 tiff_photometric;
 uint16 tiff_fillorder;
 uint16 tiff_bitspersample;
 uint16 tiff_samplesperpixel;
 uint16 tiff_planar;
 uint32 tiff_width;
 uint32 tiff_length;
 float tiff_xres;
 float tiff_yres;
 uint16 tiff_orientation;
 toff_t tiff_dataoffset;
 tsize_t tiff_datasize;
 uint16 tiff_resunit;
 uint16 pdf_centimeters;
 uint16 pdf_overrideres;
 uint16 pdf_overridepagesize;
 float pdf_defaultxres;
 float pdf_defaultyres;
 float pdf_xres;
 float pdf_yres;
 float pdf_defaultpagewidth;
 float pdf_defaultpagelength;
 float pdf_pagewidth;
 float pdf_pagelength;
 float pdf_imagewidth;
 float pdf_imagelength;
 int pdf_image_fillpage;
 T2P_BOX pdf_mediabox;
 T2P_BOX pdf_imagebox;
 uint16 pdf_majorversion;
 uint16 pdf_minorversion;
 uint32 pdf_catalog;
 uint32 pdf_pages;
 uint32 pdf_info;
 uint32 pdf_palettecs;
 uint16 pdf_fitwindow;
 uint32 pdf_startxref;

 char pdf_fileid[33];

 char pdf_datetime[17];

 char pdf_creator[512];

 char pdf_author[512];

 char pdf_title[512];

 char pdf_subject[512];

 char pdf_keywords[512];
 t2p_cs_t pdf_colorspace;
 uint16 pdf_colorspace_invert;
 uint16 pdf_switchdecode;
 uint16 pdf_palettesize;
 unsigned char* pdf_palette;
 int pdf_labrange[4];
 t2p_compress_t pdf_defaultcompression;
 uint16 pdf_defaultcompressionquality;
 t2p_compress_t pdf_compression;
 uint16 pdf_compressionquality;
 uint16 pdf_nopassthrough;
 t2p_transcode_t pdf_transcode;
 t2p_sample_t pdf_sample;
 uint32* pdf_xrefoffsets;
 uint32 pdf_xrefcount;
 tdir_t pdf_page;





 float tiff_whitechromaticities[2];
 float tiff_primarychromaticities[6];
 float tiff_referenceblackwhite[2];
 float* tiff_transferfunction[3];
 int pdf_image_interpolate;

 uint16 tiff_transferfunctioncount;
 uint32 pdf_icccs;
 uint32 tiff_iccprofilelength;
 tdata_t tiff_iccprofile;


 FILE *outputfile;
 int outputdisable;
 tsize_t outputwritten;
} T2P;



void fn_112(void);
int fn_113(float*, float*, char*);







T2P* fn_114(void);
void fn_114(T2P*);
tsize_t fn_29(T2P*, TIFF*, TIFF*);
void fn_114(T2P*);





void fn_114(T2P*, TIFF*);
int fn_119(const void*, const void*);
void fn_119(T2P*, TIFF*);
void fn_119(T2P*, TIFF*);
void fn_120(T2P*, TIFF*, ttile_t);
int fn_122(T2P_TILES, ttile_t);
int fn_123(T2P_TILES, ttile_t);
int fn_123(T2P_TILES, ttile_t);
int fn_123(T2P_TILES, ttile_t);
tsize_t fn_123(T2P*, TIFF*, TIFF*);
tsize_t fn_132(T2P*, TIFF*, TIFF*, ttile_t);






void fn_135(tdata_t, tsize_t, uint32, uint32, uint32);
void fn_140(T2P*, TIFF*);
tsize_t fn_140(T2P*, unsigned char*, unsigned char*, tsize_t);
tsize_t fn_142(T2P*, unsigned char*);
tsize_t fn_146(tdata_t, uint32);
tsize_t fn_148(tdata_t, uint32);
tsize_t fn_148(tdata_t, uint32);
tsize_t fn_149(tdata_t, uint32);
tsize_t fn_149(T2P*, TIFF*);
tsize_t fn_51(uint32, TIFF*);
tsize_t fn_52(TIFF*);
tsize_t fn_53(unsigned char*, TIFF*);
tsize_t fn_54(char*, TIFF*);
tsize_t fn_55(tdata_t, tsize_t, TIFF*);
tsize_t fn_56(TIFF*);
tsize_t fn_57(TIFF*);
tsize_t fn_58(tsize_t, uint32, TIFF*);
tsize_t fn_59(TIFF*);
tsize_t fn_60(TIFF*);
tsize_t fn_61(tsize_t, TIFF*);
tsize_t fn_62(T2P*, TIFF*);
tsize_t fn_63(T2P*, TIFF*, TIFF*);
void fn_64(T2P*);
void fn_65(T2P*, TIFF*);
tsize_t fn_66(T2P*, TIFF*);
tsize_t fn_67(uint32, T2P*, TIFF*);
void fn_68(T2P*);
void fn_69(T2P_BOX*, uint16);
void fn_70(T2P_BOX*, uint16);
tsize_t fn_71(T2P*, TIFF*);
tsize_t fn_72(ttile_t, T2P*, TIFF*);
tsize_t fn_73(T2P*, TIFF*);
tsize_t fn_74(T2P*, TIFF*);
tsize_t fn_75(T2P*, TIFF*, uint16);
tsize_t fn_76(T2P*, TIFF*, uint16);
tsize_t fn_77(T2P*, TIFF*);
tsize_t fn_78(T2P*, TIFF*);
tsize_t fn_79(T2P*, TIFF*);
tsize_t fn_80(T2P*, TIFF*);
tsize_t fn_81(T2P*, TIFF*);
tsize_t fn_82(T2P*, TIFF*);
tsize_t fn_83(ttile_t, T2P*, TIFF*);
tsize_t fn_84(T2P*, TIFF*);
tsize_t fn_85(T2P*, TIFF*);

static void
fn_86(TIFF *tif)
{
 T2P *t2p = (T2P*) TIFFClientdata(tif);
 t2p->outputdisable = 1;
}

static void
fn_87(TIFF *tif)
{
 T2P *t2p = (T2P*) TIFFClientdata(tif);
 t2p->outputdisable = 0;
}

static tmsize_t
fn_88(TIFF *tif, tdata_t var_149, tmsize_t var_100)
{
 thandle_t var_96 = TIFFClientdata(tif);
 TIFFReadWriteProc var_96 = TIFFGetWriteProc(tif);
 if (var_96)
  return var_96(var_96, var_149, var_100);
 return -1;
}

static uint64
fn_93(TIFF *tif, toff_t var_105, int var_101)
{
 thandle_t var_96 = TIFFClientdata(tif);
 TIFFSeekProc var_96 = TIFFGetSeekProc(tif);
 if (var_96)
  return var_96(var_96, var_105, var_101);
 return -1;
}

static tmsize_t
fn_96(thandle_t var_105, tdata_t var_149, tmsize_t var_100)
{
 (void) var_105, (void) var_149, (void) var_100;
 return -1;
}

static tmsize_t
fn_98(thandle_t var_105, tdata_t var_149, tmsize_t var_100)
{
 T2P *t2p = (T2P*) var_105;
 if (t2p->outputdisable <= 0 && t2p->outputfile) {
  tsize_t var_186 = fwrite(var_149, 1, var_100, t2p->outputfile);
  t2p->outputwritten += var_186;
  return var_186;
 }
 return var_100;
}

static uint64
fn_100(thandle_t var_105, uint64 var_105, int var_101)
{
 T2P *t2p = (T2P*) var_105;
 if (t2p->outputdisable <= 0 && t2p->outputfile)
  return _TIFF_fseek_f(t2p->outputfile, (_TIFF_off_t) var_105, var_101);
 return var_105;
}

static int
fn_101(thandle_t var_105)
{
 T2P *t2p = (T2P*) var_105;
 return fclose(t2p->outputfile);
}

static uint64
fn_102(thandle_t var_105)
{
 (void) var_105;
 return -1;
}

static int
fn_103(thandle_t var_105, void **var_149, toff_t *var_105)
{
 (void) var_105, (void) var_149, (void) var_105;
 return -1;
}

static void
fn_104(thandle_t var_105, void *var_149, toff_t var_105)
{
 (void) var_105, (void) var_149, (void) var_105;
}

static uint64
fn_105(uint64 var_109, uint64 var_109, T2P* t2p)
{
 uint64 var_109 = var_109 * var_109;

 if (var_109 && var_109 / var_109 != var_109) {
  TIFFError("tiff2pdf", "Integer overflow");
  t2p->t2p_error = T2P_ERR_ERROR;
  var_109 = 0;
 }

 return var_109;
}

int fn_109(int var_112, char** argv){

 extern char *optarg;
 extern int optind;

 const char *outfilename = NULL;
 T2P *t2p = NULL;
 TIFF *input = NULL, *output = NULL;
 int c, var_112 = 0;

 t2p = t2p_init();

 if (t2p == NULL){
  TIFFError("tiff2pdf", "Can't initialize context");
  goto fail;
 }

 while (argv &&
        (c = getopt(var_112, argv,
      "o:q:u:x:y:w:l:r:p:e:c:a:t:s:k:jzndifbhF")) != -1){
  switch (c) {
   case 'o':
    outfilename = optarg;
    break;






   case 'j':
    TIFFWarning(
     "tiff2pdf",
     "JPEG support in libtiff required for JPEG compression, ignoring option");
    break;







   case 'z':
    TIFFWarning(
     "tiff2pdf",
     "Zip support in libtiff required for Zip compression, ignoring option");
    break;

   case 'q':
    t2p->pdf_defaultcompressionquality=atoi(optarg);
    break;
   case 'n':
    t2p->pdf_nopassthrough=1;
    break;
   case 'd':
    t2p->pdf_defaultcompression=T2P_COMPRESS_NONE;
    break;
   case 'u':
    if(optarg[0]=='m'){
     t2p->pdf_centimeters=1;
    }
    break;
   case 'x':
    t2p->pdf_defaultxres =
     (float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);
    break;
   case 'y':
    t2p->pdf_defaultyres =
     (float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);
    break;
   case 'w':
    t2p->pdf_overridepagesize=1;
    t2p->pdf_defaultpagewidth =
     ((float)atof(optarg) * 72.0F) / (t2p->pdf_centimeters?2.54F:1.0F);
    break;
   case 'l':
    t2p->pdf_overridepagesize=1;
    t2p->pdf_defaultpagelength =
     ((float)atof(optarg) * 72.0F) / (t2p->pdf_centimeters?2.54F:1.0F);
    break;
   case 'r':
    if(optarg[0]=='o'){
     t2p->pdf_overrideres=1;
    }
    break;
   case 'p':
    if(tiff2pdf_match_paper_size(
     &(t2p->pdf_defaultpagewidth),
     &(t2p->pdf_defaultpagelength),
     optarg)){
     t2p->pdf_overridepagesize=1;
    } else {
     TIFFWarning("tiff2pdf",
     "Unknown paper size %s, ignoring option",
      optarg);
    }
    break;
   case 'i':
    t2p->pdf_colorspace_invert=1;
    break;
   case 'F':
    t2p->pdf_image_fillpage = 1;
    break;
   case 'f':
    t2p->pdf_fitwindow=1;
    break;
   case 'e':
    if (strlen(optarg) == 0) {
     t2p->pdf_datetime[0] = '\0';
    } else {
     t2p->pdf_datetime[0] = 'D';
     t2p->pdf_datetime[1] = ':';
     strncpy(t2p->pdf_datetime + 2, optarg,
      sizeof(t2p->pdf_datetime) - 3);
     t2p->pdf_datetime[sizeof(t2p->pdf_datetime) - 1] = '\0';
    }
    break;
   case 'c':
    strncpy(t2p->pdf_creator, optarg, sizeof(t2p->pdf_creator) - 1);
    t2p->pdf_creator[sizeof(t2p->pdf_creator) - 1] = '\0';
    break;
   case 'a':
    strncpy(t2p->pdf_author, optarg, sizeof(t2p->pdf_author) - 1);
    t2p->pdf_author[sizeof(t2p->pdf_author) - 1] = '\0';
    break;
   case 't':
    strncpy(t2p->pdf_title, optarg, sizeof(t2p->pdf_title) - 1);
    t2p->pdf_title[sizeof(t2p->pdf_title) - 1] = '\0';
    break;
   case 's':
    strncpy(t2p->pdf_subject, optarg, sizeof(t2p->pdf_subject) - 1);
    t2p->pdf_subject[sizeof(t2p->pdf_subject) - 1] = '\0';
    break;
   case 'k':
    strncpy(t2p->pdf_keywords, optarg, sizeof(t2p->pdf_keywords) - 1);
    t2p->pdf_keywords[sizeof(t2p->pdf_keywords) - 1] = '\0';
    break;
   case 'b':
    t2p->pdf_image_interpolate = 1;
    break;
   case 'h':
   case '?':
    tiff2pdf_usage();
    goto success;
    break;
  }
 }




 if(var_112 > optind) {
  input = TIFFOpen(argv[optind++], "r");
  if (input==NULL) {
   TIFFError("tiff2pdf",
      "Can't open input file %s for reading",
      argv[optind-1]);
   goto fail;
  }
 } else {
  TIFFError("tiff2pdf", "No input file specified");
  tiff2pdf_usage();
  goto fail;
 }

 if(var_112 > optind) {
  TIFFError("tiff2pdf",
     "No support for multiple input files");
  tiff2pdf_usage();
  goto fail;
 }




 t2p->outputdisable = 1;
 if (outfilename) {
  t2p->outputfile = fopen(outfilename, "wb");
  if (t2p->outputfile == NULL) {
   TIFFError("tiff2pdf",
      "Can't open output file %s for writing",
      outfilename);
   goto fail;
  }
 } else {
  outfilename = "-";
  t2p->outputfile = stdout;
 }

 output = TIFFClientOpen(outfilename, "w", (thandle_t) t2p,
    t2p_readproc, t2p_writeproc, t2p_seekproc,
    t2p_closeproc, t2p_sizeproc,
    t2p_mapproc, t2p_unmapproc);
 t2p->outputdisable = 0;
 if (output == NULL) {
  TIFFError("tiff2pdf",
     "Can't initialize output descriptor");
  goto fail;
 }




 t2p_validate(t2p);
 t2pSeekFile(output, (toff_t) 0, SEEK_SET);




 t2p_write_pdf(t2p, input, output);
 if (t2p->t2p_error != 0) {
  TIFFError("tiff2pdf",
     "An error occurred creating output PDF file");
  goto fail;
 }

 goto success;
fail:
 var_112 = 1;
success:
 if(input != NULL)
  TIFFClose(input);
 if (output != NULL)
  TIFFClose(output);
 if (t2p != NULL)
  t2p_free(t2p);
 return var_112;

}

void fn_112(){
 char* lines[]={
 "usage:  tiff2pdf [options] input.tiff",
 "options:",
 " -o: output to file name",






 " -q: compression quality",
 " -n: no compressed data passthrough",
 " -d: do not compress (decompress)",
 " -i: invert colors",
 " -u: set distance unit, 'i' for inch, 'm' for centimeter",
 " -x: set x resolution default in dots per unit",
 " -y: set y resolution default in dots per unit",
 " -w: width in units",
 " -l: length in units",
 " -r: 'd' for resolution default, 'o' for resolution override",
 " -p: paper size, eg \"letter\", \"legal\", \"A4\"",
  " -F: make the tiff fill the PDF page",
 " -f: set PDF \"Fit Window\" user preference",
 " -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS",
 " -c: sets document creator, overrides image software default",
 " -a: sets document author, overrides image artist default",
 " -t: sets document title, overrides image document name default",
 " -s: sets document subject, overrides image image description default",
 " -k: sets document keywords",
 " -b: set PDF \"Interpolate\" user preference",
 " -h: usage",
 NULL
 };
 int var_186=0;

 fprintf(stderr, "%s\n\n", TIFFGetVersion());
 for (var_186=0;lines[var_186]!=NULL;var_186++){
  fprintf(stderr, "%s\n", lines[var_186]);
 }

 return;
}

int fn_113(float* width, float* length, char* papersize){

 size_t var_186, var_152;
 const char* sizes[]={
  "LETTER", "A4", "LEGAL",
  "EXECUTIVE", "LETTER", "LEGAL", "LEDGER", "TABLOID",
  "A", "B", "C", "D", "E", "F", "G", "H", "J", "K",
  "A10", "A9", "A8", "A7", "A6", "A5", "A4", "A3", "A2", "A1", "A0",
  "2A0", "4A0", "2A", "4A",
  "B10", "B9", "B8", "B7", "B6", "B5", "B4", "B3", "B2", "B1", "B0",
  "JISB10", "JISB9", "JISB8", "JISB7", "JISB6", "JISB5", "JISB4",
  "JISB3", "JISB2", "JISB1", "JISB0",
  "C10", "C9", "C8", "C7", "C6", "C5", "C4", "C3", "C2", "C1", "C0",
  "RA2", "RA1", "RA0", "SRA4", "SRA3", "SRA2", "SRA1", "SRA0",
  "A3EXTRA", "A4EXTRA",
  "STATEMENT", "FOLIO", "QUARTO",
  NULL
 } ;
 const int widths[]={
  612, 595, 612,
  522, 612,612,792,792,
  612,792,1224,1584,2448,2016,792,2016,2448,2880,
  74,105,147,210,298,420,595,842,1191,1684,2384,3370,4768,3370,4768,
  88,125,176,249,354,499,709,1001,1417,2004,2835,
  91,128,181,258,363,516,729,1032,1460,2064,2920,
  79,113,162,230,323,459,649,918,1298,1298,2599,
  1219,1729,2438,638,907,1276,1814,2551,
  914,667,
  396, 612, 609,
  0
 };
 const int lengths[]={
  792,842,1008,
  756,792,1008,1224,1224,
  792,1224,1584,2448,3168,2880,6480,10296,12672,10296,
  105,147,210,298,420,595,842,1191,1684,2384,3370,4768,6741,4768,6741,
  125,176,249,354,499,709,1001,1417,2004,2835,4008,
  128,181,258,363,516,729,1032,1460,2064,2920,4127,
  113,162,230,323,459,649,918,1298,1837,1837,3677,
  1729,2438,3458,907,1276,1814,2551,3628,
  1262,914,
  612, 936, 780,
  0
 };

 var_152=strlen(papersize);
 for(var_186=0;var_186<var_152;var_186++){
  papersize[var_186]=toupper((int) papersize[var_186]);
 }
 for(var_186=0;sizes[var_186]!=NULL; var_186++){
  if (strcmp( (const char*)papersize, sizes[var_186])==0){
   *width=(float)widths[var_186];
   *length=(float)lengths[var_186];
   return1;
  }
 }

 return0;
}





T2P* fn_114()
{
 T2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));
 if(t2p==NULL){
  TIFFError(
   "tiff2pdf",
   "Can't allocate %lu bytes of memory for t2p_init",
   (unsigned long) sizeof(T2P));
  return( (T2P*) NULL );
 }
 _TIFFmemset(t2p, 0x00, sizeof(T2P));
 t2p->pdf_majorversion=1;
 t2p->pdf_minorversion=1;
 t2p->pdf_defaultxres=300.0;
 t2p->pdf_defaultyres=300.0;
 t2p->pdf_defaultpagewidth=612.0;
 t2p->pdf_defaultpagelength=792.0;
 t2p->pdf_xrefcount=3;

 return(t2p);
}





void fn_114(T2P* t2p)
{
 int var_186 = 0;

 if (t2p != NULL) {
  if(t2p->pdf_xrefoffsets != NULL){
   _TIFFfree( (tdata_t) t2p->pdf_xrefoffsets);
  }
  if(t2p->tiff_pages != NULL){
   _TIFFfree( (tdata_t) t2p->tiff_pages);
  }
  for(var_186=0;var_186<t2p->tiff_pagecount;var_186++){
   if(t2p->tiff_tiles[var_186].tiles_tiles != NULL){
    _TIFFfree( (tdata_t) t2p->tiff_tiles[var_186].tiles_tiles);
   }
  }
  if(t2p->tiff_tiles != NULL){
   _TIFFfree( (tdata_t) t2p->tiff_tiles);
  }
  if(t2p->pdf_palette != NULL){
   _TIFFfree( (tdata_t) t2p->pdf_palette);
  }





  _TIFFfree( (tdata_t) t2p );
 }

 return;
}






void fn_114(T2P* t2p){

 (void)0;

 return;
}

void fn_114(T2P* t2p, TIFF* input){

 tdir_t var_118=0;
 tdir_t var_186=0;
 uint16 var_119=0;
 uint16 var_119=0;
 uint16 var_119=0;

 var_118=TIFFNumberOfDirectories(input);
 t2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,var_118,sizeof(T2P_PAGE)));
 if(t2p->tiff_pages==NULL){
  TIFFError(
   "tiff2pdf",
   "Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for tiff_pages array, %s",
   (TIFF_SIZE_T) var_118 * sizeof(T2P_PAGE),
   TIFFFileName(input));
  t2p->t2p_error = T2P_ERR_ERROR;
  return;
 }
 _TIFFmemset( t2p->tiff_pages, 0x00, var_118 * sizeof(T2P_PAGE));
 t2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,var_118,sizeof(T2P_TILES)));
 if(t2p->tiff_tiles==NULL){
  TIFFError(
   "tiff2pdf",
   "Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for tiff_tiles array, %s",
   (TIFF_SIZE_T) var_118 * sizeof(T2P_TILES),
   TIFFFileName(input));
  t2p->t2p_error = T2P_ERR_ERROR;
  return;
 }
 _TIFFmemset( t2p->tiff_tiles, 0x00, var_118 * sizeof(T2P_TILES));
 for(var_186=0;var_186<var_118;var_186++){
  uint32 var_119 = 0;

  if(!TIFFSetDirectory(input, var_186)){
   TIFFError(
    "tiff2pdf",
    "Can't set directory %u of input file %s",
    var_186,
    TIFFFileName(input));
   t2p->t2p_error = T2P_ERR_ERROR;
   return;
  }
  if(TIFFGetField(input, TIFFTAG_PAGENUMBER, &var_119, &var_119)){
   if((var_119>var_119) && (var_119 != 0)){
    t2p->tiff_pages[t2p->tiff_pagecount].page_number =
     var_119;
   } else {
    t2p->tiff_pages[t2p->tiff_pagecount].page_number =
     var_119;
   }
   goto ispage2;
  }
  if(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &var_119)){
   if ( ((var_119 & FILETYPE_PAGE) != 0)
                             || (var_119 == 0)){
    goto ispage;
   } else {
    goto isnotpage;
   }
  }
  if(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &var_119)){
   if ((var_119 == OFILETYPE_IMAGE)
    || (var_119 == OFILETYPE_PAGE)
    || (var_119 == 0) ){
    goto ispage;
   } else {
    goto isnotpage;
   }
  }
  ispage:
  t2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount;
  ispage2:
  t2p->tiff_pages[t2p->tiff_pagecount].page_directory=var_186;
  if(TIFFIsTiled(input)){
   t2p->tiff_pages[t2p->tiff_pagecount].page_tilecount =
    TIFFNumberOfTiles(input);
  }
  t2p->tiff_pagecount++;
  isnotpage:
  (void)0;
 }

 qsort((void*) t2p->tiff_pages, t2p->tiff_pagecount,
              sizeof(T2P_PAGE), t2p_cmp_t2p_page);

 for(var_186=0;var_186<t2p->tiff_pagecount;var_186++){
  t2p->pdf_xrefcount += 5;
  TIFFSetDirectory(input, t2p->tiff_pages[var_186].page_directory );
  if((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &var_119)
                    && (var_119==PHOTOMETRIC_PALETTE))
     || TIFFGetField(input, TIFFTAG_INDEXED, &var_119)) {
   t2p->tiff_pages[var_186].page_extra++;
   t2p->pdf_xrefcount++;
  }

  if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,
                                 &(t2p->tiff_transferfunction[0]),
                                 &(t2p->tiff_transferfunction[1]),
                                 &(t2p->tiff_transferfunction[2]))) {
   if((t2p->tiff_transferfunction[1] != (float*) NULL) &&
                           (t2p->tiff_transferfunction[2] != (float*) NULL) &&
                           (t2p->tiff_transferfunction[1] !=
                            t2p->tiff_transferfunction[0])) {
    t2p->tiff_transferfunctioncount = 3;
    t2p->tiff_pages[var_186].page_extra += 4;
    t2p->pdf_xrefcount += 4;
   } else {
    t2p->tiff_transferfunctioncount = 1;
    t2p->tiff_pages[var_186].page_extra += 2;
    t2p->pdf_xrefcount += 2;
   }
   if(t2p->pdf_minorversion < 2)
    t2p->pdf_minorversion = 2;
                } else {
   t2p->tiff_transferfunctioncount=0;
  }
  if( TIFFGetField(
   input,
   TIFFTAG_ICCPROFILE,
   &(t2p->tiff_iccprofilelength),
   &(t2p->tiff_iccprofile)) != 0){
   t2p->tiff_pages[var_186].page_extra++;
   t2p->pdf_xrefcount++;
   if(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;}
  }
  t2p->tiff_tiles[var_186].tiles_tilecount=
   t2p->tiff_pages[var_186].page_tilecount;
  if( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &var_119) != 0)
   && (var_119 == PLANARCONFIG_SEPARATE ) ){
    if( !TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &var_119) )
    {
     TIFFError(
                        "tiff2pdf",
                        "Missing SamplesPerPixel, %s",
                        TIFFFileName(input));
                    t2p->t2p_error = T2P_ERR_ERROR;
                    return;
    }
                if( (t2p->tiff_tiles[var_186].tiles_tilecount % var_119) != 0 )
                {
                    TIFFError(
                        "tiff2pdf",
                        "Invalid tile count, %s",
                        TIFFFileName(input));
                    t2p->t2p_error = T2P_ERR_ERROR;
                    return;
                }
    t2p->tiff_tiles[var_186].tiles_tilecount/= var_119;
  }
  if( t2p->tiff_tiles[var_186].tiles_tilecount > 0){
   t2p->pdf_xrefcount +=
    (t2p->tiff_tiles[var_186].tiles_tilecount -1)*2;
   TIFFGetField(input,
    TIFFTAG_TILEWIDTH,
    &( t2p->tiff_tiles[var_186].tiles_tilewidth) );
   TIFFGetField(input,
    TIFFTAG_TILELENGTH,
    &( t2p->tiff_tiles[var_186].tiles_tilelength) );
   t2p->tiff_tiles[var_186].tiles_tiles =
   (T2P_TILE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->tiff_tiles[var_186].tiles_tilecount,
                                                                 sizeof(T2P_TILE)) );
   if( t2p->tiff_tiles[var_186].tiles_tiles == NULL){
    TIFFError(
     "tiff2pdf",
     "Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for t2p_read_tiff_init, %s",
     (TIFF_SIZE_T) t2p->tiff_tiles[var_186].tiles_tilecount * sizeof(T2P_TILE),
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
   }
  }
 }

 return;
}







int fn_119(const void* e1, const void* e2){

 int d;
 d = (int32)(((T2P_PAGE*)e1)->page_number) - (int32)(((T2P_PAGE*)e2)->page_number);
 if(d == 0){
  d = (int32)(((T2P_PAGE*)e1)->page_directory) - (int32)(((T2P_PAGE*)e2)->page_directory);
 }
 return d;
}

void fn_119(T2P* t2p, TIFF* input){

 int var_186=0;
 uint16* r;
 uint16* g;
 uint16* b;
 uint16* a;
 uint16 var_119;
 uint16* xuint16p;
 float* xfloatp;

 t2p->pdf_transcode = T2P_TRANSCODE_ENCODE;
 t2p->pdf_sample = T2P_SAMPLE_NOTHING;
        t2p->pdf_switchdecode = t2p->pdf_colorspace_invert;


 TIFFSetDirectory(input, t2p->tiff_pages[t2p->pdf_page].page_directory);

 TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width));
 if(t2p->tiff_width == 0){
  TIFFError(
   "tiff2pdf",
   "No support for %s with zero width",
   TIFFFileName(input) );
  t2p->t2p_error = T2P_ERR_ERROR;
  return;
 }

 TIFFGetField(input, TIFFTAG_IMAGELENGTH, &(t2p->tiff_length));
 if(t2p->tiff_length == 0){
  TIFFError(
   "tiff2pdf",
   "No support for %s with zero length",
   TIFFFileName(input) );
  t2p->t2p_error = T2P_ERR_ERROR;
  return;
 }

        if(TIFFGetField(input, TIFFTAG_COMPRESSION, &(t2p->tiff_compression)) == 0){
                TIFFError(
                        "tiff2pdf",
                        "No support for %s with no compression tag",
                        TIFFFileName(input) );
                t2p->t2p_error = T2P_ERR_ERROR;
                return;

        }
        if( TIFFIsCODECConfigured(t2p->tiff_compression) == 0){
  TIFFError(
   "tiff2pdf",
   "No support for %s with compression type %u:  not configured",
   TIFFFileName(input),
   t2p->tiff_compression
   );
  t2p->t2p_error = T2P_ERR_ERROR;
  return;

 }

 TIFFGetFieldDefaulted(input, TIFFTAG_BITSPERSAMPLE, &(t2p->tiff_bitspersample));
 switch(t2p->tiff_bitspersample){
  case 1:
  case 2:
  case 4:
  case 8:
   break;
  case 0:
   TIFFWarning(
    "tiff2pdf",
    "Image %s has 0 bits per sample, assuming 1",
    TIFFFileName(input));
   t2p->tiff_bitspersample=1;
   break;
  default:
   TIFFError(
    "tiff2pdf",
    "No support for %s with %u bits per sample",
    TIFFFileName(input),
    t2p->tiff_bitspersample);
   t2p->t2p_error = T2P_ERR_ERROR;
   return;
 }

 TIFFGetFieldDefaulted(input, TIFFTAG_SAMPLESPERPIXEL, &(t2p->tiff_samplesperpixel));
 if(t2p->tiff_samplesperpixel>4){
  TIFFError(
   "tiff2pdf",
   "No support for %s with %u samples per pixel",
   TIFFFileName(input),
   t2p->tiff_samplesperpixel);
  t2p->t2p_error = T2P_ERR_ERROR;
  return;
 }
 if(t2p->tiff_samplesperpixel==0){
  TIFFWarning(
   "tiff2pdf",
   "Image %s has 0 samples per pixel, assuming 1",
   TIFFFileName(input));
  t2p->tiff_samplesperpixel=1;
 }

 if(TIFFGetField(input, TIFFTAG_SAMPLEFORMAT, &var_119) != 0 ){
  switch(var_119){
   case 0:
   case 1:
   case 4:
    break;
   default:
    TIFFError(
     "tiff2pdf",
     "No support for %s with sample format %u",
     TIFFFileName(input),
     var_119);
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
    break;
  }
 }

 TIFFGetFieldDefaulted(input, TIFFTAG_FILLORDER, &(t2p->tiff_fillorder));

        if(TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &(t2p->tiff_photometric)) == 0){
                TIFFError(
                        "tiff2pdf",
                        "No support for %s with no photometric interpretation tag",
                        TIFFFileName(input) );
                t2p->t2p_error = T2P_ERR_ERROR;
                return;

        }

 switch(t2p->tiff_photometric){
  case PHOTOMETRIC_MINISWHITE:
  case PHOTOMETRIC_MINISBLACK:
   if (t2p->tiff_bitspersample==1){
    t2p->pdf_colorspace=T2P_CS_BILEVEL;
    if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){
     t2p->pdf_switchdecode ^= 1;
    }
   } else {
    t2p->pdf_colorspace=T2P_CS_GRAY;
    if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){
     t2p->pdf_switchdecode ^= 1;
    }
   }
   break;
  case PHOTOMETRIC_RGB:
   t2p->pdf_colorspace=T2P_CS_RGB;
   if(t2p->tiff_samplesperpixel == 3){
    break;
   }
   if(TIFFGetField(input, TIFFTAG_INDEXED, &var_119)){
    if(var_119==1)
     goto photometric_palette;
   }
   if(t2p->tiff_samplesperpixel > 3) {
    if(t2p->tiff_samplesperpixel == 4) {
     t2p->pdf_colorspace = T2P_CS_RGB;
     if(TIFFGetField(input,
       TIFFTAG_EXTRASAMPLES,
       &var_119, &xuint16p)
        && var_119 == 1) {
      if(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA){
       if( t2p->tiff_bitspersample != 8 )
       {
           TIFFError(
            "tiff2pdf",
            "No support for BitsPerSample=%d for RGBA",
            t2p->tiff_bitspersample);
           t2p->t2p_error = T2P_ERR_ERROR;
           return;
       }
       t2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;
       break;
      }
      if(xuint16p[0] == EXTRASAMPLE_UNASSALPHA){
       if( t2p->tiff_bitspersample != 8 )
       {
           TIFFError(
            "tiff2pdf",
            "No support for BitsPerSample=%d for RGBA",
            t2p->tiff_bitspersample);
           t2p->t2p_error = T2P_ERR_ERROR;
           return;
       }
       t2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;
       break;
      }
      TIFFWarning(
       "tiff2pdf",
       "RGB image %s has 4 samples per pixel, assuming RGBA",
       TIFFFileName(input));
       break;
     }
     t2p->pdf_colorspace=T2P_CS_CMYK;
     t2p->pdf_switchdecode ^= 1;
     TIFFWarning(
      "tiff2pdf",
      "RGB image %s has 4 samples per pixel, assuming inverse CMYK",
     TIFFFileName(input));
     break;
    } else {
     TIFFError(
      "tiff2pdf",
      "No support for RGB image %s with %u samples per pixel",
      TIFFFileName(input),
      t2p->tiff_samplesperpixel);
     t2p->t2p_error = T2P_ERR_ERROR;
     break;
    }
   } else {
    TIFFError(
     "tiff2pdf",
     "No support for RGB image %s with %u samples per pixel",
     TIFFFileName(input),
     t2p->tiff_samplesperpixel);
    t2p->t2p_error = T2P_ERR_ERROR;
    break;
   }
  case PHOTOMETRIC_PALETTE:
   photometric_palette:
   if(t2p->tiff_samplesperpixel!=1){
    TIFFError(
     "tiff2pdf",
     "No support for palettized image %s with not one sample per pixel",
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
   }
   t2p->pdf_colorspace=T2P_CS_RGB | T2P_CS_PALETTE;
   t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;
   if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b)){
    TIFFError(
     "tiff2pdf",
     "Palettized image %s has no color map",
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
   }
   if(t2p->pdf_palette != NULL){
    _TIFFfree(t2p->pdf_palette);
    t2p->pdf_palette=NULL;
   }
   t2p->pdf_palette = (unsigned char*)
    _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,3));
   if(t2p->pdf_palette==NULL){
    TIFFError(
     "tiff2pdf",
     "Can't allocate %u bytes of memory for t2p_read_tiff_image, %s",
     t2p->pdf_palettesize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
   }
   for(var_186=0;var_186<t2p->pdf_palettesize;var_186++){
    t2p->pdf_palette[(var_186*3)] = (unsigned char) (r[var_186]>>8);
    t2p->pdf_palette[(var_186*3)+1]= (unsigned char) (g[var_186]>>8);
    t2p->pdf_palette[(var_186*3)+2]= (unsigned char) (b[var_186]>>8);
   }
   t2p->pdf_palettesize *= 3;
   break;
  case PHOTOMETRIC_SEPARATED:
   if(TIFFGetField(input, TIFFTAG_INDEXED, &var_119)){
    if(var_119==1){
      goto photometric_palette_cmyk;
    }
   }
   if( TIFFGetField(input, TIFFTAG_INKSET, &var_119) ){
    if(var_119 != INKSET_CMYK){
     TIFFError(
      "tiff2pdf",
      "No support for %s because its inkset is not CMYK",
      TIFFFileName(input) );
     t2p->t2p_error = T2P_ERR_ERROR;
     return;
    }
   }
   if(t2p->tiff_samplesperpixel==4){
    t2p->pdf_colorspace=T2P_CS_CMYK;
   } else {
    TIFFError(
     "tiff2pdf",
     "No support for %s because it has %u samples per pixel",
     TIFFFileName(input),
     t2p->tiff_samplesperpixel);
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
   }
   break;
   photometric_palette_cmyk:
   if(t2p->tiff_samplesperpixel!=1){
    TIFFError(
     "tiff2pdf",
     "No support for palettized CMYK image %s with not one sample per pixel",
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
   }
   t2p->pdf_colorspace=T2P_CS_CMYK | T2P_CS_PALETTE;
   t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;
   if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b, &a)){
    TIFFError(
     "tiff2pdf",
     "Palettized image %s has no color map",
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
   }
   if(t2p->pdf_palette != NULL){
    _TIFFfree(t2p->pdf_palette);
    t2p->pdf_palette=NULL;
   }
   t2p->pdf_palette = (unsigned char*)
    _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,4));
   if(t2p->pdf_palette==NULL){
    TIFFError(
     "tiff2pdf",
     "Can't allocate %u bytes of memory for t2p_read_tiff_image, %s",
     t2p->pdf_palettesize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
   }
   for(var_186=0;var_186<t2p->pdf_palettesize;var_186++){
    t2p->pdf_palette[(var_186*4)] = (unsigned char) (r[var_186]>>8);
    t2p->pdf_palette[(var_186*4)+1]= (unsigned char) (g[var_186]>>8);
    t2p->pdf_palette[(var_186*4)+2]= (unsigned char) (b[var_186]>>8);
    t2p->pdf_palette[(var_186*4)+3]= (unsigned char) (a[var_186]>>8);
   }
   t2p->pdf_palettesize *= 4;
   break;
  case PHOTOMETRIC_YCBCR:
   t2p->pdf_colorspace=T2P_CS_RGB;
   if(t2p->tiff_samplesperpixel==1){
    t2p->pdf_colorspace=T2P_CS_GRAY;
    t2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;
    break;
   }
   t2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;





   break;
  case PHOTOMETRIC_CIELAB:
            if( t2p->tiff_samplesperpixel != 3){
                TIFFError(
                    "tiff2pdf",
                    "Unsupported samplesperpixel = %d for CIELAB",
                    t2p->tiff_samplesperpixel);
                t2p->t2p_error = T2P_ERR_ERROR;
                return;
            }
            if( t2p->tiff_bitspersample != 8){
                TIFFError(
                    "tiff2pdf",
                    "Invalid bitspersample = %d for CIELAB",
                    t2p->tiff_bitspersample);
                t2p->t2p_error = T2P_ERR_ERROR;
                return;
            }
   t2p->pdf_labrange[0]= -127;
   t2p->pdf_labrange[1]= 127;
   t2p->pdf_labrange[2]= -127;
   t2p->pdf_labrange[3]= 127;
   t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;
   t2p->pdf_colorspace=T2P_CS_LAB;
   break;
  case PHOTOMETRIC_ICCLAB:
   t2p->pdf_labrange[0]= 0;
   t2p->pdf_labrange[1]= 255;
   t2p->pdf_labrange[2]= 0;
   t2p->pdf_labrange[3]= 255;
   t2p->pdf_colorspace=T2P_CS_LAB;
   break;
  case PHOTOMETRIC_ITULAB:
            if( t2p->tiff_samplesperpixel != 3){
                TIFFError(
                    "tiff2pdf",
                    "Unsupported samplesperpixel = %d for ITULAB",
                    t2p->tiff_samplesperpixel);
                t2p->t2p_error = T2P_ERR_ERROR;
                return;
            }
            if( t2p->tiff_bitspersample != 8){
                TIFFError(
                    "tiff2pdf",
                    "Invalid bitspersample = %d for ITULAB",
                    t2p->tiff_bitspersample);
                t2p->t2p_error = T2P_ERR_ERROR;
                return;
            }
   t2p->pdf_labrange[0]=-85;
   t2p->pdf_labrange[1]=85;
   t2p->pdf_labrange[2]=-75;
   t2p->pdf_labrange[3]=124;
   t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;
   t2p->pdf_colorspace=T2P_CS_LAB;
   break;
  case PHOTOMETRIC_LOGL:
  case PHOTOMETRIC_LOGLUV:
   TIFFError(
    "tiff2pdf",
    "No support for %s with photometric interpretation LogL/LogLuv",
    TIFFFileName(input));
   t2p->t2p_error = T2P_ERR_ERROR;
   return;
  default:
   TIFFError(
    "tiff2pdf",
    "No support for %s with photometric interpretation %u",
    TIFFFileName(input),
    t2p->tiff_photometric);
   t2p->t2p_error = T2P_ERR_ERROR;
   return;
 }

 if(TIFFGetField(input, TIFFTAG_PLANARCONFIG, &(t2p->tiff_planar))){
  switch(t2p->tiff_planar){
   case 0:
    TIFFWarning(
     "tiff2pdf",
     "Image %s has planar configuration 0, assuming 1",
     TIFFFileName(input));
    t2p->tiff_planar=PLANARCONFIG_CONTIG;
   case PLANARCONFIG_CONTIG:
    break;
   case PLANARCONFIG_SEPARATE:
    t2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;
    if(t2p->tiff_bitspersample!=8){
     TIFFError(
      "tiff2pdf",
      "No support for %s with separated planar configuration and %u bits per sample",
      TIFFFileName(input),
      t2p->tiff_bitspersample);
     t2p->t2p_error = T2P_ERR_ERROR;
     return;
    }
    break;
   default:
    TIFFError(
     "tiff2pdf",
     "No support for %s with planar configuration %u",
     TIFFFileName(input),
     t2p->tiff_planar);
    t2p->t2p_error = T2P_ERR_ERROR;
    return;
  }
 }

        TIFFGetFieldDefaulted(input, TIFFTAG_ORIENTATION,
                              &(t2p->tiff_orientation));
        if(t2p->tiff_orientation>8){
                TIFFWarning("tiff2pdf",
                            "Image %s has orientation %u, assuming 0",
                            TIFFFileName(input), t2p->tiff_orientation);
                t2p->tiff_orientation=0;
        }

        if(TIFFGetField(input, TIFFTAG_XRESOLUTION, &(t2p->tiff_xres) ) == 0){
                t2p->tiff_xres=0.0;
        }
        if(TIFFGetField(input, TIFFTAG_YRESOLUTION, &(t2p->tiff_yres) ) == 0){
                t2p->tiff_yres=0.0;
        }
 TIFFGetFieldDefaulted(input, TIFFTAG_RESOLUTIONUNIT,
         &(t2p->tiff_resunit));
 if(t2p->tiff_resunit == RESUNIT_CENTIMETER) {
  t2p->tiff_xres *= 2.54F;
  t2p->tiff_yres *= 2.54F;
 } else if (t2p->tiff_resunit != RESUNIT_INCH
     && t2p->pdf_centimeters != 0) {
  t2p->tiff_xres *= 2.54F;
  t2p->tiff_yres *= 2.54F;
 }

 t2p_compose_pdf_page(t2p);
        if( t2p->t2p_error == T2P_ERR_ERROR )
     return;

 t2p->pdf_transcode = T2P_TRANSCODE_ENCODE;
 if(t2p->pdf_nopassthrough==0){

  (void)0;
 }

 if(t2p->pdf_transcode!=T2P_TRANSCODE_RAW){
  t2p->pdf_compression = t2p->pdf_defaultcompression;
 }

 if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){
  if(t2p->pdf_colorspace & T2P_CS_CMYK){
   t2p->tiff_samplesperpixel=4;
   t2p->tiff_photometric=PHOTOMETRIC_SEPARATED;
  } else {
   t2p->tiff_samplesperpixel=3;
   t2p->tiff_photometric=PHOTOMETRIC_RGB;
  }
 }

 if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,
    &(t2p->tiff_transferfunction[0]),
    &(t2p->tiff_transferfunction[1]),
    &(t2p->tiff_transferfunction[2]))) {
  if((t2p->tiff_transferfunction[1] != (float*) NULL) &&
                   (t2p->tiff_transferfunction[2] != (float*) NULL) &&
                   (t2p->tiff_transferfunction[1] !=
                    t2p->tiff_transferfunction[0])) {
   t2p->tiff_transferfunctioncount=3;
  } else {
   t2p->tiff_transferfunctioncount=1;
  }
 } else {
  t2p->tiff_transferfunctioncount=0;
 }
 if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp)!=0){
  t2p->tiff_whitechromaticities[0]=xfloatp[0];
  t2p->tiff_whitechromaticities[1]=xfloatp[1];
  if(t2p->pdf_colorspace & T2P_CS_GRAY){
   t2p->pdf_colorspace |= T2P_CS_CALGRAY;
  }
  if(t2p->pdf_colorspace & T2P_CS_RGB){
   t2p->pdf_colorspace |= T2P_CS_CALRGB;
  }
 }
 if(TIFFGetField(input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0){
  t2p->tiff_primarychromaticities[0]=xfloatp[0];
  t2p->tiff_primarychromaticities[1]=xfloatp[1];
  t2p->tiff_primarychromaticities[2]=xfloatp[2];
  t2p->tiff_primarychromaticities[3]=xfloatp[3];
  t2p->tiff_primarychromaticities[4]=xfloatp[4];
  t2p->tiff_primarychromaticities[5]=xfloatp[5];
  if(t2p->pdf_colorspace & T2P_CS_RGB){
   t2p->pdf_colorspace |= T2P_CS_CALRGB;
  }
 }
 if(t2p->pdf_colorspace & T2P_CS_LAB){
  if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp) != 0){
   t2p->tiff_whitechromaticities[0]=xfloatp[0];
   t2p->tiff_whitechromaticities[1]=xfloatp[1];
  } else {
   t2p->tiff_whitechromaticities[0]=0.3457F;
   t2p->tiff_whitechromaticities[1]=0.3585F;
  }
 }
 if(TIFFGetField(input,
  TIFFTAG_ICCPROFILE,
  &(t2p->tiff_iccprofilelength),
  &(t2p->tiff_iccprofile))!=0){
  t2p->pdf_colorspace |= T2P_CS_ICCBASED;
 } else {
  t2p->tiff_iccprofilelength=0;
  t2p->tiff_iccprofile=NULL;
 }

 return;
}






void fn_119(T2P* t2p, TIFF* input){

 uint64* sbc=NULL;





        uint64 var_122 = 0;

 if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){

  (void) 0;
 }
 var_122 = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
 if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
  var_122 = checkMultiply64(var_122, t2p->tiff_samplesperpixel, t2p);
 }
 if (var_122 == 0) {

  t2p->t2p_error = T2P_ERR_ERROR;
 }

 t2p->tiff_datasize = (tsize_t) var_122;
 if ((uint64) t2p->tiff_datasize != var_122) {
  TIFFError("tiff2pdf", "Integer overflow");
  t2p->t2p_error = T2P_ERR_ERROR;
 }

 return;
}






void fn_120(T2P* t2p, TIFF* input, ttile_t var_185){

 uint64* tbc = NULL;
 uint16 var_135=0;



        uint64 var_122;

 var_135 |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], var_185);
 var_135 |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], var_185);

 if(t2p->pdf_transcode==T2P_TRANSCODE_RAW){
  if(var_135



  ){
   t2p->tiff_datasize=TIFFTileSize(input);
   if (t2p->tiff_datasize == 0) {

    t2p->t2p_error = T2P_ERR_ERROR;
   }
   return;
  } else {
   TIFFGetField(input, TIFFTAG_TILEBYTECOUNTS, &tbc);
   var_122=tbc[var_185];

   t2p->tiff_datasize = (tsize_t) var_122;
   if ((uint64) t2p->tiff_datasize != var_122) {
    TIFFError("tiff2pdf", "Integer overflow");
    t2p->t2p_error = T2P_ERR_ERROR;
   }
   return;
  }
 }
 var_122 = TIFFTileSize(input);
 if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
  var_122 = checkMultiply64(var_122, t2p->tiff_samplesperpixel, t2p);
 }
 if (var_122 == 0) {

  t2p->t2p_error = T2P_ERR_ERROR;
 }

 t2p->tiff_datasize = (tsize_t) var_122;
 if ((uint64) t2p->tiff_datasize != var_122) {
  TIFFError("tiff2pdf", "Integer overflow");
  t2p->t2p_error = T2P_ERR_ERROR;
 }

 return;
}






int fn_122(T2P_TILES var_161, ttile_t var_185){

 if( ((var_185+1) % var_161.tiles_tilecountx == 0)
  && (var_161.tiles_edgetilewidth != 0) ){
  return1;
 } else {
  return0;
 }
}






int fn_123(T2P_TILES var_161, ttile_t var_185){

 if( ((var_185+1) > (var_161.tiles_tilecount-var_161.tiles_tilecountx) )
  && (var_161.tiles_edgetilelength != 0) ){
  return1;
 } else {
  return0;
 }
}






int fn_123(T2P_TILES var_161, ttile_t var_185){

 return(t2p_tile_is_right_edge(var_161, var_185) | t2p_tile_is_bottom_edge(var_161, var_185) );
}






int fn_123(T2P_TILES var_161, ttile_t var_185){

 return(t2p_tile_is_right_edge(var_161, var_185) & t2p_tile_is_bottom_edge(var_161, var_185) );
}

tsize_t fn_123(T2P* t2p, TIFF* input, TIFF* output){

 tsize_t var_186=0;
 unsigned char* var_185=NULL;
 unsigned char* samplebuffer=NULL;
 tsize_t var_135=0;
 tsize_t var_135=0;
 tsize_t var_135=0;
 tstrip_t var_186=0;
 tstrip_t var_146=0;
 tstrip_t var_132=0;
 tsize_t var_132=0;
 tsize_t var_132=0;
 tsize_t var_132=0;

 if (t2p->t2p_error != T2P_ERR_OK)
  return0;

 if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){

  (void)0;
 }

 if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
  var_185 = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
  if(var_185==NULL){
   TIFFError("tiff2pdf",
 "Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s",
    (unsigned long) t2p->tiff_datasize,
    TIFFFileName(input));
   t2p->t2p_error = T2P_ERR_ERROR;
   return0;
  }
                memset(var_185, 0, t2p->tiff_datasize);
  var_132=TIFFStripSize(input);
  var_132=TIFFNumberOfStrips(input);
  for(var_186=0;var_186<var_132;var_186++){
   var_135 =
    TIFFReadEncodedStrip(input,
    var_186,
    (tdata_t) &var_185[var_135],
    TIFFmin(var_132, t2p->tiff_datasize - var_135));
   if(var_135==-1){
    TIFFError("tiff2pdf",
     "Error on decoding strip %u of %s",
     var_186,
     TIFFFileName(input));
    _TIFFfree(var_185);
    t2p->t2p_error=T2P_ERR_ERROR;
    return0;
   }
   var_135+=var_135;
  }
 } else {
  if(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){

   var_132=TIFFStripSize(input);
   var_132=TIFFNumberOfStrips(input);

   var_132=var_132*t2p->tiff_samplesperpixel;
   var_132=var_132/t2p->tiff_samplesperpixel;

   var_185 = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
   if(var_185==NULL){
    TIFFError("tiff2pdf",
 "Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s",
     (unsigned long) t2p->tiff_datasize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return0;
   }
                        memset(var_185, 0, t2p->tiff_datasize);
   samplebuffer = (unsigned char*) _TIFFmalloc(var_132);
   if(samplebuffer==NULL){
    TIFFError("tiff2pdf",
 "Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s",
     (unsigned long) t2p->tiff_datasize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
                                _TIFFfree(var_185);
    return0;
   }
   for(var_186=0;var_186<var_132;var_186++){
    var_135=0;
    for(var_146=0;var_146<t2p->tiff_samplesperpixel;var_146++){
     var_135 =
      TIFFReadEncodedStrip(input,
       var_186 + var_146*var_132,
       (tdata_t) &(samplebuffer[var_135]),
       TIFFmin(var_132, var_132 - var_135));
     if(var_135==-1){
      TIFFError("tiff2pdf",
     "Error on decoding strip %u of %s",
       var_186 + var_146*var_132,
       TIFFFileName(input));
       _TIFFfree(var_185);
      t2p->t2p_error=T2P_ERR_ERROR;
      return0;
     }
     var_135+=var_135;
    }
    t2p_sample_planar_separate_to_contig(
     t2p,
     &(var_185[var_135]),
     samplebuffer,
     var_135);
    var_135+=var_135;
   }
   _TIFFfree(samplebuffer);
   goto dataready;
  }

  var_185 = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
  if(var_185==NULL){
   TIFFError("tiff2pdf",
 "Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s",
    (unsigned long) t2p->tiff_datasize,
    TIFFFileName(input));
   t2p->t2p_error = T2P_ERR_ERROR;
   return0;
  }
                memset(var_185, 0, t2p->tiff_datasize);
  var_132=TIFFStripSize(input);
  var_132=TIFFNumberOfStrips(input);
  for(var_186=0;var_186<var_132;var_186++){
   var_135 =
    TIFFReadEncodedStrip(input,
    var_186,
    (tdata_t) &var_185[var_135],
    TIFFmin(var_132, t2p->tiff_datasize - var_135));
   if(var_135==-1){
    TIFFError("tiff2pdf",
     "Error on decoding strip %u of %s",
     var_186,
     TIFFFileName(input));
    _TIFFfree(samplebuffer);
    _TIFFfree(var_185);
    t2p->t2p_error=T2P_ERR_ERROR;
    return0;
   }
   var_135+=var_135;
  }

  if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){

   samplebuffer=(unsigned char*)_TIFFrealloc(
    (tdata_t) var_185,
    t2p->tiff_datasize * t2p->tiff_samplesperpixel);
   if(samplebuffer==NULL){
    TIFFError("tiff2pdf",
 "Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s",
     (unsigned long) t2p->tiff_datasize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    _TIFFfree(var_185);
    return0;
   } else {
    var_185=samplebuffer;
    t2p->tiff_datasize *= t2p->tiff_samplesperpixel;
   }
   t2p_sample_realize_palette(t2p, var_185);
  }

  if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
   t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
    (tdata_t)var_185,
    t2p->tiff_width*t2p->tiff_length);
  }

  if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
   t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
    (tdata_t)var_185,
    t2p->tiff_width*t2p->tiff_length);
  }

  if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
   samplebuffer=(unsigned char*)_TIFFrealloc(
    (tdata_t)var_185,
    t2p->tiff_width*t2p->tiff_length*4);
   if(samplebuffer==NULL){
    TIFFError("tiff2pdf",
 "Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s",
     (unsigned long) t2p->tiff_datasize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    _TIFFfree(var_185);
    return0;
   } else {
    var_185=samplebuffer;
   }
   if(!TIFFReadRGBAImageOriented(
    input,
    t2p->tiff_width,
    t2p->tiff_length,
    (uint32*)var_185,
    ORIENTATION_TOPLEFT,
    0)){
    TIFFError("tiff2pdf",
 "Can't use TIFFReadRGBAImageOriented to extract RGB image from %s",
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return0;
   }
   t2p->tiff_datasize=t2p_sample_abgr_to_rgb(
    (tdata_t) var_185,
    t2p->tiff_width*t2p->tiff_length);

  }

  if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
   t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
    (tdata_t)var_185,
    t2p->tiff_width*t2p->tiff_length);
  }
 }

dataready:

 t2p_disable(output);
 TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
 TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
 TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
 TIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);
 TIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);
 TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);
 TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
 TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);

 switch(t2p->pdf_compression){
 case T2P_COMPRESS_NONE:
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
  break;

 default:
  break;
 }

 t2p_enable(output);
 t2p->outputwritten = 0;

        {
  var_135 = TIFFWriteEncodedStrip(output, (tstrip_t)0,
           var_185,
           t2p->tiff_datasize);
 }
 if (var_185 != NULL) {
  _TIFFfree(var_185);
  var_185=NULL;
 }

 if (var_135 == (tsize_t)-1) {
  TIFFError("tiff2pdf",
     "Error writing encoded strip to output PDF %s",
     TIFFFileName(output));
  t2p->t2p_error = T2P_ERR_ERROR;
  return0;
 }

 var_186 = t2p->outputwritten;
 return(var_186);
}







tsize_t fn_132(T2P* t2p, TIFF* input, TIFF* output, ttile_t var_185){

 uint16 var_135=0;
 tsize_t var_186=0;
 unsigned char* var_185=NULL;
 tsize_t var_135=0;
 unsigned char* samplebuffer=NULL;
 tsize_t var_135=0;
 tsize_t var_135=0;
 uint16 var_186=0;
 ttile_t var_135=0;

 ttile_t var_135=0;
 tsize_t var_135=0;







 if (t2p->t2p_error != T2P_ERR_OK)
  return0;

 var_135 |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], var_185);
 var_135 |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], var_185);

 if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((var_135 == 0)



 )
 ){

  (void)0;
 }

 if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
  var_185 = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
  if(var_185==NULL){
   TIFFError("tiff2pdf",
    "Can't allocate %lu bytes of memory for "
                                "t2p_readwrite_pdf_image_tile, %s",
    (unsigned long) t2p->tiff_datasize,
    TIFFFileName(input));
   t2p->t2p_error = T2P_ERR_ERROR;
   return0;
  }

  var_135 = TIFFReadEncodedTile(
   input,
   var_185,
   (tdata_t) &var_185[var_135],
   t2p->tiff_datasize);
  if(var_135==-1){
   TIFFError("tiff2pdf",
    "Error on decoding tile %u of %s",
    var_185,
    TIFFFileName(input));
   _TIFFfree(var_185);
   t2p->t2p_error=T2P_ERR_ERROR;
   return0;
  }

 } else {

  if(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
   var_135=TIFFTileSize(input);
   var_135=TIFFNumberOfTiles(input);

   var_135=var_135/t2p->tiff_samplesperpixel;
   var_185 = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
   if(var_185==NULL){
    TIFFError("tiff2pdf",
     "Can't allocate %lu bytes of memory "
                                        "for t2p_readwrite_pdf_image_tile, %s",
     (unsigned long) t2p->tiff_datasize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return0;
   }
   samplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
   if(samplebuffer==NULL){
    TIFFError("tiff2pdf",
     "Can't allocate %lu bytes of memory "
                                        "for t2p_readwrite_pdf_image_tile, %s",
     (unsigned long) t2p->tiff_datasize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return0;
   }
   var_135=0;
   for(var_186=0;var_186<t2p->tiff_samplesperpixel;var_186++){
    var_135 =
     TIFFReadEncodedTile(input,
      var_185 + var_186*var_135,
      (tdata_t) &(samplebuffer[var_135]),
      var_135);
    if(var_135==-1){
     TIFFError("tiff2pdf",
      "Error on decoding tile %u of %s",
      var_185 + var_186*var_135,
      TIFFFileName(input));
      _TIFFfree(samplebuffer);
      _TIFFfree(var_185);
     t2p->t2p_error=T2P_ERR_ERROR;
     return0;
    }
    var_135+=var_135;
   }
   t2p_sample_planar_separate_to_contig(
    t2p,
    &(var_185[var_135]),
    samplebuffer,
    var_135);
   var_135+=var_135;
   _TIFFfree(samplebuffer);
  }

  if(var_185==NULL){
   var_185 = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
   if(var_185==NULL){
    TIFFError("tiff2pdf",
     "Can't allocate %lu bytes of memory "
                                        "for t2p_readwrite_pdf_image_tile, %s",
     (unsigned long) t2p->tiff_datasize,
     TIFFFileName(input));
    t2p->t2p_error = T2P_ERR_ERROR;
    return0;
   }
   var_135 = TIFFReadEncodedTile(
    input,
    var_185,
    (tdata_t) &var_185[var_135],
    t2p->tiff_datasize);
   if(var_135==-1){
    TIFFError("tiff2pdf",
     "Error on decoding tile %u of %s",
     var_185,
     TIFFFileName(input));
    _TIFFfree(var_185);
    t2p->t2p_error=T2P_ERR_ERROR;
    return0;
   }
  }

  if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
   t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
    (tdata_t)var_185,
    t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
  }

  if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
   t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
    (tdata_t)var_185,
    t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
  }

  if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
   TIFFError("tiff2pdf",
    "No support for YCbCr to RGB in tile for %s",
    TIFFFileName(input));
   _TIFFfree(var_185);
   t2p->t2p_error = T2P_ERR_ERROR;
   return0;
  }

  if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
   t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
    (tdata_t)var_185,
    t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    *t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
  }
 }

 if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], var_185) != 0){
  t2p_tile_collapse_left(
   var_185,
   TIFFTileRowSize(input),
   t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,
   t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth,
   t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
 }


 t2p_disable(output);
 TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
 TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
 TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
 if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], var_185) == 0){
  TIFFSetField(
   output,
   TIFFTAG_IMAGEWIDTH,
   t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
 } else {
  TIFFSetField(
   output,
   TIFFTAG_IMAGEWIDTH,
   t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
 }
 if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], var_185) == 0){
  TIFFSetField(
   output,
   TIFFTAG_IMAGELENGTH,
   t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
  TIFFSetField(
   output,
   TIFFTAG_ROWSPERSTRIP,
   t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
 } else {
  TIFFSetField(
   output,
   TIFFTAG_IMAGELENGTH,
   t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
  TIFFSetField(
   output,
   TIFFTAG_ROWSPERSTRIP,
   t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
 }
 TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
 TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);

 switch(t2p->pdf_compression){
 case T2P_COMPRESS_NONE:
  TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
  break;

 default:
  break;
 }

 t2p_enable(output);
 t2p->outputwritten = 0;
 var_135 = TIFFWriteEncodedStrip(output, (tstrip_t) 0, var_185,
          TIFFStripSize(output));
 if (var_185 != NULL) {
  _TIFFfree(var_185);
  var_185 = NULL;
 }
 if (var_135 == -1) {
  TIFFError("tiff2pdf",
     "Error writing encoded tile to output PDF %s",
     TIFFFileName(output));
  t2p->t2p_error = T2P_ERR_ERROR;
  return0;
 }

 var_186 = t2p->outputwritten;

 return(var_186);
}

void fn_135(
 tdata_t var_185,
 tsize_t var_140,
 uint32 var_161,
 uint32 var_140,
 uint32 var_161){

 uint32 var_186;
 tsize_t var_140=0;

 var_140 = (var_140 * var_140 + (var_161 - 1))/ var_161;
 for(var_186=0;var_186<var_161;var_186++){
  _TIFFmemcpy(
   &(((char*)var_185)[var_140*var_186]),
   &(((char*)var_185)[var_140*var_186]),
   var_140);
 }

 return;
}

void
fn_140(T2P* t2p, TIFF* output)
{
 t2p_disable(output);
 if(!TIFFWriteDirectory(output)){
  TIFFError("tiff2pdf",
   "Error writing virtual directory to output PDF %s",
   TIFFFileName(output));
  t2p->t2p_error = T2P_ERR_ERROR;
  return;
 }
 t2p_enable(output);
 return;
}

tsize_t fn_140(
           T2P* t2p,
           unsigned char* var_185,
           unsigned char* samplebuffer,
           tsize_t var_142){

 tsize_t var_142=0;
 tsize_t var_186=0;
 tsize_t var_146=0;

 var_142=var_142/t2p->tiff_samplesperpixel;
 for(var_186=0;var_186<var_142;var_186++){
  for(var_146=0;var_146<t2p->tiff_samplesperpixel;var_146++){
   var_185[var_186*t2p->tiff_samplesperpixel + var_146] = samplebuffer[var_186 + var_146*var_142];
  }
 }

 return(var_142);
}

tsize_t fn_142(T2P* t2p, unsigned char* var_185){

 uint32 var_146=0;
 uint16 var_146=0;
 uint32 var_146=0;
 uint32 var_146=0;
 uint32 var_186=0;
 uint32 var_146=0;
 var_146=t2p->tiff_width*t2p->tiff_length;
 var_146=t2p->tiff_samplesperpixel;

 for(var_186=var_146;var_186>0;var_186--){
  var_146=var_185[var_186-1] * var_146;
  var_146= (var_186-1) * var_146;
  for(var_146=0;var_146<var_146;var_146++){
   var_185[var_146+var_146]=t2p->pdf_palette[var_146+var_146];
  }
 }

 return0;
}






tsize_t fn_146(tdata_t var_149, uint32 var_149)
{
 uint32 var_186=0;
 uint32 var_149=0;

 for(var_186=0;var_186<var_149;var_186++){
  var_149=((uint32*)var_149)[var_186];
  ((char*)var_149)[var_186*3]= (char) (var_149 & 0xff);
  ((char*)var_149)[var_186*3+1]= (char) ((var_149>>8) & 0xff);
  ((char*)var_149)[var_186*3+2]= (char) ((var_149>>16) & 0xff);
 }

 return(var_186*3);
}






tsize_t
fn_148(tdata_t var_149, uint32 var_149)
{
 uint32 var_186;

 for(var_186 = 0; var_186 < var_149; var_186++)
  memcpy((uint8*)var_149 + var_186 * 3, (uint8*)var_149 + var_186 * 4, 3);

 return(var_186 * 3);
}






tsize_t
fn_148(tdata_t var_149, uint32 var_149)
{
 uint32 var_186 = 0;
 uint32 var_149 = 0;
 uint8 var_149 = 0;

 for (var_186 = 0; var_186 < var_149; var_186++) {
  var_149=((uint32*)var_149)[var_186];
  var_149=(uint8)((255 - ((var_149 >> 24) & 0xff)));
  ((uint8 *)var_149)[var_186 * 3] = (uint8) ((var_149 >> 16) & 0xff) + var_149;
  ((uint8 *)var_149)[var_186 * 3 + 1] = (uint8) ((var_149 >> 8) & 0xff) + var_149;
  ((uint8 *)var_149)[var_186 * 3 + 2] = (uint8) (var_149 & 0xff) + var_149;
 }

 return (var_186 * 3);
}






tsize_t fn_149(tdata_t var_185, uint32 var_149){

 uint32 var_186=0;

 for(var_186=0;var_186<var_149;var_186++){
  if( (((unsigned char*)var_185)[(var_186*3)+1] & 0x80) !=0){
   ((unsigned char*)var_185)[(var_186*3)+1] =
    (unsigned char)(0x80 + ((char*)var_185)[(var_186*3)+1]);
  } else {
   ((unsigned char*)var_185)[(var_186*3)+1] |= 0x80;
  }
  if( (((unsigned char*)var_185)[(var_186*3)+2] & 0x80) !=0){
   ((unsigned char*)var_185)[(var_186*3)+2] =
    (unsigned char)(0x80 + ((char*)var_185)[(var_186*3)+2]);
  } else {
   ((unsigned char*)var_185)[(var_186*3)+2] |= 0x80;
  }
 }

 return(var_149*3);
}





tsize_t fn_149(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 char var_185[16];
 int var_185=0;

 var_185 = snprintf(var_185, sizeof(var_185), "%%PDF-%u.%u ",
     t2p->pdf_majorversion&0xff,
     t2p->pdf_minorversion&0xff);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t)"\n%\342\343\317\323\n", 7);

 return(var_186);
}





tsize_t t2p_write_pdf_obj_start(uint32 number, TIFF* output){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;

 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)number);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if (((T2P*)NULL) != NULL) ((T2P*)NULL)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185 );
 var_186 += t2pWriteFile(output, (tdata_t) " 0 obj\n", 7);

 return(var_186);
}





tsize_t t2p_write_pdf_obj_end(TIFF* output){

 tsize_t var_186=0;

 var_186 += t2pWriteFile(output, (tdata_t) "endobj\n", 7);

 return(var_186);
}





tsize_t t2p_write_pdf_name(unsigned char* name, TIFF* output){

 tsize_t var_186=0;
 uint32 var_186=0;
 char var_185[64];
 uint16 var_152=0;
 size_t var_152=0;

 var_152 = strlen((char *)name);
 if (var_152>126) {
  var_152=126;
 }
 var_186 += t2pWriteFile(output, (tdata_t) "/", 1);
 for (var_186=0;var_186<var_152;var_186++){
  if ( ((unsigned char)name[var_186]) < 0x21){
   snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
   var_185[sizeof(var_185) - 1] = '\0';
   var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
   var_152=1;
  }
  if ( ((unsigned char)name[var_186]) > 0x7E){
   snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
   var_185[sizeof(var_185) - 1] = '\0';
   var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
   var_152=1;
  }
  if (var_152==0){
   switch (name[var_186]){
    case 0x23:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x25:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x28:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x29:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x2F:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x3C:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x3E:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x5B:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x5D:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x7B:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    case 0x7D:
     snprintf(var_185, sizeof(var_185), "#%.2X", name[var_186]);
     var_185[sizeof(var_185) - 1] = '\0';
     var_186 += t2pWriteFile(output, (tdata_t) var_185, 3);
     break;
    default:
     var_186 += t2pWriteFile(output, (tdata_t) &name[var_186], 1);
   }
  }
  var_152=0;
 }
 var_186 += t2pWriteFile(output, (tdata_t) " ", 1);

 return(var_186);
}





tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output)
{
 tsize_t var_186 = 0;
 uint32 var_186 = 0;
 char var_185[64];
 size_t var_152 = 0;

 var_152 = strlen(pdfstr);
 var_186 += t2pWriteFile(output, (tdata_t) "(", 1);
 for (var_186=0; var_186<var_152; var_186++) {
  if((pdfstr[var_186]&0x80) || (pdfstr[var_186]==127) || (pdfstr[var_186]<32)){
   snprintf(var_185, sizeof(var_185), "\\%.3o", ((unsigned char)pdfstr[var_186]));
   var_186 += t2pWriteFile(output, (tdata_t)var_185, 4);
  } else {
   switch (pdfstr[var_186]){
    case 0x08:
     var_186 += t2pWriteFile(output, (tdata_t) "\\b", 2);
     break;
    case 0x09:
     var_186 += t2pWriteFile(output, (tdata_t) "\\t", 2);
     break;
    case 0x0A:
     var_186 += t2pWriteFile(output, (tdata_t) "\\n", 2);
     break;
    case 0x0C:
     var_186 += t2pWriteFile(output, (tdata_t) "\\f", 2);
     break;
    case 0x0D:
     var_186 += t2pWriteFile(output, (tdata_t) "\\r", 2);
     break;
    case 0x28:
     var_186 += t2pWriteFile(output, (tdata_t) "\\(", 2);
     break;
    case 0x29:
     var_186 += t2pWriteFile(output, (tdata_t) "\\)", 2);
     break;
    case 0x5C:
     var_186 += t2pWriteFile(output, (tdata_t) "\\\\", 2);
     break;
    default:
     var_186 += t2pWriteFile(output, (tdata_t) &pdfstr[var_186], 1);
   }
  }
 }
 var_186 += t2pWriteFile(output, (tdata_t) ") ", 1);

 return(var_186);
}






tsize_t t2p_write_pdf_stream(tdata_t var_185, tsize_t var_152, TIFF* output){

 tsize_t var_186=0;

 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_152);

 return(var_186);
}





tsize_t t2p_write_pdf_stream_start(TIFF* output){

 tsize_t var_186=0;

 var_186 += t2pWriteFile(output, (tdata_t) "stream\n", 7);

 return(var_186);
}





tsize_t t2p_write_pdf_stream_end(TIFF* output){

 tsize_t var_186=0;

 var_186 += t2pWriteFile(output, (tdata_t) "\nendstream\n", 11);

 return(var_186);
}





tsize_t t2p_write_pdf_stream_dict(tsize_t var_152, uint32 number, TIFF* output){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;

 var_186 += t2pWriteFile(output, (tdata_t) "/Length ", 8);
 if(var_152!=0){
  var_186 += t2p_write_pdf_stream_length(var_152, output);
 } else {
  var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)number);
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if (((T2P*)NULL) != NULL) ((T2P*)NULL)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
 }

 return(var_186);
}





tsize_t t2p_write_pdf_stream_dict_start(TIFF* output){

 tsize_t var_186=0;

 var_186 += t2pWriteFile(output, (tdata_t) "<< \n", 4);

 return(var_186);
}





tsize_t t2p_write_pdf_stream_dict_end(TIFF* output){

 tsize_t var_186=0;

 var_186 += t2pWriteFile(output, (tdata_t) " >>\n", 4);

 return(var_186);
}





tsize_t t2p_write_pdf_stream_length(tsize_t var_152, TIFF* output){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;

 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)var_152);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if (((T2P*)NULL) != NULL) ((T2P*)NULL)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);

 return(var_186);
}





tsize_t t2p_write_pdf_catalog(T2P* t2p, TIFF* output)
{
 tsize_t var_186 = 0;
 char var_185[32];
 int var_185 = 0;

 var_186 += t2pWriteFile(output,
  (tdata_t)"<< \n/Type /Catalog \n/Pages ",
  27);
 var_185 = snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->pdf_pages);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185,
    TIFFmin((size_t)var_185, sizeof(var_185) - 1));
 var_186 += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
 if(t2p->pdf_fitwindow){
  var_186 += t2pWriteFile(output,
   (tdata_t) "/ViewerPreferences <</FitWindow true>>\n",
   39);
 }
 var_186 += t2pWriteFile(output, (tdata_t)">>\n", 3);

 return(var_186);
}





tsize_t t2p_write_pdf_info(T2P* t2p, TIFF* input, TIFF* output)
{
 tsize_t var_186 = 0;
 char* info;
 char var_185[512];

 if(t2p->pdf_datetime[0] == '\0')
  t2p_pdf_tifftime(t2p, input);
 if (strlen(t2p->pdf_datetime) > 0) {
  var_186 += t2pWriteFile(output, (tdata_t) "<< \n/CreationDate ", 18);
  var_186 += t2p_write_pdf_string(t2p->pdf_datetime, output);
  var_186 += t2pWriteFile(output, (tdata_t) "\n/ModDate ", 10);
  var_186 += t2p_write_pdf_string(t2p->pdf_datetime, output);
 }
 var_186 += t2pWriteFile(output, (tdata_t) "\n/Producer ", 11);
 snprintf(var_185, sizeof(var_185), "libtiff / tiff2pdf - %d", TIFFLIB_VERSION);
 var_186 += t2p_write_pdf_string(var_185, output);
 var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
 if (t2p->pdf_creator[0] != '\0') {
  var_186 += t2pWriteFile(output, (tdata_t) "/Creator ", 9);
  var_186 += t2p_write_pdf_string(t2p->pdf_creator, output);
  var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
 } else {
  if (TIFFGetField(input, TIFFTAG_SOFTWARE, &info) != 0 && info) {
   if(strlen(info) >= sizeof(t2p->pdf_creator))
    info[sizeof(t2p->pdf_creator) - 1] = '\0';
   var_186 += t2pWriteFile(output, (tdata_t) "/Creator ", 9);
   var_186 += t2p_write_pdf_string(info, output);
   var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
  }
 }
 if (t2p->pdf_author[0] != '\0') {
  var_186 += t2pWriteFile(output, (tdata_t) "/Author ", 8);
  var_186 += t2p_write_pdf_string(t2p->pdf_author, output);
  var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
 } else {
  if ((TIFFGetField(input, TIFFTAG_ARTIST, &info) != 0
       || TIFFGetField(input, TIFFTAG_COPYRIGHT, &info) != 0)
      && info) {
   if (strlen(info) >= sizeof(t2p->pdf_author))
    info[sizeof(t2p->pdf_author) - 1] = '\0';
   var_186 += t2pWriteFile(output, (tdata_t) "/Author ", 8);
   var_186 += t2p_write_pdf_string(info, output);
   var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
  }
 }
 if (t2p->pdf_title[0] != '\0') {
  var_186 += t2pWriteFile(output, (tdata_t) "/Title ", 7);
  var_186 += t2p_write_pdf_string(t2p->pdf_title, output);
  var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
 } else {
  if (TIFFGetField(input, TIFFTAG_DOCUMENTNAME, &info) != 0){
   if(strlen(info) > 511) {
    info[512] = '\0';
   }
   var_186 += t2pWriteFile(output, (tdata_t) "/Title ", 7);
   var_186 += t2p_write_pdf_string(info, output);
   var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
  }
 }
 if (t2p->pdf_subject[0] != '\0') {
  var_186 += t2pWriteFile(output, (tdata_t) "/Subject ", 9);
  var_186 += t2p_write_pdf_string(t2p->pdf_subject, output);
  var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
 } else {
  if (TIFFGetField(input, TIFFTAG_IMAGEDESCRIPTION, &info) != 0 && info) {
   if (strlen(info) >= sizeof(t2p->pdf_subject))
    info[sizeof(t2p->pdf_subject) - 1] = '\0';
   var_186 += t2pWriteFile(output, (tdata_t) "/Subject ", 9);
   var_186 += t2p_write_pdf_string(info, output);
   var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
  }
 }
 if (t2p->pdf_keywords[0] != '\0') {
  var_186 += t2pWriteFile(output, (tdata_t) "/Keywords ", 10);
  var_186 += t2p_write_pdf_string(t2p->pdf_keywords, output);
  var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
 }
 var_186 += t2pWriteFile(output, (tdata_t) ">> \n", 4);

 return(var_186);
}






void t2p_pdf_currenttime(T2P* t2p)
{
 struct struct_152* currenttime;
 time_t timenow;

 if (time(&timenow) == (time_t) -1) {
  TIFFError("tiff2pdf",
     "Can't get the current time: %s", strerror(errno));
  timenow = (time_t) 0;
 }

 currenttime = localtime(&timenow);
 snprintf(t2p->pdf_datetime, sizeof(t2p->pdf_datetime),
   "D:%.4d%.2d%.2d%.2d%.2d%.2d",
   (currenttime->tm_year + 1900) % 65536,
   (currenttime->tm_mon + 1) % 256,
   (currenttime->tm_mday) % 256,
   (currenttime->tm_hour) % 256,
   (currenttime->tm_min) % 256,
   (currenttime->tm_sec) % 256);

 return;
}






void t2p_pdf_tifftime(T2P* t2p, TIFF* input)
{
 char* datetime;

 if (TIFFGetField(input, TIFFTAG_DATETIME, &datetime) != 0
     && (strlen(datetime) >= 19) ){
  t2p->pdf_datetime[0]='D';
  t2p->pdf_datetime[1]=':';
  t2p->pdf_datetime[2]=datetime[0];
  t2p->pdf_datetime[3]=datetime[1];
  t2p->pdf_datetime[4]=datetime[2];
  t2p->pdf_datetime[5]=datetime[3];
  t2p->pdf_datetime[6]=datetime[5];
  t2p->pdf_datetime[7]=datetime[6];
  t2p->pdf_datetime[8]=datetime[8];
  t2p->pdf_datetime[9]=datetime[9];
  t2p->pdf_datetime[10]=datetime[11];
  t2p->pdf_datetime[11]=datetime[12];
  t2p->pdf_datetime[12]=datetime[14];
  t2p->pdf_datetime[13]=datetime[15];
  t2p->pdf_datetime[14]=datetime[17];
  t2p->pdf_datetime[15]=datetime[18];
  t2p->pdf_datetime[16] = '\0';
 } else {
  t2p_pdf_currenttime(t2p);
 }

 return;
}





tsize_t t2p_write_pdf_pages(T2P* t2p, TIFF* output)
{
 tsize_t var_186=0;
 tdir_t var_186=0;
 char var_185[32];
 int var_185=0;

 int var_154=0;
 var_186 += t2pWriteFile(output,
  (tdata_t) "<< \n/Type /Pages \n/Kids [ ", 26);
 var_154 = t2p->pdf_pages+1;
 for (var_186=0;var_186<t2p->tiff_pagecount;var_186++){
  var_185=snprintf(var_185, sizeof(var_185), "%d", var_154);
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
  if ( ((var_186+1)%8)==0 ) {
   var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
  }
  var_154 +=3;
  var_154 += t2p->tiff_pages[var_186].page_extra;
  if(t2p->tiff_pages[var_186].page_tilecount>0){
   var_154 += (2 * t2p->tiff_pages[var_186].page_tilecount);
  } else {
   var_154 +=2;
  }
 }
 var_186 += t2pWriteFile(output, (tdata_t) "] \n/Count ", 10);
 var_185=snprintf(var_185, sizeof(var_185), "%d", t2p->tiff_pagecount);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " \n>> \n", 6);

 return(var_186);
}





tsize_t t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output){

 unsigned int var_186=0;
 tsize_t var_186=0;
 char var_185[256];
 int var_185=0;

 var_186 += t2pWriteFile(output, (tdata_t) "<<\n/Type /Page \n/Parent ", 24);
 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->pdf_pages);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
 var_186 += t2pWriteFile(output, (tdata_t) "/MediaBox [", 11);
 var_185=snprintf(var_185, sizeof(var_185), "%.4f",t2p->pdf_mediabox.x1);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " ", 1);
 var_185=snprintf(var_185, sizeof(var_185), "%.4f",t2p->pdf_mediabox.y1);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " ", 1);
 var_185=snprintf(var_185, sizeof(var_185), "%.4f",t2p->pdf_mediabox.x2);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " ", 1);
 var_185=snprintf(var_185, sizeof(var_185), "%.4f",t2p->pdf_mediabox.y2);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "] \n", 3);
 var_186 += t2pWriteFile(output, (tdata_t) "/Contents ", 10);
 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)(object + 1));
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
 var_186 += t2pWriteFile(output, (tdata_t) "/Resources << \n", 15);
 if( t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount != 0 ){
  var_186 += t2pWriteFile(output, (tdata_t) "/XObject <<\n", 12);
  for(var_186=0;var_186<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;var_186++){
   var_186 += t2pWriteFile(output, (tdata_t) "/Im", 3);
   var_185 = snprintf(var_185, sizeof(var_185), "%u", t2p->pdf_page+1);
   do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
   var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
   var_186 += t2pWriteFile(output, (tdata_t) "_", 1);
   var_185 = snprintf(var_185, sizeof(var_185), "%u", var_186+1);
   do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
   var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
   var_186 += t2pWriteFile(output, (tdata_t) " ", 1);
   var_185 = snprintf(var_185, sizeof(var_185), "%lu",
    (unsigned long)(object+3+(2*var_186)+t2p->tiff_pages[t2p->pdf_page].page_extra));
   do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
   var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
   var_186 += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
   if(var_186%4==3){
    var_186 += t2pWriteFile(output, (tdata_t) "\n", 1);
   }
  }
  var_186 += t2pWriteFile(output, (tdata_t) ">>\n", 3);
 } else {
   var_186 += t2pWriteFile(output, (tdata_t) "/XObject <<\n", 12);
   var_186 += t2pWriteFile(output, (tdata_t) "/Im", 3);
   var_185 = snprintf(var_185, sizeof(var_185), "%u", t2p->pdf_page+1);
   do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
   var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
   var_186 += t2pWriteFile(output, (tdata_t) " ", 1);
   var_185 = snprintf(var_185, sizeof(var_185), "%lu",
    (unsigned long)(object+3+(2*var_186)+t2p->tiff_pages[t2p->pdf_page].page_extra));
   do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
   var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
   var_186 += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
  var_186 += t2pWriteFile(output, (tdata_t) ">>\n", 3);
 }
 if(t2p->tiff_transferfunctioncount != 0) {
  var_186 += t2pWriteFile(output, (tdata_t) "/ExtGState <<", 13);
  t2pWriteFile(output, (tdata_t) "/GS1 ", 5);
  var_185 = snprintf(var_185, sizeof(var_185), "%lu",
   (unsigned long)(object + 3));
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
  var_186 += t2pWriteFile(output, (tdata_t) ">> \n", 4);
 }
 var_186 += t2pWriteFile(output, (tdata_t) "/ProcSet [ ", 11);
 if(t2p->pdf_colorspace & T2P_CS_BILEVEL
  || t2p->pdf_colorspace & T2P_CS_GRAY
  ){
  var_186 += t2pWriteFile(output, (tdata_t) "/ImageB ", 8);
 } else {
  var_186 += t2pWriteFile(output, (tdata_t) "/ImageC ", 8);
  if(t2p->pdf_colorspace & T2P_CS_PALETTE){
   var_186 += t2pWriteFile(output, (tdata_t) "/ImageI ", 8);
  }
 }
 var_186 += t2pWriteFile(output, (tdata_t) "]\n>>\n>>\n", 8);

 return(var_186);
}





void t2p_compose_pdf_page(T2P* t2p){

 uint32 var_186=0;
 uint32 var_186=0;
 T2P_TILE* var_161=NULL;
 T2P_BOX* boxp=NULL;
 uint32 var_161=0;
 uint32 var_161=0;
 uint32 var_161=0;
 uint32 var_161=0;
 int var_161=0;
 float var_161=0;
 float var_161=0;
 float var_161=0;

 t2p->pdf_xres = t2p->tiff_xres;
 t2p->pdf_yres = t2p->tiff_yres;
 if(t2p->pdf_overrideres) {
  t2p->pdf_xres = t2p->pdf_defaultxres;
  t2p->pdf_yres = t2p->pdf_defaultyres;
 }
 if(t2p->pdf_xres == 0.0)
  t2p->pdf_xres = t2p->pdf_defaultxres;
 if(t2p->pdf_yres == 0.0)
  t2p->pdf_yres = t2p->pdf_defaultyres;
 if (t2p->pdf_image_fillpage) {
  var_161 = t2p->pdf_defaultpagewidth/t2p->tiff_width;
  var_161 = t2p->pdf_defaultpagelength/t2p->tiff_length;
  if (var_161 < var_161 ) {
   t2p->pdf_imagewidth = t2p->pdf_defaultpagewidth;
   t2p->pdf_imagelength = t2p->tiff_length * var_161;
  } else {
   t2p->pdf_imagewidth = t2p->tiff_width * var_161;
   t2p->pdf_imagelength = t2p->pdf_defaultpagelength;
  }
 } else if (t2p->tiff_resunit != RESUNIT_CENTIMETER
  && t2p->tiff_resunit != RESUNIT_INCH) {
  t2p->pdf_imagewidth = ((float)(t2p->tiff_width))/t2p->pdf_xres;
  t2p->pdf_imagelength = ((float)(t2p->tiff_length))/t2p->pdf_yres;
 } else {
  t2p->pdf_imagewidth =
   ((float)(t2p->tiff_width))*72.0F/t2p->pdf_xres;
  t2p->pdf_imagelength =
   ((float)(t2p->tiff_length))*72.0F/t2p->pdf_yres;
 }
 if(t2p->pdf_overridepagesize != 0) {
  t2p->pdf_pagewidth = t2p->pdf_defaultpagewidth;
  t2p->pdf_pagelength = t2p->pdf_defaultpagelength;
 } else {
  t2p->pdf_pagewidth = t2p->pdf_imagewidth;
  t2p->pdf_pagelength = t2p->pdf_imagelength;
 }
 t2p->pdf_mediabox.x1=0.0;
 t2p->pdf_mediabox.y1=0.0;
 t2p->pdf_mediabox.x2=t2p->pdf_pagewidth;
 t2p->pdf_mediabox.y2=t2p->pdf_pagelength;
 t2p->pdf_imagebox.x1=0.0;
 t2p->pdf_imagebox.y1=0.0;
 t2p->pdf_imagebox.x2=t2p->pdf_imagewidth;
 t2p->pdf_imagebox.y2=t2p->pdf_imagelength;
 if(t2p->pdf_overridepagesize!=0){
  t2p->pdf_imagebox.x1+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);
  t2p->pdf_imagebox.y1+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);
  t2p->pdf_imagebox.x2+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);
  t2p->pdf_imagebox.y2+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);
 }
 if(t2p->tiff_orientation > 4){
  var_161=t2p->pdf_mediabox.x2;
  t2p->pdf_mediabox.x2=t2p->pdf_mediabox.y2;
  t2p->pdf_mediabox.y2=var_161;
 }
 var_161=((t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount==0) ? 0 : 1;
 if(var_161==0){
  t2p_compose_pdf_page_orient(&(t2p->pdf_imagebox), t2p->tiff_orientation);
  return;
 } else {
  var_161=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilewidth;
  var_161=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilelength;
  if( var_161 > INT_MAX ||
      var_161 > INT_MAX ||
      t2p->tiff_width > INT_MAX - var_161 ||
      t2p->tiff_length > INT_MAX - var_161 )
  {
      TIFFError("tiff2pdf", "Integer overflow");
      t2p->t2p_error = T2P_ERR_ERROR;
      return;
  }
  var_161=(t2p->tiff_width +
   var_161 -1)/
   var_161;
  (t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecountx=var_161;
  var_161=(t2p->tiff_length +
   var_161 -1)/
   var_161;
  (t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecounty=var_161;
  (t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilewidth=
   t2p->tiff_width % var_161;
  (t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilelength=
   t2p->tiff_length % var_161;
  var_161=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tiles;
  for(var_186=0;var_186<var_161-1;var_186++){
   for(var_186=0;var_186<var_161-1;var_186++){
    boxp=&(var_161[var_186*var_161+var_186].tile_box);
    boxp->x1 =
     t2p->pdf_imagebox.x1
     + ((float)(t2p->pdf_imagewidth * var_186 * var_161)
     / (float)t2p->tiff_width);
    boxp->x2 =
     t2p->pdf_imagebox.x1
     + ((float)(t2p->pdf_imagewidth * (var_186+1) * var_161)
     / (float)t2p->tiff_width);
    boxp->y1 =
     t2p->pdf_imagebox.y2
     - ((float)(t2p->pdf_imagelength * (var_186+1) * var_161)
     / (float)t2p->tiff_length);
    boxp->y2 =
     t2p->pdf_imagebox.y2
     - ((float)(t2p->pdf_imagelength * var_186 * var_161)
     / (float)t2p->tiff_length);
   }
   boxp=&(var_161[var_186*var_161+var_186].tile_box);
   boxp->x1 =
    t2p->pdf_imagebox.x1
    + ((float)(t2p->pdf_imagewidth * var_186 * var_161)
    / (float)t2p->tiff_width);
   boxp->x2 = t2p->pdf_imagebox.x2;
   boxp->y1 =
    t2p->pdf_imagebox.y2
    - ((float)(t2p->pdf_imagelength * (var_186+1) * var_161)
    / (float)t2p->tiff_length);
   boxp->y2 =
    t2p->pdf_imagebox.y2
    - ((float)(t2p->pdf_imagelength * var_186 * var_161)
    / (float)t2p->tiff_length);
  }
  for(var_186=0;var_186<var_161-1;var_186++){
   boxp=&(var_161[var_186*var_161+var_186].tile_box);
   boxp->x1 =
    t2p->pdf_imagebox.x1
    + ((float)(t2p->pdf_imagewidth * var_186 * var_161)
    / (float)t2p->tiff_width);
   boxp->x2 =
    t2p->pdf_imagebox.x1
    + ((float)(t2p->pdf_imagewidth * (var_186+1) * var_161)
    / (float)t2p->tiff_width);
   boxp->y1 = t2p->pdf_imagebox.y1;
   boxp->y2 =
    t2p->pdf_imagebox.y2
    - ((float)(t2p->pdf_imagelength * var_186 * var_161)
    / (float)t2p->tiff_length);
  }
  boxp=&(var_161[var_186*var_161+var_186].tile_box);
  boxp->x1 =
   t2p->pdf_imagebox.x1
   + ((float)(t2p->pdf_imagewidth * var_186 * var_161)
   / (float)t2p->tiff_width);
  boxp->x2 = t2p->pdf_imagebox.x2;
  boxp->y1 = t2p->pdf_imagebox.y1;
  boxp->y2 =
   t2p->pdf_imagebox.y2
   - ((float)(t2p->pdf_imagelength * var_186 * var_161)
   / (float)t2p->tiff_length);
 }
 if(t2p->tiff_orientation==0 || t2p->tiff_orientation==1){
  for(var_186=0;var_186<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;var_186++){
   t2p_compose_pdf_page_orient( &(var_161[var_186].tile_box) , 0);
  }
  return;
 }
 for(var_186=0;var_186<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;var_186++){
  boxp=&(var_161[var_186].tile_box);
  boxp->x1 -= t2p->pdf_imagebox.x1;
  boxp->x2 -= t2p->pdf_imagebox.x1;
  boxp->y1 -= t2p->pdf_imagebox.y1;
  boxp->y2 -= t2p->pdf_imagebox.y1;
  if(t2p->tiff_orientation==2 || t2p->tiff_orientation==3){
   boxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;
   boxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;
  }
  if(t2p->tiff_orientation==3 || t2p->tiff_orientation==4){
   boxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;
   boxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;
  }
  if(t2p->tiff_orientation==8 || t2p->tiff_orientation==5){
   boxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;
   boxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;
  }
  if(t2p->tiff_orientation==5 || t2p->tiff_orientation==6){
   boxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;
   boxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;
  }
  if(t2p->tiff_orientation > 4){
   var_161=boxp->x1;
   boxp->x1 = boxp->y1;
   boxp->y1 = var_161;
   var_161=boxp->x2;
   boxp->x2 = boxp->y2;
   boxp->y2 = var_161;
   t2p_compose_pdf_page_orient_flip(boxp, t2p->tiff_orientation);
  } else {
   t2p_compose_pdf_page_orient(boxp, t2p->tiff_orientation);
  }

 }

 return;
}

void t2p_compose_pdf_page_orient(T2P_BOX* boxp, uint16 orientation){

 float m1[9];
 float var_161=0.0;

 if( boxp->x1 > boxp->x2){
  var_161=boxp->x1;
  boxp->x1=boxp->x2;
  boxp->x2 = var_161;
 }
 if( boxp->y1 > boxp->y2){
  var_161=boxp->y1;
  boxp->y1=boxp->y2;
  boxp->y2 = var_161;
 }
 boxp->mat[0]=m1[0]=boxp->x2-boxp->x1;
 boxp->mat[1]=m1[1]=0.0;
 boxp->mat[2]=m1[2]=0.0;
 boxp->mat[3]=m1[3]=0.0;
 boxp->mat[4]=m1[4]=boxp->y2-boxp->y1;
 boxp->mat[5]=m1[5]=0.0;
 boxp->mat[6]=m1[6]=boxp->x1;
 boxp->mat[7]=m1[7]=boxp->y1;
 boxp->mat[8]=m1[8]=1.0;
 switch(orientation){
  case 0:
  case 1:
   break;
  case 2:
   boxp->mat[0]=0.0F-m1[0];
   boxp->mat[6]+=m1[0];
   break;
  case 3:
   boxp->mat[0]=0.0F-m1[0];
   boxp->mat[4]=0.0F-m1[4];
   boxp->mat[6]+=m1[0];
   boxp->mat[7]+=m1[4];
   break;
  case 4:
   boxp->mat[4]=0.0F-m1[4];
   boxp->mat[7]+=m1[4];
   break;
  case 5:
   boxp->mat[0]=0.0F;
   boxp->mat[1]=0.0F-m1[0];
   boxp->mat[3]=0.0F-m1[4];
   boxp->mat[4]=0.0F;
   boxp->mat[6]+=m1[4];
   boxp->mat[7]+=m1[0];
   break;
  case 6:
   boxp->mat[0]=0.0F;
   boxp->mat[1]=0.0F-m1[0];
   boxp->mat[3]=m1[4];
   boxp->mat[4]=0.0F;
   boxp->mat[7]+=m1[0];
   break;
  case 7:
   boxp->mat[0]=0.0F;
   boxp->mat[1]=m1[0];
   boxp->mat[3]=m1[4];
   boxp->mat[4]=0.0F;
   break;
  case 8:
   boxp->mat[0]=0.0F;
   boxp->mat[1]=m1[0];
   boxp->mat[3]=0.0F-m1[4];
   boxp->mat[4]=0.0F;
   boxp->mat[6]+=m1[4];
   break;
 }

 return;
}

void t2p_compose_pdf_page_orient_flip(T2P_BOX* boxp, uint16 orientation){

 float m1[9];
 float var_161=0.0;

 if( boxp->x1 > boxp->x2){
  var_161=boxp->x1;
  boxp->x1=boxp->x2;
  boxp->x2 = var_161;
 }
 if( boxp->y1 > boxp->y2){
  var_161=boxp->y1;
  boxp->y1=boxp->y2;
  boxp->y2 = var_161;
 }
 boxp->mat[0]=m1[0]=boxp->x2-boxp->x1;
 boxp->mat[1]=m1[1]=0.0F;
 boxp->mat[2]=m1[2]=0.0F;
 boxp->mat[3]=m1[3]=0.0F;
 boxp->mat[4]=m1[4]=boxp->y2-boxp->y1;
 boxp->mat[5]=m1[5]=0.0F;
 boxp->mat[6]=m1[6]=boxp->x1;
 boxp->mat[7]=m1[7]=boxp->y1;
 boxp->mat[8]=m1[8]=1.0F;
 switch(orientation){
  case 5:
   boxp->mat[0]=0.0F;
   boxp->mat[1]=0.0F-m1[4];
   boxp->mat[3]=0.0F-m1[0];
   boxp->mat[4]=0.0F;
   boxp->mat[6]+=m1[0];
   boxp->mat[7]+=m1[4];
   break;
  case 6:
   boxp->mat[0]=0.0F;
   boxp->mat[1]=0.0F-m1[4];
   boxp->mat[3]=m1[0];
   boxp->mat[4]=0.0F;
   boxp->mat[7]+=m1[4];
   break;
  case 7:
   boxp->mat[0]=0.0F;
   boxp->mat[1]=m1[4];
   boxp->mat[3]=m1[0];
   boxp->mat[4]=0.0F;
   break;
  case 8:
   boxp->mat[0]=0.0F;
   boxp->mat[1]=m1[4];
   boxp->mat[3]=0.0F-m1[0];
   boxp->mat[4]=0.0F;
   boxp->mat[6]+=m1[0];
   break;
 }

 return;
}





tsize_t t2p_write_pdf_page_content_stream(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 ttile_t var_186=0;
 char var_185[512];
 int var_185=0;
 T2P_BOX box;

 if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount>0){
  for(var_186=0;var_186<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount; var_186++){
   box=t2p->tiff_tiles[t2p->pdf_page].tiles_tiles[var_186].tile_box;
   var_185=snprintf(var_185, sizeof(var_185),
    "q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d_%ld Do Q\n",
    t2p->tiff_transferfunctioncount?"/GS1 gs ":"",
    box.mat[0],
    box.mat[1],
    box.mat[3],
    box.mat[4],
    box.mat[6],
    box.mat[7],
    t2p->pdf_page + 1,
    (long)(var_186 + 1));
   do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
   var_186 += t2p_write_pdf_stream(var_185, var_185, output);
  }
 } else {
  box=t2p->pdf_imagebox;
  var_185=snprintf(var_185, sizeof(var_185),
   "q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d Do Q\n",
   t2p->tiff_transferfunctioncount?"/GS1 gs ":"",
   box.mat[0],
   box.mat[1],
   box.mat[3],
   box.mat[4],
   box.mat[6],
   box.mat[7],
   t2p->pdf_page+1);
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2p_write_pdf_stream(var_185, var_185, output);
 }

 return(var_186);
}





tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t var_185,
            T2P* t2p,
            TIFF* output){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;

 var_186 += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);
 var_186 += t2pWriteFile(output,
  (tdata_t) "/Type /XObject \n/Subtype /Image \n/Name /Im",
  42);
 var_185=snprintf(var_185, sizeof(var_185), "%u", t2p->pdf_page+1);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 if(var_185 != 0){
  var_186 += t2pWriteFile(output, (tdata_t) "_", 1);
  var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)var_185);
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 }
 var_186 += t2pWriteFile(output, (tdata_t) "\n/Width ", 8);
 if(var_185==0){
  var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->tiff_width);
 } else {
  if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], var_185-1)!=0){
   var_185=snprintf(var_185, sizeof(var_185), "%lu",
    (unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
  } else {
   var_185=snprintf(var_185, sizeof(var_185), "%lu",
    (unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
  }
 }
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "\n/Height ", 9);
 if(var_185==0){
  var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->tiff_length);
 } else {
  if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], var_185-1)!=0){
   var_185=snprintf(var_185, sizeof(var_185), "%lu",
    (unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
  } else {
   var_185=snprintf(var_185, sizeof(var_185), "%lu",
    (unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
  }
 }
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "\n/BitsPerComponent ", 19);
 var_185=snprintf(var_185, sizeof(var_185), "%u", t2p->tiff_bitspersample);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "\n/ColorSpace ", 13);
 var_186 += t2p_write_pdf_xobject_cs(t2p, output);
 if (t2p->pdf_image_interpolate)
  var_186 += t2pWriteFile(output,
      (tdata_t) "\n/Interpolate true", 18);
 if( (t2p->pdf_switchdecode != 0)




  ){
  var_186 += t2p_write_pdf_xobject_decode(t2p, output);
 }
 var_186 += t2p_write_pdf_xobject_stream_filter(var_185, t2p, output);

 return(var_186);
}






tsize_t t2p_write_pdf_xobject_cs(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 char var_185[128];
 int var_185=0;

 float var_185=1.0;
 float var_185=1.0;
 float var_185=1.0;

 if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){
  var_186 += t2p_write_pdf_xobject_icccs(t2p, output);
  return(var_186);
 }
 if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){
  var_186 += t2pWriteFile(output, (tdata_t) "[ /Indexed ", 11);
  t2p->pdf_colorspace ^= T2P_CS_PALETTE;
  var_186 += t2p_write_pdf_xobject_cs(t2p, output);
  t2p->pdf_colorspace |= T2P_CS_PALETTE;
  var_185=snprintf(var_185, sizeof(var_185), "%u", (0x0001 << t2p->tiff_bitspersample)-1 );
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " ", 1);
  var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->pdf_palettecs );
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " 0 R ]\n", 7);
  return(var_186);
 }
 if(t2p->pdf_colorspace & T2P_CS_BILEVEL){
   var_186 += t2pWriteFile(output, (tdata_t) "/DeviceGray \n", 13);
 }
 if(t2p->pdf_colorspace & T2P_CS_GRAY){
   if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    var_186 += t2p_write_pdf_xobject_calcs(t2p, output);
   } else {
    var_186 += t2pWriteFile(output, (tdata_t) "/DeviceGray \n", 13);
   }
 }
 if(t2p->pdf_colorspace & T2P_CS_RGB){
   if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    var_186 += t2p_write_pdf_xobject_calcs(t2p, output);
   } else {
    var_186 += t2pWriteFile(output, (tdata_t) "/DeviceRGB \n", 12);
   }
 }
 if(t2p->pdf_colorspace & T2P_CS_CMYK){
   var_186 += t2pWriteFile(output, (tdata_t) "/DeviceCMYK \n", 13);
 }
 if(t2p->pdf_colorspace & T2P_CS_LAB){
   var_186 += t2pWriteFile(output, (tdata_t) "[/Lab << \n", 10);
   var_186 += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
   var_185 = t2p->tiff_whitechromaticities[0];
   var_185 = t2p->tiff_whitechromaticities[1];
   var_185 = 1.0F - (var_185 + var_185);
   var_185 /= var_185;
   var_185 /= var_185;
   var_185 = 1.0F;
   var_185=snprintf(var_185, sizeof(var_185), "[%.4f %.4f %.4f] \n", var_185, var_185, var_185);
   do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
   var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
   var_186 += t2pWriteFile(output, (tdata_t) "/Range ", 7);
   var_185=snprintf(var_185, sizeof(var_185), "[%d %d %d %d] \n",
    t2p->pdf_labrange[0],
    t2p->pdf_labrange[1],
    t2p->pdf_labrange[2],
    t2p->pdf_labrange[3]);
   do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
   var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
   var_186 += t2pWriteFile(output, (tdata_t) ">>] \n", 5);

 }

 return(var_186);
}

tsize_t t2p_write_pdf_transfer(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;

 var_186 += t2pWriteFile(output, (tdata_t) "<< /Type /ExtGState \n/TR ", 25);
 if(t2p->tiff_transferfunctioncount == 1){
  var_185=snprintf(var_185, sizeof(var_185), "%lu",
          (unsigned long)(t2p->pdf_xrefcount + 1));
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
 } else {
  var_186 += t2pWriteFile(output, (tdata_t) "[ ", 2);
  var_185=snprintf(var_185, sizeof(var_185), "%lu",
          (unsigned long)(t2p->pdf_xrefcount + 1));
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
  var_185=snprintf(var_185, sizeof(var_185), "%lu",
          (unsigned long)(t2p->pdf_xrefcount + 2));
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
  var_185=snprintf(var_185, sizeof(var_185), "%lu",
          (unsigned long)(t2p->pdf_xrefcount + 3));
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
  var_186 += t2pWriteFile(output, (tdata_t) "/Identity ] ", 12);
 }

 var_186 += t2pWriteFile(output, (tdata_t) " >> \n", 5);

 return(var_186);
}

tsize_t t2p_write_pdf_transfer_dict(T2P* t2p, TIFF* output, uint16 var_186){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;
 (void)var_186;

 var_186 += t2pWriteFile(output, (tdata_t) "/FunctionType 0 \n", 17);
 var_186 += t2pWriteFile(output, (tdata_t) "/Domain [0.0 1.0] \n", 19);
 var_186 += t2pWriteFile(output, (tdata_t) "/Range [0.0 1.0] \n", 18);
 var_185=snprintf(var_185, sizeof(var_185), "/Size [%u] \n", (1<<t2p->tiff_bitspersample));
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "/BitsPerSample 16 \n", 19);
 var_186 += t2p_write_pdf_stream_dict(((tsize_t)1)<<(t2p->tiff_bitspersample+1), 0, output);

 return(var_186);
}

tsize_t t2p_write_pdf_transfer_stream(T2P* t2p, TIFF* output, uint16 var_186){

 tsize_t var_186=0;

 var_186 += t2p_write_pdf_stream(
  t2p->tiff_transferfunction[var_186],
  (((tsize_t)1)<<(t2p->tiff_bitspersample+1)),
  output);

 return(var_186);
}





tsize_t t2p_write_pdf_xobject_calcs(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 char var_185[256];
 int var_185=0;

 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=0.0;
 float var_185=1.0;
 float var_185=1.0;
 float var_185=1.0;

 var_186 += t2pWriteFile(output, (tdata_t) "[", 1);
 if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
  var_186 += t2pWriteFile(output, (tdata_t) "/CalGray ", 9);
  var_185 = t2p->tiff_whitechromaticities[0];
  var_185 = t2p->tiff_whitechromaticities[1];
  var_185 = 1.0F - (var_185 + var_185);
  var_185 /= var_185;
  var_185 /= var_185;
  var_185 = 1.0F;
 }
 if(t2p->pdf_colorspace & T2P_CS_CALRGB){
  var_186 += t2pWriteFile(output, (tdata_t) "/CalRGB ", 8);
  var_185 = t2p->tiff_whitechromaticities[0];
  var_185 = t2p->tiff_whitechromaticities[1];
  var_185 = t2p->tiff_primarychromaticities[0];
  var_185 = t2p->tiff_primarychromaticities[1];
  var_185 = t2p->tiff_primarychromaticities[2];
  var_185 = t2p->tiff_primarychromaticities[3];
  var_185 = t2p->tiff_primarychromaticities[4];
  var_185 = t2p->tiff_primarychromaticities[5];
  var_185 = var_185 * ((var_185 - var_185)*var_185 - (var_185-var_185)*var_185 + (var_185-var_185)*var_185);
  var_185 = (var_185/var_185) * ((var_185-var_185)*var_185 - (var_185-var_185)*var_185 + (var_185-var_185)*var_185) / var_185;
  var_185 = var_185 * var_185 / var_185;
  var_185 = var_185 * (((1-var_185)/var_185)-1);
  var_185 = ((0.0F-(var_185))/var_185) * ((var_185-var_185)*var_185 - (var_185-var_185)*var_185 + (var_185-var_185)*var_185) / var_185;
  var_185 = var_185 * var_185 / var_185;
  var_185 = var_185 * (((1-var_185)/var_185)-1);
  var_185 = (var_185/var_185) * ((var_185-var_185)*var_185 - (var_185-var_185)*var_185 + (var_185-var_185)*var_185) / var_185;
  var_185 = var_185 * var_185 / var_185;
  var_185 = var_185 * (((1-var_185)/var_185)-1);
  var_185 = (var_185 * var_185) + (var_185 * var_185) + (var_185 * var_185);
  var_185 = (var_185 * var_185) + (var_185 * var_185) + (var_185 * var_185);
  var_185 = (var_185 * var_185) + (var_185 * var_185) + (var_185 * var_185);
  var_185 /= var_185;
  var_185 /= var_185;
  var_185 = 1.0;
 }
 var_186 += t2pWriteFile(output, (tdata_t) "<< \n", 4);
 if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
  var_186 += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
  var_185=snprintf(var_185, sizeof(var_185), "[%.4f %.4f %.4f] \n", var_185, var_185, var_185);
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) "/Gamma 2.2 \n", 12);
 }
 if(t2p->pdf_colorspace & T2P_CS_CALRGB){
  var_186 += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
  var_185=snprintf(var_185, sizeof(var_185), "[%.4f %.4f %.4f] \n", var_185, var_185, var_185);
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) "/Matrix ", 8);
  var_185=snprintf(var_185, sizeof(var_185), "[%.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f] \n",
   var_185, var_185, var_185,
   var_185, var_185, var_185,
   var_185, var_185, var_185);
  do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
  var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
  var_186 += t2pWriteFile(output, (tdata_t) "/Gamma [2.2 2.2 2.2] \n", 22);
 }
 var_186 += t2pWriteFile(output, (tdata_t) ">>] \n", 5);

 return(var_186);
}





tsize_t t2p_write_pdf_xobject_icccs(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;

 var_186 += t2pWriteFile(output, (tdata_t) "[/ICCBased ", 11);
 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->pdf_icccs);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " 0 R] \n", 7);

 return(var_186);
}

tsize_t t2p_write_pdf_xobject_icccs_dict(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;

 var_186 += t2pWriteFile(output, (tdata_t) "/N ", 3);
 var_185=snprintf(var_185, sizeof(var_185), "%u \n", t2p->tiff_samplesperpixel);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "/Alternate ", 11);
 t2p->pdf_colorspace ^= T2P_CS_ICCBASED;
 var_186 += t2p_write_pdf_xobject_cs(t2p, output);
 t2p->pdf_colorspace |= T2P_CS_ICCBASED;
 var_186 += t2p_write_pdf_stream_dict(t2p->tiff_iccprofilelength, 0, output);

 return(var_186);
}

tsize_t t2p_write_pdf_xobject_icccs_stream(T2P* t2p, TIFF* output){

 tsize_t var_186=0;

 var_186 += t2p_write_pdf_stream(
    (tdata_t) t2p->tiff_iccprofile,
    (tsize_t) t2p->tiff_iccprofilelength,
    output);

 return(var_186);
}





tsize_t t2p_write_pdf_xobject_palettecs_stream(T2P* t2p, TIFF* output){

 tsize_t var_186=0;

 var_186 += t2p_write_pdf_stream(
    (tdata_t) t2p->pdf_palette,
    (tsize_t) t2p->pdf_palettesize,
    output);

 return(var_186);
}





tsize_t t2p_write_pdf_xobject_decode(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 int var_186=0;

 var_186 += t2pWriteFile(output, (tdata_t) "/Decode [ ", 10);
 for (var_186=0;var_186<t2p->tiff_samplesperpixel;var_186++){
  var_186 += t2pWriteFile(output, (tdata_t) "1 0 ", 4);
 }
 var_186 += t2pWriteFile(output, (tdata_t) "]\n", 2);

 return(var_186);
}






tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t var_185, T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 char var_185[32];
 int var_185=0;

 if(t2p->pdf_compression==T2P_COMPRESS_NONE){
  return(var_186);
 }
 var_186 += t2pWriteFile(output, (tdata_t) "/Filter ", 8);
 switch(t2p->pdf_compression){

  default:
   break;
 }

 return(var_186);
}





tsize_t t2p_write_pdf_xreftable(T2P* t2p, TIFF* output){

 tsize_t var_186=0;
 char var_185[64];
 int var_185=0;
 uint32 var_186=0;

 var_186 += t2pWriteFile(output, (tdata_t) "xref\n0 ", 7);
 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)(t2p->pdf_xrefcount + 1));
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " \n0000000000 65535 f \n", 22);
 for (var_186=0;var_186<t2p->pdf_xrefcount;var_186++){
  snprintf(var_185, sizeof(var_185), "%.10lu 00000 n \n",
   (unsigned long)t2p->pdf_xrefoffsets[var_186]);
  var_186 += t2pWriteFile(output, (tdata_t) var_185, 20);
 }

 return(var_186);
}





tsize_t t2p_write_pdf_trailer(T2P* t2p, TIFF* output)
{

 tsize_t var_186 = 0;
 char var_185[32];
 int var_185 = 0;
 size_t var_186 = 0;

 for (var_186 = 0; var_186 < sizeof(t2p->pdf_fileid) - 8; var_186 += 8)
  snprintf(t2p->pdf_fileid + var_186, 9, "%.8X", rand());

 var_186 += t2pWriteFile(output, (tdata_t) "trailer\n<<\n/Size ", 17);
 var_185 = snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)(t2p->pdf_xrefcount+1));
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "\n/Root ", 7);
 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->pdf_catalog);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " 0 R \n/Info ", 12);
 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->pdf_info);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) " 0 R \n/ID[<", 11);
 var_186 += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,
    sizeof(t2p->pdf_fileid) - 1);
 var_186 += t2pWriteFile(output, (tdata_t) "><", 2);
 var_186 += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,
    sizeof(t2p->pdf_fileid) - 1);
 var_186 += t2pWriteFile(output, (tdata_t) ">]\n>>\nstartxref\n", 16);
 var_185=snprintf(var_185, sizeof(var_185), "%lu", (unsigned long)t2p->pdf_startxref);
 do { if ((var_185) < 0) var_185 = 0; else if((var_185) >= (int)sizeof(var_185)) (var_185) = sizeof(var_185) - 1; else break; if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; } while0;
 var_186 += t2pWriteFile(output, (tdata_t) var_185, var_185);
 var_186 += t2pWriteFile(output, (tdata_t) "\n%%EOF\n", 7);

 return(var_186);
}

tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){

 tsize_t var_186=0;
 ttile_t var_186=0;
 tsize_t var_186=0;
 uint16 var_186=0;

 t2p_read_tiff_init(t2p, input);
 if(t2p->t2p_error!=T2P_ERR_OK){return0;}
 t2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) );
 if(t2p->pdf_xrefoffsets==NULL){
  TIFFError(
   "tiff2pdf",
   "Can't allocate %u bytes of memory for t2p_write_pdf",
   (unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) );
  t2p->t2p_error = T2P_ERR_ERROR;
  return(var_186);
 }
 t2p->pdf_xrefcount=0;
 t2p->pdf_catalog=1;
 t2p->pdf_info=2;
 t2p->pdf_pages=3;
 var_186 += t2p_write_pdf_header(t2p, output);
 t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
 t2p->pdf_catalog=t2p->pdf_xrefcount;
 var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
 var_186 += t2p_write_pdf_catalog(t2p, output);
 var_186 += t2p_write_pdf_obj_end(output);
 t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
 t2p->pdf_info=t2p->pdf_xrefcount;
 var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
 var_186 += t2p_write_pdf_info(t2p, input, output);
 var_186 += t2p_write_pdf_obj_end(output);
 t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
 t2p->pdf_pages=t2p->pdf_xrefcount;
 var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
 var_186 += t2p_write_pdf_pages(t2p, output);
 var_186 += t2p_write_pdf_obj_end(output);
 for(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){
  t2p_read_tiff_data(t2p, input);
  if(t2p->t2p_error!=T2P_ERR_OK){return0;}
  t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
  var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
  var_186 += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output);
  var_186 += t2p_write_pdf_obj_end(output);
  t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
  var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
  var_186 += t2p_write_pdf_stream_dict_start(output);
  var_186 += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);
  var_186 += t2p_write_pdf_stream_dict_end(output);
  var_186 += t2p_write_pdf_stream_start(output);
  var_186=var_186;
  var_186 += t2p_write_pdf_page_content_stream(t2p, output);
  var_186=var_186-var_186;
  var_186 += t2p_write_pdf_stream_end(output);
  var_186 += t2p_write_pdf_obj_end(output);
  t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
  var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
  var_186 += t2p_write_pdf_stream_length(var_186, output);
  var_186 += t2p_write_pdf_obj_end(output);
  if(t2p->tiff_transferfunctioncount != 0){
   t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
   var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
   var_186 += t2p_write_pdf_transfer(t2p, output);
   var_186 += t2p_write_pdf_obj_end(output);
   for(var_186=0; var_186 < t2p->tiff_transferfunctioncount; var_186++){
    t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
    var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    var_186 += t2p_write_pdf_stream_dict_start(output);
    var_186 += t2p_write_pdf_transfer_dict(t2p, output, var_186);
    var_186 += t2p_write_pdf_stream_dict_end(output);
    var_186 += t2p_write_pdf_stream_start(output);

    var_186 += t2p_write_pdf_transfer_stream(t2p, output, var_186);

    var_186 += t2p_write_pdf_stream_end(output);
    var_186 += t2p_write_pdf_obj_end(output);
   }
  }
  if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){
   t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
   t2p->pdf_palettecs=t2p->pdf_xrefcount;
   var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
   var_186 += t2p_write_pdf_stream_dict_start(output);
   var_186 += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output);
   var_186 += t2p_write_pdf_stream_dict_end(output);
   var_186 += t2p_write_pdf_stream_start(output);

   var_186 += t2p_write_pdf_xobject_palettecs_stream(t2p, output);

   var_186 += t2p_write_pdf_stream_end(output);
   var_186 += t2p_write_pdf_obj_end(output);
  }
  if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){
   t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
   t2p->pdf_icccs=t2p->pdf_xrefcount;
   var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
   var_186 += t2p_write_pdf_stream_dict_start(output);
   var_186 += t2p_write_pdf_xobject_icccs_dict(t2p, output);
   var_186 += t2p_write_pdf_stream_dict_end(output);
   var_186 += t2p_write_pdf_stream_start(output);

   var_186 += t2p_write_pdf_xobject_icccs_stream(t2p, output);

   var_186 += t2p_write_pdf_stream_end(output);
   var_186 += t2p_write_pdf_obj_end(output);
  }
  if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){
   for(var_186=0;var_186<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;var_186++){
    t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
    var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    var_186 += t2p_write_pdf_stream_dict_start(output);
    var_186 += t2p_write_pdf_xobject_stream_dict(
     var_186+1,
     t2p,
     output);
    var_186 += t2p_write_pdf_stream_dict_end(output);
    var_186 += t2p_write_pdf_stream_start(output);
    var_186=var_186;
    t2p_read_tiff_size_tile(t2p, input, var_186);
    var_186 += t2p_readwrite_pdf_image_tile(t2p, input, output, var_186);
    t2p_write_advance_directory(t2p, output);
    if(t2p->t2p_error!=T2P_ERR_OK){return0;}
    var_186=var_186-var_186;
    var_186 += t2p_write_pdf_stream_end(output);
    var_186 += t2p_write_pdf_obj_end(output);
    t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
    var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    var_186 += t2p_write_pdf_stream_length(var_186, output);
    var_186 += t2p_write_pdf_obj_end(output);
   }
  } else {
   t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
   var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
   var_186 += t2p_write_pdf_stream_dict_start(output);
   var_186 += t2p_write_pdf_xobject_stream_dict(
    0,
    t2p,
    output);
   var_186 += t2p_write_pdf_stream_dict_end(output);
   var_186 += t2p_write_pdf_stream_start(output);
   var_186=var_186;
   t2p_read_tiff_size(t2p, input);
   var_186 += t2p_readwrite_pdf_image(t2p, input, output);
   t2p_write_advance_directory(t2p, output);
   if(t2p->t2p_error!=T2P_ERR_OK){return0;}
   var_186=var_186-var_186;
   var_186 += t2p_write_pdf_stream_end(output);
   var_186 += t2p_write_pdf_obj_end(output);
   t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=var_186;
   var_186 += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
   var_186 += t2p_write_pdf_stream_length(var_186, output);
   var_186 += t2p_write_pdf_obj_end(output);
  }
 }
 t2p->pdf_startxref = var_186;
 var_186 += t2p_write_pdf_xreftable(t2p, output);
 var_186 += t2p_write_pdf_trailer(t2p, output);
 t2p_disable(output);

 return(var_186);
}
