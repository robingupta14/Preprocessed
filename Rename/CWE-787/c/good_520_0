







rfbBool var_2=TRUE;

static void
fn_1(const char *format, ...)
{
    va_list args;
    char buf[256];
    time_t log_clock;

    if(!var_2)
      return;

    va_start(args, format);

    time(&log_clock);
    strftime(buf, 255, "%d/%m/%Y %X ", localtime(&log_clock));
    fprintf(stderr, "%s", buf);

    vfprintf(stderr, format, args);
    fflush(stderr);

    va_end(args);
}

rfbClientLogProc var_109=var_5;
rfbClientLogProc var_108=var_5;



rfbClientProtocolExtension* rfbClientExtensions = NULL;

void fn_5(rfbClientProtocolExtension* var_108)
{
 var_108->next = rfbClientExtensions;
 rfbClientExtensions = var_108;
}



void fn_7(rfbClient* client, void* tag, void* data)
{
 rfbClientData* clientData = client->clientData;

 while(clientData && clientData->tag != tag)
  clientData = clientData->next;
 if(clientData == NULL) {
  clientData = calloc(sizeof(rfbClientData), 1);
  clientData->next = client->clientData;
  client->clientData = clientData;
  clientData->tag = tag;
 }

 clientData->data = data;
}

void* fn_8(rfbClient* client, void* tag)
{
 rfbClientData* clientData = client->clientData;

 while(clientData) {
  if(clientData->tag == tag)
   return clientData->data;
  clientData = clientData->next;
 }

 return NULL;
}

static rfbBool fn_9(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_14(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_15(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_16(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_17(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_18(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_19(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_20(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_21(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_22(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_23(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_24(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_25(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_26(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_27(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_28(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_29(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_30(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_31(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_32(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_33(rfbClient* client, int var_35, int var_35, int var_35, int var_35);
static rfbBool fn_34(rfbClient* client, int var_35, int var_35, int var_35, int var_35);

rfbBool
fn_35(rfbClient* client, int var_42)
{
    return (client->supportedMessages.client2server[((var_42 & 0xFF)/8)] & (1<<(var_42 % 8)) ? TRUE : FALSE);
}

rfbBool
fn_37(rfbClient* client, int var_42)
{
    return (client->supportedMessages.server2client[((var_42 & 0xFF)/8)] & (1<<(var_42 % 8)) ? TRUE : FALSE);
}

void
fn_38(rfbClient* client, int var_42)
{
  client->supportedMessages.client2server[((var_42 & 0xFF)/8)] |= (1<<(var_42 % 8));
}

void
fn_39(rfbClient* client, int var_42)
{
  client->supportedMessages.server2client[((var_42 & 0xFF)/8)] |= (1<<(var_42 % 8));
}

void
fn_40(rfbClient* client, int var_42)
{
  client->supportedMessages.client2server[((var_42 & 0xFF)/8)] &= (!(1<<(var_42 % 8)));
}

void
fn_41(rfbClient* client, int var_42)
{
  client->supportedMessages.server2client[((var_42 & 0xFF)/8)] &= (!(1<<(var_42 % 8)));
}


void
fn_42(rfbClient* client)
{
    memset((char *)&client->supportedMessages,0,sizeof(client->supportedMessages));


    SetClient2Server(client, rfbSetPixelFormat);

    SetClient2Server(client, rfbSetEncodings);
    SetClient2Server(client, rfbFramebufferUpdateRequest);
    SetClient2Server(client, rfbKeyEvent);
    SetClient2Server(client, rfbPointerEvent);
    SetClient2Server(client, rfbClientCutText);



    SetServer2Client(client, rfbFramebufferUpdate);
    SetServer2Client(client, rfbSetColourMapEntries);
    SetServer2Client(client, rfbBell);
    SetServer2Client(client, rfbServerCutText);
}

void
fn_43(rfbClient* client)
{
    DefaultSupportedMessages(client);
    SetClient2Server(client, rfbFileTransfer);
    SetClient2Server(client, rfbSetScale);
    SetClient2Server(client, rfbSetServerInput);
    SetClient2Server(client, rfbSetSW);
    SetClient2Server(client, rfbTextChat);
    SetClient2Server(client, rfbPalmVNCSetScaleFactor);

    SetServer2Client(client, rfbResizeFrameBuffer);
    SetServer2Client(client, rfbPalmVNCReSizeFrameBuffer);
    SetServer2Client(client, rfbFileTransfer);
    SetServer2Client(client, rfbTextChat);
}


void
fn_44(rfbClient* client)
{
    DefaultSupportedMessages(client);
    SetClient2Server(client, rfbFileTransfer);
    SetClient2Server(client, rfbSetServerInput);
    SetClient2Server(client, rfbSetSW);


    SetServer2Client(client, rfbFileTransfer);
    SetServer2Client(client, rfbTextChat);
}


static rfbBool
fn_45(const char *name)
{
  struct struct_46 sb;
  if(stat(name, &sb) == 0 && (sb.st_mode & S_IFMT) == S_IFSOCK)
    return TRUE;
  return FALSE;
}






rfbBool
fn_47(rfbClient* client,const char *hostname, int var_49)
{
  if (client->serverPort==-1) {

    const char* magic="vncLog0.0";
    char buffer[10];
    rfbVNCRec* rec = (rfbVNCRec*)malloc(sizeof(rfbVNCRec));
    client->vncRec = rec;

    rec->file = fopen(client->serverHost,"rb");
    rec->tv.tv_sec = 0;
    rec->readTimestamp = FALSE;
    rec->doNotSleep = FALSE;

    if (!rec->file) {
      var_109("Could not open %s.\n",client->serverHost);
      return FALSE;
    }
    setbuf(rec->file,NULL);

    if (fread(buffer,1,strlen(magic),rec->file) != strlen(magic) || strncmp(buffer,magic,strlen(magic))) {
      var_109("File %s was not recorded by vncrec.\n",client->serverHost);
      fclose(rec->file);
      return FALSE;
    }
    client->sock = -1;
    return TRUE;
  }


  if(IsUnixSocket(hostname))

    client->sock = ConnectClientToUnixSock(hostname);
  else

  {




    {
      unsigned int host;


      if (!StringToIPAddr(hostname, &host)) {
        var_109("Couldn't convert '%s' to host address\n", hostname);
        return FALSE;
      }
      client->sock = ConnectClientToTcpAddr(host, var_49);
    }
  }

  if (client->sock < 0) {
    var_109("Unable to connect to VNC server\n");
    return FALSE;
  }

  if(client->QoS_DSCP && !SetDSCP(client->sock, client->QoS_DSCP))
     return FALSE;

  return SetNonBlocking(client->sock);
}





rfbBool fn_49(rfbClient* client,const char *repeaterHost, int var_52, const char *destHost, int var_52)
{
  rfbProtocolVersionMsg pv;
  int major,minor;
  char tmphost[250];
  int tmphostlen;





  {
    unsigned int host;
    if (!StringToIPAddr(repeaterHost, &host)) {
      var_109("Couldn't convert '%s' to host address\n", repeaterHost);
      return FALSE;
    }

    client->sock = ConnectClientToTcpAddr(host, var_52);
  }

  if (client->sock < 0) {
    var_109("Unable to connect to VNC repeater\n");
    return FALSE;
  }

  if (!SetNonBlocking(client->sock))
    return FALSE;

  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))
    return FALSE;
  pv[sz_rfbProtocolVersionMsg] = 0;


  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {
    var_109("Not a valid VNC repeater (%s)\n",pv);
    return FALSE;
  }

  var_109("Connected to VNC repeater, using protocol version %d.%d\n", major, minor);

  tmphostlen = snprintf(tmphost, sizeof(tmphost), "%s:%d", destHost, var_52);
  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))
    return FALSE;

  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))
    return FALSE;

  return TRUE;
}

extern void fn_52(unsigned char* bytes, char* passwd);
extern void fn_53(unsigned char *where, const int var_54, unsigned char *var_104);

rfbBool
fn_56(rfbClient* client)
{
    uint32_t var_59=0, var_60=0;
    char *reason=NULL;

    if (!ReadFromRFBServer(client, (char *)&var_59, 4)) return FALSE;

    var_59 = rfbClientSwap32IfLE(var_59);

    switch (var_59) {
    case rfbVncAuthOK:
      var_109("VNC authentication succeeded\n");
      return TRUE;
      break;
    case rfbVncAuthFailed:
      if (client->major==3 && client->minor>7)
      {

        if (!ReadFromRFBServer(client, (char *)&var_60, 4)) return FALSE;
        var_60 = rfbClientSwap32IfLE(var_60);
        reason = malloc((uint64_t)var_60+1);
        if (!ReadFromRFBServer(client, reason, var_60)) { free(reason); return FALSE; }
        reason[var_60]=0;
        var_109("VNC connection failed: %s\n",reason);
        free(reason);
        return FALSE;
      }
      var_109("VNC authentication failed\n");
      return FALSE;
    case rfbVncAuthTooMany:
      var_109("VNC authentication failed - too many tries\n");
      return FALSE;
    }

    var_109("Unknown VNC authentication result: %d\n",
                 (int)var_59);
    return FALSE;
}

static void
fn_59(rfbClient* client)
{
    uint32_t var_60;
    char *reason;


    if (!ReadFromRFBServer(client, (char *)&var_60, 4)) return;
    var_60 = rfbClientSwap32IfLE(var_60);
    reason = malloc((uint64_t)var_60+1);
    if (!ReadFromRFBServer(client, reason, var_60)) { free(reason); return; }
    reason[var_60]=0;
    var_109("VNC connection failed: %s\n",reason);
    free(reason);
}

static rfbBool
fn_60(rfbClient* client, uint32_t *result, rfbBool var_65)
{
    uint8_t var_92=0;
    uint8_t var_106=0;
    uint8_t var_65=0;
    rfbBool extAuthHandler;
    uint8_t tAuth[256];
    char buf1[500],buf2[10];
    uint32_t authScheme;
    rfbClientProtocolExtension* var_108;

    if (!ReadFromRFBServer(client, (char *)&var_92, 1)) return FALSE;

    if (var_92==0)
    {
        var_109("List of security types is ZERO, expecting an error to follow\n");
        ReadReason(client);
        return FALSE;
    }

    var_109("We have %d security types to read\n", var_92);
    authScheme=0;

    for (var_106=0;var_106<var_92;var_106++)
    {
        if (!ReadFromRFBServer(client, (char *)&tAuth[var_106], 1)) return FALSE;
        var_109("%d) Received security type %d\n", var_106, tAuth[var_106]);
        if (var_65) continue;
        extAuthHandler=FALSE;
        for (var_108 = rfbClientExtensions; var_108; var_108 = var_108->next) {
            if (!var_108->handleAuthentication) continue;
            uint32_t const* secType;
            for (secType = var_108->securityTypes; secType && *secType; secType++) {
                if (tAuth[var_106]==*secType) {
                    extAuthHandler=TRUE;
                }
            }
        }
        if (tAuth[var_106]==rfbVncAuth || tAuth[var_106]==rfbNoAuth ||
   extAuthHandler ||






            (tAuth[var_106]==rfbARD && client->GetCredential) ||
            (!var_65 && (tAuth[var_106]==rfbTLS || (tAuth[var_106]==rfbVeNCrypt && client->GetCredential))))
        {
            if (!var_65 && client->clientAuthSchemes)
            {
                int i;
                for (i=0;client->clientAuthSchemes[i];i++)
                {
                    if (client->clientAuthSchemes[i]==(uint32_t)tAuth[var_106])
                    {
                        var_65++;
                        authScheme=tAuth[var_106];
                        break;
                    }
                }
            }
            else
            {
                var_65++;
                authScheme=tAuth[var_106];
            }
            if (var_65)
            {
                var_109("Selecting security type %d (%d/%d in the list)\n", authScheme, var_106, var_92);

                if (!WriteToRFBServer(client, (char *)&tAuth[var_106], 1)) return FALSE;
            }
        }
    }
    if (authScheme==0)
    {
        memset(buf1, 0, sizeof(buf1));
        for (var_106=0;var_106<var_92;var_106++)
        {
            if (strlen(buf1)>=sizeof(buf1)-1) break;
            snprintf(buf2, sizeof(buf2), (var_106>0 ? ", %d" : "%d"), (int)tAuth[var_106]);
            strncat(buf1, buf2, sizeof(buf1)-strlen(buf1)-1);
        }
        var_109("Unknown authentication scheme from VNC server: %s\n",
               buf1);
        return FALSE;
    }
    *result = authScheme;
    return TRUE;
}

static rfbBool
fn_65(rfbClient *client)
{
    uint8_t challenge[CHALLENGESIZE];
    char *passwd=NULL;
    int i;

    if (!ReadFromRFBServer(client, (char *)challenge, CHALLENGESIZE)) return FALSE;

    if (client->serverPort!=-1) {
      if (client->GetPassword)
        passwd = client->GetPassword(client);

      if ((!passwd) || (strlen(passwd) == 0)) {
        var_109("Reading password failed\n");
        return FALSE;
      }
      if (strlen(passwd) > 8) {
        passwd[8] = '\0';
      }

      rfbClientEncryptBytes(challenge, passwd);


      for (i = strlen(passwd); i >= 0; i--) {
        passwd[i] = '\0';
      }
      free(passwd);

      if (!WriteToRFBServer(client, (char *)challenge, CHALLENGESIZE)) return FALSE;
    }


    if (!rfbHandleAuthResult(client)) return FALSE;

    return TRUE;
}

static void
fn_66(rfbCredential *cred)
{
  if (cred->userCredential.username) free(cred->userCredential.username);
  if (cred->userCredential.password) free(cred->userCredential.password);
  free(cred);
}

static rfbBool
fn_67(rfbClient *client)
{
  uint32_t ulen, ulensw;
  uint32_t plen, plensw;
  rfbCredential *cred;

  if (!client->GetCredential)
  {
    var_109("GetCredential callback is not set.\n");
    return FALSE;
  }
  cred = client->GetCredential(client, rfbCredentialTypeUser);
  if (!cred)
  {
    var_109("Reading credential failed\n");
    return FALSE;
  }

  ulen = (cred->userCredential.username ? strlen(cred->userCredential.username) : 0);
  ulensw = rfbClientSwap32IfLE(ulen);
  plen = (cred->userCredential.password ? strlen(cred->userCredential.password) : 0);
  plensw = rfbClientSwap32IfLE(plen);
  if (!WriteToRFBServer(client, (char *)&ulensw, 4) ||
      !WriteToRFBServer(client, (char *)&plensw, 4))
  {
    FreeUserCredential(cred);
    return FALSE;
  }
  if (ulen > 0)
  {
    if (!WriteToRFBServer(client, cred->userCredential.username, ulen))
    {
      FreeUserCredential(cred);
      return FALSE;
    }
  }
  if (plen > 0)
  {
    if (!WriteToRFBServer(client, cred->userCredential.password, plen))
    {
      FreeUserCredential(cred);
      return FALSE;
    }
  }

  FreeUserCredential(cred);


  if (!rfbHandleAuthResult(client)) return FALSE;

  return TRUE;
}





static uint64_t
fn_68(uint64_t var_102, uint64_t var_106, uint64_t var_74)
{
  uint64_t r;
  for(r=0;var_102>0;var_102>>=1)
  {
    if (var_102&1) r=((r+var_106)%var_74+(r+var_106<r?(((uint64_t)-1)%var_74+1)%var_74:0));
    var_106=((var_106+var_106)%var_74+(var_106+var_106<var_106?(((uint64_t)-1)%var_74+1)%var_74:0));
  }
  return r;
}

static uint64_t
fn_72(uint64_t var_74, uint64_t var_108, uint64_t var_74)
{
  uint64_t r;
  for(r=1;var_108>0;var_108>>=1)
  {
    if(var_108&1) r=rfbMulM64(r,var_74,var_74);
    var_74=rfbMulM64(var_74,var_74,var_74);
  }
  return r;
}

static rfbBool
fn_74(rfbClient *client)
{
  uint64_t gen, mod, resp, priv, pub, var_104;
  uint8_t username[256], password[64];
  rfbCredential *cred;

  if (!ReadFromRFBServer(client, (char *)&gen, 8)) return FALSE;
  if (!ReadFromRFBServer(client, (char *)&mod, 8)) return FALSE;
  if (!ReadFromRFBServer(client, (char *)&resp, 8)) return FALSE;
  gen = rfbClientSwap64IfLE(gen);
  mod = rfbClientSwap64IfLE(mod);
  resp = rfbClientSwap64IfLE(resp);

  if (!client->GetCredential)
  {
    var_109("GetCredential callback is not set.\n");
    return FALSE;
  }
  var_109("WARNING! MSLogon security type has very low password encryption! " "Use it only with SSH tunnel or trusted network.\n");

  cred = client->GetCredential(client, rfbCredentialTypeUser);
  if (!cred)
  {
    var_109("Reading credential failed\n");
    return FALSE;
  }

  memset(username, 0, sizeof(username));
  strncpy((char *)username, cred->userCredential.username, sizeof(username));
  memset(password, 0, sizeof(password));
  strncpy((char *)password, cred->userCredential.password, sizeof(password));
  FreeUserCredential(cred);

  srand(time(NULL));
  priv = ((uint64_t)rand())<<32;
  priv |= (uint64_t)rand();

  pub = rfbPowM64(gen, priv, mod);
  var_104 = rfbPowM64(resp, priv, mod);
  pub = rfbClientSwap64IfLE(pub);
  var_104 = rfbClientSwap64IfLE(var_104);

  rfbClientEncryptBytes2(username, sizeof(username), (unsigned char *)&var_104);
  rfbClientEncryptBytes2(password, sizeof(password), (unsigned char *)&var_104);

  if (!WriteToRFBServer(client, (char *)&pub, 8)) return FALSE;
  if (!WriteToRFBServer(client, (char *)username, sizeof(username))) return FALSE;
  if (!WriteToRFBServer(client, (char *)password, sizeof(password))) return FALSE;


  if (!rfbHandleAuthResult(client)) return FALSE;

  return TRUE;
}

void
fn_75(rfbClient* client,const uint32_t *authSchemes, int var_77)
{
  int i;

  if (client->clientAuthSchemes)
  {
    free(client->clientAuthSchemes);
    client->clientAuthSchemes = NULL;
  }
  if (authSchemes)
  {
    if (var_77<0)
    {


      for (var_77=0;authSchemes[var_77];var_77++) ;
    }
    client->clientAuthSchemes = (uint32_t*)malloc(sizeof(uint32_t)*(var_77+1));
    for (i=0;i<var_77;i++)
      client->clientAuthSchemes[i] = authSchemes[i];
    client->clientAuthSchemes[var_77] = 0;
  }
}





rfbBool
fn_77(rfbClient* client)
{
  rfbProtocolVersionMsg pv;
  int major,minor;
  uint32_t authScheme;
  uint32_t subAuthScheme;
  rfbClientInitMsg ci;




  if (client->listenSpecified)
    errorMessageOnReadFailure = FALSE;

  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;
  pv[sz_rfbProtocolVersionMsg]=0;

  errorMessageOnReadFailure = TRUE;

  pv[sz_rfbProtocolVersionMsg] = 0;

  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2) {
    var_109("Not a valid VNC server (%s)\n",pv);
    return FALSE;
  }


  DefaultSupportedMessages(client);
  client->major = major;
  client->minor = minor;


  if ((major==rfbProtocolMajorVersion) && (minor>rfbProtocolMinorVersion))
    client->minor = rfbProtocolMinorVersion;


  if (major==3 && (minor==4 || minor==6)) {
      var_109("UltraVNC server detected, enabling UltraVNC specific messages\n",pv);
      DefaultSupportedMessagesUltraVNC(client);
  }


  if (major==3 && (minor==14 || minor==16)) {
     minor = minor - 10;
     client->minor = minor;
     var_109("UltraVNC Single Click server detected, enabling UltraVNC specific messages\n",pv);
     DefaultSupportedMessagesUltraVNC(client);
  }


  if (major==3 && minor==5) {
      var_109("TightVNC server detected, enabling TightVNC specific messages\n",pv);
      DefaultSupportedMessagesTightVNC(client);
  }


  if ((major==3 && minor>8) || major>3)
  {
    client->major=3;
    client->minor=8;
  }

  var_109("VNC server supports protocol version %d.%d (viewer %d.%d)\n",
   major, minor, rfbProtocolMajorVersion, rfbProtocolMinorVersion);

  sprintf(pv,rfbProtocolVersionFormat,client->major,client->minor);

  if (!WriteToRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;



  if (client->major==3 && client->minor > 6)
  {
    if (!ReadSupportedSecurityType(client, &authScheme, FALSE)) return FALSE;
  }
  else
  {
    if (!ReadFromRFBServer(client, (char *)&authScheme, 4)) return FALSE;
    authScheme = rfbClientSwap32IfLE(authScheme);
  }

  var_109("Selected Security Scheme %d\n", authScheme);
  client->authScheme = authScheme;

  switch (authScheme) {

  case rfbConnFailed:
    ReadReason(client);
    return FALSE;

  case rfbNoAuth:
    var_109("No authentication needed\n");


    if ((client->major==3 && client->minor > 7) || client->major>3)
        if (!rfbHandleAuthResult(client)) return FALSE;

    break;

  case rfbVncAuth:
    if (!HandleVncAuth(client)) return FALSE;
    break;







  case rfbMSLogon:
    if (!HandleMSLogonAuth(client)) return FALSE;
    break;

  case rfbARD:

    var_109("GCrypt support was not compiled in\n");
    return FALSE;



    break;

  case rfbTLS:
    if (!HandleAnonTLSAuth(client)) return FALSE;



    if (!ReadSupportedSecurityType(client, &subAuthScheme, TRUE)) return FALSE;
    client->subAuthScheme = subAuthScheme;

    switch (subAuthScheme) {

      case rfbConnFailed:
        ReadReason(client);
        return FALSE;

      case rfbNoAuth:
        var_109("No sub authentication needed\n");

        if ((client->major==3 && client->minor > 7) || client->major>3)
            if (!rfbHandleAuthResult(client)) return FALSE;
        break;

      case rfbVncAuth:
        if (!HandleVncAuth(client)) return FALSE;
        break;







      default:
        var_109("Unknown sub authentication scheme from VNC server: %d\n",
            (int)subAuthScheme);
        return FALSE;
    }

    break;

  case rfbVeNCrypt:
    if (!HandleVeNCryptAuth(client)) return FALSE;

    switch (client->subAuthScheme) {

      case rfbVeNCryptTLSNone:
      case rfbVeNCryptX509None:
        var_109("No sub authentication needed\n");
        if (!rfbHandleAuthResult(client)) return FALSE;
        break;

      case rfbVeNCryptTLSVNC:
      case rfbVeNCryptX509VNC:
        if (!HandleVncAuth(client)) return FALSE;
        break;

      case rfbVeNCryptTLSPlain:
      case rfbVeNCryptX509Plain:
        if (!HandlePlainAuth(client)) return FALSE;
        break;

      default:
        var_109("Unknown sub authentication scheme from VNC server: %d\n",
            client->subAuthScheme);
        return FALSE;
    }

    break;

  default:
    {
      rfbBool var_79=FALSE;
      rfbClientProtocolExtension* var_108;
      for (var_108 = rfbClientExtensions; var_108; var_108 = var_108->next) {
        uint32_t const* secType;
        if (!var_108->handleAuthentication) continue;
        for (secType = var_108->securityTypes; secType && *secType; secType++) {
          if (authScheme==*secType) {
            if (!var_108->handleAuthentication(client, authScheme)) return FALSE;
            if (!rfbHandleAuthResult(client)) return FALSE;
            var_79=TRUE;
          }
        }
      }
      if (var_79) break;
    }
    var_109("Unknown authentication scheme from VNC server: %d\n",
     (int)authScheme);
    return FALSE;
  }

  ci.shared = (client->appData.shareDesktop ? 1 : 0);

  if (!WriteToRFBServer(client, (char *)&ci, sz_rfbClientInitMsg)) return FALSE;

  if (!ReadFromRFBServer(client, (char *)&client->si, sz_rfbServerInitMsg)) return FALSE;

  client->si.framebufferWidth = rfbClientSwap16IfLE(client->si.framebufferWidth);
  client->si.framebufferHeight = rfbClientSwap16IfLE(client->si.framebufferHeight);
  client->si.format.redMax = rfbClientSwap16IfLE(client->si.format.redMax);
  client->si.format.greenMax = rfbClientSwap16IfLE(client->si.format.greenMax);
  client->si.format.blueMax = rfbClientSwap16IfLE(client->si.format.blueMax);
  client->si.nameLength = rfbClientSwap32IfLE(client->si.nameLength);


  client->desktopName = malloc((uint64_t)client->si.nameLength + 1);
  if (!client->desktopName) {
    var_109("Error allocating memory for desktop name, %lu bytes\n",
            (unsigned long)client->si.nameLength);
    return FALSE;
  }

  if (!ReadFromRFBServer(client, client->desktopName, client->si.nameLength)) return FALSE;

  client->desktopName[client->si.nameLength] = 0;

  var_109("Desktop name \"%s\"\n",client->desktopName);

  var_109("Connected to VNC server, using protocol version %d.%d\n",
   client->major, client->minor);

  var_109("VNC server default format:\n");
  PrintPixelFormat(&client->si.format);

  return TRUE;
}






rfbBool
fn_79(rfbClient* client)
{
  rfbSetPixelFormatMsg spf;
  char buf[sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4];

  rfbSetEncodingsMsg *se = (rfbSetEncodingsMsg *)buf;
  uint32_t *encs = (uint32_t *)(&buf[sz_rfbSetEncodingsMsg]);
  int var_105 = 0;
  rfbBool var_84 = FALSE;
  rfbBool var_84 = FALSE;
  rfbBool var_84 = FALSE;
  rfbClientProtocolExtension* var_108;

  if (!SupportsClient2Server(client, rfbSetPixelFormat)) return TRUE;

  spf.type = rfbSetPixelFormat;
  spf.pad1 = 0;
  spf.pad2 = 0;
  spf.format = client->format;
  spf.format.redMax = rfbClientSwap16IfLE(spf.format.redMax);
  spf.format.greenMax = rfbClientSwap16IfLE(spf.format.greenMax);
  spf.format.blueMax = rfbClientSwap16IfLE(spf.format.blueMax);

  if (!WriteToRFBServer(client, (char *)&spf, sz_rfbSetPixelFormatMsg))
    return FALSE;


  if (!SupportsClient2Server(client, rfbSetEncodings)) return TRUE;

  se->type = rfbSetEncodings;
  se->pad = 0;
  se->nEncodings = 0;

  if (client->appData.encodingsString) {
    const char *encStr = client->appData.encodingsString;
    int encStrLen;
    do {
      const char *nextEncStr = strchr(encStr, ' ');
      if (nextEncStr) {
 encStrLen = nextEncStr - encStr;
 nextEncStr++;
      } else {
 encStrLen = strlen(encStr);
      }

      if (strncasecmp(encStr,"raw",encStrLen) == 0) {
 encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);
      } else if (strncasecmp(encStr,"copyrect",encStrLen) == 0) {
 encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);

      } else if (strncasecmp(encStr,"hextile",encStrLen) == 0) {
 encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);

      } else if ((strncasecmp(encStr,"ultra",encStrLen) == 0) || (strncasecmp(encStr,"ultrazip",encStrLen) == 0)) {

        encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);
        encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);
      } else if (strncasecmp(encStr,"corre",encStrLen) == 0) {
 encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);
      } else if (strncasecmp(encStr,"rre",encStrLen) == 0) {
 encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);
      } else {
 var_109("Unknown encoding '%.*s'\n",encStrLen,encStr);
      }

      encStr = nextEncStr;
    } while (encStr && se->nEncodings < MAX_ENCODINGS);

    if (se->nEncodings < MAX_ENCODINGS && var_84) {
      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +
       rfbEncodingCompressLevel0);
    }

    if (se->nEncodings < MAX_ENCODINGS && var_84) {
      if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)
        client->appData.qualityLevel = 5;
      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +
       rfbEncodingQualityLevel0);
    }
  }
  else {
    if (SameMachine(client->sock)) {



      var_109("Same machine: preferring raw encoding\n");
      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);





    }

    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);






    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);





    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);

    if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9) {
      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +
       rfbEncodingCompressLevel0);
    } else {




      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCompressLevel1);
    }

    if (client->appData.enableJPEG) {
      if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)
 client->appData.qualityLevel = 5;
      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +
       rfbEncodingQualityLevel0);
    }
  }




  if (client->appData.useRemoteCursor) {
    if (se->nEncodings < MAX_ENCODINGS)
      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXCursor);
    if (se->nEncodings < MAX_ENCODINGS)
      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRichCursor);
    if (se->nEncodings < MAX_ENCODINGS)
      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingPointerPos);
  }


  if (se->nEncodings < MAX_ENCODINGS)
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingKeyboardLedState);


  if (se->nEncodings < MAX_ENCODINGS && client->canHandleNewFBSize)
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingNewFBSize);


  if (se->nEncodings < MAX_ENCODINGS && var_84)
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingLastRect);


  if (se->nEncodings < MAX_ENCODINGS)
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedMessages);
  if (se->nEncodings < MAX_ENCODINGS)
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedEncodings);
  if (se->nEncodings < MAX_ENCODINGS)
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingServerIdentity);


  if (se->nEncodings < MAX_ENCODINGS)
    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXvp);


  for(var_108 = rfbClientExtensions; var_108; var_108 = var_108->next)
    if(var_108->encodings) {
      int* enc;
      for(enc = var_108->encodings; *enc; enc++)
        if(se->nEncodings < MAX_ENCODINGS)
          encs[se->nEncodings++] = rfbClientSwap32IfLE(*enc);
    }

  var_105 = sz_rfbSetEncodingsMsg + se->nEncodings * 4;

  se->nEncodings = rfbClientSwap16IfLE(se->nEncodings);

  if (!WriteToRFBServer(client, buf, var_105)) return FALSE;

  return TRUE;
}






rfbBool
fn_84(rfbClient* client)
{
 return SendFramebufferUpdateRequest(client,
   client->updateRect.x, client->updateRect.y,
   client->updateRect.w, client->updateRect.h, TRUE);
}






rfbBool
fn_85(rfbClient* client, int var_102, int var_106, int var_89, int var_106, rfbBool var_89)
{
  rfbFramebufferUpdateRequestMsg fur;

  if (!SupportsClient2Server(client, rfbFramebufferUpdateRequest)) return TRUE;

  fur.type = rfbFramebufferUpdateRequest;
  fur.incremental = var_89 ? 1 : 0;
  fur.x = rfbClientSwap16IfLE(var_102);
  fur.y = rfbClientSwap16IfLE(var_106);
  fur.w = rfbClientSwap16IfLE(var_89);
  fur.h = rfbClientSwap16IfLE(var_106);

  if (!WriteToRFBServer(client, (char *)&fur, sz_rfbFramebufferUpdateRequestMsg))
    return FALSE;

  return TRUE;
}





rfbBool
fn_89(rfbClient* client,int var_91)
{
  rfbSetScaleMsg ssm;

  ssm.scale = var_91;
  ssm.pad = 0;


  if (SupportsClient2Server(client, rfbSetScale)) {
      ssm.type = rfbSetScale;
      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))
          return FALSE;
  }

  if (SupportsClient2Server(client, rfbPalmVNCSetScaleFactor)) {
      ssm.type = rfbPalmVNCSetScaleFactor;
      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))
          return FALSE;
  }

  return TRUE;
}







rfbBool fn_91(rfbClient* client, char *text)
{
    rfbTextChatMsg chat;
    int var_92 = strlen(text);

    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;
    chat.type = rfbTextChat;
    chat.pad1 = 0;
    chat.pad2 = 0;
    chat.length = (uint32_t)var_92;
    chat.length = rfbClientSwap32IfLE(chat.length);

    if (!WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg))
        return FALSE;

    if (var_92>0) {
        if (!WriteToRFBServer(client, text, var_92))
            return FALSE;
    }
    return TRUE;
}

rfbBool fn_92(rfbClient* client)
{
    rfbTextChatMsg chat;

    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;
    chat.type = rfbTextChat;
    chat.pad1 = 0;
    chat.pad2 = 0;
    chat.length = rfbClientSwap32IfLE(rfbTextChatOpen);
    return (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);
}

rfbBool fn_93(rfbClient* client)
{
    rfbTextChatMsg chat;
    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;
    chat.type = rfbTextChat;
    chat.pad1 = 0;
    chat.pad2 = 0;
    chat.length = rfbClientSwap32IfLE(rfbTextChatClose);
    return (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);
}

rfbBool fn_94(rfbClient* client)
{
    rfbTextChatMsg chat;
    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;
    chat.type = rfbTextChat;
    chat.pad1 = 0;
    chat.pad2 = 0;
    chat.length = rfbClientSwap32IfLE(rfbTextChatFinished);
    return (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);
}






rfbBool fn_95(rfbClient* client, int var_97)
{
    rfbSetServerInputMsg msg;

    if (!SupportsClient2Server(client, rfbSetServerInput)) return TRUE;

    msg.type = rfbSetServerInput;
    msg.status = (var_97 ? 1 : 0);
    msg.pad = 0;
    return (WriteToRFBServer(client, (char *)&msg, sz_rfbSetServerInputMsg) ? TRUE : FALSE);
}

rfbBool fn_97(rfbClient* client, uint8_t var_100, uint8_t var_100)
{
    rfbXvpMsg xvp;

    if (!SupportsClient2Server(client, rfbXvp)) return TRUE;
    xvp.type = rfbXvp;
    xvp.pad = 0;
    xvp.version = var_100;
    xvp.code = var_100;

    if (!WriteToRFBServer(client, (char *)&xvp, sz_rfbXvpMsg))
        return FALSE;

    return TRUE;
}






rfbBool
fn_100(rfbClient* client,int var_102, int var_106, int var_102)
{
  rfbPointerEventMsg pe;

  if (!SupportsClient2Server(client, rfbPointerEvent)) return TRUE;

  pe.type = rfbPointerEvent;
  pe.buttonMask = var_102;
  if (var_102 < 0) var_102 = 0;
  if (var_106 < 0) var_106 = 0;

  pe.x = rfbClientSwap16IfLE(var_102);
  pe.y = rfbClientSwap16IfLE(var_106);
  return WriteToRFBServer(client, (char *)&pe, sz_rfbPointerEventMsg);
}






rfbBool
fn_102(rfbClient* client, uint32_t var_104, rfbBool var_104)
{
  rfbKeyEventMsg ke;

  if (!SupportsClient2Server(client, rfbKeyEvent)) return TRUE;

  memset(&ke, 0, sizeof(ke));
  ke.type = rfbKeyEvent;
  ke.down = var_104 ? 1 : 0;
  ke.key = rfbClientSwap32IfLE(var_104);
  return WriteToRFBServer(client, (char *)&ke, sz_rfbKeyEventMsg);
}






rfbBool
fn_104(rfbClient* client, char *str, int var_105)
{
  rfbClientCutTextMsg cct;

  if (!SupportsClient2Server(client, rfbClientCutText)) return TRUE;

  memset(&cct, 0, sizeof(cct));
  cct.type = rfbClientCutText;
  cct.length = rfbClientSwap32IfLE(var_105);
  return (WriteToRFBServer(client, (char *)&cct, sz_rfbClientCutTextMsg) &&
    WriteToRFBServer(client, str, var_105));
}







rfbBool
fn_105(rfbClient* client)
{
  rfbServerToClientMsg msg;

  if (client->serverPort==-1)
    client->vncRec->readTimestamp = TRUE;
  if (!ReadFromRFBServer(client, (char *)&msg, 1))
    return FALSE;

  switch (msg.type) {

  case rfbSetColourMapEntries:
  {

    break;
  }

  case rfbFramebufferUpdate:
  {
    rfbFramebufferUpdateRectHeader rect;
    int linesToRead;
    int bytesPerLine;
    int i;

    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,
      sz_rfbFramebufferUpdateMsg - 1))
      return FALSE;

    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);

    for (i = 0; i < msg.fu.nRects; i++) {
      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))
 return FALSE;

      rect.encoding = rfbClientSwap32IfLE(rect.encoding);
      if (rect.encoding == rfbEncodingLastRect)
 break;

      rect.r.x = rfbClientSwap16IfLE(rect.r.x);
      rect.r.y = rfbClientSwap16IfLE(rect.r.y);
      rect.r.w = rfbClientSwap16IfLE(rect.r.w);
      rect.r.h = rfbClientSwap16IfLE(rect.r.h);


      if (rect.encoding == rfbEncodingXCursor ||
   rect.encoding == rfbEncodingRichCursor) {

 if (!HandleCursorShape(client,
          rect.r.x, rect.r.y, rect.r.w, rect.r.h,
          rect.encoding)) {
   return FALSE;
 }
 continue;
      }

      if (rect.encoding == rfbEncodingPointerPos) {
 if (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {
   return FALSE;
 }
 continue;
      }

      if (rect.encoding == rfbEncodingKeyboardLedState) {

          client->KeyboardLedStateEnabled = 1;
          if (client->HandleKeyboardLedState!=NULL)
              client->HandleKeyboardLedState(client, rect.r.x, 0);

          client->CurrentKeyboardLedState = rect.r.x;
          continue;
      }

      if (rect.encoding == rfbEncodingNewFBSize) {
 client->width = rect.r.w;
 client->height = rect.r.h;
 client->updateRect.x = client->updateRect.y = 0;
 client->updateRect.w = client->width;
 client->updateRect.h = client->height;
 if (!client->MallocFrameBuffer(client))
   return FALSE;
 SendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);
 var_109("Got new framebuffer size: %dx%d\n", rect.r.w, rect.r.h);
 continue;
      }


      if (rect.encoding == rfbEncodingSupportedMessages) {
          int var_106;
          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))
              return FALSE;




          var_109("client2server supported messages (bit flags)\n");
          for (var_106=0;var_106<32;var_106+=8)
            var_109("%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\n", var_106,
                client->supportedMessages.client2server[var_106], client->supportedMessages.client2server[var_106+1],
                client->supportedMessages.client2server[var_106+2], client->supportedMessages.client2server[var_106+3],
                client->supportedMessages.client2server[var_106+4], client->supportedMessages.client2server[var_106+5],
                client->supportedMessages.client2server[var_106+6], client->supportedMessages.client2server[var_106+7]);

          var_109("server2client supported messages (bit flags)\n");
          for (var_106=0;var_106<32;var_106+=8)
            var_109("%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\n", var_106,
                client->supportedMessages.server2client[var_106], client->supportedMessages.server2client[var_106+1],
                client->supportedMessages.server2client[var_106+2], client->supportedMessages.server2client[var_106+3],
                client->supportedMessages.server2client[var_106+4], client->supportedMessages.server2client[var_106+5],
                client->supportedMessages.server2client[var_106+6], client->supportedMessages.server2client[var_106+7]);
          continue;
      }


      if (rect.encoding == rfbEncodingSupportedEncodings) {
          char *buffer;
          buffer = malloc(rect.r.w);
          if (!ReadFromRFBServer(client, buffer, rect.r.w))
          {
              free(buffer);
              return FALSE;
          }



          free(buffer);
          continue;
      }


      if (rect.encoding == rfbEncodingServerIdentity) {
          char *buffer;
          buffer = malloc(rect.r.w+1);
          if (!ReadFromRFBServer(client, buffer, rect.r.w))
          {
              free(buffer);
              return FALSE;
          }
          buffer[rect.r.w]=0;
          var_109("Connected to Server \"%s\"\n", buffer);
          free(buffer);
          continue;
      }


      if (rect.encoding != rfbEncodingUltraZip)
      {
        if ((rect.r.x + rect.r.w > client->width) ||
     (rect.r.y + rect.r.h > client->height))
     {
       var_109("Rect too large: %dx%d at (%d, %d)\n",
      rect.r.w, rect.r.h, rect.r.x, rect.r.y);
       return FALSE;
            }

        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);
      }

      switch (rect.encoding) {

      case rfbEncodingRaw: {
 int var_106=rect.r.y, var_106=rect.r.h;

 bytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;



 linesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;

 while (linesToRead && var_106 > 0) {
   if (linesToRead > var_106)
     linesToRead = var_106;

   if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))
     return FALSE;

   client->GotBitmap(client, (uint8_t *)client->buffer,
      rect.r.x, var_106, rect.r.w,linesToRead);

   var_106 -= linesToRead;
   var_106 += linesToRead;

 }
 break;
      }

      case rfbEncodingCopyRect:
      {
 rfbCopyRect cr;

 if (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))
   return FALSE;

 cr.srcX = rfbClientSwap16IfLE(cr.srcX);
 cr.srcY = rfbClientSwap16IfLE(cr.srcY);




 client->SoftCursorLockArea(client,
       cr.srcX, cr.srcY, rect.r.w, rect.r.h);

        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,
                            rect.r.x, rect.r.y);

 break;
      }

      case rfbEncodingRRE:
      {
 switch (client->format.bitsPerPixel) {
 case 8:
   if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 case 16:
   if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 case 32:
   if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 }
 break;
      }

      case rfbEncodingCoRRE:
      {
 switch (client->format.bitsPerPixel) {
 case 8:
   if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 case 16:
   if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 case 32:
   if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 }
 break;
      }

      case rfbEncodingHextile:
      {
 switch (client->format.bitsPerPixel) {
 case 8:
   if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 case 16:
   if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 case 32:
   if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
     return FALSE;
   break;
 }
 break;
      }

      case rfbEncodingUltra:
      {
        switch (client->format.bitsPerPixel) {
        case 8:
          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
            return FALSE;
          break;
        case 16:
          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
            return FALSE;
          break;
        case 32:
          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
            return FALSE;
          break;
        }
        break;
      }
      case rfbEncodingUltraZip:
      {
        switch (client->format.bitsPerPixel) {
        case 8:
          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
            return FALSE;
          break;
        case 16:
          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
            return FALSE;
          break;
        case 32:
          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
            return FALSE;
          break;
        }
        break;
      }

      case rfbEncodingTRLE:
   {
        switch (client->format.bitsPerPixel) {
        case 8:
          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))
            return FALSE;
          break;
        case 16:
          if (client->si.format.greenMax > 0x1F) {
            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))
              return FALSE;
          } else {
            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))
              return FALSE;
          }
          break;
        case 32: {
          uint32_t var_107 =
              (client->format.redMax << client->format.redShift) |
              (client->format.greenMax << client->format.greenShift) |
              (client->format.blueMax << client->format.blueShift);
          if ((client->format.bigEndian && (var_107 & 0xff) == 0) ||
              (!client->format.bigEndian && (var_107 & 0xff000000) == 0)) {
            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))
              return FALSE;
          } else if (!client->format.bigEndian && (var_107 & 0xff) == 0) {
            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))
              return FALSE;
          } else if (client->format.bigEndian && (var_107 & 0xff000000) == 0) {
            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,
                                  rect.r.h))
              return FALSE;
          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,
                                   rect.r.h))
            return FALSE;
          break;
        }
        }
        break;
      }

      default:
  {
    rfbBool var_108 = FALSE;
    rfbClientProtocolExtension* var_108;

    for(var_108 = rfbClientExtensions; !var_108 && var_108; var_108 = var_108->next)
      if(var_108->handleEncoding && var_108->handleEncoding(client, &rect))
        var_108 = TRUE;

    if(!var_108) {
      var_109("Unknown rect encoding %d\n",
   (int)rect.encoding);
      return FALSE;
    }
  }
      }


      client->SoftCursorUnlockScreen(client);

      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);
    }

    if (!SendIncrementalFramebufferUpdateRequest(client))
      return FALSE;

    if (client->FinishedFrameBufferUpdate)
      client->FinishedFrameBufferUpdate(client);

    break;
  }

  case rfbBell:
  {
    client->Bell(client);

    break;
  }

  case rfbServerCutText:
  {
    char *buffer;

    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
      sz_rfbServerCutTextMsg - 1))
      return FALSE;

    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);

    if (msg.sct.length > 1048576) {
     var_108("Ignoring too big cut text length sent by server: %u B > 1 MB\n", (unsigned int)msg.sct.length);
     return FALSE;
    }

    buffer = malloc((uint64_t)msg.sct.length+1);

    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {
      free(buffer);
      return FALSE;
    }

    buffer[msg.sct.length] = 0;

    if (client->GotXCutText)
      client->GotXCutText(client, buffer, msg.sct.length);

    free(buffer);

    break;
  }

  case rfbTextChat:
  {
      char *buffer=NULL;
      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
                             sz_rfbTextChatMsg- 1))
        return FALSE;
      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);
      switch(msg.tc.length) {
      case rfbTextChatOpen:
          var_109("Received TextChat Open\n");
          if (client->HandleTextChat!=NULL)
              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);
          break;
      case rfbTextChatClose:
          var_109("Received TextChat Close\n");
         if (client->HandleTextChat!=NULL)
              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);
          break;
      case rfbTextChatFinished:
          var_109("Received TextChat Finished\n");
         if (client->HandleTextChat!=NULL)
              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);
          break;
      default:
          buffer=malloc(msg.tc.length+1);
          if (!ReadFromRFBServer(client, buffer, msg.tc.length))
          {
              free(buffer);
              return FALSE;
          }

          buffer[msg.tc.length]=0;
          var_109("Received TextChat \"%s\"\n", buffer);
          if (client->HandleTextChat!=NULL)
              client->HandleTextChat(client, (int)msg.tc.length, buffer);
          free(buffer);
          break;
      }
      break;
  }

  case rfbXvp:
  {
    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
                           sz_rfbXvpMsg -1))
      return FALSE;

    SetClient2Server(client, rfbXvp);



    SetServer2Client(client, rfbXvp);

    if(client->HandleXvpMsg)
      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);

    break;
  }

  case rfbResizeFrameBuffer:
  {
    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
                           sz_rfbResizeFrameBufferMsg -1))
      return FALSE;
    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);
    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);
    client->updateRect.x = client->updateRect.y = 0;
    client->updateRect.w = client->width;
    client->updateRect.h = client->height;
    if (!client->MallocFrameBuffer(client))
      return FALSE;

    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);
    var_109("Got new framebuffer size: %dx%d\n", client->width, client->height);
    break;
  }

  case rfbPalmVNCReSizeFrameBuffer:
  {
    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))
      return FALSE;
    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);
    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);
    client->updateRect.x = client->updateRect.y = 0;
    client->updateRect.w = client->width;
    client->updateRect.h = client->height;
    if (!client->MallocFrameBuffer(client))
      return FALSE;
    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);
    var_109("Got new framebuffer size: %dx%d\n", client->width, client->height);
    break;
  }

  default:
    {
      rfbBool var_108 = FALSE;
      rfbClientProtocolExtension* var_108;

      for(var_108 = rfbClientExtensions; !var_108 && var_108; var_108 = var_108->next)
 if(var_108->handleMessage && var_108->handleMessage(client, &msg))
   var_108 = TRUE;

      if(!var_108) {
 char buffer[256];
 var_109("Unknown message type %d from VNC server\n",msg.type);
 ReadFromRFBServer(client, buffer, 256);
 return FALSE;
      }
    }
  }

  return TRUE;
}

void
fn_108(rfbPixelFormat *format)
{
  if (format->bitsPerPixel == 1) {
    var_109("  Single bit per pixel.\n");
    var_109(
     "  %s significant bit in each byte is leftmost on the screen.\n",
     (format->bigEndian ? "Most" : "Least"));
  } else {
    var_109("  %d bits per pixel.\n",format->bitsPerPixel);
    if (format->bitsPerPixel != 8) {
      var_109("  %s significant byte first in each pixel.\n",
       (format->bigEndian ? "Most" : "Least"));
    }
    if (format->trueColour) {
      var_109("  TRUE colour: max red %d green %d blue %d"
     ", shift red %d green %d blue %d\n",
     format->redMax, format->greenMax, format->blueMax,
     format->redShift, format->greenShift, format->blueShift);
    } else {
      var_109("  Colour map (not true colour).\n");
    }
  }
}
