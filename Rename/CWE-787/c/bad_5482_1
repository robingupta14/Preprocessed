







extern int fn_0(int, char**, char*);

static int var_46 = -1;
static uint32 tilewidth;
static uint32 tilelength;

static uint16 config;
static uint16 compression;
static uint16 predictor;
static int preset;
static uint16 fillorder;
static uint16 orientation;
static uint32 rowsperstrip;
static uint32 g3opts;
static int var_103 = 0;
static uint32 var_31 = (uint32) -1;
static int var_46 = 75;
static int var_46 = var_46;
static uint16 var_31 = (uint16) -1;
static uint16 var_31 = (uint16) -1;
static int var_30 = -1;

static int fn_42(TIFF*, TIFF*);
static int fn_31(char*);
static void fn_31(void);

static char var_28 = ',';
static TIFF* bias = NULL;
static int var_48 = 0;
static int var_48 = 0;

static int fn_16 (TIFF *tif, char **imageSpec)





{
 if (**imageSpec == var_28) {
  char *start = *imageSpec + 1;
  tdir_t var_18 = (tdir_t)strtol(start, imageSpec, 0);
  if (start == *imageSpec) var_18 = TIFFCurrentDirectory (tif);
  if (**imageSpec)
  {
   if (**imageSpec == var_28) {

    if ((*imageSpec)[1] == '\0') *imageSpec = NULL;
   }else{
    fprintf (stderr,
        "Expected a %c separated image # list after %s\n",
        var_28, TIFFFileName (tif));
    exit (-4);
   }
  }
  if (TIFFSetDirectory (tif, var_18)) return 1;
  fprintf (stderr, "%s%c%d not found!\n",
      TIFFFileName(tif), var_28, (int) var_18);
 }
 return 0;
}


static TIFF* fn_18 (char **imageSpec)





{
 TIFF *tif;
 char *fn = *imageSpec;
 *imageSpec = strchr (fn, var_28);
 if (*imageSpec) {
  **imageSpec = '\0';
  tif = TIFFOpen (fn, "r");

  if (!(*imageSpec)[1]) {*imageSpec = NULL; return tif;}
  if (tif) {
   **imageSpec = var_28;
   if (!nextSrcImage(tif, imageSpec)) {
    TIFFClose (tif);
    tif = NULL;
   }
  }
 }else
  tif = TIFFOpen (fn, "r");
 return tif;
}

int
fn_19(int var_29, char* argv[])
{
 uint16 var_29 = (uint16) -1;
 uint16 var_29 = 0;
 uint32 var_29 = (uint32) -1;
 uint32 var_29 = (uint32) -1;
 uint32 var_29 = (uint32) 0;
 uint64 var_29 = 0;
 TIFF* in;
 TIFF* out;
 char var_29[10];
 char* mp = var_29;
 int c;

 extern int optind;
 extern char* optarg;


 *mp++ = 'w';
 *mp = '\0';
 while ((c = getopt(var_29, argv, ",:b:c:f:l:o:p:r:w:aistBLMC8x")) != -1)
  switch (c) {
  case ',':
   if (optarg[0] != '=') usage();
   var_28 = optarg[1];
   break;
  case 'b':
   if (bias) {
    fputs ("Only 1 bias image may be specified\n", stderr);
    exit (-2);
   }
   {
    uint16 var_29 = (uint16) -1;
    char **biasFn = &optarg;
    bias = openSrcImage (biasFn);
    if (!bias) exit (-5);
    if (TIFFIsTiled (bias)) {
     fputs ("Bias image must be organized in strips\n", stderr);
     exit (-7);
    }
    TIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &var_29);
    if (var_29 != 1) {
     fputs ("Bias image must be monochrome\n", stderr);
     exit (-7);
    }
   }
   break;
  case 'a':
   var_29[0] = 'a';
   break;
  case 'c':
   if (!processCompressOptions(optarg))
    usage();
   break;
  case 'f':
   if ((strcmp(optarg,"lsb2msb") == 0))
    var_29 = FILLORDER_LSB2MSB;
   else if ((strcmp(optarg,"msb2lsb") == 0))
    var_29 = FILLORDER_MSB2LSB;
   else
    usage();
   break;
  case 'i':
   var_103 = 1;
   break;
  case 'l':
   var_46 = 1;
   var_29 = atoi(optarg);
   break;
  case 'o':
   var_29 = strtoul(optarg, NULL, 0);
   break;
  case 'p':
   if ((strcmp(optarg,"separate") == 0))
    var_29 = PLANARCONFIG_SEPARATE;
   else if ((strcmp(optarg,"contig") == 0))
    var_29 = PLANARCONFIG_CONTIG;
   else
    usage();
   break;
  case 'r':
   var_29 = atol(optarg);
   break;
  case 's':
   var_46 = 0;
   break;
  case 't':
   var_46 = 1;
   break;
  case 'w':
   var_46 = 1;
   var_29 = atoi(optarg);
   break;
  case 'B':
   *mp++ = 'b'; *mp = '\0';
   break;
  case 'L':
   *mp++ = 'l'; *mp = '\0';
   break;
  case 'M':
   *mp++ = 'm'; *mp = '\0';
   break;
  case 'C':
   *mp++ = 'c'; *mp = '\0';
   break;
  case '8':
   *mp++ = '8'; *mp = '\0';
   break;
  case 'x':
   var_48 = 1;
   break;
  case '?':
   usage();

  }
 if (var_29 - optind < 2)
  usage();
 out = TIFFOpen(argv[var_29-1], var_29);
 if (out == NULL)
  return -2;
 if ((var_29 - optind) == 2)
  var_48 = -1;
 for (; optind < var_29-1 ; optind++) {
  char *imageCursor = argv[optind];
  in = openSrcImage (&imageCursor);
  if (in == NULL) {
   (void) TIFFClose(out);
   return -3;
  }
  if (var_29 != 0 && !TIFFSetSubDirectory(in, var_29)) {
   TIFFError(TIFFFileName(in),
       "Error, setting subdirectory at " TIFF_UINT64_FORMAT, var_29);
   (void) TIFFClose(in);
   (void) TIFFClose(out);
   return 1;
  }
  for (;;) {
   config = var_29;
   compression = var_31;
   predictor = var_31;
                        preset = var_30;
   fillorder = var_29;
   rowsperstrip = var_29;
   tilewidth = var_29;
   tilelength = var_29;
   g3opts = var_31;
   if (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {
    (void) TIFFClose(in);
    (void) TIFFClose(out);
    return 1;
   }
   if (imageCursor) {
    if (!nextSrcImage(in, &imageCursor)) break;
   }else
    if (!TIFFReadDirectory(in)) break;
  }
  (void) TIFFClose(in);
 }

 (void) TIFFClose(out);
 return 0;
}

static void
fn_29(char* cp)
{
 if ( (cp = strchr(cp, ':')) ) {
  do {
   cp++;
   if (isdigit((int)*cp))
    var_31 = atoi(cp);
   else if (*cp == 'p')
    var_30 = atoi(++cp);
   else
    usage();
  } while( (cp = strchr(cp, ':')) );
 }
}

static void
fn_30(char* cp)
{
 if( (cp = strchr(cp, ':')) ) {
  if (var_31 == (uint32) -1)
   var_31 = 0;
  do {
   cp++;
   if ((strncmp(cp,"1d",2) == 0))
    var_31 &= ~GROUP3OPT_2DENCODING;
   else if ((strncmp(cp,"2d",2) == 0))
    var_31 |= GROUP3OPT_2DENCODING;
   else if ((strncmp(cp,"fill",4) == 0))
    var_31 |= GROUP3OPT_FILLBITS;
   else
    usage();
  } while( (cp = strchr(cp, ':')) );
 }
}

static int
fn_31(char* opt)
{
 if ((strcmp(opt,"none") == 0)) {
  var_31 = COMPRESSION_NONE;
 } else if ((strcmp(opt,"packbits") == 0)) {
  var_31 = COMPRESSION_PACKBITS;
 } else if ((strncmp(opt,"jpeg",4) == 0)) {
  char* cp = strchr(opt, ':');

  var_31 = COMPRESSION_JPEG;
  while( cp )
  {
   if (isdigit((int)cp[1]))
    var_46 = atoi(cp+1);
   else if (cp[1] == 'r' )
    var_46 = JPEGCOLORMODE_RAW;
   else
    usage();

   cp = strchr(cp+1,':');
  }
 } else if ((strncmp(opt,"g3",2) == 0)) {
  processG3Options(opt);
  var_31 = COMPRESSION_CCITTFAX3;
 } else if ((strcmp(opt,"g4") == 0)) {
  var_31 = COMPRESSION_CCITTFAX4;
 } else if ((strncmp(opt,"lzw",3) == 0)) {
  char* cp = strchr(opt, ':');
  if (cp)
   var_31 = atoi(cp+1);
  var_31 = COMPRESSION_LZW;
 } else if ((strncmp(opt,"zip",3) == 0)) {
  processZIPOptions(opt);
  var_31 = COMPRESSION_ADOBE_DEFLATE;
 } else if ((strncmp(opt,"lzma",4) == 0)) {
  processZIPOptions(opt);
  var_31 = COMPRESSION_LZMA;
 } else if ((strncmp(opt,"jbig",4) == 0)) {
  var_31 = COMPRESSION_JBIG;
 } else if ((strncmp(opt,"sgilog",6) == 0)) {
  var_31 = COMPRESSION_SGILOG;
 } else
  return 0;
 return 1;
}

char* stuff[] = {
"usage: tiffcp [options] input... output",
"where options are:",
" -a              append to output instead of overwriting",
" -o offset       set initial directory offset",
" -p contig       pack samples contiguously (e.g. RGBRGB...)",
" -p separate     store samples separately (e.g. RRR...GGG...BBB...)",
" -s              write output in strips",
" -t              write output in tiles",
" -x              force the merged tiff pages in sequence",
" -8              write BigTIFF instead of default ClassicTIFF",
" -B              write big-endian instead of native byte order",
" -L              write little-endian instead of native byte order",
" -M              disable use of memory-mapped files",
" -C              disable strip chopping",
" -i              ignore read errors",
" -b file[,#]     bias (dark) monochrome image to be subtracted from all others",
" -,=%            use % rather than , to separate image #'s (per Note below)",
"",
" -r #            make each strip have no more than # rows",
" -w #            set output tile width (pixels)",
" -l #            set output tile length (pixels)",
"",
" -f lsb2msb      force lsb-to-msb FillOrder for output",
" -f msb2lsb      force msb-to-lsb FillOrder for output",
"",
" -c lzw[:opts]   compress output with Lempel-Ziv & Welch encoding",
" -c zip[:opts]   compress output with deflate encoding",
" -c lzma[:opts]  compress output with LZMA2 encoding",
" -c jpeg[:opts]  compress output with JPEG encoding",
" -c jbig         compress output with ISO JBIG encoding",
" -c packbits     compress output with packbits encoding",
" -c g3[:opts]    compress output with CCITT Group 3 encoding",
" -c g4           compress output with CCITT Group 4 encoding",
" -c sgilog       compress output with SGILOG encoding",
" -c none         use no compression algorithm on output",
"",
"Group 3 options:",
" 1d              use default CCITT Group 3 1D-encoding",
" 2d              use optional CCITT Group 3 2D-encoding",
" fill            byte-align EOL codes",
"For example, -c g3:2d:fill to get G3-2D-encoded data with byte-aligned EOLs",
"",
"JPEG options:",
" #               set compression quality level (0-100, default 75)",
" r               output color image as RGB rather than YCbCr",
"For example, -c jpeg:r:50 to get JPEG-encoded RGB data with 50% comp. quality",
"",
"LZW, Deflate (ZIP) and LZMA2 options:",
" #               set predictor value",
" p#              set compression level (preset)",
"For example, -c lzw:2 to get LZW-encoded data with horizontal differencing,",
"-c zip:3:p9 for Deflate encoding with maximum compression level and floating",
"point predictor.",
"",
"Note that input filenames may be of the form filename,x,y,z",
"where x, y, and z specify image numbers in the filename to copy.",
"example:  tiffcp -c none -b esp.tif,1 esp.tif,0 test.tif",
"  subtract 2nd image in esp.tif from 1st yielding uncompressed result test.tif",
NULL
};

static void
fn_31(void)
{
 char var_111[BUFSIZ];
 int var_59;

 setbuf(stderr, var_111);
 fprintf(stderr, "%s\n\n", TIFFGetVersion());
 for (var_59 = 0; stuff[var_59] != NULL; var_59++)
  fprintf(stderr, "%s\n", stuff[var_59]);
 exit(-1);
}

static void
fn_33(TIFF* in, TIFF* out, uint16 var_37, uint16 var_37, TIFFDataType var_37)
{
 switch (var_37) {
 case TIFF_SHORT:
  if (var_37 == 1) {
   uint16 shortv;
   if (TIFFGetField(in, var_37, &shortv)) TIFFSetField(out, var_37, shortv);
  } else if (var_37 == 2) {
   uint16 shortv1, shortv2;
   if (TIFFGetField(in, var_37, &shortv1, &shortv2)) TIFFSetField(out, var_37, shortv1, shortv2);
  } else if (var_37 == 4) {
   uint16 *tr, *tg, *tb, *ta;
   if (TIFFGetField(in, var_37, &tr, &tg, &tb, &ta)) TIFFSetField(out, var_37, tr, tg, tb, ta);
  } else if (var_37 == (uint16) -1) {
   uint16 shortv1;
   uint16* shortav;
   if (TIFFGetField(in, var_37, &shortv1, &shortav)) TIFFSetField(out, var_37, shortv1, shortav);
  }
  break;
 case TIFF_LONG:
  { uint32 longv;
    if (TIFFGetField(in, var_37, &longv)) TIFFSetField(out, var_37, longv);
  }
  break;
 case TIFF_RATIONAL:
  if (var_37 == 1) {
   float floatv;
   if (TIFFGetField(in, var_37, &floatv)) TIFFSetField(out, var_37, floatv);
  } else if (var_37 == (uint16) -1) {
   float* floatav;
   if (TIFFGetField(in, var_37, &floatav)) TIFFSetField(out, var_37, floatav);
  }
  break;
 case TIFF_ASCII:
  { char* stringv;
    if (TIFFGetField(in, var_37, &stringv)) TIFFSetField(out, var_37, stringv);
  }
  break;
 case TIFF_DOUBLE:
  if (var_37 == 1) {
   double doublev;
   if (TIFFGetField(in, var_37, &doublev)) TIFFSetField(out, var_37, doublev);
  } else if (var_37 == (uint16) -1) {
   double* doubleav;
   if (TIFFGetField(in, var_37, &doubleav)) TIFFSetField(out, var_37, doubleav);
  }
  break;
 default:
  TIFFError(TIFFFileName(in),
      "Data type %d is not supported, tag %d skipped.",
      var_37, var_37);
 }
}

static struct struct_46 {
 uint16 tag;
 uint16 count;
 TIFFDataType type;
} tags[] = {
 { TIFFTAG_SUBFILETYPE, 1, TIFF_LONG },
 { TIFFTAG_THRESHHOLDING, 1, TIFF_SHORT },
 { TIFFTAG_DOCUMENTNAME, 1, TIFF_ASCII },
 { TIFFTAG_IMAGEDESCRIPTION, 1, TIFF_ASCII },
 { TIFFTAG_MAKE, 1, TIFF_ASCII },
 { TIFFTAG_MODEL, 1, TIFF_ASCII },
 { TIFFTAG_MINSAMPLEVALUE, 1, TIFF_SHORT },
 { TIFFTAG_MAXSAMPLEVALUE, 1, TIFF_SHORT },
 { TIFFTAG_XRESOLUTION, 1, TIFF_RATIONAL },
 { TIFFTAG_YRESOLUTION, 1, TIFF_RATIONAL },
 { TIFFTAG_PAGENAME, 1, TIFF_ASCII },
 { TIFFTAG_XPOSITION, 1, TIFF_RATIONAL },
 { TIFFTAG_YPOSITION, 1, TIFF_RATIONAL },
 { TIFFTAG_RESOLUTIONUNIT, 1, TIFF_SHORT },
 { TIFFTAG_SOFTWARE, 1, TIFF_ASCII },
 { TIFFTAG_DATETIME, 1, TIFF_ASCII },
 { TIFFTAG_ARTIST, 1, TIFF_ASCII },
 { TIFFTAG_HOSTCOMPUTER, 1, TIFF_ASCII },
 { TIFFTAG_WHITEPOINT, (uint16) -1, TIFF_RATIONAL },
 { TIFFTAG_PRIMARYCHROMATICITIES,(uint16) -1,TIFF_RATIONAL },
 { TIFFTAG_HALFTONEHINTS, 2, TIFF_SHORT },
 { TIFFTAG_INKSET, 1, TIFF_SHORT },
 { TIFFTAG_DOTRANGE, 2, TIFF_SHORT },
 { TIFFTAG_TARGETPRINTER, 1, TIFF_ASCII },
 { TIFFTAG_SAMPLEFORMAT, 1, TIFF_SHORT },
 { TIFFTAG_YCBCRCOEFFICIENTS, (uint16) -1,TIFF_RATIONAL },
 { TIFFTAG_YCBCRSUBSAMPLING, 2, TIFF_SHORT },
 { TIFFTAG_YCBCRPOSITIONING, 1, TIFF_SHORT },
 { TIFFTAG_REFERENCEBLACKWHITE, (uint16) -1,TIFF_RATIONAL },
 { TIFFTAG_EXTRASAMPLES, (uint16) -1, TIFF_SHORT },
 { TIFFTAG_SMINSAMPLEVALUE, 1, TIFF_DOUBLE },
 { TIFFTAG_SMAXSAMPLEVALUE, 1, TIFF_DOUBLE },
 { TIFFTAG_STONITS, 1, TIFF_DOUBLE },
};




typedef int (*copyFunc)
    (TIFF* in, TIFF* out, uint32 var_124, uint32 var_124, uint16 var_123);
static copyFunc fn_123(TIFF*, TIFF*, uint16, uint16);



static int
fn_42(TIFF* in, TIFF* out)
{
 uint16 var_123, var_123 = 1;
 uint16 input_compression, var_46 = var_44;
 copyFunc cf;
 uint32 var_111, length;
 struct struct_46* p;

 if (TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &var_111)) TIFFSetField(out, TIFFTAG_IMAGEWIDTH, var_111);
 if (TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length)) TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);
 if (TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &var_123)) TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, var_123);
 if (TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &var_123)) TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, var_123);
 if (compression != (uint16)-1)
  TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
 else
  if (TIFFGetField(in, TIFFTAG_COMPRESSION, &compression)) TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
 TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);
 TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &var_46);
 if (input_compression == COMPRESSION_JPEG) {

  TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, var_46);
 } else if (var_46 == PHOTOMETRIC_YCBCR) {

  uint16 subsamplinghor,subsamplingver;

  TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
          &subsamplinghor, &subsamplingver);
  if (subsamplinghor!=1 || subsamplingver!=1) {
   fprintf(stderr, "tiffcp: %s: Can't copy/convert subsampled image.\n",
    TIFFFileName(in));
   return 0;
  }
 }
 if (compression == COMPRESSION_JPEG) {
  if (var_46 == PHOTOMETRIC_RGB &&
      var_46 == var_46)
    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
  else
    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, var_46);
 }
 else if (compression == COMPRESSION_SGILOG
     || compression == COMPRESSION_SGILOG24)
  TIFFSetField(out, TIFFTAG_PHOTOMETRIC,
      var_123 == 1 ?
      PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
 else if (input_compression == COMPRESSION_JPEG &&
    var_123 == 3 ) {


  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
 }
 else
  cpTag(in, out, TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);
 if (fillorder != 0)
  TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
 else
  cpTag(in, out, TIFFTAG_FILLORDER, 1, TIFF_SHORT);



 TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
 switch (orientation) {
  case ORIENTATION_BOTRIGHT:
  case ORIENTATION_RIGHTBOT:
   TIFFWarning(TIFFFileName(in), "using bottom-left orientation");
   orientation = ORIENTATION_BOTLEFT;

  case ORIENTATION_LEFTBOT:
  case ORIENTATION_BOTLEFT:
   break;
  case ORIENTATION_TOPRIGHT:
  case ORIENTATION_RIGHTTOP:
  default:
   TIFFWarning(TIFFFileName(in), "using top-left orientation");
   orientation = ORIENTATION_TOPLEFT;

  case ORIENTATION_LEFTTOP:
  case ORIENTATION_TOPLEFT:
   break;
 }
 TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);





 if (var_46 == -1)
  var_46 = TIFFIsTiled(in);
 if (var_46) {






  if (tilewidth == (uint32) -1)
   TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
  if (tilelength == (uint32) -1)
   TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);
  TIFFDefaultTileSize(out, &tilewidth, &tilelength);
  TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
  TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
 } else {





  if (rowsperstrip == (uint32) 0) {
   if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,
       &rowsperstrip)) {
    rowsperstrip =
        TIFFDefaultStripSize(out, rowsperstrip);
   }
   if (rowsperstrip > length && rowsperstrip != (uint32)-1)
    rowsperstrip = length;
  }
  else if (rowsperstrip == (uint32) -1)
   rowsperstrip = length;
  TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
 }
 if (config != (uint16) -1)
  TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
 else
  if (TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config)) TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
 if (var_123 <= 4)
  cpTag(in, out, TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
 cpTag(in, out, TIFFTAG_COLORMAP, 4, TIFF_SHORT);

 switch (compression) {
  case COMPRESSION_JPEG:
   TIFFSetField(out, TIFFTAG_JPEGQUALITY, var_46);
   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, var_46);
   break;
  case COMPRESSION_JBIG:
   cpTag(in, out, TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
   cpTag(in, out, TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
   cpTag(in, out, TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
   cpTag(in, out, TIFFTAG_FAXDCS, 1, TIFF_ASCII);
   break;
  case COMPRESSION_LZW:
  case COMPRESSION_ADOBE_DEFLATE:
  case COMPRESSION_DEFLATE:
                case COMPRESSION_LZMA:
   if (predictor != (uint16)-1)
    TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
   else
    if (TIFFGetField(in, TIFFTAG_PREDICTOR, &predictor)) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
   if (preset != -1) {
                                if (compression == COMPRESSION_ADOBE_DEFLATE
                                         || compression == COMPRESSION_DEFLATE)
                                        TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);
    else if (compression == COMPRESSION_LZMA)
     TIFFSetField(out, TIFFTAG_LZMAPRESET, preset);
                        }
   break;
  case COMPRESSION_CCITTFAX3:
  case COMPRESSION_CCITTFAX4:
   if (compression == COMPRESSION_CCITTFAX3) {
    if (g3opts != (uint32) -1)
     TIFFSetField(out, TIFFTAG_GROUP3OPTIONS,
         g3opts);
    else
     if (TIFFGetField(in, TIFFTAG_GROUP3OPTIONS, &g3opts)) TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);
   } else
    cpTag(in, out, TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
   cpTag(in, out, TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
   cpTag(in, out, TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
   cpTag(in, out, TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
   cpTag(in, out, TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
   cpTag(in, out, TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
   cpTag(in, out, TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
   break;
 }
 {
  uint32 len32;
  void** data;
  if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
   TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
 }
 {
  uint16 ninks;
  const char* var_48;
  if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
   TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
   if (TIFFGetField(in, TIFFTAG_INKNAMES, &var_48)) {
    int var_48 = strlen(var_48) + 1;
    const char* cp = var_48;
    while (ninks > 1) {
     cp = strchr(cp, '\0');
                                        cp++;
                                        var_48 += (strlen(cp) + 1);
     ninks--;
    }
    TIFFSetField(out, TIFFTAG_INKNAMES, var_48, var_48);
   }
  }
 }
 {
  unsigned short pg0, pg1;

  if (var_48 == 1) {
   if (var_48 < 0) {
    if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))
     TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
   } else
    TIFFSetField(out, TIFFTAG_PAGENUMBER, var_48++, 0);

  } else {
   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
    if (var_48 < 0)
     TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
    else
     TIFFSetField(out, TIFFTAG_PAGENUMBER, var_48++, 0);
   }
  }
 }

 for (p = tags; p < &tags[(sizeof (tags) / sizeof (tags[0]))]; p++)
  cpTag(in, out, p->tag, p->count, p->type);

 cf = pickCopyFunc(in, out, var_123, var_123);
 return (cf ? (*cf)(in, out, length, var_111, var_123) : 0);
}

typedef int (*readFunc)(TIFF*, uint8*, uint32, uint32, tsample_t);




typedef int (*writeFunc)(TIFF*, uint8*, uint32, uint32, tsample_t);




static int fn_48(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 tsize_t var_94 = TIFFScanlineSize(in);
 tdata_t var_111;
 uint32 var_111;

 var_111 = _TIFFmalloc(var_94);
 if (!var_111)
  return 0;
 _TIFFmemset(var_111, 0, var_94);
 (void) var_123; (void) var_123;
 for (var_111 = 0; var_111 < var_123; var_111++) {
  if (TIFFReadScanline(in, var_111, var_111, 0) < 0 && !var_103) {
   TIFFError(TIFFFileName(in),
      "Error, can't read scanline %lu",
      (unsigned long) var_111);
   goto bad;
  }
  if (TIFFWriteScanline(out, var_111, var_111, 0) < 0) {
   TIFFError(TIFFFileName(out),
      "Error, can't write scanline %lu",
      (unsigned long) var_111);
   goto bad;
  }
 }
 _TIFFfree(var_111);
 return 1;
bad:
 _TIFFfree(var_111);
 return 0;
}


typedef void biasFn (void *image, void *bias, uint32 var_59);

static void fn_55 (void *var_59, void *var_59, uint32 var_59){ uint8 *image = var_59; uint8 *bias = var_59; while (var_59--) { *image = *image > *bias ? *image-*bias : 0; image++, bias++; } }
static void fn_57 (void *var_59, void *var_59, uint32 var_59){ uint16 *image = var_59; uint16 *bias = var_59; while (var_59--) { *image = *image > *bias ? *image-*bias : 0; image++, bias++; } }
static void fn_58 (void *var_59, void *var_59, uint32 var_59){ uint32 *image = var_59; uint32 *bias = var_59; while (var_59--) { *image = *image > *bias ? *image-*bias : 0; image++, bias++; } }

static biasFn *fn_59 (unsigned var_61)
{
 switch (var_61) {
  case 8: return subtract8;
  case 16: return subtract16;
  case 32: return subtract32;
 }
 return NULL;
}




static int fn_61(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 if (var_123 == 1) {
  tsize_t var_66 = TIFFScanlineSize(bias);
  tsize_t var_67 = TIFFScanlineSize(in);
  tdata_t var_111, biasBuf;
  uint32 var_66 = 0, var_66 = 0;
  TIFFGetField(bias, TIFFTAG_IMAGEWIDTH, &var_66);
  TIFFGetField(bias, TIFFTAG_IMAGELENGTH, &var_66);
  if (var_66 == var_67 &&
      var_123 == var_66 && var_123 == var_66) {
   uint16 var_67 = 0;
   biasFn *subtractLine;
   TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &var_67);
   subtractLine = lineSubtractFn (var_67);
   if (subtractLine) {
    uint32 var_111;
    var_111 = _TIFFmalloc(var_67);
    biasBuf = _TIFFmalloc(var_67);
    for (var_111 = 0; var_111 < var_123; var_111++) {
     if (TIFFReadScanline(in, var_111, var_111, 0) < 0
         && !var_103) {
      TIFFError(TIFFFileName(in),
          "Error, can't read scanline %lu",
          (unsigned long) var_111);
      goto bad;
     }
     if (TIFFReadScanline(bias, biasBuf, var_111, 0) < 0
         && !var_103) {
      TIFFError(TIFFFileName(in),
          "Error, can't read biased scanline %lu",
          (unsigned long) var_111);
      goto bad;
     }
     subtractLine (var_111, biasBuf, var_123);
     if (TIFFWriteScanline(out, var_111, var_111, 0) < 0) {
      TIFFError(TIFFFileName(out),
          "Error, can't write scanline %lu",
          (unsigned long) var_111);
      goto bad;
     }
    }

    _TIFFfree(var_111);
    _TIFFfree(biasBuf);
    TIFFSetDirectory(bias,
        TIFFCurrentDirectory(bias));
    return 1;
bad:
    _TIFFfree(var_111);
    _TIFFfree(biasBuf);
    return 0;
   } else {
    TIFFError(TIFFFileName(in),
        "No support for biasing %d bit pixels\n",
        var_67);
    return 0;
   }
  }
  TIFFError(TIFFFileName(in),
      "Bias image %s,%d\nis not the same size as %s,%d\n",
      TIFFFileName(bias), TIFFCurrentDirectory(bias),
      TIFFFileName(in), TIFFCurrentDirectory(in));
  return 0;
 } else {
  TIFFError(TIFFFileName(in),
      "Can't bias %s,%d as it has >1 Sample/Pixel\n",
      TIFFFileName(in), TIFFCurrentDirectory(in));
  return 0;
 }

}





static int fn_67(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 tsize_t var_108 = TIFFStripSize(in);
 tdata_t var_111 = _TIFFmalloc(var_108);

 (void) var_123; (void) var_123;
 if (var_111) {
  tstrip_t s, var_70 = TIFFNumberOfStrips(in);
  uint32 var_111 = 0;
  _TIFFmemset(var_111, 0, var_108);
  for (s = 0; s < var_70; s++) {
   tsize_t var_71 = (var_111 + rowsperstrip > var_123) ?
       TIFFVStripSize(in, var_123 - var_111) : var_108;
   if (TIFFReadEncodedStrip(in, s, var_111, var_71) < 0
       && !var_103) {
    TIFFError(TIFFFileName(in),
        "Error, can't read strip %lu",
        (unsigned long) s);
    goto bad;
   }
   if (TIFFWriteEncodedStrip(out, s, var_111, var_71) < 0) {
    TIFFError(TIFFFileName(out),
        "Error, can't write strip %lu",
        (unsigned long) s);
    goto bad;
   }
   var_111 += rowsperstrip;
  }
  _TIFFfree(var_111);
  return 1;
 } else {
  TIFFError(TIFFFileName(in),
      "Error, can't allocate memory buffer of size %lu "
      "to read strips", (unsigned long) var_108);
  return 0;
 }

bad:
 _TIFFfree(var_111);
 return 0;
}




static int fn_71(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 tsize_t var_94 = TIFFScanlineSize(in);
 tdata_t var_111;
 uint32 var_111;
 tsample_t s;

 (void) var_123;
 var_111 = _TIFFmalloc(var_94);
 if (!var_111)
  return 0;
 _TIFFmemset(var_111, 0, var_94);
 for (s = 0; s < var_123; s++) {
  for (var_111 = 0; var_111 < var_123; var_111++) {
   if (TIFFReadScanline(in, var_111, var_111, s) < 0 && !var_103) {
    TIFFError(TIFFFileName(in),
        "Error, can't read scanline %lu",
        (unsigned long) var_111);
    goto bad;
   }
   if (TIFFWriteScanline(out, var_111, var_111, s) < 0) {
    TIFFError(TIFFFileName(out),
        "Error, can't write scanline %lu",
        (unsigned long) var_111);
    goto bad;
   }
  }
 }
 _TIFFfree(var_111);
 return 1;
bad:
 _TIFFfree(var_111);
 return 0;
}




static int fn_72(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 tsize_t var_77 = TIFFScanlineSize(in);
 tsize_t var_77 = TIFFScanlineSize(out);
 tdata_t inbuf;
 tdata_t outbuf;
 register uint8 *inp, *outp;
 register uint32 var_94;
 uint32 var_111;
 tsample_t s;

 inbuf = _TIFFmalloc(var_77);
 outbuf = _TIFFmalloc(var_77);
 if (!inbuf || !outbuf)
  goto bad;
 _TIFFmemset(inbuf, 0, var_77);
 _TIFFmemset(outbuf, 0, var_77);

 for (s = 0; s < var_123; s++) {
  for (var_111 = 0; var_111 < var_123; var_111++) {
   if (TIFFReadScanline(in, inbuf, var_111, 0) < 0
       && !var_103) {
    TIFFError(TIFFFileName(in),
        "Error, can't read scanline %lu",
        (unsigned long) var_111);
    goto bad;
   }
   inp = ((uint8*)inbuf) + s;
   outp = (uint8*)outbuf;
   for (var_94 = var_123; var_94-- > 0;) {
    *outp++ = *inp;
    inp += var_123;
   }
   if (TIFFWriteScanline(out, outbuf, var_111, s) < 0) {
    TIFFError(TIFFFileName(out),
        "Error, can't write scanline %lu",
        (unsigned long) var_111);
    goto bad;
   }
  }
 }
 if (inbuf) _TIFFfree(inbuf);
 if (outbuf) _TIFFfree(outbuf);
 return 1;
bad:
 if (inbuf) _TIFFfree(inbuf);
 if (outbuf) _TIFFfree(outbuf);
 return 0;
}




static int fn_76(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 tsize_t var_77 = TIFFScanlineSize(in);
 tsize_t var_77 = TIFFScanlineSize(out);
 tdata_t inbuf;
 tdata_t outbuf;
 register uint8 *inp, *outp;
 register uint32 var_94;
 uint32 var_111;
 tsample_t s;

 inbuf = _TIFFmalloc(var_77);
 outbuf = _TIFFmalloc(var_77);
 if (!inbuf || !outbuf)
                goto bad;
 _TIFFmemset(inbuf, 0, var_77);
 _TIFFmemset(outbuf, 0, var_77);
 for (var_111 = 0; var_111 < var_123; var_111++) {

  for (s = 0; s < var_123; s++) {
   if (TIFFReadScanline(in, inbuf, var_111, s) < 0
       && !var_103) {
    TIFFError(TIFFFileName(in),
        "Error, can't read scanline %lu",
        (unsigned long) var_111);
    goto bad;
   }
   inp = (uint8*)inbuf;
   outp = ((uint8*)outbuf) + s;
   for (var_94 = var_123; var_94-- > 0;) {
    *outp = *inp++;
    outp += var_123;
   }
  }
  if (TIFFWriteScanline(out, outbuf, var_111, 0) < 0) {
   TIFFError(TIFFFileName(out),
       "Error, can't write scanline %lu",
       (unsigned long) var_111);
   goto bad;
  }
 }
 if (inbuf) _TIFFfree(inbuf);
 if (outbuf) _TIFFfree(outbuf);
 return 1;
bad:
 if (inbuf) _TIFFfree(inbuf);
 if (outbuf) _TIFFfree(outbuf);
 return 0;
}

static void
fn_77(uint8* out, uint8* in,
    uint32 var_86, uint32 var_86, int var_86, int var_86)
{
 while (var_86-- > 0) {
  uint32 var_86 = var_86;
  while (var_86-- > 0)
   *out++ = *in++;
  out += var_86;
  in += var_86;
 }
}

static void
fn_83(uint8* out, uint8* in,
    uint32 var_86, uint32 var_86, int var_86, int var_86, tsample_t var_123,
    int var_111 )
{
 while (var_86-- > 0) {
  uint32 var_86 = var_86;
  while (var_86-- > 0)
  {
   int var_94 = var_111;

   while( var_94-- ) {
    *out++ = *in++;
   }
   in += (var_123-1) * var_111;
  }
  out += var_86;
  in += var_86;
 }
}

static void
fn_85(uint8* out, uint8* in,
    uint32 var_86, uint32 var_86, int var_86, int var_86, tsample_t var_123,
    int var_111)
{
 while (var_86-- > 0) {
  uint32 var_86 = var_86;
  while (var_86-- > 0) {
   int var_94 = var_111;

   while( var_94-- ) {
    *out++ = *in++;
   }
   out += (var_123-1)*var_111;
  }
  out += var_86;
  in += var_86;
 }
}

static int
fn_86(TIFF* in, TIFF* out, readFunc var_91, writeFunc var_91,
 uint32 var_123, uint32 var_123, tsample_t var_123)
{
 int var_103 = 0;
 tdata_t var_111 = NULL;
 tsize_t var_94 = TIFFRasterScanlineSize(in);
 tsize_t var_91 = var_94 * (tsize_t)var_123;



 if (var_94
     && var_123
     && var_91 / (tsize_t)var_123 == var_94) {
  var_111 = _TIFFmalloc(var_91);
  if (var_111) {
   if ((*var_91)(in, (uint8*)var_111, var_123,
       var_123, var_123)) {
    var_103 = (*var_91)(out, (uint8*)var_111,
        var_123, var_123, var_123);
   }
   _TIFFfree(var_111);
  } else {
   TIFFError(TIFFFileName(in),
       "Error, can't allocate space for image buffer");
  }
 } else {
  TIFFError(TIFFFileName(in), "Error, no space for image buffer");
 }

 return var_103;
}

static int fn_91(TIFF* in, uint8* var_111, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 tsize_t var_94 = TIFFScanlineSize(in);
 uint8* bufp = var_111;
 uint32 var_111;

 (void) var_123; (void) var_123;
 for (var_111 = 0; var_111 < var_123; var_111++) {
  if (TIFFReadScanline(in, (tdata_t) bufp, var_111, 0) < 0
      && !var_103) {
   TIFFError(TIFFFileName(in),
       "Error, can't read scanline %lu",
       (unsigned long) var_111);
   return 0;
  }
  bufp += var_94;
 }

 return 1;
}

static int fn_92(TIFF* in, uint8* var_111, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 int var_103 = 1;
 tsize_t var_94 = TIFFScanlineSize(in);
 tdata_t var_94;
 if (!var_94)
  return 0;

 var_94 = _TIFFmalloc(var_94);
 if (!var_94)
  return 0;
 _TIFFmemset(var_94, 0, var_94);
 (void) var_123;
 if (var_94) {
  uint8* bufp = (uint8*) var_111;
  uint32 var_111;
  tsample_t s;
  for (var_111 = 0; var_111 < var_123; var_111++) {

   for (s = 0; s < var_123; s++) {
    uint8* bp = bufp + s;
    tsize_t var_94 = var_94;
    uint8* sbuf = var_94;

    if (TIFFReadScanline(in, var_94, var_111, s) < 0
        && !var_103) {
     TIFFError(TIFFFileName(in),
         "Error, can't read scanline %lu",
         (unsigned long) var_111);
         var_103 = 0;
     goto done;
    }
    while (var_94-- > 0)
     *bp = *sbuf++, bp += var_123;
   }
   bufp += var_94 * var_123;
  }
 }

done:
 _TIFFfree(var_94);
 return var_103;
}

static int fn_94(TIFF* in, uint8* var_111, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 int var_103 = 1;
 tsize_t var_111 = TIFFTileSize(in);
 tdata_t tilebuf;
 uint32 var_111 = TIFFScanlineSize(in);
 uint32 var_111 = TIFFTileRowSize(in);
 int var_111 = var_111 - var_111;
 uint8* bufp = (uint8*) var_111;
 uint32 tw, tl;
 uint32 var_111;

 (void) var_123;
 tilebuf = _TIFFmalloc(var_111);
 if (tilebuf == 0)
  return 0;
 _TIFFmemset(tilebuf, 0, var_111);
 (void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
 (void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);

 for (var_111 = 0; var_111 < var_123; var_111 += tl) {
  uint32 var_111 = (var_111+tl > var_123) ? var_123-var_111 : tl;
  uint32 var_111 = 0;
  uint32 col;

  for (col = 0; col < var_123; col += tw) {
   if (TIFFReadTile(in, tilebuf, col, var_111, 0, 0) < 0
       && !var_103) {
    TIFFError(TIFFFileName(in),
        "Error, can't read tile at %lu %lu",
        (unsigned long) col,
        (unsigned long) var_111);
    var_103 = 0;
    goto done;
   }
   if (var_111 + var_111 > var_111) {
    uint32 var_111 = var_111 - var_111;
    uint32 var_111 = var_111 - var_111;
    cpStripToTile(bufp + var_111,
        tilebuf, var_111, var_111,
        var_111 + var_111, var_111 );
   } else
    cpStripToTile(bufp + var_111,
        tilebuf, var_111, var_111,
        var_111, 0);
   var_111 += var_111;
  }
  bufp += var_111 * var_111;
 }
done:
 _TIFFfree(tilebuf);
 return var_103;
}

static int fn_102(TIFF* in, uint8* var_111, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 int var_103 = 1;
 uint32 var_111 = TIFFRasterScanlineSize(in);
 uint32 var_111 = TIFFTileRowSize(in);
 int var_111 = var_111 - var_111*var_123;
 tsize_t var_111 = TIFFTileSize(in);
 tdata_t tilebuf;
 uint8* bufp = (uint8*) var_111;
 uint32 tw, tl;
 uint32 var_111;
 uint16 bps, var_111;

 tilebuf = _TIFFmalloc(var_111);
 if (tilebuf == 0)
  return 0;
 _TIFFmemset(tilebuf, 0, var_111);
 (void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
 (void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
 (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
 assert( bps % 8 == 0 );
 var_111 = bps/8;

 for (var_111 = 0; var_111 < var_123; var_111 += tl) {
  uint32 var_111 = (var_111+tl > var_123) ? var_123-var_111 : tl;
  uint32 var_111 = 0;
  uint32 col;

  for (col = 0; col < var_123; col += tw) {
   tsample_t s;

   for (s = 0; s < var_123; s++) {
    if (TIFFReadTile(in, tilebuf, col, var_111, 0, s) < 0
        && !var_103) {
     TIFFError(TIFFFileName(in),
         "Error, can't read tile at %lu %lu, "
         "sample %lu",
         (unsigned long) col,
         (unsigned long) var_111,
         (unsigned long) s);
     var_103 = 0;
     goto done;
    }




    if (var_111 + var_111*var_123 > var_111) {
     uint32 var_111 = var_111 - var_111;
     int var_111 = var_111*var_123 - var_111;
     cpSeparateBufToContigBuf(
         bufp+var_111+s*var_111,
         tilebuf, var_111,
         var_111/(var_123*var_111),
         var_111 + var_111,
         var_111/var_123, var_123,
         var_111);
    } else
     cpSeparateBufToContigBuf(
         bufp+var_111+s*var_111,
         tilebuf, var_111, tw,
         var_111, 0, var_123,
         var_111);
   }
   var_111 += var_111*var_123;
  }
  bufp += var_111 * var_111;
 }
done:
 _TIFFfree(tilebuf);
 return var_103;
}

static int fn_103(TIFF* out, uint8* var_111, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 uint32 var_111, rowsperstrip;
 tstrip_t var_108 = 0;

 (void) var_123; (void) var_123;
 (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
 for (var_111 = 0; var_111 < var_123; var_111 += rowsperstrip) {
  uint32 var_108 = (var_111+rowsperstrip > var_123) ?
      var_123-var_111 : rowsperstrip;
  tsize_t var_108 = TIFFVStripSize(out, var_108);
  if (TIFFWriteEncodedStrip(out, var_108++, var_111, var_108) < 0) {
   TIFFError(TIFFFileName(out),
       "Error, can't write strip %u", var_108 - 1);
   return 0;
  }
  var_111 += var_108;
 }
 return 1;
}

static int fn_106(TIFF* out, uint8* var_111, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 uint32 var_108 = var_123 * var_123;
 uint32 rowsperstrip;
 tsize_t var_108 = TIFFStripSize(out);
 tdata_t obuf;
 tstrip_t var_108 = 0;
 tsample_t s;

 obuf = _TIFFmalloc(var_108);
 if (obuf == NULL)
  return 0;
 _TIFFmemset(obuf, 0, var_108);
 (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
 for (s = 0; s < var_123; s++) {
  uint32 var_111;
  for (var_111 = 0; var_111 < var_123; var_111 += rowsperstrip) {
   uint32 var_108 = (var_111+rowsperstrip > var_123) ?
       var_123-var_111 : rowsperstrip;
   tsize_t var_108 = TIFFVStripSize(out, var_108);

   cpContigBufToSeparateBuf(
       obuf, (uint8*) var_111 + var_111*var_108 + s,
       var_108, var_123, 0, 0, var_123, 1);
   if (TIFFWriteEncodedStrip(out, var_108++, obuf, var_108) < 0) {
    TIFFError(TIFFFileName(out),
        "Error, can't write strip %u",
        var_108 - 1);
    _TIFFfree(obuf);
    return 0;
   }
  }
 }
 _TIFFfree(obuf);
 return 1;

}

static int fn_108(TIFF* out, uint8* var_111, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 uint32 var_111 = TIFFScanlineSize(out);
 uint32 var_111 = TIFFTileRowSize(out);
 int var_111 = var_111 - var_111;
 tsize_t var_111 = TIFFTileSize(out);
 tdata_t obuf;
 uint8* bufp = (uint8*) var_111;
 uint32 tl, tw;
 uint32 var_111;

 (void) var_123;

 obuf = _TIFFmalloc(TIFFTileSize(out));
 if (obuf == NULL)
  return 0;
 _TIFFmemset(obuf, 0, var_111);
 (void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
 (void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
 for (var_111 = 0; var_111 < var_123; var_111 += tilelength) {
  uint32 var_111 = (var_111+tl > var_123) ? var_123-var_111 : tl;
  uint32 var_111 = 0;
  uint32 col;

  for (col = 0; col < var_123; col += tw) {




   if (var_111 + var_111 > var_111) {
    uint32 var_111 = var_111 - var_111;
    int var_111 = var_111 - var_111;
    cpStripToTile(obuf, bufp + var_111, var_111, var_111,
        var_111, var_111 + var_111);
   } else
    cpStripToTile(obuf, bufp + var_111, var_111, var_111,
        0, var_111);
   if (TIFFWriteTile(out, obuf, col, var_111, 0, 0) < 0) {
    TIFFError(TIFFFileName(out),
        "Error, can't write tile at %lu %lu",
        (unsigned long) col,
        (unsigned long) var_111);
    _TIFFfree(obuf);
    return 0;
   }
   var_111 += var_111;
  }
  bufp += var_111 * var_111;
 }
 _TIFFfree(obuf);
 return 1;
}

static int fn_109(TIFF* out, uint8* var_111, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 uint32 var_111 = TIFFScanlineSize(out);
 tsize_t var_111 = TIFFTileRowSize(out);
 uint32 var_111 = TIFFRasterScanlineSize(out);
 int var_111 = var_111 - var_111*var_123;
 tsize_t var_111 = TIFFTileSize(out);
 tdata_t obuf;
 uint8* bufp = (uint8*) var_111;
 uint32 tl, tw;
 uint32 var_111;
 uint16 bps, var_111;

 obuf = _TIFFmalloc(TIFFTileSize(out));
 if (obuf == NULL)
  return 0;
 _TIFFmemset(obuf, 0, var_111);
 (void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
 (void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
 (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
 assert( bps % 8 == 0 );
 var_111 = bps/8;

 for (var_111 = 0; var_111 < var_123; var_111 += tl) {
  uint32 var_111 = (var_111+tl > var_123) ? var_123-var_111 : tl;
  uint32 var_111 = 0;
  uint32 col;

  for (col = 0; col < var_123; col += tw) {
   tsample_t s;
   for (s = 0; s < var_123; s++) {




    if (var_111 + var_111 > var_111) {
     uint32 var_111 = (var_111 - var_111);
     int var_111 = var_111 - var_111;

     cpContigBufToSeparateBuf(obuf,
         bufp + (var_111*var_123) + s,
         var_111, var_111/var_111,
         var_111, (var_111*var_123)+var_111, var_123,
         var_111);
    } else
     cpContigBufToSeparateBuf(obuf,
         bufp + (var_111*var_123) + s,
         var_111, tilewidth,
         0, var_111, var_123,
         var_111);
    if (TIFFWriteTile(out, obuf, col, var_111, 0, s) < 0) {
     TIFFError(TIFFFileName(out),
         "Error, can't write tile at %lu %lu "
         "sample %lu",
         (unsigned long) col,
         (unsigned long) var_111,
         (unsigned long) s);
     _TIFFfree(obuf);
     return 0;
    }
   }
   var_111 += var_111;
  }
  bufp += var_111 * var_111;
 }
 _TIFFfree(obuf);
 return 1;
}




static int fn_111(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readContigStripsIntoBuffer,
     writeBufferToContigTiles,
     var_123, var_123, var_123);
}




static int fn_112(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readContigStripsIntoBuffer,
     writeBufferToSeparateTiles,
     var_123, var_123, var_123);
}




static int fn_113(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readSeparateStripsIntoBuffer,
     writeBufferToContigTiles,
     var_123, var_123, var_123);
}




static int fn_114(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readSeparateStripsIntoBuffer,
     writeBufferToSeparateTiles,
     var_123, var_123, var_123);
}




static int fn_115(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readContigTilesIntoBuffer,
     writeBufferToContigTiles,
     var_123, var_123, var_123);
}




static int fn_116(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readContigTilesIntoBuffer,
     writeBufferToSeparateTiles,
     var_123, var_123, var_123);
}




static int fn_117(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readSeparateTilesIntoBuffer,
     writeBufferToContigTiles,
     var_123, var_123, var_123);
}




static int fn_118(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readSeparateTilesIntoBuffer,
     writeBufferToSeparateTiles,
     var_123, var_123, var_123);
}




static int fn_119(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readContigTilesIntoBuffer,
     writeBufferToContigStrips,
     var_123, var_123, var_123);
}




static int fn_120(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readContigTilesIntoBuffer,
     writeBufferToSeparateStrips,
     var_123, var_123, var_123);
}




static int fn_121(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readSeparateTilesIntoBuffer,
     writeBufferToContigStrips,
     var_123, var_123, var_123);
}




static int fn_122(TIFF* in, TIFF* out, uint32 var_123, uint32 var_123, tsample_t var_123)
{
 return cpImage(in, out,
     readSeparateTilesIntoBuffer,
     writeBufferToSeparateStrips,
     var_123, var_123, var_123);
}




static copyFunc
fn_123(TIFF* in, TIFF* out, uint16 var_123, uint16 var_123)
{
 uint16 shortv;
 uint32 var_124, var_124, tw, tl;
 int bychunk;

 (void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);
 if (shortv != config && var_123 != 8 && var_123 > 1) {
  fprintf(stderr,
      "%s: Cannot handle different planar configuration w/ bits/sample != 8\n",
      TIFFFileName(in));
  return (NULL);
 }
 TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &var_124);
 TIFFGetField(in, TIFFTAG_IMAGELENGTH, &var_124);
 if (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {
  uint32 var_124 = (uint32) -1L;
  TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &var_124);

  bychunk = !bias && (rowsperstrip == var_124);
 }else{
  if (bias) {
   fprintf(stderr,
       "%s: Cannot handle tiled configuration w/bias image\n",
   TIFFFileName(in));
   return (NULL);
  }
  if (TIFFIsTiled(out)) {
   if (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))
    tw = var_124;
   if (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))
    tl = var_124;
   bychunk = (tw == tilewidth && tl == tilelength);
  } else {
   TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
   TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
   bychunk = (tw == var_124 && tl == rowsperstrip);
  }
 }



 switch(((long)(((shortv)<<11)|((config)<<3)|((TIFFIsTiled(in))<<2)|((TIFFIsTiled(out))<<1)|(bychunk)))) {

  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_CONTIG)<<3)|0|2|0)):
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_CONTIG)<<3)|0|2|1)):
   return cpContigStrips2ContigTiles;
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_SEPARATE)<<3)|0|2|0)):
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_SEPARATE)<<3)|0|2|1)):
   return cpContigStrips2SeparateTiles;
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_CONTIG)<<3)|0|2|0)):
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_CONTIG)<<3)|0|2|1)):
   return cpSeparateStrips2ContigTiles;
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_SEPARATE)<<3)|0|2|0)):
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_SEPARATE)<<3)|0|2|1)):
   return cpSeparateStrips2SeparateTiles;

  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_CONTIG)<<3)|4|2|0)):
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_CONTIG)<<3)|4|2|1)):
   return cpContigTiles2ContigTiles;
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_SEPARATE)<<3)|4|2|0)):
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_SEPARATE)<<3)|4|2|1)):
   return cpContigTiles2SeparateTiles;
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_CONTIG)<<3)|4|2|0)):
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_CONTIG)<<3)|4|2|1)):
   return cpSeparateTiles2ContigTiles;
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_SEPARATE)<<3)|4|2|0)):
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_SEPARATE)<<3)|4|2|1)):
   return cpSeparateTiles2SeparateTiles;

  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_CONTIG)<<3)|4|0|0)):
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_CONTIG)<<3)|4|0|1)):
   return cpContigTiles2ContigStrips;
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_SEPARATE)<<3)|4|0|0)):
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_SEPARATE)<<3)|4|0|1)):
   return cpContigTiles2SeparateStrips;
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_CONTIG)<<3)|4|0|0)):
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_CONTIG)<<3)|4|0|1)):
   return cpSeparateTiles2ContigStrips;
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_SEPARATE)<<3)|4|0|0)):
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_SEPARATE)<<3)|4|0|1)):
   return cpSeparateTiles2SeparateStrips;

  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_CONTIG)<<3)|0|0|0)):
   return bias ? cpBiasedContig2Contig : cpContig2ContigByRow;
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_CONTIG)<<3)|0|0|1)):
   return cpDecodedStrips;
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_SEPARATE)<<3)|0|0|0)):
  case ((long)(((PLANARCONFIG_CONTIG)<<11)|((PLANARCONFIG_SEPARATE)<<3)|0|0|1)):
   return cpContig2SeparateByRow;
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_CONTIG)<<3)|0|0|0)):
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_CONTIG)<<3)|0|0|1)):
   return cpSeparate2ContigByRow;
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_SEPARATE)<<3)|0|0|0)):
  case ((long)(((PLANARCONFIG_SEPARATE)<<11)|((PLANARCONFIG_SEPARATE)<<3)|0|0|1)):
   return cpSeparate2SeparateByRow;
 }



 fprintf(stderr, "tiffcp: %s: Don't know how to copy/convert image.\n",
     TIFFFileName(in));
 return (NULL);
}
