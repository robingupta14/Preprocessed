







const char av_codec_ffversion[] = "FFmpeg version " FFMPEG_VERSION;

static int (*lockmgr_cb)(void **mutex, enum enumtype_181 var_181) = NULL;



volatile int ff_avcodec_locked;
static int volatile var_183 = 0;
static void *codec_mutex;
static void *avformat_mutex;

void fn_3(void *var_8, unsigned int *var_208, size_t var_97)
{
    uint8_t **p = var_8;
    if (var_97 > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
        av_freep(p);
        *var_208 = 0;
        return;
    }
    if (!ff_fast_malloc(p, var_208, var_97 + AV_INPUT_BUFFER_PADDING_SIZE, 1))
        memset(*p + var_97, 0, AV_INPUT_BUFFER_PADDING_SIZE);
}

void fn_7(void *var_8, unsigned int *var_208, size_t var_97)
{
    uint8_t **p = var_8;
    if (var_97 > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
        av_freep(p);
        *var_208 = 0;
        return;
    }
    if (!ff_fast_malloc(p, var_208, var_97 + AV_INPUT_BUFFER_PADDING_SIZE, 1))
        memset(*p, 0, var_97 + AV_INPUT_BUFFER_PADDING_SIZE);
}


static AVCodec *first_avcodec = NULL;
static AVCodec **last_avcodec = &first_avcodec;

AVCodec *fn_8(const AVCodec *c)
{
    if (c)
        return c->next;
    else
        return first_avcodec;
}

static av_cold void fn_9(void)
{
    static int var_11 = 0;

    if (var_11 != 0)
        return;
    var_11 = 1;

    if (CONFIG_ME_CMP)
        ff_me_cmp_init_static();
}

int fn_11(const AVCodec *codec)
{
    return codec && (codec->encode_sub || codec->encode2 ||codec->send_frame);
}

int fn_12(const AVCodec *codec)
{
    return codec && (codec->decode || codec->send_packet);
}

av_cold void fn_13(AVCodec *codec)
{
    AVCodec **p;
    avcodec_init();
    p = last_avcodec;
    codec->next = NULL;

    while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, codec))
        p = &(*p)->next;
    last_avcodec = &codec->next;

    if (codec->init_static_data)
        codec->init_static_data(codec);
}

int fn_14(AVCodecContext *s, int var_29, int var_52)
{
    int var_205 = av_image_check_size2(var_29, var_52, s->max_pixels, AV_PIX_FMT_NONE, 0, s);

    if (var_205 < 0)
        var_29 = var_52 = 0;

    s->coded_width = var_29;
    s->coded_height = var_52;
    s->width = AV_CEIL_RSHIFT(var_29, s->lowres);
    s->height = AV_CEIL_RSHIFT(var_52, s->lowres);

    return var_205;
}

int fn_18(AVCodecContext *avctx, AVRational var_20)
{
    int var_205 = av_image_check_sar(avctx->width, avctx->height, var_20);

    if (var_205 < 0) {
        av_log(avctx, AV_LOG_WARNING, "ignoring invalid SAR: %d/%d\n",
               var_20.num, var_20.den);
        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };
        return var_205;
    } else {
        avctx->sample_aspect_ratio = var_20;
    }
    return 0;
}

int fn_20(AVFrame *frame,
                                        enum enumtype_23 var_23)
{
    AVFrameSideData *side_data;
    enum enumtype_23 *data;

    side_data = av_frame_get_side_data(frame, AV_FRAME_DATA_MATRIXENCODING);
    if (!side_data)
        side_data = av_frame_new_side_data(frame, AV_FRAME_DATA_MATRIXENCODING,
                                           sizeof(enum enumtype_23));

    if (!side_data)
        return AVERROR(ENOMEM);

    data = (enum enumtype_23*)side_data->data;
    *data = var_23;

    return 0;
}

void fn_23(AVCodecContext *s, int *var_29, int *var_52,
                               int linesize_align[AV_NUM_DATA_POINTERS])
{
    int i;
    int var_26 = 1;
    int var_26 = 1;
    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);

    if (desc) {
        var_26 = 1 << desc->log2_chroma_w;
        var_26 = 1 << desc->log2_chroma_h;
    }

    switch (s->pix_fmt) {
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUYV422:
    case AV_PIX_FMT_YVYU422:
    case AV_PIX_FMT_UYVY422:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_GBRP:
    case AV_PIX_FMT_GBRAP:
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_GRAY16BE:
    case AV_PIX_FMT_GRAY16LE:
    case AV_PIX_FMT_YUVJ420P:
    case AV_PIX_FMT_YUVJ422P:
    case AV_PIX_FMT_YUVJ440P:
    case AV_PIX_FMT_YUVJ444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9LE:
    case AV_PIX_FMT_YUV420P9BE:
    case AV_PIX_FMT_YUV420P10LE:
    case AV_PIX_FMT_YUV420P10BE:
    case AV_PIX_FMT_YUV420P12LE:
    case AV_PIX_FMT_YUV420P12BE:
    case AV_PIX_FMT_YUV420P14LE:
    case AV_PIX_FMT_YUV420P14BE:
    case AV_PIX_FMT_YUV420P16LE:
    case AV_PIX_FMT_YUV420P16BE:
    case AV_PIX_FMT_YUVA420P9LE:
    case AV_PIX_FMT_YUVA420P9BE:
    case AV_PIX_FMT_YUVA420P10LE:
    case AV_PIX_FMT_YUVA420P10BE:
    case AV_PIX_FMT_YUVA420P16LE:
    case AV_PIX_FMT_YUVA420P16BE:
    case AV_PIX_FMT_YUV422P9LE:
    case AV_PIX_FMT_YUV422P9BE:
    case AV_PIX_FMT_YUV422P10LE:
    case AV_PIX_FMT_YUV422P10BE:
    case AV_PIX_FMT_YUV422P12LE:
    case AV_PIX_FMT_YUV422P12BE:
    case AV_PIX_FMT_YUV422P14LE:
    case AV_PIX_FMT_YUV422P14BE:
    case AV_PIX_FMT_YUV422P16LE:
    case AV_PIX_FMT_YUV422P16BE:
    case AV_PIX_FMT_YUVA422P9LE:
    case AV_PIX_FMT_YUVA422P9BE:
    case AV_PIX_FMT_YUVA422P10LE:
    case AV_PIX_FMT_YUVA422P10BE:
    case AV_PIX_FMT_YUVA422P16LE:
    case AV_PIX_FMT_YUVA422P16BE:
    case AV_PIX_FMT_YUV440P10LE:
    case AV_PIX_FMT_YUV440P10BE:
    case AV_PIX_FMT_YUV440P12LE:
    case AV_PIX_FMT_YUV440P12BE:
    case AV_PIX_FMT_YUV444P9LE:
    case AV_PIX_FMT_YUV444P9BE:
    case AV_PIX_FMT_YUV444P10LE:
    case AV_PIX_FMT_YUV444P10BE:
    case AV_PIX_FMT_YUV444P12LE:
    case AV_PIX_FMT_YUV444P12BE:
    case AV_PIX_FMT_YUV444P14LE:
    case AV_PIX_FMT_YUV444P14BE:
    case AV_PIX_FMT_YUV444P16LE:
    case AV_PIX_FMT_YUV444P16BE:
    case AV_PIX_FMT_YUVA444P9LE:
    case AV_PIX_FMT_YUVA444P9BE:
    case AV_PIX_FMT_YUVA444P10LE:
    case AV_PIX_FMT_YUVA444P10BE:
    case AV_PIX_FMT_YUVA444P16LE:
    case AV_PIX_FMT_YUVA444P16BE:
    case AV_PIX_FMT_GBRP9LE:
    case AV_PIX_FMT_GBRP9BE:
    case AV_PIX_FMT_GBRP10LE:
    case AV_PIX_FMT_GBRP10BE:
    case AV_PIX_FMT_GBRP12LE:
    case AV_PIX_FMT_GBRP12BE:
    case AV_PIX_FMT_GBRP14LE:
    case AV_PIX_FMT_GBRP14BE:
    case AV_PIX_FMT_GBRP16LE:
    case AV_PIX_FMT_GBRP16BE:
    case AV_PIX_FMT_GBRAP12LE:
    case AV_PIX_FMT_GBRAP12BE:
    case AV_PIX_FMT_GBRAP16LE:
    case AV_PIX_FMT_GBRAP16BE:
        var_26 = 16;
        var_26 = 32;
        break;
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUVJ411P:
    case AV_PIX_FMT_UYYVYY411:
        var_26 = 32;
        var_26 = 32;
        break;
    case AV_PIX_FMT_YUV410P:
        if (s->codec_id == AV_CODEC_ID_SVQ1) {
            var_26 = 64;
            var_26 = 64;
        }
        break;
    case AV_PIX_FMT_RGB555:
        if (s->codec_id == AV_CODEC_ID_RPZA) {
            var_26 = 4;
            var_26 = 4;
        }
        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
            var_26 = 8;
            var_26 = 8;
        }
        break;
    case AV_PIX_FMT_PAL8:
    case AV_PIX_FMT_BGR8:
    case AV_PIX_FMT_RGB8:
        if (s->codec_id == AV_CODEC_ID_SMC ||
            s->codec_id == AV_CODEC_ID_CINEPAK) {
            var_26 = 4;
            var_26 = 4;
        }
        if (s->codec_id == AV_CODEC_ID_JV ||
            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
            var_26 = 8;
            var_26 = 8;
        }
        break;
    case AV_PIX_FMT_BGR24:
        if ((s->codec_id == AV_CODEC_ID_MSZH) ||
            (s->codec_id == AV_CODEC_ID_ZLIB)) {
            var_26 = 4;
            var_26 = 4;
        }
        break;
    case AV_PIX_FMT_RGB24:
        if (s->codec_id == AV_CODEC_ID_CINEPAK) {
            var_26 = 4;
            var_26 = 4;
        }
        break;
    default:
        break;
    }

    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {
        var_26 = FFMAX(var_26, 8);
    }

    *var_29 = FFALIGN(*var_29, var_26);
    *var_52 = FFALIGN(*var_52, var_26);
    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {


        *var_52 += 2;





        *var_29 = FFMAX(*var_29, 32);
    }

    for (i = 0; i < 4; i++)
        linesize_align[i] = STRIDE_ALIGN;
}

void fn_26(AVCodecContext *s, int *var_29, int *var_52)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int var_29 = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int var_42;

    avcodec_align_dimensions2(s, var_29, var_52, linesize_align);
    var_42 = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= var_29;
    linesize_align[2] <<= var_29;
    var_42 = FFMAX3(var_42, linesize_align[1], linesize_align[2]);
    *var_29 = FFALIGN(*var_29, var_42);
}

int fn_29(int *var_35, int *var_35, enum enumtype_34 var_35)
{
    if (var_35 <= AVCHROMA_LOC_UNSPECIFIED || var_35 >= AVCHROMA_LOC_NB)
        return AVERROR(EINVAL);
    var_35--;

    *var_35 = (var_35&1) * 128;
    *var_35 = ((var_35>>1)^(var_35<4)) * 128;

    return 0;
}

enum enumtype_34 fn_34(int var_35, int var_35)
{
    int var_35, xout, yout;

    for (var_35 = AVCHROMA_LOC_UNSPECIFIED + 1; var_35 < AVCHROMA_LOC_NB; var_35++) {
        if (avcodec_enum_to_chroma_pos(&xout, &yout, var_35) == 0 && xout == var_35 && yout == var_35)
            return var_35;
    }
    return AVCHROMA_LOC_UNSPECIFIED;
}

int fn_35(AVFrame *frame, int var_42,
                             enum enumtype_157 var_42, const uint8_t *buf,
                             int var_149, int var_42)
{
    int var_169, var_46, needed_size, var_205 = 0;

    needed_size = av_samples_get_buffer_size(NULL, var_42,
                                             frame->nb_samples, var_42,
                                             var_42);
    if (var_149 < needed_size)
        return AVERROR(EINVAL);

    var_46 = av_sample_fmt_is_planar(var_42);
    if (var_46 && var_42 > AV_NUM_DATA_POINTERS) {
        if (!(frame->extended_data = av_mallocz_array(var_42,
                                                sizeof(*frame->extended_data))))
            return AVERROR(ENOMEM);
    } else {
        frame->extended_data = frame->data;
    }

    if ((var_205 = av_samples_fill_arrays(frame->extended_data, &frame->linesize[0],
                                      (uint8_t *)(intptr_t)buf, var_42, frame->nb_samples,
                                      var_42, var_42)) < 0) {
        if (frame->extended_data != frame->data)
            av_freep(&frame->extended_data);
        return var_205;
    }
    if (frame->extended_data != frame->data) {
        for (var_169 = 0; var_169 < AV_NUM_DATA_POINTERS; var_169++)
            frame->data[var_169] = frame->extended_data[var_169];
    }

    return var_205;
}

static int fn_42(AVCodecContext *avctx, AVFrame *frame)
{
    FramePool *pool = avctx->internal->pool;
    int i, var_205;

    switch (avctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO: {
        uint8_t *data[4];
        int linesize[4];
        int var_208[4] = { 0 };
        int var_45 = frame->width;
        int var_45 = frame->height;
        int tmpsize, unaligned;

        if (pool->format == frame->format &&
            pool->width == frame->width && pool->height == frame->height)
            return 0;

        avcodec_align_dimensions2(avctx, &var_45, &var_45, pool->stride_align);

        do {


            var_205 = av_image_fill_linesizes(linesize, avctx->pix_fmt, var_45);
            if (var_205 < 0)
                return var_205;

            var_45 += var_45 & ~(var_45 - 1);

            unaligned = 0;
            for (i = 0; i < 4; i++)
                unaligned |= linesize[i] % pool->stride_align[i];
        } while (unaligned);

        tmpsize = av_image_fill_pointers(data, avctx->pix_fmt, var_45,
                                         NULL, linesize);
        if (tmpsize < 0)
            return -1;

        for (i = 0; i < 3 && data[i + 1]; i++)
            var_208[i] = data[i + 1] - data[i];
        var_208[i] = tmpsize - (data[i] - data[0]);

        for (i = 0; i < 4; i++) {
            av_buffer_pool_uninit(&pool->pools[i]);
            pool->linesize[i] = linesize[i];
            if (var_208[i]) {
                pool->pools[i] = av_buffer_pool_init(var_208[i] + 16 + STRIDE_ALIGN - 1,
                                                     CONFIG_MEMORY_POISONING ?
                                                        NULL :
                                                        av_buffer_allocz);
                if (!pool->pools[i]) {
                    var_205 = AVERROR(ENOMEM);
                    goto fail;
                }
            }
        }
        pool->format = frame->format;
        pool->width = frame->width;
        pool->height = frame->height;

        break;
        }
    case AVMEDIA_TYPE_AUDIO: {
        int var_169 = av_frame_get_channels(frame);
        int var_46 = av_sample_fmt_is_planar(frame->format);
        int var_111 = var_46 ? var_169 : 1;

        if (pool->format == frame->format && pool->planes == var_111 &&
            pool->channels == var_169 && frame->nb_samples == pool->samples)
            return 0;

        av_buffer_pool_uninit(&pool->pools[0]);
        var_205 = av_samples_get_buffer_size(&pool->linesize[0], var_169,
                                         frame->nb_samples, frame->format, 0);
        if (var_205 < 0)
            goto fail;

        pool->pools[0] = av_buffer_pool_init(pool->linesize[0], NULL);
        if (!pool->pools[0]) {
            var_205 = AVERROR(ENOMEM);
            goto fail;
        }

        pool->format = frame->format;
        pool->planes = var_111;
        pool->channels = var_169;
        pool->samples = frame->nb_samples;
        break;
        }
    default: av_assert0(0);
    }
    return 0;
fail:
    for (i = 0; i < 4; i++)
        av_buffer_pool_uninit(&pool->pools[i]);
    pool->format = -1;
    pool->planes = pool->channels = pool->samples = 0;
    pool->width = pool->height = 0;
    return var_205;
}

static int fn_46(AVCodecContext *avctx, AVFrame *frame)
{
    FramePool *pool = avctx->internal->pool;
    int var_111 = pool->planes;
    int i;

    frame->linesize[0] = pool->linesize[0];

    if (var_111 > AV_NUM_DATA_POINTERS) {
        frame->extended_data = av_mallocz_array(var_111, sizeof(*frame->extended_data));
        frame->nb_extended_buf = var_111 - AV_NUM_DATA_POINTERS;
        frame->extended_buf = av_mallocz_array(frame->nb_extended_buf,
                                          sizeof(*frame->extended_buf));
        if (!frame->extended_data || !frame->extended_buf) {
            av_freep(&frame->extended_data);
            av_freep(&frame->extended_buf);
            return AVERROR(ENOMEM);
        }
    } else {
        frame->extended_data = frame->data;
        av_assert0(frame->nb_extended_buf == 0);
    }

    for (i = 0; i < FFMIN(var_111, AV_NUM_DATA_POINTERS); i++) {
        frame->buf[i] = av_buffer_pool_get(pool->pools[0]);
        if (!frame->buf[i])
            goto fail;
        frame->extended_data[i] = frame->data[i] = frame->buf[i]->data;
    }
    for (i = 0; i < frame->nb_extended_buf; i++) {
        frame->extended_buf[i] = av_buffer_pool_get(pool->pools[0]);
        if (!frame->extended_buf[i])
            goto fail;
        frame->extended_data[i + AV_NUM_DATA_POINTERS] = frame->extended_buf[i]->data;
    }

    if (avctx->debug & FF_DEBUG_BUFFERS)
        av_log(avctx, AV_LOG_DEBUG, "default_get_buffer called on frame %p", frame);

    return 0;
fail:
    av_frame_unref(frame);
    return AVERROR(ENOMEM);
}

static int fn_47(AVCodecContext *s, AVFrame *pic)
{
    FramePool *pool = s->internal->pool;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pic->format);
    int i;

    if (pic->data[0] || pic->data[1] || pic->data[2] || pic->data[3]) {
        av_log(s, AV_LOG_ERROR, "pic->data[*]!=NULL in avcodec_default_get_buffer\n");
        return -1;
    }

    if (!desc) {
        av_log(s, AV_LOG_ERROR,
            "Unable to get pixel format descriptor for format %s\n",
            av_get_pix_fmt_name(pic->format));
        return AVERROR(EINVAL);
    }

    memset(pic->data, 0, sizeof(pic->data));
    pic->extended_data = pic->data;

    for (i = 0; i < 4 && pool->pools[i]; i++) {
        pic->linesize[i] = pool->linesize[i];

        pic->buf[i] = av_buffer_pool_get(pool->pools[i]);
        if (!pic->buf[i])
            goto fail;

        pic->data[i] = pic->buf[i]->data;
    }
    for (; i < AV_NUM_DATA_POINTERS; i++) {
        pic->data[i] = NULL;
        pic->linesize[i] = 0;
    }
    if (desc->flags & AV_PIX_FMT_FLAG_PAL ||
        desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)
        avpriv_set_systematic_pal2((uint32_t *)pic->data[1], pic->format);

    if (s->debug & FF_DEBUG_BUFFERS)
        av_log(s, AV_LOG_DEBUG, "default_get_buffer called on pic %p\n", pic);

    return 0;
fail:
    av_frame_unref(pic);
    return AVERROR(ENOMEM);
}

void fn_48(AVFrame *frame, const int c[4])
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);
    int p, y, var_186;

    av_assert0(desc->flags & AV_PIX_FMT_FLAG_PLANAR);

    for (p = 0; p<desc->nb_components; p++) {
        uint8_t *dst = frame->data[p];
        int var_52 = p == 1 || p == 2;
        int var_52 = var_52 ? AV_CEIL_RSHIFT(frame->width, desc->log2_chroma_w) : frame->width;
        int var_52 = var_52 ? AV_CEIL_RSHIFT(frame->height, desc->log2_chroma_h) : frame->height;
        for (y = 0; y < var_52; y++) {
            if (desc->comp[0].depth >= 9) {
                for (var_186 = 0; var_186<var_52; var_186++)
                    ((uint16_t*)dst)[var_186] = c[p];
            }else
                memset(dst, c[p], var_52);
            dst += frame->linesize[p];
        }
    }
}

int fn_52(AVCodecContext *avctx, AVFrame *frame, int var_189)
{
    int var_205;

    if (avctx->hw_frames_ctx)
        return av_hwframe_get_buffer(avctx->hw_frames_ctx, frame, 0);

    if ((var_205 = update_frame_pool(avctx, frame)) < 0)
        return var_205;

    switch (avctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        return video_get_buffer(avctx, frame);
    case AVMEDIA_TYPE_AUDIO:
        return audio_get_buffer(avctx, frame);
    default:
        return -1;
    }
}

static int fn_54(AVPacket *avpkt, AVFrame *frame)
{
    int var_208;
    const uint8_t *side_metadata;

    AVDictionary **frame_md = avpriv_frame_get_metadatap(frame);

    side_metadata = av_packet_get_side_data(avpkt,
                                            AV_PKT_DATA_STRINGS_METADATA, &var_208);
    return av_packet_unpack_dictionary(side_metadata, var_208, frame_md);
}

int fn_55(AVCodecContext *avctx, AVFrame *frame)
{
    AVPacket *pkt = avctx->internal->pkt;
    int i;
    static const struct {
        enum enumtype_56 packet;
        enum enumtype_57 frame;
    } sd[] = {
        { AV_PKT_DATA_REPLAYGAIN , AV_FRAME_DATA_REPLAYGAIN },
        { AV_PKT_DATA_DISPLAYMATRIX, AV_FRAME_DATA_DISPLAYMATRIX },
        { AV_PKT_DATA_SPHERICAL, AV_FRAME_DATA_SPHERICAL },
        { AV_PKT_DATA_STEREO3D, AV_FRAME_DATA_STEREO3D },
        { AV_PKT_DATA_AUDIO_SERVICE_TYPE, AV_FRAME_DATA_AUDIO_SERVICE_TYPE },
        { AV_PKT_DATA_MASTERING_DISPLAY_METADATA, AV_FRAME_DATA_MASTERING_DISPLAY_METADATA },
    };

    if (pkt) {
        frame->pts = pkt->pts;





        av_frame_set_pkt_pos (frame, pkt->pos);
        av_frame_set_pkt_duration(frame, pkt->duration);
        av_frame_set_pkt_size (frame, pkt->size);

        for (i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
            int var_208;
            uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &var_208);
            if (packet_sd) {
                AVFrameSideData *frame_sd = av_frame_new_side_data(frame,
                                                                   sd[i].frame,
                                                                   var_208);
                if (!frame_sd)
                    return AVERROR(ENOMEM);

                memcpy(frame_sd->data, packet_sd, var_208);
            }
        }
        add_metadata_from_side_data(pkt, frame);

        if (pkt->flags & AV_PKT_FLAG_DISCARD) {
            frame->flags |= AV_FRAME_FLAG_DISCARD;
        } else {
            frame->flags = (frame->flags & ~AV_FRAME_FLAG_DISCARD);
        }
    } else {
        frame->pts = var_128;





        av_frame_set_pkt_pos (frame, -1);
        av_frame_set_pkt_duration(frame, 0);
        av_frame_set_pkt_size (frame, -1);
    }
    frame->reordered_opaque = avctx->reordered_opaque;

    if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
        frame->color_primaries = avctx->color_primaries;
    if (frame->color_trc == AVCOL_TRC_UNSPECIFIED)
        frame->color_trc = avctx->color_trc;
    if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)
        av_frame_set_colorspace(frame, avctx->colorspace);
    if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)
        av_frame_set_color_range(frame, avctx->color_range);
    if (frame->chroma_location == AVCHROMA_LOC_UNSPECIFIED)
        frame->chroma_location = avctx->chroma_sample_location;

    switch (avctx->codec->type) {
    case AVMEDIA_TYPE_VIDEO:
        frame->format = avctx->pix_fmt;
        if (!frame->sample_aspect_ratio.num)
            frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

        if (frame->width && frame->height &&
            av_image_check_sar(frame->width, frame->height,
                               frame->sample_aspect_ratio) < 0) {
            av_log(avctx, AV_LOG_WARNING, "ignoring invalid SAR: %u/%u\n",
                   frame->sample_aspect_ratio.num,
                   frame->sample_aspect_ratio.den);
            frame->sample_aspect_ratio = (AVRational){ 0, 1 };
        }

        break;
    case AVMEDIA_TYPE_AUDIO:
        if (!frame->sample_rate)
            frame->sample_rate = avctx->sample_rate;
        if (frame->format < 0)
            frame->format = avctx->sample_fmt;
        if (!frame->channel_layout) {
            if (avctx->channel_layout) {
                 if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
                     avctx->channels) {
                     av_log(avctx, AV_LOG_ERROR, "Inconsistent channel "
                            "configuration.\n");
                     return AVERROR(EINVAL);
                 }

                frame->channel_layout = avctx->channel_layout;
            } else {
                if (avctx->channels > FF_SANE_NB_CHANNELS) {
                    av_log(avctx, AV_LOG_ERROR, "Too many channels: %d.\n",
                           avctx->channels);
                    return AVERROR(ENOSYS);
                }
            }
        }
        av_frame_set_channels(frame, avctx->channels);
        break;
    }
    return 0;
}

int fn_59(AVCodecContext *avctx, AVFrame *frame)
{
    return ff_init_buffer_info(avctx, frame);
}

static void fn_60(AVCodecContext *avctx, AVFrame *frame)
{
    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
        int i;
        int var_62 = av_pix_fmt_count_planes(frame->format);
        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);
        int var_189 = desc ? desc->flags : 0;
        if (var_62 == 1 && (var_189 & AV_PIX_FMT_FLAG_PAL))
            var_62 = 2;
        for (i = 0; i < var_62; i++) {
            av_assert0(frame->data[i]);
        }

        if (var_62 == 1 && (var_189 & AV_PIX_FMT_FLAG_PSEUDOPAL))
            var_62 = 2;

        for (i = var_62; var_62 > 0 && i < FF_ARRAY_ELEMS(frame->data); i++) {
            if (frame->data[i])
                av_log(avctx, AV_LOG_ERROR, "Buffer returned by get_buffer2() did not zero unused plane pointers\n");
            frame->data[i] = NULL;
        }
    }
}

static int fn_62(AVCodecContext *avctx, AVFrame *frame, int var_189)
{
    const AVHWAccel *hwaccel = avctx->hwaccel;
    int var_64 = 1;
    int var_205;

    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
        if ((var_205 = av_image_check_size2(avctx->width, avctx->height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx)) < 0 || avctx->pix_fmt<0) {
            av_log(avctx, AV_LOG_ERROR, "video_get_buffer: image parameters invalid\n");
            return AVERROR(EINVAL);
        }

        if (frame->width <= 0 || frame->height <= 0) {
            frame->width = FFMAX(avctx->width, AV_CEIL_RSHIFT(avctx->coded_width, avctx->lowres));
            frame->height = FFMAX(avctx->height, AV_CEIL_RSHIFT(avctx->coded_height, avctx->lowres));
            var_64 = 0;
        }

        if (frame->data[0] || frame->data[1] || frame->data[2] || frame->data[3]) {
            av_log(avctx, AV_LOG_ERROR, "pic->data[*]!=NULL in get_buffer_internal\n");
            return AVERROR(EINVAL);
        }
    }
    var_205 = ff_decode_frame_props(avctx, frame);
    if (var_205 < 0)
        return var_205;

    if (hwaccel) {
        if (hwaccel->alloc_frame) {
            var_205 = hwaccel->alloc_frame(avctx, frame);
            goto end;
        }
    } else
        avctx->sw_pix_fmt = avctx->pix_fmt;

    var_205 = avctx->get_buffer2(avctx, frame, var_189);
    if (var_205 >= 0)
        validate_avframe_allocation(avctx, frame);

end:
    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO && !var_64) {
        frame->width = avctx->width;
        frame->height = avctx->height;
    }

    return var_205;
}

int fn_64(AVCodecContext *avctx, AVFrame *frame, int var_189)
{
    int var_205 = get_buffer_internal(avctx, frame, var_189);
    if (var_205 < 0) {
        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
        frame->width = frame->height = 0;
    }
    return var_205;
}

static int fn_65(AVCodecContext *avctx, AVFrame *frame)
{
    AVFrame *var_208;
    int var_205;

    av_assert0(avctx->codec_type == AVMEDIA_TYPE_VIDEO);

    if (frame->data[0] && (frame->width != avctx->width || frame->height != avctx->height || frame->format != avctx->pix_fmt)) {
        av_log(avctx, AV_LOG_WARNING, "Picture changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s in reget buffer()\n",
               frame->width, frame->height, av_get_pix_fmt_name(frame->format), avctx->width, avctx->height, av_get_pix_fmt_name(avctx->pix_fmt));
        av_frame_unref(frame);
    }

    ff_init_buffer_info(avctx, frame);

    if (!frame->data[0])
        return ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF);

    if (av_frame_is_writable(frame))
        return ff_decode_frame_props(avctx, frame);

    var_208 = av_frame_alloc();
    if (!var_208)
        return AVERROR(ENOMEM);

    av_frame_move_ref(var_208, frame);

    var_205 = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF);
    if (var_205 < 0) {
        av_frame_free(&var_208);
        return var_205;
    }

    av_frame_copy(frame, var_208);
    av_frame_free(&var_208);

    return 0;
}

int fn_67(AVCodecContext *avctx, AVFrame *frame)
{
    int var_205 = reget_buffer_internal(avctx, frame);
    if (var_205 < 0)
        av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n");
    return var_205;
}

int fn_68(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2), void *arg, int *var_205, int var_197, int var_208)
{
    int i;

    for (i = 0; i < var_197; i++) {
        int var_74 = func(c, (char *)arg + i * var_208);
        if (var_205)
            var_205[i] = var_74;
    }
    emms_c();
    return 0;
}

int fn_71(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int var_72, int var_73), void *arg, int *var_205, int var_197)
{
    int i;

    for (i = 0; i < var_197; i++) {
        int var_74 = func(c, arg, i, 0);
        if (var_205)
            var_205[i] = var_74;
    }
    emms_c();
    return 0;
}

enum enumtype_188 fn_75(const PixelFormatTag *tags,
                                       unsigned int var_77)
{
    while (tags->pix_fmt >= 0) {
        if (tags->fourcc == var_77)
            return tags->pix_fmt;
        tags++;
    }
    return AV_PIX_FMT_NONE;
}

static int fn_77(enum enumtype_188 var_85)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(var_85);
    return desc->flags & AV_PIX_FMT_FLAG_HWACCEL;
}

enum enumtype_188 fn_79(struct struct_80 *s, const enum enumtype_188 *var_188)
{
    while (*var_188 != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt(*var_188))
        ++var_188;
    return var_188[0];
}

static AVHWAccel *fn_82(enum enumtype_160 var_159,
                               enum enumtype_188 var_85)
{
    AVHWAccel *hwaccel = NULL;

    while ((hwaccel = av_hwaccel_next(hwaccel)))
        if (hwaccel->id == var_159
            && hwaccel->pix_fmt == var_85)
            return hwaccel;
    return NULL;
}

static int fn_85(AVCodecContext *avctx,
                         const enum enumtype_188 var_188,
                         const char *name)
{
    AVHWAccel *hwa = find_hwaccel(avctx->codec_id, var_188);
    int var_205 = 0;

    if (avctx->active_thread_type & FF_THREAD_FRAME) {
        av_log(avctx, AV_LOG_WARNING,
               "Hardware accelerated decoding with frame threading is known to be unstable and its use is discouraged.\n");
    }

    if (!hwa) {
        av_log(avctx, AV_LOG_ERROR,
               "Could not find an AVHWAccel for the pixel format: %s",
               name);
        return AVERROR(ENOENT);
    }

    if (hwa->capabilities & HWACCEL_CODEC_CAP_EXPERIMENTAL &&
        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {
        av_log(avctx, AV_LOG_WARNING, "Ignoring experimental hwaccel: %s\n",
               hwa->name);
        return AVERROR_PATCHWELCOME;
    }

    if (hwa->priv_data_size) {
        avctx->internal->hwaccel_priv_data = av_mallocz(hwa->priv_data_size);
        if (!avctx->internal->hwaccel_priv_data)
            return AVERROR(ENOMEM);
    }

    if (hwa->init) {
        var_205 = hwa->init(avctx);
        if (var_205 < 0) {
            av_freep(&avctx->internal->hwaccel_priv_data);
            return var_205;
        }
    }

    avctx->hwaccel = hwa;

    return 0;
}

int fn_86(AVCodecContext *avctx, const enum enumtype_188 *var_188)
{
    const AVPixFmtDescriptor *desc;
    enum enumtype_188 *choices;
    enum enumtype_188 var_205;
    unsigned var_202 = 0;

    while (var_188[var_202] != AV_PIX_FMT_NONE)
        ++var_202;

    av_assert0(var_202 >= 1);
    avctx->sw_pix_fmt = var_188[var_202 - 1];
    av_assert2(!is_hwaccel_pix_fmt(avctx->sw_pix_fmt));

    choices = av_malloc_array(var_202 + 1, sizeof(*choices));
    if (!choices)
        return AV_PIX_FMT_NONE;

    memcpy(choices, var_188, (var_202 + 1) * sizeof(*choices));

    for (;;) {
        if (avctx->hwaccel && avctx->hwaccel->uninit)
            avctx->hwaccel->uninit(avctx);
        av_freep(&avctx->internal->hwaccel_priv_data);
        avctx->hwaccel = NULL;

        av_buffer_unref(&avctx->hw_frames_ctx);

        var_205 = avctx->get_format(avctx, choices);

        desc = av_pix_fmt_desc_get(var_205);
        if (!desc) {
            var_205 = AV_PIX_FMT_NONE;
            break;
        }

        if (!(desc->flags & AV_PIX_FMT_FLAG_HWACCEL))
            break;





        if (avctx->hw_frames_ctx) {
            AVHWFramesContext *hw_frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
            if (hw_frames_ctx->format != var_205) {
                av_log(avctx, AV_LOG_ERROR, "Format returned from get_buffer() "
                       "does not match the format of provided AVHWFramesContext\n");
                var_205 = AV_PIX_FMT_NONE;
                break;
            }
        }

        if (!setup_hwaccel(avctx, var_205, desc->name))
            break;


        for (var_202 = 0; choices[var_202] != var_205; var_202++)
            av_assert0(choices[var_202] != AV_PIX_FMT_NONE);

        do
            choices[var_202] = choices[var_202 + 1];
        while (choices[var_202++] != AV_PIX_FMT_NONE);
    }

    av_freep(&choices);
    return var_205;
}

MAKE_ACCESSORS(AVCodecContext, codec, AVRational, pkt_timebase)
MAKE_ACCESSORS(AVCodecContext, codec, const AVCodecDescriptor *, codec_descriptor)
MAKE_ACCESSORS(AVCodecContext, codec, int, lowres)
MAKE_ACCESSORS(AVCodecContext, codec, int, seek_preroll)
MAKE_ACCESSORS(AVCodecContext, codec, uint16_t*, chroma_intra_matrix)

unsigned fn_88(const AVCodecContext *codec)
{
    return codec->properties;
}

int fn_89(const AVCodec *codec)
{
    return codec->max_lowres;
}

int fn_90(const AVCodec *codec){
    return !!(codec->caps_internal & FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM);
}

static void fn_91(AVSubtitle *sub)
{
    memset(sub, 0, sizeof(*sub));
    sub->pts = var_128;
}

static int64_t fn_92(AVCodecContext *ctx)
{
    int64_t bit_rate;
    int bits_per_sample;

    switch (ctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
    case AVMEDIA_TYPE_DATA:
    case AVMEDIA_TYPE_SUBTITLE:
    case AVMEDIA_TYPE_ATTACHMENT:
        bit_rate = ctx->bit_rate;
        break;
    case AVMEDIA_TYPE_AUDIO:
        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);
        bit_rate = bits_per_sample ? ctx->sample_rate * (int64_t)ctx->channels * bits_per_sample : ctx->bit_rate;
        break;
    default:
        bit_rate = 0;
        break;
    }
    return bit_rate;
}

int attribute_align_arg fn_93(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
{
    int var_205 = 0;

    ff_unlock_avcodec(codec);

    var_205 = avcodec_open2(avctx, codec, options);

    ff_lock_avcodec(avctx, codec);
    return var_205;
}

int attribute_align_arg fn_94(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
{
    int var_205 = 0;
    AVDictionary *var_208 = NULL;
    const AVPixFmtDescriptor *pixdesc;

    if (avcodec_is_open(avctx))
        return 0;

    if ((!codec && !avctx->codec)) {
        av_log(avctx, AV_LOG_ERROR, "No codec provided to avcodec_open2()\n");
        return AVERROR(EINVAL);
    }
    if ((codec && avctx->codec && codec != avctx->codec)) {
        av_log(avctx, AV_LOG_ERROR, "This AVCodecContext was allocated for %s, "
                                    "but %s passed to avcodec_open2()\n", avctx->codec->name, codec->name);
        return AVERROR(EINVAL);
    }
    if (!codec)
        codec = avctx->codec;

    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)
        return AVERROR(EINVAL);

    if (options)
        av_dict_copy(&var_208, *options, 0);

    var_205 = ff_lock_avcodec(avctx, codec);
    if (var_205 < 0)
        return var_205;

    avctx->internal = av_mallocz(sizeof(AVCodecInternal));
    if (!avctx->internal) {
        var_205 = AVERROR(ENOMEM);
        goto end;
    }

    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));
    if (!avctx->internal->pool) {
        var_205 = AVERROR(ENOMEM);
        goto free_and_end;
    }

    avctx->internal->to_free = av_frame_alloc();
    if (!avctx->internal->to_free) {
        var_205 = AVERROR(ENOMEM);
        goto free_and_end;
    }

    avctx->internal->buffer_frame = av_frame_alloc();
    if (!avctx->internal->buffer_frame) {
        var_205 = AVERROR(ENOMEM);
        goto free_and_end;
    }

    avctx->internal->buffer_pkt = av_packet_alloc();
    if (!avctx->internal->buffer_pkt) {
        var_205 = AVERROR(ENOMEM);
        goto free_and_end;
    }

    if (codec->priv_data_size > 0) {
        if (!avctx->priv_data) {
            avctx->priv_data = av_mallocz(codec->priv_data_size);
            if (!avctx->priv_data) {
                var_205 = AVERROR(ENOMEM);
                goto end;
            }
            if (codec->priv_class) {
                *(const AVClass **)avctx->priv_data = codec->priv_class;
                av_opt_set_defaults(avctx->priv_data);
            }
        }
        if (codec->priv_class && (var_205 = av_opt_set_dict(avctx->priv_data, &var_208)) < 0)
            goto free_and_end;
    } else {
        avctx->priv_data = NULL;
    }
    if ((var_205 = av_opt_set_dict(avctx, &var_208)) < 0)
        goto free_and_end;

    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {
        av_log(avctx, AV_LOG_ERROR, "Codec (%s) not on whitelist \'%s\'\n", codec->name, avctx->codec_whitelist);
        var_205 = AVERROR(EINVAL);
        goto free_and_end;
    }


    if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&
          (avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_VP6F || avctx->codec_id == AV_CODEC_ID_DXV))) {
    if (avctx->coded_width && avctx->coded_height)
        var_205 = ff_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);
    else if (avctx->width && avctx->height)
        var_205 = ff_set_dimensions(avctx, avctx->width, avctx->height);
    if (var_205 < 0)
        goto free_and_end;
    }

    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)
        && ( av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0
           || av_image_check_size2(avctx->width, avctx->height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx) < 0)) {
        av_log(avctx, AV_LOG_WARNING, "Ignoring invalid width/height values\n");
        ff_set_dimensions(avctx, 0, 0);
    }

    if (avctx->width > 0 && avctx->height > 0) {
        if (av_image_check_sar(avctx->width, avctx->height,
                               avctx->sample_aspect_ratio) < 0) {
            av_log(avctx, AV_LOG_WARNING, "ignoring invalid SAR: %u/%u\n",
                   avctx->sample_aspect_ratio.num,
                   avctx->sample_aspect_ratio.den);
            avctx->sample_aspect_ratio = (AVRational){ 0, 1 };
        }
    }



    if (av_codec_is_decoder(codec))
        av_freep(&avctx->subtitle_header);

    if (avctx->channels > FF_SANE_NB_CHANNELS) {
        var_205 = AVERROR(EINVAL);
        goto free_and_end;
    }

    avctx->codec = codec;
    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&
        avctx->codec_id == AV_CODEC_ID_NONE) {
        avctx->codec_type = codec->type;
        avctx->codec_id = codec->id;
    }
    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type
                                         && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {
        av_log(avctx, AV_LOG_ERROR, "Codec type or id mismatches\n");
        var_205 = AVERROR(EINVAL);
        goto free_and_end;
    }
    avctx->frame_number = 0;
    avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);

    if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&
        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {
        const char *codec_string = av_codec_is_encoder(codec) ? "encoder" : "decoder";
        AVCodec *codec2;
        av_log(avctx, AV_LOG_ERROR,
               "The %s '%s' is experimental but experimental codecs are not enabled, "
               "add '-strict %d' if you want to use it.\n",
               codec_string, codec->name, FF_COMPLIANCE_EXPERIMENTAL);
        codec2 = av_codec_is_encoder(codec) ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id);
        if (!(codec2->capabilities & AV_CODEC_CAP_EXPERIMENTAL))
            av_log(avctx, AV_LOG_ERROR, "Alternatively use the non experimental %s '%s'.\n",
                codec_string, codec2->name);
        var_205 = AVERROR_EXPERIMENTAL;
        goto free_and_end;
    }

    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&
        (!avctx->time_base.num || !avctx->time_base.den)) {
        avctx->time_base.num = 1;
        avctx->time_base.den = avctx->sample_rate;
    }

    if (!HAVE_THREADS)
        av_log(avctx, AV_LOG_WARNING, "Warning: not compiled with thread support, using thread emulation\n");

    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {
        ff_unlock_avcodec(codec);
        var_205 = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);
        ff_lock_avcodec(avctx, codec);
        if (var_205 < 0)
            goto free_and_end;
    }

    if (HAVE_THREADS
        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {
        var_205 = ff_thread_init(avctx);
        if (var_205 < 0) {
            goto free_and_end;
        }
    }
    if (!HAVE_THREADS && !(codec->capabilities & AV_CODEC_CAP_AUTO_THREADS))
        avctx->thread_count = 1;

    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {
        av_log(avctx, AV_LOG_WARNING, "The maximum value for lowres supported by the decoder is %d\n",
               avctx->codec->max_lowres);
        avctx->lowres = avctx->codec->max_lowres;
    }







    if (av_codec_is_encoder(avctx->codec)) {
        int i;

        if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {
            av_log(avctx, AV_LOG_ERROR, "The encoder timebase is not set.\n");
            var_205 = AVERROR(EINVAL);
            goto free_and_end;
        }

        if (avctx->codec->sample_fmts) {
            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {
                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])
                    break;
                if (avctx->channels == 1 &&
                    av_get_planar_sample_fmt(avctx->sample_fmt) ==
                    av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {
                    avctx->sample_fmt = avctx->codec->sample_fmts[i];
                    break;
                }
            }
            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {
                char buf[128];
                snprintf(buf, sizeof(buf), "%d", avctx->sample_fmt);
                av_log(avctx, AV_LOG_ERROR, "Specified sample format %s is invalid or not supported\n",
                       (char *)av_x_if_null(av_get_sample_fmt_name(avctx->sample_fmt), buf));
                var_205 = AVERROR(EINVAL);
                goto free_and_end;
            }
        }
        if (avctx->codec->pix_fmts) {
            for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)
                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])
                    break;
            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE
                && !((avctx->codec_id == AV_CODEC_ID_MJPEG || avctx->codec_id == AV_CODEC_ID_LJPEG)
                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {
                char buf[128];
                snprintf(buf, sizeof(buf), "%d", avctx->pix_fmt);
                av_log(avctx, AV_LOG_ERROR, "Specified pixel format %s is invalid or not supported\n",
                       (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));
                var_205 = AVERROR(EINVAL);
                goto free_and_end;
            }
            if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||
                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||
                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||
                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||
                avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)
                avctx->color_range = AVCOL_RANGE_JPEG;
        }
        if (avctx->codec->supported_samplerates) {
            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)
                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])
                    break;
            if (avctx->codec->supported_samplerates[i] == 0) {
                av_log(avctx, AV_LOG_ERROR, "Specified sample rate %d is not supported\n",
                       avctx->sample_rate);
                var_205 = AVERROR(EINVAL);
                goto free_and_end;
            }
        }
        if (avctx->sample_rate < 0) {
            av_log(avctx, AV_LOG_ERROR, "Specified sample rate %d is not supported\n",
                    avctx->sample_rate);
            var_205 = AVERROR(EINVAL);
            goto free_and_end;
        }
        if (avctx->codec->channel_layouts) {
            if (!avctx->channel_layout) {
                av_log(avctx, AV_LOG_WARNING, "Channel layout not specified\n");
            } else {
                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)
                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])
                        break;
                if (avctx->codec->channel_layouts[i] == 0) {
                    char buf[512];
                    av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
                    av_log(avctx, AV_LOG_ERROR, "Specified channel layout '%s' is not supported\n", buf);
                    var_205 = AVERROR(EINVAL);
                    goto free_and_end;
                }
            }
        }
        if (avctx->channel_layout && avctx->channels) {
            int var_96 = av_get_channel_layout_nb_channels(avctx->channel_layout);
            if (var_96 != avctx->channels) {
                char buf[512];
                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
                av_log(avctx, AV_LOG_ERROR,
                       "Channel layout '%s' with %d channels does not match number of specified channels %d\n",
                       buf, var_96, avctx->channels);
                var_205 = AVERROR(EINVAL);
                goto free_and_end;
            }
        } else if (avctx->channel_layout) {
            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
        }
        if (avctx->channels < 0) {
            av_log(avctx, AV_LOG_ERROR, "Specified number of channels %d is not supported\n",
                    avctx->channels);
            var_205 = AVERROR(EINVAL);
            goto free_and_end;
        }
        if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
            pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);
            if ( avctx->bits_per_raw_sample < 0
                || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {
                av_log(avctx, AV_LOG_WARNING, "Specified bit depth %d not possible with the specified pixel formats depth %d\n",
                    avctx->bits_per_raw_sample, pixdesc->comp[0].depth);
                avctx->bits_per_raw_sample = pixdesc->comp[0].depth;
            }
            if (avctx->width <= 0 || avctx->height <= 0) {
                av_log(avctx, AV_LOG_ERROR, "dimensions not set\n");
                var_205 = AVERROR(EINVAL);
                goto free_and_end;
            }
        }
        if ( (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)
            && avctx->bit_rate>0 && avctx->bit_rate<1000) {
            av_log(avctx, AV_LOG_WARNING, "Bitrate %"PRId64" is extremely low, maybe you mean %"PRId64"k\n", (int64_t)avctx->bit_rate, (int64_t)avctx->bit_rate);
        }

        if (!avctx->rc_initial_buffer_occupancy)
            avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3 / 4;

        if (avctx->ticks_per_frame && avctx->time_base.num &&
            avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {
            av_log(avctx, AV_LOG_ERROR,
                   "ticks_per_frame %d too large for the timebase %d/%d.",
                   avctx->ticks_per_frame,
                   avctx->time_base.num,
                   avctx->time_base.den);
            goto free_and_end;
        }

        if (avctx->hw_frames_ctx) {
            AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
            if (frames_ctx->format != avctx->pix_fmt) {
                av_log(avctx, AV_LOG_ERROR,
                       "Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\n");
                var_205 = AVERROR(EINVAL);
                goto free_and_end;
            }
        }
    }

    avctx->pts_correction_num_faulty_pts =
    avctx->pts_correction_num_faulty_dts = 0;
    avctx->pts_correction_last_pts =
    avctx->pts_correction_last_dts = INT64_MIN;

    if ( !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY
        && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)
        av_log(avctx, AV_LOG_WARNING,
               "gray decoding requested but not enabled at configuration time\n");

    if ( avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)
        || avctx->internal->frame_thread_encoder)) {
        var_205 = avctx->codec->init(avctx);
        if (var_205 < 0) {
            goto free_and_end;
        }
    }

    var_205=0;






    if (av_codec_is_decoder(avctx->codec)) {
        if (!avctx->bit_rate)
            avctx->bit_rate = get_bit_rate(avctx);

        if (avctx->channel_layout) {
            int var_96 = av_get_channel_layout_nb_channels(avctx->channel_layout);
            if (!avctx->channels)
                avctx->channels = var_96;
            else if (var_96 != avctx->channels) {
                char buf[512];
                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
                av_log(avctx, AV_LOG_WARNING,
                       "Channel layout '%s' with %d channels does not match specified number of channels %d: "
                       "ignoring specified channel layout\n",
                       buf, var_96, avctx->channels);
                avctx->channel_layout = 0;
            }
        }
        if (avctx->channels && avctx->channels < 0 ||
            avctx->channels > FF_SANE_NB_CHANNELS) {
            var_205 = AVERROR(EINVAL);
            goto free_and_end;
        }
        if (avctx->sub_charenc) {
            if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {
                av_log(avctx, AV_LOG_ERROR, "Character encoding is only "
                       "supported with subtitles codecs\n");
                var_205 = AVERROR(EINVAL);
                goto free_and_end;
            } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {
                av_log(avctx, AV_LOG_WARNING, "Codec '%s' is bitmap-based, "
                       "subtitles character encoding will be ignored\n",
                       avctx->codec_descriptor->name);
                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;
            } else {


                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)
                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;

                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {

                    av_log(avctx, AV_LOG_ERROR, "Character encoding subtitles "
                           "conversion needs a libavcodec built with iconv support "
                           "for this codec\n");
                    var_205 = AVERROR(ENOSYS);
                    goto free_and_end;

                }
            }
        }





    }
    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {
        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);
    }

end:
    ff_unlock_avcodec(codec);
    if (options) {
        av_dict_free(options);
        *options = var_208;
    }

    return var_205;
free_and_end:
    if (avctx->codec &&
        (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP))
        avctx->codec->close(avctx);

    if (codec->priv_class && codec->priv_data_size)
        av_opt_free(avctx->priv_data);
    av_opt_free(avctx);







    av_dict_free(&var_208);
    av_freep(&avctx->priv_data);
    if (avctx->internal) {
        av_packet_free(&avctx->internal->buffer_pkt);
        av_frame_free(&avctx->internal->buffer_frame);
        av_frame_free(&avctx->internal->to_free);
        av_freep(&avctx->internal->pool);
    }
    av_freep(&avctx->internal);
    avctx->codec = NULL;
    goto end;
}

int fn_96(AVCodecContext *avctx, AVPacket *avpkt, int64_t var_208, int64_t var_97)
{
    if (avpkt->size < 0) {
        av_log(avctx, AV_LOG_ERROR, "Invalid negative user packet size %d\n", avpkt->size);
        return AVERROR(EINVAL);
    }
    if (var_208 < 0 || var_208 > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
        av_log(avctx, AV_LOG_ERROR, "Invalid minimum required packet size %"PRId64" (max allowed is %d)\n",
               var_208, INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE);
        return AVERROR(EINVAL);
    }

    if (avctx && 2*var_97 < var_208) {
        av_assert0(!avpkt->data || avpkt->data != avctx->internal->byte_buffer);
        if (!avpkt->data || avpkt->size < var_208) {
            av_fast_padded_malloc(&avctx->internal->byte_buffer, &avctx->internal->byte_buffer_size, var_208);
            avpkt->data = avctx->internal->byte_buffer;
            avpkt->size = avctx->internal->byte_buffer_size;
        }
    }

    if (avpkt->data) {
        AVBufferRef *buf = avpkt->buf;

        if (avpkt->size < var_208) {
            av_log(avctx, AV_LOG_ERROR, "User packet is too small (%d < %"PRId64")\n", avpkt->size, var_208);
            return AVERROR(EINVAL);
        }

        av_init_packet(avpkt);
        avpkt->buf = buf;
        avpkt->size = var_208;
        return 0;
    } else {
        int var_205 = av_new_packet(avpkt, var_208);
        if (var_205 < 0)
            av_log(avctx, AV_LOG_ERROR, "Failed to allocate packet of size %"PRId64"\n", var_208);
        return var_205;
    }
}

int fn_97(AVPacket *avpkt, int var_208)
{
    return ff_alloc_packet2(NULL, avpkt, var_208, 0);
}




static int fn_98(AVCodecContext *s, AVFrame **dst, const AVFrame *src)
{
    AVFrame *frame = NULL;
    int var_205;

    if (!(frame = av_frame_alloc()))
        return AVERROR(ENOMEM);

    frame->format = src->format;
    frame->channel_layout = src->channel_layout;
    av_frame_set_channels(frame, av_frame_get_channels(src));
    frame->nb_samples = s->frame_size;
    var_205 = av_frame_get_buffer(frame, 32);
    if (var_205 < 0)
        goto fail;

    var_205 = av_frame_copy_props(frame, src);
    if (var_205 < 0)
        goto fail;

    if ((var_205 = av_samples_copy(frame->extended_data, src->extended_data, 0, 0,
                               src->nb_samples, s->channels, s->sample_fmt)) < 0)
        goto fail;
    if ((var_205 = av_samples_set_silence(frame->extended_data, src->nb_samples,
                                      frame->nb_samples - src->nb_samples,
                                      s->channels, s->sample_fmt)) < 0)
        goto fail;

    *dst = frame;

    return 0;

fail:
    av_frame_free(&frame);
    return var_205;
}

int attribute_align_arg fn_99(AVCodecContext *avctx,
                                              AVPacket *avpkt,
                                              const AVFrame *frame,
                                              int *got_packet_ptr)
{
    AVFrame *extended_frame = NULL;
    AVFrame *padded_frame = NULL;
    int var_205;
    AVPacket var_104 = *avpkt;
    int var_104 = !var_104.data;

    *got_packet_ptr = 0;

    if (!avctx->codec->encode2) {
        av_log(avctx, AV_LOG_ERROR, "This encoder requires using the avcodec_send_frame() API.\n");
        return AVERROR(ENOSYS);
    }

    if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY) && !frame) {
        av_packet_unref(avpkt);
        av_init_packet(avpkt);
        return 0;
    }


    if (frame && !frame->extended_data) {
        if (av_sample_fmt_is_planar(avctx->sample_fmt) &&
            avctx->channels > AV_NUM_DATA_POINTERS) {
            av_log(avctx, AV_LOG_ERROR, "Encoding to a planar sample format, "
                                        "with more than %d channels, but extended_data is not set.\n",
                   AV_NUM_DATA_POINTERS);
            return AVERROR(EINVAL);
        }
        av_log(avctx, AV_LOG_WARNING, "extended_data is not set.\n");

        extended_frame = av_frame_alloc();
        if (!extended_frame)
            return AVERROR(ENOMEM);

        memcpy(extended_frame, frame, sizeof(AVFrame));
        extended_frame->extended_data = extended_frame->data;
        frame = extended_frame;
    }


    if (frame) {
        AVFrameSideData *sd = av_frame_get_side_data(frame, AV_FRAME_DATA_AUDIO_SERVICE_TYPE);
        if (sd && sd->size >= sizeof(enum enumtype_103))
            avctx->audio_service_type = *(enum enumtype_103*)sd->data;
    }


    if (frame) {
        if (avctx->codec->capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME) {
            if (frame->nb_samples > avctx->frame_size) {
                av_log(avctx, AV_LOG_ERROR, "more samples than frame size (avcodec_encode_audio2)\n");
                var_205 = AVERROR(EINVAL);
                goto end;
            }
        } else if (!(avctx->codec->capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE)) {
            if (frame->nb_samples < avctx->frame_size &&
                !avctx->internal->last_audio_frame) {
                var_205 = pad_last_frame(avctx, &padded_frame, frame);
                if (var_205 < 0)
                    goto end;

                frame = padded_frame;
                avctx->internal->last_audio_frame = 1;
            }

            if (frame->nb_samples != avctx->frame_size) {
                av_log(avctx, AV_LOG_ERROR, "nb_samples (%d) != frame_size (%d) (avcodec_encode_audio2)\n", frame->nb_samples, avctx->frame_size);
                var_205 = AVERROR(EINVAL);
                goto end;
            }
        }
    }

    av_assert0(avctx->codec->encode2);

    var_205 = avctx->codec->encode2(avctx, avpkt, frame, got_packet_ptr);
    if (!var_205) {
        if (*got_packet_ptr) {
            if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY)) {
                if (avpkt->pts == var_128)
                    avpkt->pts = frame->pts;
                if (!avpkt->duration)
                    avpkt->duration = ff_samples_to_time_base(avctx,
                                                              frame->nb_samples);
            }
            avpkt->dts = avpkt->pts;
        } else {
            avpkt->size = 0;
        }
    }
    if (avpkt->data && avpkt->data == avctx->internal->byte_buffer) {
        var_104 = 0;
        if (var_104.data) {
            if (var_104.size >= avpkt->size) {
                memcpy(var_104.data, avpkt->data, avpkt->size);
            } else {
                av_log(avctx, AV_LOG_ERROR, "Provided packet is too small, needs to be %d\n", avpkt->size);
                avpkt->size = var_104.size;
                var_205 = -1;
            }
            avpkt->buf = var_104.buf;
            avpkt->data = var_104.data;
        } else {
            if (av_dup_packet(avpkt) < 0) {
                var_205 = AVERROR(ENOMEM);
            }
        }
    }

    if (!var_205) {
        if (var_104 && avpkt->data) {
            var_205 = av_buffer_realloc(&avpkt->buf, avpkt->size + AV_INPUT_BUFFER_PADDING_SIZE);
            if (var_205 >= 0)
                avpkt->data = avpkt->buf->data;
        }

        avctx->frame_number++;
    }

    if (var_205 < 0 || !*got_packet_ptr) {
        av_packet_unref(avpkt);
        av_init_packet(avpkt);
        goto end;
    }




    avpkt->flags |= AV_PKT_FLAG_KEY;

end:
    av_frame_free(&padded_frame);
    av_free(extended_frame);





    return var_205;
}

int attribute_align_arg fn_103(AVCodecContext *avctx,
                                              AVPacket *avpkt,
                                              const AVFrame *frame,
                                              int *got_packet_ptr)
{
    int var_205;
    AVPacket var_104 = *avpkt;
    int var_104 = !var_104.data;

    *got_packet_ptr = 0;

    if (!avctx->codec->encode2) {
        av_log(avctx, AV_LOG_ERROR, "This encoder requires using the avcodec_send_frame() API.\n");
        return AVERROR(ENOSYS);
    }

    if(CONFIG_FRAME_THREAD_ENCODER &&
       avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))
        return ff_thread_video_encode_frame(avctx, avpkt, frame, got_packet_ptr);

    if ((avctx->flags&AV_CODEC_FLAG_PASS1) && avctx->stats_out)
        avctx->stats_out[0] = '\0';

    if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY) && !frame) {
        av_packet_unref(avpkt);
        av_init_packet(avpkt);
        avpkt->size = 0;
        return 0;
    }

    if (av_image_check_size2(avctx->width, avctx->height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx))
        return AVERROR(EINVAL);

    if (frame && frame->format == AV_PIX_FMT_NONE)
        av_log(avctx, AV_LOG_WARNING, "AVFrame.format is not set\n");
    if (frame && (frame->width == 0 || frame->height == 0))
        av_log(avctx, AV_LOG_WARNING, "AVFrame.width or height is not set\n");

    av_assert0(avctx->codec->encode2);

    var_205 = avctx->codec->encode2(avctx, avpkt, frame, got_packet_ptr);
    av_assert0(var_205 <= 0);

    emms_c();

    if (avpkt->data && avpkt->data == avctx->internal->byte_buffer) {
        var_104 = 0;
        if (var_104.data) {
            if (var_104.size >= avpkt->size) {
                memcpy(var_104.data, avpkt->data, avpkt->size);
            } else {
                av_log(avctx, AV_LOG_ERROR, "Provided packet is too small, needs to be %d\n", avpkt->size);
                avpkt->size = var_104.size;
                var_205 = -1;
            }
            avpkt->buf = var_104.buf;
            avpkt->data = var_104.data;
        } else {
            if (av_dup_packet(avpkt) < 0) {
                var_205 = AVERROR(ENOMEM);
            }
        }
    }

    if (!var_205) {
        if (!*got_packet_ptr)
            avpkt->size = 0;
        else if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
            avpkt->pts = avpkt->dts = frame->pts;

        if (var_104 && avpkt->data) {
            var_205 = av_buffer_realloc(&avpkt->buf, avpkt->size + AV_INPUT_BUFFER_PADDING_SIZE);
            if (var_205 >= 0)
                avpkt->data = avpkt->buf->data;
        }

        avctx->frame_number++;
    }

    if (var_205 < 0 || !*got_packet_ptr)
        av_packet_unref(avpkt);

    return var_205;
}

int fn_104(AVCodecContext *avctx, uint8_t *buf, int var_149,
                            const AVSubtitle *sub)
{
    int var_205;
    if (sub->start_display_time) {
        av_log(avctx, AV_LOG_ERROR, "start_display_time must be 0.\n");
        return -1;
    }

    var_205 = avctx->codec->encode_sub(avctx, buf, var_149, sub);
    avctx->frame_number++;
    return var_205;
}

static int64_t fn_105(AVCodecContext *ctx,
                                 int64_t var_109, int64_t var_109)
{
    int64_t var_109 = var_128;

    if (var_109 != var_128) {
        ctx->pts_correction_num_faulty_dts += var_109 <= ctx->pts_correction_last_dts;
        ctx->pts_correction_last_dts = var_109;
    } else if (var_109 != var_128)
        ctx->pts_correction_last_dts = var_109;

    if (var_109 != var_128) {
        ctx->pts_correction_num_faulty_pts += var_109 <= ctx->pts_correction_last_pts;
        ctx->pts_correction_last_pts = var_109;
    } else if(var_109 != var_128)
        ctx->pts_correction_last_pts = var_109;

    if ((ctx->pts_correction_num_faulty_pts<=ctx->pts_correction_num_faulty_dts || var_109 == var_128)
       && var_109 != var_128)
        var_109 = var_109;
    else
        var_109 = var_109;

    return var_109;
}

static int fn_109(AVCodecContext *avctx, AVPacket *avpkt)
{
    int var_208 = 0, var_205;
    const uint8_t *data;
    uint32_t var_189;
    int64_t val;

    data = av_packet_get_side_data(avpkt, AV_PKT_DATA_PARAM_CHANGE, &var_208);
    if (!data)
        return 0;

    if (!(avctx->codec->capabilities & AV_CODEC_CAP_PARAM_CHANGE)) {
        av_log(avctx, AV_LOG_ERROR, "This decoder does not support parameter "
               "changes, but PARAM_CHANGE side data was sent to it.\n");
        var_205 = AVERROR(EINVAL);
        goto fail2;
    }

    if (var_208 < 4)
        goto fail;

    var_189 = bytestream_get_le32(&data);
    var_208 -= 4;

    if (var_189 & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {
        if (var_208 < 4)
            goto fail;
        val = bytestream_get_le32(&data);
        if (val <= 0 || val > INT_MAX) {
            av_log(avctx, AV_LOG_ERROR, "Invalid channel count");
            var_205 = AVERROR_INVALIDDATA;
            goto fail2;
        }
        avctx->channels = val;
        var_208 -= 4;
    }
    if (var_189 & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {
        if (var_208 < 8)
            goto fail;
        avctx->channel_layout = bytestream_get_le64(&data);
        var_208 -= 8;
    }
    if (var_189 & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {
        if (var_208 < 4)
            goto fail;
        val = bytestream_get_le32(&data);
        if (val <= 0 || val > INT_MAX) {
            av_log(avctx, AV_LOG_ERROR, "Invalid sample rate");
            var_205 = AVERROR_INVALIDDATA;
            goto fail2;
        }
        avctx->sample_rate = val;
        var_208 -= 4;
    }
    if (var_189 & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {
        if (var_208 < 8)
            goto fail;
        avctx->width = bytestream_get_le32(&data);
        avctx->height = bytestream_get_le32(&data);
        var_208 -= 8;
        var_205 = ff_set_dimensions(avctx, avctx->width, avctx->height);
        if (var_205 < 0)
            goto fail2;
    }

    return 0;
fail:
    av_log(avctx, AV_LOG_ERROR, "PARAM_CHANGE side data too small.\n");
    var_205 = AVERROR_INVALIDDATA;
fail2:
    if (var_205 < 0) {
        av_log(avctx, AV_LOG_ERROR, "Error applying parameter changes.\n");
        if (avctx->err_recognition & AV_EF_EXPLODE)
            return var_205;
    }
    return 0;
}

static int fn_110(AVCodecInternal *avci, AVFrame *frame)
{
    int var_205;


    av_frame_unref(avci->to_free);
    av_frame_move_ref(avci->to_free, frame);




    var_205 = av_frame_copy_props(frame, avci->to_free);
    if (var_205 < 0)
        return var_205;

    memcpy(frame->data, avci->to_free->data, sizeof(frame->data));
    memcpy(frame->linesize, avci->to_free->linesize, sizeof(frame->linesize));
    if (avci->to_free->extended_data != avci->to_free->data) {
        int var_111 = av_frame_get_channels(avci->to_free);
        int var_208 = var_111 * sizeof(*frame->extended_data);

        if (!var_208) {
            av_frame_unref(frame);
            return AVERROR_BUG;
        }

        frame->extended_data = av_malloc(var_208);
        if (!frame->extended_data) {
            av_frame_unref(frame);
            return AVERROR(ENOMEM);
        }
        memcpy(frame->extended_data, avci->to_free->extended_data,
               var_208);
    } else
        frame->extended_data = frame->data;

    frame->format = avci->to_free->format;
    frame->width = avci->to_free->width;
    frame->height = avci->to_free->height;
    frame->channel_layout = avci->to_free->channel_layout;
    frame->nb_samples = avci->to_free->nb_samples;
    av_frame_set_channels(frame, av_frame_get_channels(avci->to_free));

    return 0;
}

int attribute_align_arg fn_111(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              const AVPacket *avpkt)
{
    AVCodecInternal *avci = avctx->internal;
    int var_205;

    AVPacket var_208 = *avpkt;

    if (!avctx->codec)
        return AVERROR(EINVAL);
    if (avctx->codec->type != AVMEDIA_TYPE_VIDEO) {
        av_log(avctx, AV_LOG_ERROR, "Invalid media type for video\n");
        return AVERROR(EINVAL);
    }

    if (!avctx->codec->decode) {
        av_log(avctx, AV_LOG_ERROR, "This decoder requires using the avcodec_send_packet() API.\n");
        return AVERROR(ENOSYS);
    }

    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size2(avctx->coded_width, avctx->coded_height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx))
        return AVERROR(EINVAL);

    avctx->internal->pkt = avpkt;
    var_205 = apply_param_change(avctx, avpkt);
    if (var_205 < 0)
        return var_205;

    av_frame_unref(picture);

    if ((avctx->codec->capabilities & AV_CODEC_CAP_DELAY) || avpkt->size ||
        (avctx->active_thread_type & FF_THREAD_FRAME)) {
        int var_127 = av_packet_split_side_data(&var_208);
        var_205 = apply_param_change(avctx, &var_208);
        if (var_205 < 0)
            goto fail;

        avctx->internal->pkt = &var_208;
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            var_205 = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         &var_208);
        else {
            var_205 = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       &var_208);
            if (!(avctx->codec->caps_internal & FF_CODEC_CAP_SETS_PKT_DTS))
                picture->pkt_dts = avpkt->dts;

            if(!avctx->has_b_frames){
                av_frame_set_pkt_pos(picture, avpkt->pos);
            }


            if (!(avctx->codec->capabilities & AV_CODEC_CAP_DR1)) {
                if (!picture->sample_aspect_ratio.num) picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
                if (!picture->width) picture->width = avctx->width;
                if (!picture->height) picture->height = avctx->height;
                if (picture->format == AV_PIX_FMT_NONE) picture->format = avctx->pix_fmt;
            }
        }

fail:
        emms_c();

        avctx->internal->pkt = NULL;
        if (var_127) {
            av_packet_free_side_data(&var_208);
            if(var_205 == var_208.size)
                var_205 = avpkt->size;
        }
        if (picture->flags & AV_FRAME_FLAG_DISCARD) {
            *got_picture_ptr = 0;
        }
        if (*got_picture_ptr) {
            if (!avctx->refcounted_frames) {
                int var_181 = unrefcount_frame(avci, picture);
                if (var_181 < 0)
                    return var_181;
            }

            avctx->frame_number++;
            av_frame_set_best_effort_timestamp(picture,
                                               guess_correct_pts(avctx,
                                                                 picture->pts,
                                                                 picture->pkt_dts));
        } else
            av_frame_unref(picture);
    } else
        var_205 = 0;



    av_assert0(!picture->extended_data || picture->extended_data == picture->data);






    return var_205;
}

int attribute_align_arg fn_114(AVCodecContext *avctx,
                                              AVFrame *frame,
                                              int *got_frame_ptr,
                                              const AVPacket *avpkt)
{
    AVCodecInternal *avci = avctx->internal;
    int var_205 = 0;

    *got_frame_ptr = 0;

    if (!avctx->codec)
        return AVERROR(EINVAL);

    if (!avctx->codec->decode) {
        av_log(avctx, AV_LOG_ERROR, "This decoder requires using the avcodec_send_packet() API.\n");
        return AVERROR(ENOSYS);
    }

    if (!avpkt->data && avpkt->size) {
        av_log(avctx, AV_LOG_ERROR, "invalid packet: NULL data, size != 0\n");
        return AVERROR(EINVAL);
    }
    if (avctx->codec->type != AVMEDIA_TYPE_AUDIO) {
        av_log(avctx, AV_LOG_ERROR, "Invalid media type for audio\n");
        return AVERROR(EINVAL);
    }

    av_frame_unref(frame);

    if ((avctx->codec->capabilities & AV_CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        uint8_t *side;
        int side_size;
        uint32_t var_119 = 0;
        uint8_t var_119 = 0;
        uint8_t var_119 = 0;

        AVPacket var_208 = *avpkt;
        int var_127 = av_packet_split_side_data(&var_208);
        var_205 = apply_param_change(avctx, &var_208);
        if (var_205 < 0)
            goto fail;

        avctx->internal->pkt = &var_208;
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            var_205 = ff_thread_decode_frame(avctx, frame, got_frame_ptr, &var_208);
        else {
            var_205 = avctx->codec->decode(avctx, frame, got_frame_ptr, &var_208);
            av_assert0(var_205 <= var_208.size);
            frame->pkt_dts = avpkt->dts;
        }
        if (var_205 >= 0 && *got_frame_ptr) {
            avctx->frame_number++;
            av_frame_set_best_effort_timestamp(frame,
                                               guess_correct_pts(avctx,
                                                                 frame->pts,
                                                                 frame->pkt_dts));
            if (frame->format == AV_SAMPLE_FMT_NONE)
                frame->format = avctx->sample_fmt;
            if (!frame->channel_layout)
                frame->channel_layout = avctx->channel_layout;
            if (!av_frame_get_channels(frame))
                av_frame_set_channels(frame, avctx->channels);
            if (!frame->sample_rate)
                frame->sample_rate = avctx->sample_rate;
        }

        side= av_packet_get_side_data(avctx->internal->pkt, AV_PKT_DATA_SKIP_SAMPLES, &side_size);
        if(side && side_size>=10) {
            avctx->internal->skip_samples = AV_RL32(side);
            var_119 = AV_RL32(side + 4);
            av_log(avctx, AV_LOG_DEBUG, "skip %d / discard %d samples due to side data\n",
                   avctx->internal->skip_samples, (int)var_119);
            var_119 = AV_RL8(side + 8);
            var_119 = AV_RL8(side + 9);
        }

        if ((frame->flags & AV_FRAME_FLAG_DISCARD) && *got_frame_ptr &&
            !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
            avctx->internal->skip_samples = FFMAX(0, avctx->internal->skip_samples - frame->nb_samples);
            *got_frame_ptr = 0;
        }

        if (avctx->internal->skip_samples > 0 && *got_frame_ptr &&
            !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
            if(frame->nb_samples <= avctx->internal->skip_samples){
                *got_frame_ptr = 0;
                avctx->internal->skip_samples -= frame->nb_samples;
                av_log(avctx, AV_LOG_DEBUG, "skip whole frame, skip left: %d\n",
                       avctx->internal->skip_samples);
            } else {
                av_samples_copy(frame->extended_data, frame->extended_data, 0, avctx->internal->skip_samples,
                                frame->nb_samples - avctx->internal->skip_samples, avctx->channels, frame->format);
                if(avctx->pkt_timebase.num && avctx->sample_rate) {
                    int64_t var_119 = av_rescale_q(avctx->internal->skip_samples,
                                                   (AVRational){1, avctx->sample_rate},
                                                   avctx->pkt_timebase);
                    if(frame->pts!=var_128)
                        frame->pts += var_119;






                    if(frame->pkt_dts!=var_128)
                        frame->pkt_dts += var_119;
                    if (av_frame_get_pkt_duration(frame) >= var_119)
                        av_frame_set_pkt_duration(frame, av_frame_get_pkt_duration(frame) - var_119);
                } else {
                    av_log(avctx, AV_LOG_WARNING, "Could not update timestamps for skipped samples.\n");
                }
                av_log(avctx, AV_LOG_DEBUG, "skip %d/%d samples\n",
                       avctx->internal->skip_samples, frame->nb_samples);
                frame->nb_samples -= avctx->internal->skip_samples;
                avctx->internal->skip_samples = 0;
            }
        }

        if (var_119 > 0 && var_119 <= frame->nb_samples && *got_frame_ptr &&
            !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
            if (var_119 == frame->nb_samples) {
                *got_frame_ptr = 0;
            } else {
                if(avctx->pkt_timebase.num && avctx->sample_rate) {
                    int64_t var_119 = av_rescale_q(frame->nb_samples - var_119,
                                                   (AVRational){1, avctx->sample_rate},
                                                   avctx->pkt_timebase);
                    av_frame_set_pkt_duration(frame, var_119);
                } else {
                    av_log(avctx, AV_LOG_WARNING, "Could not update timestamps for discarded samples.\n");
                }
                av_log(avctx, AV_LOG_DEBUG, "discard %d/%d samples\n",
                       (int)var_119, frame->nb_samples);
                frame->nb_samples -= var_119;
            }
        }

        if ((avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL) && *got_frame_ptr) {
            AVFrameSideData *fside = av_frame_new_side_data(frame, AV_FRAME_DATA_SKIP_SAMPLES, 10);
            if (fside) {
                AV_WL32(fside->data, avctx->internal->skip_samples);
                AV_WL32(fside->data + 4, var_119);
                AV_WL8(fside->data + 8, var_119);
                AV_WL8(fside->data + 9, var_119);
                avctx->internal->skip_samples = 0;
            }
        }
fail:
        avctx->internal->pkt = NULL;
        if (var_127) {
            av_packet_free_side_data(&var_208);
            if(var_205 == var_208.size)
                var_205 = avpkt->size;
        }

        if (var_205 >= 0 && *got_frame_ptr) {
            if (!avctx->refcounted_frames) {
                int var_181 = unrefcount_frame(avci, frame);
                if (var_181 < 0)
                    return var_181;
            }
        } else
            av_frame_unref(frame);
    }

    av_assert0(var_205 <= avpkt->size);

    if (!avci->showed_multi_packet_warning &&
        var_205 >= 0 && var_205 != avpkt->size && !(avctx->codec->capabilities & AV_CODEC_CAP_SUBFRAMES)) {
            av_log(avctx, AV_LOG_WARNING, "Multiple frames in a packet.\n");
        avci->showed_multi_packet_warning = 1;
    }

    return var_205;
}


static int fn_119(AVCodecContext *avctx,
                           AVPacket *outpkt, const AVPacket *inpkt)
{

    if (avctx->sub_charenc_mode != FF_SUB_CHARENC_MODE_PRE_DECODER || inpkt->size == 0)
        return 0;

    av_log(avctx, AV_LOG_ERROR, "requesting subtitles recoding without iconv");
    return AVERROR(EINVAL);

}

static int fn_120(const uint8_t *str)
{
    const uint8_t *byte;
    uint32_t codepoint, min;

    while (*str) {
        byte = str;
        GET_UTF8(codepoint, *(byte++), return 0;);
        min = byte - str == 1 ? 0 : byte - str == 2 ? 0x80 :
              1 << (5 * (byte - str) - 4);
        if (codepoint < min || codepoint >= 0x110000 ||
            codepoint == 0xFFFE ||
            codepoint >= 0xD800 && codepoint <= 0xDFFF )
            return 0;
        str = byte;
    }
    return 1;
}

int fn_121(AVCodecContext *avctx, AVSubtitle *sub,
                             int *got_sub_ptr,
                             AVPacket *avpkt)
{
    int i, var_205 = 0;

    if (!avpkt->data && avpkt->size) {
        av_log(avctx, AV_LOG_ERROR, "invalid packet: NULL data, size != 0\n");
        return AVERROR(EINVAL);
    }
    if (!avctx->codec)
        return AVERROR(EINVAL);
    if (avctx->codec->type != AVMEDIA_TYPE_SUBTITLE) {
        av_log(avctx, AV_LOG_ERROR, "Invalid media type for subtitles\n");
        return AVERROR(EINVAL);
    }

    *got_sub_ptr = 0;
    get_subtitle_defaults(sub);

    if ((avctx->codec->capabilities & AV_CODEC_CAP_DELAY) || avpkt->size) {
        AVPacket pkt_recoded;
        AVPacket var_208 = *avpkt;
        int var_127 = av_packet_split_side_data(&var_208);


        if (var_127) {





            memset(var_208.data + var_208.size, 0,
                   FFMIN(avpkt->size - var_208.size, AV_INPUT_BUFFER_PADDING_SIZE));
        }

        pkt_recoded = var_208;
        var_205 = recode_subtitle(avctx, &pkt_recoded, &var_208);
        if (var_205 < 0) {
            *got_sub_ptr = 0;
        } else {
            avctx->internal->pkt = &pkt_recoded;

            if (avctx->pkt_timebase.num && avpkt->pts != var_128)
                sub->pts = av_rescale_q(avpkt->pts,
                                        avctx->pkt_timebase, AV_TIME_BASE_Q);
            var_205 = avctx->codec->decode(avctx, sub, got_sub_ptr, &pkt_recoded);
            av_assert1((var_205 >= 0) >= !!*got_sub_ptr &&
                       !!*got_sub_ptr >= !!sub->num_rects);

            if (sub->num_rects && !sub->end_display_time && avpkt->duration &&
                avctx->pkt_timebase.num) {
                AVRational var_123 = { 1, 1000 };
                sub->end_display_time = av_rescale_q(avpkt->duration,
                                                     avctx->pkt_timebase, var_123);
            }

            for (i = 0; i < sub->num_rects; i++) {
                if (sub->rects[i]->ass && !utf8_check(sub->rects[i]->ass)) {
                    av_log(avctx, AV_LOG_ERROR,
                           "Invalid UTF-8 in decoded subtitles text; "
                           "maybe missing -sub_charenc option\n");
                    avsubtitle_free(sub);
                    return AVERROR_INVALIDDATA;
                }
            }

            if (var_208.data != pkt_recoded.data) {

                pkt_recoded.side_data = NULL;
                pkt_recoded.side_data_elems = 0;

                av_packet_unref(&pkt_recoded);
            }
            if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB)
                sub->format = 0;
            else if (avctx->codec_descriptor->props & AV_CODEC_PROP_TEXT_SUB)
                sub->format = 1;
            avctx->internal->pkt = NULL;
        }

        if (var_127) {
            av_packet_free_side_data(&var_208);
            if(var_205 == var_208.size)
                var_205 = avpkt->size;
        }

        if (*got_sub_ptr)
            avctx->frame_number++;
    }

    return var_205;
}

void fn_123(AVSubtitle *sub)
{
    int i;

    for (i = 0; i < sub->num_rects; i++) {
        av_freep(&sub->rects[i]->data[0]);
        av_freep(&sub->rects[i]->data[1]);
        av_freep(&sub->rects[i]->data[2]);
        av_freep(&sub->rects[i]->data[3]);
        av_freep(&sub->rects[i]->text);
        av_freep(&sub->rects[i]->ass);
        av_freep(&sub->rects[i]);
    }

    av_freep(&sub->rects);

    memset(sub, 0, sizeof(AVSubtitle));
}

static int fn_124(AVCodecContext *avctx, AVPacket *pkt)
{
    int got_frame;
    int var_205;

    av_assert0(!avctx->internal->buffer_frame->buf[0]);

    if (!pkt)
        pkt = avctx->internal->buffer_pkt;




    avctx->refcounted_frames = 1;



    if (avctx->internal->draining_done)
        return AVERROR_EOF;

    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
        var_205 = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,
                                    &got_frame, pkt);
        if (var_205 >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))
            var_205 = pkt->size;
    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
        var_205 = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,
                                    &got_frame, pkt);
    } else {
        var_205 = AVERROR(EINVAL);
    }

    if (var_205 == AVERROR(EAGAIN))
        var_205 = pkt->size;

    if (var_205 < 0)
        return var_205;

    if (avctx->internal->draining && !got_frame)
        avctx->internal->draining_done = 1;

    if (var_205 >= pkt->size) {
        av_packet_unref(avctx->internal->buffer_pkt);
    } else {
        int var_126 = var_205;

        if (pkt != avctx->internal->buffer_pkt) {
            av_packet_unref(avctx->internal->buffer_pkt);
            if ((var_205 = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)
                return var_205;
        }

        avctx->internal->buffer_pkt->data += var_126;
        avctx->internal->buffer_pkt->size -= var_126;
        avctx->internal->buffer_pkt->pts = var_128;
        avctx->internal->buffer_pkt->dts = var_128;
    }

    if (got_frame)
        av_assert0(avctx->internal->buffer_frame->buf[0]);

    return 0;
}

int attribute_align_arg fn_126(AVCodecContext *avctx, const AVPacket *avpkt)
{
    int var_205;

    if (!avcodec_is_open(avctx) || !av_codec_is_decoder(avctx->codec))
        return AVERROR(EINVAL);

    if (avctx->internal->draining)
        return AVERROR_EOF;

    if (avpkt && !avpkt->size && avpkt->data)
        return AVERROR(EINVAL);

    if (!avpkt || !avpkt->size) {
        avctx->internal->draining = 1;
        avpkt = NULL;

        if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
            return 0;
    }

    if (avctx->codec->send_packet) {
        if (avpkt) {
            AVPacket var_208 = *avpkt;
            int var_127 = av_packet_split_side_data(&var_208);
            var_205 = apply_param_change(avctx, &var_208);
            if (var_205 >= 0)
                var_205 = avctx->codec->send_packet(avctx, &var_208);
            if (var_127)
                av_packet_free_side_data(&var_208);
            return var_205;
        } else {
            return avctx->codec->send_packet(avctx, NULL);
        }
    }




    if (avctx->internal->buffer_pkt->size || avctx->internal->buffer_frame->buf[0])
        return AVERROR(EAGAIN);





    return do_decode(avctx, (AVPacket *)avpkt);
}

int attribute_align_arg fn_127(AVCodecContext *avctx, AVFrame *frame)
{
    int var_205;

    av_frame_unref(frame);

    if (!avcodec_is_open(avctx) || !av_codec_is_decoder(avctx->codec))
        return AVERROR(EINVAL);

    if (avctx->codec->receive_frame) {
        if (avctx->internal->draining && !(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
            return AVERROR_EOF;
        var_205 = avctx->codec->receive_frame(avctx, frame);
        if (var_205 >= 0) {
            if (av_frame_get_best_effort_timestamp(frame) == var_128) {
                av_frame_set_best_effort_timestamp(frame,
                    guess_correct_pts(avctx, frame->pts, frame->pkt_dts));
            }
        }
        return var_205;
    }



    if (!avctx->internal->buffer_frame->buf[0]) {
        if (!avctx->internal->buffer_pkt->size && !avctx->internal->draining)
            return AVERROR(EAGAIN);

        while 1 {
            if ((var_205 = do_decode(avctx, avctx->internal->buffer_pkt)) < 0) {
                av_packet_unref(avctx->internal->buffer_pkt);
                return var_205;
            }




            if (avctx->internal->buffer_frame->buf[0] ||
                !avctx->internal->buffer_pkt->size)
                break;
        }
    }

    if (!avctx->internal->buffer_frame->buf[0])
        return avctx->internal->draining ? AVERROR_EOF : AVERROR(EAGAIN);

    av_frame_move_ref(frame, avctx->internal->buffer_frame);
    return 0;
}

static int fn_128(AVCodecContext *avctx, const AVFrame *frame, int *got_packet)
{
    int var_205;
    *got_packet = 0;

    av_packet_unref(avctx->internal->buffer_pkt);
    avctx->internal->buffer_pkt_valid = 0;

    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
        var_205 = avcodec_encode_video2(avctx, avctx->internal->buffer_pkt,
                                    frame, got_packet);
    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
        var_205 = avcodec_encode_audio2(avctx, avctx->internal->buffer_pkt,
                                    frame, got_packet);
    } else {
        var_205 = AVERROR(EINVAL);
    }

    if (var_205 >= 0 && *got_packet) {


        av_assert0(!avctx->internal->buffer_pkt->data || avctx->internal->buffer_pkt->buf);
        avctx->internal->buffer_pkt_valid = 1;
        var_205 = 0;
    } else {
        av_packet_unref(avctx->internal->buffer_pkt);
    }

    return var_205;
}

int attribute_align_arg fn_129(AVCodecContext *avctx, const AVFrame *frame)
{
    if (!avcodec_is_open(avctx) || !av_codec_is_encoder(avctx->codec))
        return AVERROR(EINVAL);

    if (avctx->internal->draining)
        return AVERROR_EOF;

    if (!frame) {
        avctx->internal->draining = 1;

        if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
            return 0;
    }

    if (avctx->codec->send_frame)
        return avctx->codec->send_frame(avctx, frame);







    if (avctx->internal->buffer_pkt_valid)
        return AVERROR(EAGAIN);

    return do_encode(avctx, frame, &(int){0});
}

int attribute_align_arg fn_130(AVCodecContext *avctx, AVPacket *avpkt)
{
    av_packet_unref(avpkt);

    if (!avcodec_is_open(avctx) || !av_codec_is_encoder(avctx->codec))
        return AVERROR(EINVAL);

    if (avctx->codec->receive_packet) {
        if (avctx->internal->draining && !(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
            return AVERROR_EOF;
        return avctx->codec->receive_packet(avctx, avpkt);
    }



    if (!avctx->internal->buffer_pkt_valid) {
        int got_packet;
        int var_205;
        if (!avctx->internal->draining)
            return AVERROR(EAGAIN);
        var_205 = do_encode(avctx, NULL, &got_packet);
        if (var_205 < 0)
            return var_205;
        if (var_205 >= 0 && !got_packet)
            return AVERROR_EOF;
    }

    av_packet_move_ref(avpkt, avctx->internal->buffer_pkt);
    avctx->internal->buffer_pkt_valid = 0;
    return 0;
}

av_cold int fn_131(AVCodecContext *avctx)
{
    int i;

    if (!avctx)
        return 0;

    if (avcodec_is_open(avctx)) {
        FramePool *pool = avctx->internal->pool;
        if (CONFIG_FRAME_THREAD_ENCODER &&
            avctx->internal->frame_thread_encoder && avctx->thread_count > 1) {
            ff_frame_thread_encoder_free(avctx);
        }
        if (HAVE_THREADS && avctx->internal->thread_ctx)
            ff_thread_free(avctx);
        if (avctx->codec && avctx->codec->close)
            avctx->codec->close(avctx);
        avctx->internal->byte_buffer_size = 0;
        av_freep(&avctx->internal->byte_buffer);
        av_frame_free(&avctx->internal->to_free);
        av_frame_free(&avctx->internal->buffer_frame);
        av_packet_free(&avctx->internal->buffer_pkt);
        for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)
            av_buffer_pool_uninit(&pool->pools[i]);
        av_freep(&avctx->internal->pool);

        if (avctx->hwaccel && avctx->hwaccel->uninit)
            avctx->hwaccel->uninit(avctx);
        av_freep(&avctx->internal->hwaccel_priv_data);

        av_freep(&avctx->internal);
    }

    for (i = 0; i < avctx->nb_coded_side_data; i++)
        av_freep(&avctx->coded_side_data[i].data);
    av_freep(&avctx->coded_side_data);
    avctx->nb_coded_side_data = 0;

    av_buffer_unref(&avctx->hw_frames_ctx);

    if (avctx->priv_data && avctx->codec && avctx->codec->priv_class)
        av_opt_free(avctx->priv_data);
    av_opt_free(avctx);
    av_freep(&avctx->priv_data);
    if (av_codec_is_encoder(avctx->codec)) {
        av_freep(&avctx->extradata);





    }
    avctx->codec = NULL;
    avctx->active_thread_type = 0;

    return 0;
}

static enum enumtype_160 fn_132(enum enumtype_160 var_169)
{
    switch(var_169){


        default : return var_169;
    }
}

static AVCodec *fn_134(enum enumtype_160 var_169, int var_136)
{
    AVCodec *p, *experimental = NULL;
    p = first_avcodec;
    var_169= remap_deprecated_codec_id(var_169);
    while (p) {
        if ((var_136 ? av_codec_is_encoder(p) : av_codec_is_decoder(p)) &&
            p->id == var_169) {
            if (p->capabilities & AV_CODEC_CAP_EXPERIMENTAL && !experimental) {
                experimental = p;
            } else
                return p;
        }
        p = p->next;
    }
    return experimental;
}

AVCodec *fn_136(enum enumtype_160 var_169)
{
    return find_encdec(var_169, 1);
}

AVCodec *fn_137(const char *name)
{
    AVCodec *p;
    if (!name)
        return NULL;
    p = first_avcodec;
    while (p) {
        if (av_codec_is_encoder(p) && strcmp(name, p->name) == 0)
            return p;
        p = p->next;
    }
    return NULL;
}

AVCodec *fn_138(enum enumtype_160 var_169)
{
    return find_encdec(var_169, 0);
}

AVCodec *fn_139(const char *name)
{
    AVCodec *p;
    if (!name)
        return NULL;
    p = first_avcodec;
    while (p) {
        if (av_codec_is_decoder(p) && strcmp(name, p->name) == 0)
            return p;
        p = p->next;
    }
    return NULL;
}

const char *fn_140(enum enumtype_160 var_169)
{
    const AVCodecDescriptor *cd;
    AVCodec *codec;

    if (var_169 == AV_CODEC_ID_NONE)
        return "none";
    cd = avcodec_descriptor_get(var_169);
    if (cd)
        return cd->name;
    av_log(NULL, AV_LOG_WARNING, "Codec 0x%x is not in the full list.\n", var_169);
    codec = avcodec_find_decoder(var_169);
    if (codec)
        return codec->name;
    codec = avcodec_find_encoder(var_169);
    if (codec)
        return codec->name;
    return "unknown_codec";
}

size_t fn_141(char *buf, size_t var_149, unsigned int var_143)
{
    int i, len, var_205 = 0;






    for (i = 0; i < 4; i++) {
        len = snprintf(buf, var_149,
                       (((var_143 & 0xFF) >= '0' && (var_143 & 0xFF) <= '9') || ((var_143 & 0xFF) >= 'a' && (var_143 & 0xFF) <= 'z') || ((var_143 & 0xFF) >= 'A' && (var_143 & 0xFF) <= 'Z') || ((var_143 & 0xFF) == '.' || (var_143 & 0xFF) == ' ' || (var_143 & 0xFF) == '-' || (var_143 & 0xFF) == '_')) ? "%c" : "[%d]", var_143 & 0xFF);
        buf += len;
        var_149 = var_149 > len ? var_149 - len : 0;
        var_205 += len;
        var_143 >>= 8;
    }
    return var_205;
}

void fn_143(char *buf, int var_149, AVCodecContext *enc, int var_149)
{
    const char *codec_type;
    const char *codec_name;
    const char *var_151 = NULL;
    int64_t var_169;
    int var_148 = 0;
    AVRational display_aspect_ratio;
    const char *separator = enc->dump_separator ? (const char *)enc->dump_separator : ", ";

    if (!buf || var_149 <= 0)
        return;
    codec_type = av_get_media_type_string(enc->codec_type);
    codec_name = avcodec_get_name(enc->codec_id);
    var_151 = avcodec_profile_name(enc->codec_id, enc->profile);

    snprintf(buf, var_149, "%s: %s", codec_type ? codec_type : "unknown",
             codec_name);
    buf[0] ^= 'a' ^ 'A';

    if (enc->codec && strcmp(enc->codec->name, codec_name))
        snprintf(buf + strlen(buf), var_149 - strlen(buf), " (%s)", enc->codec->name);

    if (var_151)
        snprintf(buf + strlen(buf), var_149 - strlen(buf), " (%s)", var_151);
    if ( enc->codec_type == AVMEDIA_TYPE_VIDEO
        && av_log_get_level() >= AV_LOG_VERBOSE
        && enc->refs)
        snprintf(buf + strlen(buf), var_149 - strlen(buf),
                 ", %d reference frame%s",
                 enc->refs, enc->refs > 1 ? "s" : "");

    if (enc->codec_tag) {
        char tag_buf[32];
        av_get_codec_tag_string(tag_buf, sizeof(tag_buf), enc->codec_tag);
        snprintf(buf + strlen(buf), var_149 - strlen(buf),
                 " (%s / 0x%04X)", tag_buf, enc->codec_tag);
    }

    switch (enc->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        {
            char detail[256] = "(";

            av_strlcat(buf, separator, var_149);

            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                 "%s", enc->pix_fmt == AV_PIX_FMT_NONE ? "none" :
                     av_get_pix_fmt_name(enc->pix_fmt));
            if (enc->bits_per_raw_sample && enc->pix_fmt != AV_PIX_FMT_NONE &&
                enc->bits_per_raw_sample < av_pix_fmt_desc_get(enc->pix_fmt)->comp[0].depth)
                av_strlcatf(detail, sizeof(detail), "%d bpc, ", enc->bits_per_raw_sample);
            if (enc->color_range != AVCOL_RANGE_UNSPECIFIED)
                av_strlcatf(detail, sizeof(detail), "%s, ",
                            av_color_range_name(enc->color_range));

            if (enc->colorspace != AVCOL_SPC_UNSPECIFIED ||
                enc->color_primaries != AVCOL_PRI_UNSPECIFIED ||
                enc->color_trc != AVCOL_TRC_UNSPECIFIED) {
                if (enc->colorspace != (int)enc->color_primaries ||
                    enc->colorspace != (int)enc->color_trc) {
                    var_148 = 1;
                    av_strlcatf(detail, sizeof(detail), "%s/%s/%s, ",
                                av_color_space_name(enc->colorspace),
                                av_color_primaries_name(enc->color_primaries),
                                av_color_transfer_name(enc->color_trc));
                } else
                    av_strlcatf(detail, sizeof(detail), "%s, ",
                                av_get_colorspace_name(enc->colorspace));
            }

            if (enc->field_order != AV_FIELD_UNKNOWN) {
                const char *field_order = "progressive";
                if (enc->field_order == AV_FIELD_TT)
                    field_order = "top first";
                else if (enc->field_order == AV_FIELD_BB)
                    field_order = "bottom first";
                else if (enc->field_order == AV_FIELD_TB)
                    field_order = "top coded first (swapped)";
                else if (enc->field_order == AV_FIELD_BT)
                    field_order = "bottom coded first (swapped)";

                av_strlcatf(detail, sizeof(detail), "%s, ", field_order);
            }

            if (av_log_get_level() >= AV_LOG_VERBOSE &&
                enc->chroma_sample_location != AVCHROMA_LOC_UNSPECIFIED)
                av_strlcatf(detail, sizeof(detail), "%s, ",
                            av_chroma_location_name(enc->chroma_sample_location));

            if (strlen(detail) > 1) {
                detail[strlen(detail) - 2] = 0;
                av_strlcatf(buf, var_149, "%s)", detail);
            }
        }

        if (enc->width) {
            av_strlcat(buf, var_148 ? separator : ", ", var_149);

            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                     "%dx%d",
                     enc->width, enc->height);

            if (av_log_get_level() >= AV_LOG_VERBOSE &&
                (enc->width != enc->coded_width ||
                 enc->height != enc->coded_height))
                snprintf(buf + strlen(buf), var_149 - strlen(buf),
                         " (%dx%d)", enc->coded_width, enc->coded_height);

            if (enc->sample_aspect_ratio.num) {
                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,
                          enc->width * (int64_t)enc->sample_aspect_ratio.num,
                          enc->height * (int64_t)enc->sample_aspect_ratio.den,
                          1048576);
                snprintf(buf + strlen(buf), var_149 - strlen(buf),
                         " [SAR %d:%d DAR %d:%d]",
                         enc->sample_aspect_ratio.num, enc->sample_aspect_ratio.den,
                         display_aspect_ratio.num, display_aspect_ratio.den);
            }
            if (av_log_get_level() >= AV_LOG_DEBUG) {
                int var_149 = av_gcd(enc->time_base.num, enc->time_base.den);
                snprintf(buf + strlen(buf), var_149 - strlen(buf),
                         ", %d/%d",
                         enc->time_base.num / var_149, enc->time_base.den / var_149);
            }
        }
        if (var_149) {
            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                     ", q=%d-%d", enc->qmin, enc->qmax);
        } else {
            if (enc->properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS)
                snprintf(buf + strlen(buf), var_149 - strlen(buf),
                         ", Closed Captions");
            if (enc->properties & FF_CODEC_PROPERTY_LOSSLESS)
                snprintf(buf + strlen(buf), var_149 - strlen(buf),
                         ", lossless");
        }
        break;
    case AVMEDIA_TYPE_AUDIO:
        av_strlcat(buf, separator, var_149);

        if (enc->sample_rate) {
            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                     "%d Hz, ", enc->sample_rate);
        }
        av_get_channel_layout_string(buf + strlen(buf), var_149 - strlen(buf), enc->channels, enc->channel_layout);
        if (enc->sample_fmt != AV_SAMPLE_FMT_NONE) {
            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                     ", %s", av_get_sample_fmt_name(enc->sample_fmt));
        }
        if ( enc->bits_per_raw_sample > 0
            && enc->bits_per_raw_sample != av_get_bytes_per_sample(enc->sample_fmt) * 8)
            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                     " (%d bit)", enc->bits_per_raw_sample);
        if (av_log_get_level() >= AV_LOG_VERBOSE) {
            if (enc->initial_padding)
                snprintf(buf + strlen(buf), var_149 - strlen(buf),
                         ", delay %d", enc->initial_padding);
            if (enc->trailing_padding)
                snprintf(buf + strlen(buf), var_149 - strlen(buf),
                         ", padding %d", enc->trailing_padding);
        }
        break;
    case AVMEDIA_TYPE_DATA:
        if (av_log_get_level() >= AV_LOG_DEBUG) {
            int var_149 = av_gcd(enc->time_base.num, enc->time_base.den);
            if (var_149)
                snprintf(buf + strlen(buf), var_149 - strlen(buf),
                         ", %d/%d",
                         enc->time_base.num / var_149, enc->time_base.den / var_149);
        }
        break;
    case AVMEDIA_TYPE_SUBTITLE:
        if (enc->width)
            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                     ", %dx%d", enc->width, enc->height);
        break;
    default:
        return;
    }
    if (var_149) {
        if (enc->flags & AV_CODEC_FLAG_PASS1)
            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                     ", pass 1");
        if (enc->flags & AV_CODEC_FLAG_PASS2)
            snprintf(buf + strlen(buf), var_149 - strlen(buf),
                     ", pass 2");
    }
    var_169 = get_bit_rate(enc);
    if (var_169 != 0) {
        snprintf(buf + strlen(buf), var_149 - strlen(buf),
                 ", %"PRId64" kb/s", var_169 / 1000);
    } else if (enc->rc_max_rate > 0) {
        snprintf(buf + strlen(buf), var_149 - strlen(buf),
                 ", max. %"PRId64" kb/s", (int64_t)enc->rc_max_rate / 1000);
    }
}

const char *fn_149(const AVCodec *codec, int var_151)
{
    const AVProfile *p;
    if (var_151 == FF_PROFILE_UNKNOWN || !codec->profiles)
        return NULL;

    for (p = codec->profiles; p->profile != FF_PROFILE_UNKNOWN; p++)
        if (p->profile == var_151)
            return p->name;

    return NULL;
}

const char *fn_150(enum enumtype_160 var_159, int var_151)
{
    const AVCodecDescriptor *desc = avcodec_descriptor_get(var_159);
    const AVProfile *p;

    if (var_151 == FF_PROFILE_UNKNOWN || !desc || !desc->profiles)
        return NULL;

    for (p = desc->profiles; p->profile != FF_PROFILE_UNKNOWN; p++)
        if (p->profile == var_151)
            return p->name;

    return NULL;
}

unsigned fn_151(void)
{

    av_assert0(AV_CODEC_ID_PCM_S8_PLANAR==65563);
    av_assert0(AV_CODEC_ID_ADPCM_G722==69660);

    av_assert0(AV_CODEC_ID_SRT==94216);
    av_assert0(LIBAVCODEC_VERSION_MICRO >= 100);

    return LIBAVCODEC_VERSION_INT;
}

const char *fn_152(void)
{
    return FFMPEG_CONFIGURATION;
}

const char *fn_153(void)
{

    return "libavcodec license: " FFMPEG_LICENSE + sizeof("libavcodec license: ") - 1;
}

void fn_154(AVCodecContext *avctx)
{
    avctx->internal->draining = 0;
    avctx->internal->draining_done = 0;
    av_frame_unref(avctx->internal->buffer_frame);
    av_packet_unref(avctx->internal->buffer_pkt);
    avctx->internal->buffer_pkt_valid = 0;

    if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
        ff_thread_flush(avctx);
    else if (avctx->codec->flush)
        avctx->codec->flush(avctx);

    avctx->pts_correction_last_pts =
    avctx->pts_correction_last_dts = INT64_MIN;

    if (!avctx->refcounted_frames)
        av_frame_unref(avctx->internal->to_free);
}

int fn_155(enum enumtype_160 var_159)
{
    switch (var_159) {
    case AV_CODEC_ID_8SVX_EXP:
    case AV_CODEC_ID_8SVX_FIB:
    case AV_CODEC_ID_ADPCM_CT:
    case AV_CODEC_ID_ADPCM_IMA_APC:
    case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:
    case AV_CODEC_ID_ADPCM_IMA_OKI:
    case AV_CODEC_ID_ADPCM_IMA_WS:
    case AV_CODEC_ID_ADPCM_G722:
    case AV_CODEC_ID_ADPCM_YAMAHA:
    case AV_CODEC_ID_ADPCM_AICA:
        return 4;
    case AV_CODEC_ID_DSD_LSBF:
    case AV_CODEC_ID_DSD_MSBF:
    case AV_CODEC_ID_DSD_LSBF_PLANAR:
    case AV_CODEC_ID_DSD_MSBF_PLANAR:
    case AV_CODEC_ID_PCM_ALAW:
    case AV_CODEC_ID_PCM_MULAW:
    case AV_CODEC_ID_PCM_S8:
    case AV_CODEC_ID_PCM_S8_PLANAR:
    case AV_CODEC_ID_PCM_U8:
    case AV_CODEC_ID_PCM_ZORK:
    case AV_CODEC_ID_SDX2_DPCM:
        return 8;
    case AV_CODEC_ID_PCM_S16BE:
    case AV_CODEC_ID_PCM_S16BE_PLANAR:
    case AV_CODEC_ID_PCM_S16LE:
    case AV_CODEC_ID_PCM_S16LE_PLANAR:
    case AV_CODEC_ID_PCM_U16BE:
    case AV_CODEC_ID_PCM_U16LE:
        return 16;
    case AV_CODEC_ID_PCM_S24DAUD:
    case AV_CODEC_ID_PCM_S24BE:
    case AV_CODEC_ID_PCM_S24LE:
    case AV_CODEC_ID_PCM_S24LE_PLANAR:
    case AV_CODEC_ID_PCM_U24BE:
    case AV_CODEC_ID_PCM_U24LE:
        return 24;
    case AV_CODEC_ID_PCM_S32BE:
    case AV_CODEC_ID_PCM_S32LE:
    case AV_CODEC_ID_PCM_S32LE_PLANAR:
    case AV_CODEC_ID_PCM_U32BE:
    case AV_CODEC_ID_PCM_U32LE:
    case AV_CODEC_ID_PCM_F32BE:
    case AV_CODEC_ID_PCM_F32LE:
    case AV_CODEC_ID_PCM_F24LE:
    case AV_CODEC_ID_PCM_F16LE:
        return 32;
    case AV_CODEC_ID_PCM_F64BE:
    case AV_CODEC_ID_PCM_F64LE:
    case AV_CODEC_ID_PCM_S64BE:
    case AV_CODEC_ID_PCM_S64LE:
        return 64;
    default:
        return 0;
    }
}

enum enumtype_160 fn_156(enum enumtype_157 var_188, int var_158)
{
    static const enum enumtype_160 map[AV_SAMPLE_FMT_NB][2] = {
        [AV_SAMPLE_FMT_U8 ] = { AV_CODEC_ID_PCM_U8, AV_CODEC_ID_PCM_U8 },
        [AV_SAMPLE_FMT_S16 ] = { AV_CODEC_ID_PCM_S16LE, AV_CODEC_ID_PCM_S16BE },
        [AV_SAMPLE_FMT_S32 ] = { AV_CODEC_ID_PCM_S32LE, AV_CODEC_ID_PCM_S32BE },
        [AV_SAMPLE_FMT_FLT ] = { AV_CODEC_ID_PCM_F32LE, AV_CODEC_ID_PCM_F32BE },
        [AV_SAMPLE_FMT_DBL ] = { AV_CODEC_ID_PCM_F64LE, AV_CODEC_ID_PCM_F64BE },
        [AV_SAMPLE_FMT_U8P ] = { AV_CODEC_ID_PCM_U8, AV_CODEC_ID_PCM_U8 },
        [AV_SAMPLE_FMT_S16P] = { AV_CODEC_ID_PCM_S16LE, AV_CODEC_ID_PCM_S16BE },
        [AV_SAMPLE_FMT_S32P] = { AV_CODEC_ID_PCM_S32LE, AV_CODEC_ID_PCM_S32BE },
        [AV_SAMPLE_FMT_S64P] = { AV_CODEC_ID_PCM_S64LE, AV_CODEC_ID_PCM_S64BE },
        [AV_SAMPLE_FMT_FLTP] = { AV_CODEC_ID_PCM_F32LE, AV_CODEC_ID_PCM_F32BE },
        [AV_SAMPLE_FMT_DBLP] = { AV_CODEC_ID_PCM_F64LE, AV_CODEC_ID_PCM_F64BE },
    };
    if (var_188 < 0 || var_188 >= AV_SAMPLE_FMT_NB)
        return AV_CODEC_ID_NONE;
    if (var_158 < 0 || var_158 > 1)
        var_158 = AV_NE(1, 0);
    return map[var_188][var_158];
}

int fn_158(enum enumtype_160 var_159)
{
    switch (var_159) {
    case AV_CODEC_ID_ADPCM_SBPRO_2:
        return 2;
    case AV_CODEC_ID_ADPCM_SBPRO_3:
        return 3;
    case AV_CODEC_ID_ADPCM_SBPRO_4:
    case AV_CODEC_ID_ADPCM_IMA_WAV:
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_ADPCM_SWF:
    case AV_CODEC_ID_ADPCM_MS:
        return 4;
    default:
        return av_get_exact_bits_per_sample(var_159);
    }
}

static int fn_159(enum enumtype_160 var_169, int var_169, int var_169, int var_169,
                                    uint32_t var_168, int var_168, int64_t var_169,
                                    uint8_t * extradata, int var_169, int var_171)
{
    int var_169 = av_get_exact_bits_per_sample(var_169);
    int var_168 = (var_169 > 0 && var_171 / var_169 > 0) ? var_171 / var_169 : 1;


    if (var_169 > 0 && var_169 > 0 && var_171 > 0 && var_169 < 32768 && var_169 < 32768)
        return (var_171 * 8LL) / (var_169 * var_169);
    var_169 = var_168;


    switch (var_169) {
    case AV_CODEC_ID_ADPCM_ADX: return 32;
    case AV_CODEC_ID_ADPCM_IMA_QT: return 64;
    case AV_CODEC_ID_ADPCM_EA_XAS: return 128;
    case AV_CODEC_ID_AMR_NB:
    case AV_CODEC_ID_EVRC:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QCELP:
    case AV_CODEC_ID_RA_288: return 160;
    case AV_CODEC_ID_AMR_WB:
    case AV_CODEC_ID_GSM_MS: return 320;
    case AV_CODEC_ID_MP1: return 384;
    case AV_CODEC_ID_ATRAC1: return 512;
    case AV_CODEC_ID_ATRAC3: return 1024 * var_168;
    case AV_CODEC_ID_ATRAC3P: return 2048;
    case AV_CODEC_ID_MP2:
    case AV_CODEC_ID_MUSEPACK7: return 1152;
    case AV_CODEC_ID_AC3: return 1536;
    }

    if (var_169 > 0) {

        if (var_169 == AV_CODEC_ID_TTA)
            return 256 * var_169 / 245;
        else if (var_169 == AV_CODEC_ID_DST)
            return 588 * var_169 / 44100;

        if (var_169 > 0) {

            if (var_169 == AV_CODEC_ID_BINKAUDIO_DCT)
                return (480 << (var_169 / 22050)) / var_169;
        }
    }

    if (var_169 > 0) {

        if (var_169 == AV_CODEC_ID_SIPR) {
            switch (var_169) {
            case 20: return 160;
            case 19: return 144;
            case 29: return 288;
            case 37: return 480;
            }
        } else if (var_169 == AV_CODEC_ID_ILBC) {
            switch (var_169) {
            case 38: return 160;
            case 50: return 240;
            }
        }
    }

    if (var_171 > 0) {

        if (var_169 == AV_CODEC_ID_TRUESPEECH)
            return 240 * (var_171 / 32);
        if (var_169 == AV_CODEC_ID_NELLYMOSER)
            return 256 * (var_171 / 64);
        if (var_169 == AV_CODEC_ID_RA_144)
            return 160 * (var_171 / 20);
        if (var_169 == AV_CODEC_ID_G723_1)
            return 240 * (var_171 / 24);

        if (var_169 > 0) {

            if (var_169 == AV_CODEC_ID_ADPCM_G726)
                return var_171 * 8 / var_169;
        }

        if (var_169 > 0 && var_169 < INT_MAX/16) {

            switch (var_169) {
            case AV_CODEC_ID_ADPCM_AFC:
                return var_171 / (9 * var_169) * 16;
            case AV_CODEC_ID_ADPCM_PSX:
            case AV_CODEC_ID_ADPCM_DTK:
                return var_171 / (16 * var_169) * 28;
            case AV_CODEC_ID_ADPCM_4XM:
            case AV_CODEC_ID_ADPCM_IMA_DAT4:
            case AV_CODEC_ID_ADPCM_IMA_ISS:
                return (var_171 - 4 * var_169) * 2 / var_169;
            case AV_CODEC_ID_ADPCM_IMA_SMJPEG:
                return (var_171 - 4) * 2 / var_169;
            case AV_CODEC_ID_ADPCM_IMA_AMV:
                return (var_171 - 8) * 2 / var_169;
            case AV_CODEC_ID_ADPCM_THP:
            case AV_CODEC_ID_ADPCM_THP_LE:
                if (extradata)
                    return var_171 * 14 / (8 * var_169);
                break;
            case AV_CODEC_ID_ADPCM_XA:
                return (var_171 / 128) * 224 / var_169;
            case AV_CODEC_ID_INTERPLAY_DPCM:
                return (var_171 - 6 - var_169) / var_169;
            case AV_CODEC_ID_ROQ_DPCM:
                return (var_171 - 8) / var_169;
            case AV_CODEC_ID_XAN_DPCM:
                return (var_171 - 2 * var_169) / var_169;
            case AV_CODEC_ID_MACE3:
                return 3 * var_171 / var_169;
            case AV_CODEC_ID_MACE6:
                return 6 * var_171 / var_169;
            case AV_CODEC_ID_PCM_LXF:
                return 2 * (var_171 / (5 * var_169));
            case AV_CODEC_ID_IAC:
            case AV_CODEC_ID_IMC:
                return 4 * var_171 / var_169;
            }

            if (var_168) {

                if (var_169 == AV_CODEC_ID_SOL_DPCM) {
                    if (var_168 == 3)
                        return var_171 / var_169;
                    else
                        return var_171 * 2 / var_169;
                }
            }

            if (var_169 > 0) {

                int var_169 = var_171 / var_169;
                switch (var_169) {
                case AV_CODEC_ID_ADPCM_IMA_WAV:
                    if (var_169 < 2 || var_169 > 5)
                        return 0;
                    return var_169 * (1 + (var_169 - 4 * var_169) / (var_169 * var_169) * 8);
                case AV_CODEC_ID_ADPCM_IMA_DK3:
                    return var_169 * (((var_169 - 16) * 2 / 3 * 4) / var_169);
                case AV_CODEC_ID_ADPCM_IMA_DK4:
                    return var_169 * (1 + (var_169 - 4 * var_169) * 2 / var_169);
                case AV_CODEC_ID_ADPCM_IMA_RAD:
                    return var_169 * ((var_169 - 4 * var_169) * 2 / var_169);
                case AV_CODEC_ID_ADPCM_MS:
                    return var_169 * (2 + (var_169 - 7 * var_169) * 2 / var_169);
                case AV_CODEC_ID_ADPCM_MTAF:
                    return var_169 * (var_169 - 16) * 2 / var_169;
                }
            }

            if (var_169 > 0) {

                switch (var_169) {
                case AV_CODEC_ID_PCM_DVD:
                    if(var_169<4)
                        return 0;
                    return 2 * (var_171 / ((var_169 * 2 / 8) * var_169));
                case AV_CODEC_ID_PCM_BLURAY:
                    if(var_169<4)
                        return 0;
                    return var_171 / ((FFALIGN(var_169, 2) * var_169) / 8);
                case AV_CODEC_ID_S302M:
                    return 2 * (var_171 / ((var_169 + 4) / 4)) / var_169;
                }
            }
        }
    }


    if (var_169 > 1 && var_171)
        return var_169;



    if (var_169 > 0 && var_171 > 0 && var_169 > 0 && var_169 > 1) {
        if (var_169 == AV_CODEC_ID_WMAV1 || var_169 == AV_CODEC_ID_WMAV2)
            return (var_171 * 8LL * var_169) / var_169;
    }

    return 0;
}

int fn_169(AVCodecContext *avctx, int var_171)
{
    return get_audio_frame_duration(avctx->codec_id, avctx->sample_rate,
                                    avctx->channels, avctx->block_align,
                                    avctx->codec_tag, avctx->bits_per_coded_sample,
                                    avctx->bit_rate, avctx->extradata, avctx->frame_size,
                                    var_171);
}

int fn_170(AVCodecParameters *par, int var_171)
{
    return get_audio_frame_duration(par->codec_id, par->sample_rate,
                                    par->channels, par->block_align,
                                    par->codec_tag, par->bits_per_coded_sample,
                                    par->bit_rate, par->extradata, par->frame_size,
                                    var_171);
}


int fn_171(AVCodecContext *s)
{
    return -1;
}



unsigned int fn_172(unsigned char *s, unsigned int var_174)
{
    unsigned int var_202 = 0;

    while (var_174 >= 0xff) {
        *s++ = 0xff;
        var_174 -= 0xff;
        var_202++;
    }
    *s = var_174;
    var_202++;
    return var_202;
}

int fn_174(const uint16_t(*tab)[2], int var_208, int var_177, int var_177)
{
    int i;
    for (i = 0; i < var_208 && !(tab[i][0] == var_177 && tab[i][1] == var_177); i++) ;
    return i;
}

static AVHWAccel *first_hwaccel = NULL;
static AVHWAccel **var_179 = &first_hwaccel;

void fn_178(AVHWAccel *hwaccel)
{
    AVHWAccel **p = var_179;
    hwaccel->next = NULL;
    while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, hwaccel))
        p = &(*p)->next;
    var_179 = &hwaccel->next;
}

AVHWAccel *fn_179(const AVHWAccel *hwaccel)
{
    return hwaccel ? hwaccel->next : first_hwaccel;
}

int fn_180(int (*cb)(void **mutex, enum enumtype_181 var_181))
{
    if (lockmgr_cb) {


        lockmgr_cb(&codec_mutex, AV_LOCK_DESTROY);
        lockmgr_cb(&avformat_mutex, AV_LOCK_DESTROY);
        lockmgr_cb = NULL;
        codec_mutex = NULL;
        avformat_mutex = NULL;
    }

    if (cb) {
        void *new_codec_mutex = NULL;
        void *new_avformat_mutex = NULL;
        int var_181;
        if (var_181 = cb(&new_codec_mutex, AV_LOCK_CREATE)) {
            return var_181 > 0 ? AVERROR_UNKNOWN : var_181;
        }
        if (var_181 = cb(&new_avformat_mutex, AV_LOCK_CREATE)) {

            cb(&new_codec_mutex, AV_LOCK_DESTROY);
            return var_181 > 0 ? AVERROR_UNKNOWN : var_181;
        }
        lockmgr_cb = cb;
        codec_mutex = new_codec_mutex;
        avformat_mutex = new_avformat_mutex;
    }

    return 0;
}

int fn_181(AVCodecContext *log_ctx, const AVCodec *codec)
{
    if (codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || !codec->init)
        return 0;

    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))
            return -1;
    }

    if (avpriv_atomic_int_add_and_fetch(&var_183, 1) != 1) {
        av_log(log_ctx, AV_LOG_ERROR,
               "Insufficient thread locking. At least %d threads are "
               "calling avcodec_open2() at the same time right now.\n",
               var_183);
        if (!lockmgr_cb)
            av_log(log_ctx, AV_LOG_ERROR, "No lock manager is set, please see av_lockmgr_register()\n");
        ff_avcodec_locked = 1;
        ff_unlock_avcodec(codec);
        return AVERROR(EINVAL);
    }
    av_assert0(!ff_avcodec_locked);
    ff_avcodec_locked = 1;
    return 0;
}

int fn_182(const AVCodec *codec)
{
    if (codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || !codec->init)
        return 0;

    av_assert0(ff_avcodec_locked);
    ff_avcodec_locked = 0;
    avpriv_atomic_int_add_and_fetch(&var_183, -1);
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&codec_mutex, AV_LOCK_RELEASE))
            return -1;
    }

    return 0;
}

int fn_183(void)
{
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))
            return -1;
    }
    return 0;
}

int fn_184(void)
{
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_RELEASE))
            return -1;
    }
    return 0;
}

unsigned int fn_185(unsigned int var_186)
{
    return av_toupper(var_186 & 0xFF) +
          (av_toupper((var_186 >> 8) & 0xFF) << 8) +
          (av_toupper((var_186 >> 16) & 0xFF) << 16) +
((unsigned)av_toupper((var_186 >> 24) & 0xFF) << 24);
}

int fn_186(ThreadFrame *dst, ThreadFrame *src)
{
    int var_205;

    dst->owner = src->owner;

    var_205 = av_frame_ref(dst->f, src->f);
    if (var_205 < 0)
        return var_205;

    av_assert0(!dst->progress);

    if (src->progress &&
        !(dst->progress = av_buffer_ref(src->progress))) {
        ff_thread_release_buffer(dst->owner, dst);
        return AVERROR(ENOMEM);
    }

    return 0;
}



enum enumtype_188 fn_187(AVCodecContext *avctx, const enum enumtype_188 *var_188)
{
    return ff_get_format(avctx, var_188);
}

int fn_188(AVCodecContext *avctx, ThreadFrame *f, int var_189)
{
    f->owner = avctx;
    return ff_get_buffer(avctx, f->f, var_189);
}

void fn_189(AVCodecContext *avctx, ThreadFrame *f)
{
    if (f->f)
        av_frame_unref(f->f);
}

void fn_190(AVCodecContext *avctx)
{
}

void fn_191(ThreadFrame *f, int var_195, int var_202)
{
}

void fn_194(ThreadFrame *f, int var_195, int var_202)
{
}

int fn_195(AVCodecContext *avctx)
{
    return 1;
}

int fn_196(AVCodecContext *avctx, int var_197)
{
    return 0;
}

void fn_197(AVCodecContext *avctx)
{
}

void fn_198(AVCodecContext *avctx, int var_202, int var_202, int var_200)
{
}

void fn_201(AVCodecContext *avctx, int var_202, int var_202, int var_202)
{
}



int fn_202(AVCodecContext *s)
{
    return !!s->internal;
}

int fn_203(AVCodecContext *avctx, struct struct_204 *buf)
{
    int var_205;
    char *str;

    var_205 = av_bprint_finalize(buf, &str);
    if (var_205 < 0)
        return var_205;
    if (!av_bprint_is_complete(buf)) {
        av_free(str);
        return AVERROR(ENOMEM);
    }

    avctx->extradata = str;





    avctx->extradata_size = buf->len;
    return 0;
}

const uint8_t *fn_205(const uint8_t *av_restrict p,
                                      const uint8_t *end,
                                      uint32_t *av_restrict state)
{
    int i;

    av_assert0(p <= end);
    if (p >= end)
        return end;

    for (i = 0; i < 3; i++) {
        uint32_t var_208 = *state << 8;
        *state = var_208 + *(p++);
        if (var_208 == 0x100 || p == end)
            return p;
    }

    while (p < end) {
        if (p[-1] > 1 ) p += 3;
        else if (p[-2] ) p += 2;
        else if (p[-3]|(p[-1]-1)) p++;
        else {
            p++;
            break;
        }
    }

    p = FFMIN(p, end) - 4;
    *state = AV_RB32(p);

    return p + 4;
}

AVCPBProperties *fn_206(size_t *var_208)
{
    AVCPBProperties *props = av_mallocz(sizeof(AVCPBProperties));
    if (!props)
        return NULL;

    if (var_208)
        *var_208 = sizeof(*props);

    props->vbv_delay = UINT64_MAX;

    return props;
}

AVCPBProperties *fn_207(AVCodecContext *avctx)
{
    AVPacketSideData *var_208;
    AVCPBProperties *props;
    size_t var_208;

    props = av_cpb_properties_alloc(&var_208);
    if (!props)
        return NULL;

    var_208 = av_realloc_array(avctx->coded_side_data, avctx->nb_coded_side_data + 1, sizeof(*var_208));
    if (!var_208) {
        av_freep(&props);
        return NULL;
    }

    avctx->coded_side_data = var_208;
    avctx->nb_coded_side_data++;

    avctx->coded_side_data[avctx->nb_coded_side_data - 1].type = AV_PKT_DATA_CPB_PROPERTIES;
    avctx->coded_side_data[avctx->nb_coded_side_data - 1].data = (uint8_t*)props;
    avctx->coded_side_data[avctx->nb_coded_side_data - 1].size = var_208;

    return props;
}

static void fn_208(AVCodecParameters *par)
{
    av_freep(&par->extradata);

    memset(par, 0, sizeof(*par));

    par->codec_type = AVMEDIA_TYPE_UNKNOWN;
    par->codec_id = AV_CODEC_ID_NONE;
    par->format = -1;
    par->field_order = AV_FIELD_UNKNOWN;
    par->color_range = AVCOL_RANGE_UNSPECIFIED;
    par->color_primaries = AVCOL_PRI_UNSPECIFIED;
    par->color_trc = AVCOL_TRC_UNSPECIFIED;
    par->color_space = AVCOL_SPC_UNSPECIFIED;
    par->chroma_location = AVCHROMA_LOC_UNSPECIFIED;
    par->sample_aspect_ratio = (AVRational){ 0, 1 };
    par->profile = FF_PROFILE_UNKNOWN;
    par->level = FF_LEVEL_UNKNOWN;
}

AVCodecParameters *fn_209(void)
{
    AVCodecParameters *par = av_mallocz(sizeof(*par));

    if (!par)
        return NULL;
    codec_parameters_reset(par);
    return par;
}

void fn_210(AVCodecParameters **ppar)
{
    AVCodecParameters *par = *ppar;

    if (!par)
        return;
    codec_parameters_reset(par);

    av_freep(ppar);
}

int fn_211(AVCodecParameters *dst, const AVCodecParameters *src)
{
    codec_parameters_reset(dst);
    memcpy(dst, src, sizeof(*dst));

    dst->extradata = NULL;
    dst->extradata_size = 0;
    if (src->extradata) {
        dst->extradata = av_mallocz(src->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
        if (!dst->extradata)
            return AVERROR(ENOMEM);
        memcpy(dst->extradata, src->extradata, src->extradata_size);
        dst->extradata_size = src->extradata_size;
    }

    return 0;
}

int fn_212(AVCodecParameters *par,
                                    const AVCodecContext *codec)
{
    codec_parameters_reset(par);

    par->codec_type = codec->codec_type;
    par->codec_id = codec->codec_id;
    par->codec_tag = codec->codec_tag;

    par->bit_rate = codec->bit_rate;
    par->bits_per_coded_sample = codec->bits_per_coded_sample;
    par->bits_per_raw_sample = codec->bits_per_raw_sample;
    par->profile = codec->profile;
    par->level = codec->level;

    switch (par->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        par->format = codec->pix_fmt;
        par->width = codec->width;
        par->height = codec->height;
        par->field_order = codec->field_order;
        par->color_range = codec->color_range;
        par->color_primaries = codec->color_primaries;
        par->color_trc = codec->color_trc;
        par->color_space = codec->colorspace;
        par->chroma_location = codec->chroma_sample_location;
        par->sample_aspect_ratio = codec->sample_aspect_ratio;
        par->video_delay = codec->has_b_frames;
        break;
    case AVMEDIA_TYPE_AUDIO:
        par->format = codec->sample_fmt;
        par->channel_layout = codec->channel_layout;
        par->channels = codec->channels;
        par->sample_rate = codec->sample_rate;
        par->block_align = codec->block_align;
        par->frame_size = codec->frame_size;
        par->initial_padding = codec->initial_padding;
        par->trailing_padding = codec->trailing_padding;
        par->seek_preroll = codec->seek_preroll;
        break;
    case AVMEDIA_TYPE_SUBTITLE:
        par->width = codec->width;
        par->height = codec->height;
        break;
    }

    if (codec->extradata) {
        par->extradata = av_mallocz(codec->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
        if (!par->extradata)
            return AVERROR(ENOMEM);
        memcpy(par->extradata, codec->extradata, codec->extradata_size);
        par->extradata_size = codec->extradata_size;
    }

    return 0;
}

int fn_213(AVCodecContext *codec,
                                  const AVCodecParameters *par)
{
    codec->codec_type = par->codec_type;
    codec->codec_id = par->codec_id;
    codec->codec_tag = par->codec_tag;

    codec->bit_rate = par->bit_rate;
    codec->bits_per_coded_sample = par->bits_per_coded_sample;
    codec->bits_per_raw_sample = par->bits_per_raw_sample;
    codec->profile = par->profile;
    codec->level = par->level;

    switch (par->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        codec->pix_fmt = par->format;
        codec->width = par->width;
        codec->height = par->height;
        codec->field_order = par->field_order;
        codec->color_range = par->color_range;
        codec->color_primaries = par->color_primaries;
        codec->color_trc = par->color_trc;
        codec->colorspace = par->color_space;
        codec->chroma_sample_location = par->chroma_location;
        codec->sample_aspect_ratio = par->sample_aspect_ratio;
        codec->has_b_frames = par->video_delay;
        break;
    case AVMEDIA_TYPE_AUDIO:
        codec->sample_fmt = par->format;
        codec->channel_layout = par->channel_layout;
        codec->channels = par->channels;
        codec->sample_rate = par->sample_rate;
        codec->block_align = par->block_align;
        codec->frame_size = par->frame_size;
        codec->delay =
        codec->initial_padding = par->initial_padding;
        codec->trailing_padding = par->trailing_padding;
        codec->seek_preroll = par->seek_preroll;
        break;
    case AVMEDIA_TYPE_SUBTITLE:
        codec->width = par->width;
        codec->height = par->height;
        break;
    }

    if (par->extradata) {
        av_freep(&codec->extradata);
        codec->extradata = av_mallocz(par->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
        if (!codec->extradata)
            return AVERROR(ENOMEM);
        memcpy(codec->extradata, par->extradata, par->extradata_size);
        codec->extradata_size = par->extradata_size;
    }

    return 0;
}

int fn_214(const AVFrame *frame, size_t var_216,
                     void **data, size_t *sei_size)
{
    AVFrameSideData *side_data = NULL;
    uint8_t *sei_data;

    if (frame)
        side_data = av_frame_get_side_data(frame, AV_FRAME_DATA_A53_CC);

    if (!side_data) {
        *data = NULL;
        return 0;
    }

    *sei_size = side_data->size + 11;
    *data = av_mallocz(*sei_size + var_216);
    if (!*data)
        return AVERROR(ENOMEM);
    sei_data = (uint8_t*)*data + var_216;


    sei_data[0] = 181;
    sei_data[1] = 0;
    sei_data[2] = 49;







    AV_WL32(sei_data + 3, MKTAG('G', 'A', '9', '4'));
    sei_data[7] = 3;
    sei_data[8] = ((side_data->size/3) & 0x1f) | 0x40;
    sei_data[9] = 0;

    memcpy(sei_data + 10, side_data->data, side_data->size);

    sei_data[side_data->size+10] = 255;

    return 0;
}
