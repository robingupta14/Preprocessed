







FILE_RCSID("@(#)$File: cdf.c,v 1.115 2019/08/23 14:29:14 christos Exp $")

static union {
 char s[4];
 uint32_t u;
} cdf_bo;

static void *
fn_0(const char *file __attribute__((__unused__)),
    size_t var_31 __attribute__((__unused__)), size_t var_7)
{

                              ;
 return malloc(var_7);
}


static void *
fn_3(const char *file __attribute__((__unused__)),
    size_t var_31 __attribute__((__unused__)), void *var_76, size_t var_7)
{

                              ;
 return realloc(var_76, var_7);
}


static void *
fn_5(const char *file __attribute__((__unused__)),
    size_t var_31 __attribute__((__unused__)), size_t var_7, size_t var_7)
{

                                                      ;
 return calloc(var_7, var_7);
}




static uint16_t
fn_7(uint16_t var_19)
{
 uint16_t rv;
 uint8_t *s = var_38(uint8_t *, fn_67(void *, &sv));
 uint8_t *d = var_38(uint8_t *, fn_67(void *, &rv));
 d[0] = s[1];
 d[1] = s[0];
 return rv;
}




static uint32_t
fn_11(uint32_t var_19)
{
 uint32_t rv;
 uint8_t *s = var_38(uint8_t *, fn_67(void *, &sv));
 uint8_t *d = var_38(uint8_t *, fn_67(void *, &rv));
 d[0] = s[3];
 d[1] = s[2];
 d[2] = s[1];
 d[3] = s[0];
 return rv;
}




static uint64_t
fn_12(uint64_t var_19)
{
 uint64_t rv;
 uint8_t *s = var_38(uint8_t *, fn_67(void *, &sv));
 uint8_t *d = var_38(uint8_t *, fn_67(void *, &rv));
 d[0] = s[7];
 d[1] = s[6];
 d[2] = s[5];
 d[3] = s[4];
 d[4] = s[3];
 d[5] = s[2];
 d[6] = s[1];
 d[7] = s[0];
 return rv;
}





static uint32_t
fn_13(const uint8_t *var_76, size_t var_65)
{
 uint32_t rv;
 (void)memcpy(&rv, var_76 + var_65 * sizeof(uint32_t), sizeof(rv));
 return (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(rv) : var_76(uint32_t, rv)));
}






uint16_t
fn_16(uint16_t var_19)
{
 return (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(var_19) : var_76(uint16_t, var_19)));
}

uint32_t
fn_17(uint32_t var_19)
{
 return (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_19) : var_76(uint32_t, var_19)));
}

uint64_t
fn_18(uint64_t var_19)
{
 return (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(var_19) : var_76(uint64_t, var_19)));
}

void
fn_19(cdf_header_t *h)
{
 size_t var_76;

 h->h_magic = (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(h->h_magic) : var_76(uint64_t, h->h_magic)));
 h->h_uuid[0] = (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(h->h_uuid[0]) : var_76(uint64_t, h->h_uuid[0])));
 h->h_uuid[1] = (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(h->h_uuid[1]) : var_76(uint64_t, h->h_uuid[1])));
 h->h_revision = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(h->h_revision) : var_76(uint16_t, h->h_revision)));
 h->h_version = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(h->h_version) : var_76(uint16_t, h->h_version)));
 h->h_byte_order = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(h->h_byte_order) : var_76(uint16_t, h->h_byte_order)));
 h->h_sec_size_p2 = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(h->h_sec_size_p2) : var_76(uint16_t, h->h_sec_size_p2)));
 h->h_short_sec_size_p2 = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(h->h_short_sec_size_p2) : var_76(uint16_t, h->h_short_sec_size_p2)));
 h->h_num_sectors_in_sat = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(h->h_num_sectors_in_sat) : var_76(uint32_t, h->h_num_sectors_in_sat)));
 h->h_secid_first_directory = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(h->h_secid_first_directory) : var_76(uint32_t, h->h_secid_first_directory)));
 h->h_min_size_standard_stream =
     (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(h->h_min_size_standard_stream) : var_76(uint32_t, h->h_min_size_standard_stream)));
 h->h_secid_first_sector_in_short_sat =
     (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, h->h_secid_first_sector_in_short_sat)) : var_76(uint32_t, var_76(uint32_t, h->h_secid_first_sector_in_short_sat))));
 h->h_num_sectors_in_short_sat =
     (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(h->h_num_sectors_in_short_sat) : var_76(uint32_t, h->h_num_sectors_in_short_sat)));
 h->h_secid_first_sector_in_master_sat =
     (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, h->h_secid_first_sector_in_master_sat)) : var_76(uint32_t, var_76(uint32_t, h->h_secid_first_sector_in_master_sat))));
 h->h_num_sectors_in_master_sat =
     (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(h->h_num_sectors_in_master_sat) : var_76(uint32_t, h->h_num_sectors_in_master_sat)));
 for (var_76 = 0; var_76 < __arraycount(h->h_master_sat); var_76++) {
  h->h_master_sat[var_76] =
      (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, h->h_master_sat[var_76])) : var_76(uint32_t, var_76(uint32_t, h->h_master_sat[var_76]))));
 }
}

void
fn_21(cdf_header_t *h, char *buf)
{
 size_t var_76;
 size_t var_76 = 0;

 (void)memcpy(&(h->h_magic), &buf[var_76], sizeof(h->h_magic)), var_76 += sizeof(h->h_magic);
 (void)memcpy((h->h_uuid), &buf[var_76], sizeof(h->h_uuid)), var_76 += sizeof(h->h_uuid);
 (void)memcpy(&(h->h_revision), &buf[var_76], sizeof(h->h_revision)), var_76 += sizeof(h->h_revision);
 (void)memcpy(&(h->h_version), &buf[var_76], sizeof(h->h_version)), var_76 += sizeof(h->h_version);
 (void)memcpy(&(h->h_byte_order), &buf[var_76], sizeof(h->h_byte_order)), var_76 += sizeof(h->h_byte_order);
 (void)memcpy(&(h->h_sec_size_p2), &buf[var_76], sizeof(h->h_sec_size_p2)), var_76 += sizeof(h->h_sec_size_p2);
 (void)memcpy(&(h->h_short_sec_size_p2), &buf[var_76], sizeof(h->h_short_sec_size_p2)), var_76 += sizeof(h->h_short_sec_size_p2);
 (void)memcpy((h->h_unused0), &buf[var_76], sizeof(h->h_unused0)), var_76 += sizeof(h->h_unused0);
 (void)memcpy(&(h->h_num_sectors_in_sat), &buf[var_76], sizeof(h->h_num_sectors_in_sat)), var_76 += sizeof(h->h_num_sectors_in_sat);
 (void)memcpy(&(h->h_secid_first_directory), &buf[var_76], sizeof(h->h_secid_first_directory)), var_76 += sizeof(h->h_secid_first_directory);
 (void)memcpy((h->h_unused1), &buf[var_76], sizeof(h->h_unused1)), var_76 += sizeof(h->h_unused1);
 (void)memcpy(&(h->h_min_size_standard_stream), &buf[var_76], sizeof(h->h_min_size_standard_stream)), var_76 += sizeof(h->h_min_size_standard_stream);
 (void)memcpy(&(h->h_secid_first_sector_in_short_sat), &buf[var_76], sizeof(h->h_secid_first_sector_in_short_sat)), var_76 += sizeof(h->h_secid_first_sector_in_short_sat);
 (void)memcpy(&(h->h_num_sectors_in_short_sat), &buf[var_76], sizeof(h->h_num_sectors_in_short_sat)), var_76 += sizeof(h->h_num_sectors_in_short_sat);
 (void)memcpy(&(h->h_secid_first_sector_in_master_sat), &buf[var_76], sizeof(h->h_secid_first_sector_in_master_sat)), var_76 += sizeof(h->h_secid_first_sector_in_master_sat);
 (void)memcpy(&(h->h_num_sectors_in_master_sat), &buf[var_76], sizeof(h->h_num_sectors_in_master_sat)), var_76 += sizeof(h->h_num_sectors_in_master_sat);
 for (var_76 = 0; var_76 < __arraycount(h->h_master_sat); var_76++)
  (void)memcpy(&(h->h_master_sat[var_76]), &buf[var_76], sizeof(h->h_master_sat[var_76])), var_76 += sizeof(h->h_master_sat[var_76]);
}

void
fn_23(cdf_directory_t *d)
{
 d->d_namelen = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(d->d_namelen) : var_76(uint16_t, d->d_namelen)));
 d->d_left_child = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, d->d_left_child)) : var_76(uint32_t, var_76(uint32_t, d->d_left_child))));
 d->d_right_child = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, d->d_right_child)) : var_76(uint32_t, var_76(uint32_t, d->d_right_child))));
 d->d_storage = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, d->d_storage)) : var_76(uint32_t, var_76(uint32_t, d->d_storage))));
 d->d_storage_uuid[0] = (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(d->d_storage_uuid[0]) : var_76(uint64_t, d->d_storage_uuid[0])));
 d->d_storage_uuid[1] = (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(d->d_storage_uuid[1]) : var_76(uint64_t, d->d_storage_uuid[1])));
 d->d_flags = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(d->d_flags) : var_76(uint32_t, d->d_flags)));
 d->d_created = (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(var_76(uint64_t, d->d_created)) : var_76(uint64_t, var_76(uint64_t, d->d_created))));
 d->d_modified = (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(var_76(uint64_t, d->d_modified)) : var_76(uint64_t, var_76(uint64_t, d->d_modified))));
 d->d_stream_first_sector = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, d->d_stream_first_sector)) : var_76(uint32_t, var_76(uint32_t, d->d_stream_first_sector))));

 d->d_size = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(d->d_size) : var_76(uint32_t, d->d_size)));
}

void
fn_24(cdf_classid_t *d)
{
 d->cl_dword = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(d->cl_dword) : var_76(uint32_t, d->cl_dword)));
 d->cl_word[0] = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(d->cl_word[0]) : var_76(uint16_t, d->cl_word[0])));
 d->cl_word[1] = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(d->cl_word[1]) : var_76(uint16_t, d->cl_word[1])));
}

void
fn_25(cdf_directory_t *d, char *buf)
{
 size_t var_76 = 0;

 (void)memcpy((d->d_name), &buf[var_76], sizeof(d->d_name)), var_76 += sizeof(d->d_name);
 (void)memcpy(&(d->d_namelen), &buf[var_76], sizeof(d->d_namelen)), var_76 += sizeof(d->d_namelen);
 (void)memcpy(&(d->d_type), &buf[var_76], sizeof(d->d_type)), var_76 += sizeof(d->d_type);
 (void)memcpy(&(d->d_color), &buf[var_76], sizeof(d->d_color)), var_76 += sizeof(d->d_color);
 (void)memcpy(&(d->d_left_child), &buf[var_76], sizeof(d->d_left_child)), var_76 += sizeof(d->d_left_child);
 (void)memcpy(&(d->d_right_child), &buf[var_76], sizeof(d->d_right_child)), var_76 += sizeof(d->d_right_child);
 (void)memcpy(&(d->d_storage), &buf[var_76], sizeof(d->d_storage)), var_76 += sizeof(d->d_storage);
 (void)memcpy((d->d_storage_uuid), &buf[var_76], sizeof(d->d_storage_uuid)), var_76 += sizeof(d->d_storage_uuid);
 (void)memcpy(&(d->d_flags), &buf[var_76], sizeof(d->d_flags)), var_76 += sizeof(d->d_flags);
 (void)memcpy(&(d->d_created), &buf[var_76], sizeof(d->d_created)), var_76 += sizeof(d->d_created);
 (void)memcpy(&(d->d_modified), &buf[var_76], sizeof(d->d_modified)), var_76 += sizeof(d->d_modified);
 (void)memcpy(&(d->d_stream_first_sector), &buf[var_76], sizeof(d->d_stream_first_sector)), var_76 += sizeof(d->d_stream_first_sector);
 (void)memcpy(&(d->d_size), &buf[var_76], sizeof(d->d_size)), var_76 += sizeof(d->d_size);
 (void)memcpy(&(d->d_unused0), &buf[var_76], sizeof(d->d_unused0)), var_76 += sizeof(d->d_unused0);
}

int
fn_26(cdf_stream_t *scn)
{
 scn->sst_len = 0;
 scn->sst_dirlen = 0;
 scn->sst_ss = 0;
 free(scn->sst_tab);
 scn->sst_tab = NULL;
 return -1;
}

static size_t
fn_27(const cdf_stream_t *sst, const cdf_header_t *h)
{
 size_t var_69 = sst->sst_dirlen < h->h_min_size_standard_stream ?
     CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);
 assert(var_69 == sst->sst_ss);
 return sst->sst_ss;
}

static int
fn_29(const cdf_stream_t *sst, const cdf_header_t *h,
    const void *var_76, size_t var_60, int var_31)
{
 const char *b = var_38(const char *, sst->sst_tab);
 const char *e = var_38(const char *, var_76) + var_60;
 size_t var_69 = cdf_check_stream(sst, h);
           (void)&var_31;
 if (e >= b && var_76(size_t, e - b) <= var_69 * sst->sst_len)
  return 0;



                                          ;
 errno = EINVAL;
 return -1;
}

static ssize_t
fn_31(const cdf_info_t *info, off_t var_34, void *buf, size_t var_76)
{
 size_t var_34 = var_76(size_t, var_34 + var_76);

 if (var_76(off_t, var_34 + var_76) != var_76(off_t, var_34))
  goto out;

 if (info->i_buf != NULL && info->i_len >= var_34) {
  (void)memcpy(buf, &info->i_buf[var_34], var_76);
  return var_76(ssize_t, var_76);
 }

 if (info->i_fd == -1)
  goto out;

 if (pread(info->i_fd, buf, var_76, var_34) != var_76(ssize_t, var_76))
  return -1;

 return var_76(ssize_t, var_76);
out:
 errno = EINVAL;
 return -1;
}

int
fn_34(const cdf_info_t *info, cdf_header_t *h)
{
 char buf[512];

 (void)memcpy(cdf_bo.s, "\01\02\03\04", 4);
 if (cdf_read(info, var_76(off_t, 0), buf, sizeof(buf)) == -1)
  return -1;
 cdf_unpack_header(h, buf);
 cdf_swap_header(h);
 if (h->h_magic != CDF_MAGIC) {



                                     ;
  goto out;
 }
 if (h->h_sec_size_p2 > 20) {
                                                      ;
  goto out;
 }
 if (h->h_short_sec_size_p2 > 20) {

                              ;
  goto out;
 }
 return 0;
out:
 errno = EINVAL;
 return -1;
}


ssize_t
fn_35(const cdf_info_t *info, void *buf, size_t var_65, size_t var_76,
    const cdf_header_t *h, cdf_secid_t var_71)
{
 size_t var_69 = CDF_SEC_SIZE(h);
 size_t pos;

 if (var_76(size_t, ~0ULL) / var_69 < var_76(size_t, var_71))
  return -1;

 pos = CDF_SEC_POS(h, var_71);
 assert(var_69 == var_76);
 return cdf_read(info, var_76(off_t, pos), var_38(char *, buf) + var_65, var_76);
}

ssize_t
fn_37(const cdf_stream_t *sst, void *buf, size_t var_65,
    size_t var_76, const cdf_header_t *h, cdf_secid_t var_71)
{
 size_t var_69 = CDF_SHORT_SEC_SIZE(h);
 size_t pos;

 if (var_76(size_t, ~0ULL) / var_69 < var_76(size_t, var_71))
  return -1;

 pos = CDF_SHORT_SEC_POS(h, var_71);
 assert(var_69 == var_76);
 if (pos + var_76 > CDF_SEC_SIZE(h) * sst->sst_len) {


                                                 ;
  goto out;
 }
 (void)memcpy(var_38(char *, buf) + var_65,
     var_38(const char *, sst->sst_tab) + pos, var_76);
 return var_76;
out:
 errno = EINVAL;
 return -1;
}




int
fn_38(const cdf_info_t *info, cdf_header_t *h, cdf_sat_t *sat)
{
 size_t var_76, j, k;
 size_t var_69 = CDF_SEC_SIZE(h);
 cdf_secid_t *msa, mid, sec;
 size_t var_40 = (var_69 / sizeof(mid)) - 1;

 for (var_76 = 0; var_76 < __arraycount(h->h_master_sat); var_76++)
  if (h->h_master_sat[var_76] == CDF_SECID_FREE)
   break;


 if ((var_40 > 0 &&
     h->h_num_sectors_in_master_sat > (UINT32_MAX / (64 * var_69)) / var_40) ||
     var_76 > (UINT32_MAX / (64 * var_69))) {

                                                              ;
  errno = EINVAL;
  return -1;
 }

 sat->sat_len = h->h_num_sectors_in_master_sat * var_40 + var_76;

                       ;
 if ((sat->sat_tab = var_76(cdf_secid_t *, cdf_calloc("/tmp/tmp6t83cgcw.c", 473, (sat->sat_len), (var_69))))
     == NULL)
  return -1;

 for (var_76 = 0; var_76 < __arraycount(h->h_master_sat); var_76++) {
  if (h->h_master_sat[var_76] < 0)
   break;
  if (cdf_read_sector(info, sat->sat_tab, var_69 * var_76, var_69, h,
      h->h_master_sat[var_76]) != var_76(ssize_t, var_69)) {
                                                     ;
   goto out1;
  }
 }

 if ((msa = var_76(cdf_secid_t *, cdf_calloc("/tmp/tmp6t83cgcw.c", 487, 1, (var_69)))) == NULL)
  goto out1;

 mid = h->h_secid_first_sector_in_master_sat;
 for (j = 0; j < h->h_num_sectors_in_master_sat; j++) {
  if (mid < 0)
   goto out;
  if (j >= CDF_LOOP_LIMIT) {
                                                ;
   goto out3;
  }
  if (cdf_read_sector(info, msa, 0, var_69, h, mid) !=
      var_76(ssize_t, var_69)) {
                                             ;
   goto out2;
  }
  for (k = 0; k < var_40; k++, var_76++) {
   sec = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, msa[k])) : var_76(uint32_t, var_76(uint32_t, msa[k]))));
   if (sec < 0)
    goto out;
   if (var_76 >= sat->sat_len) {


                     ;
       goto out3;
   }
   if (cdf_read_sector(info, sat->sat_tab, var_69 * var_76, var_69, h,
       sec) != var_76(ssize_t, var_69)) {

                           ;
    goto out2;
   }
  }
  mid = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, msa[var_40])) : var_76(uint32_t, var_76(uint32_t, msa[var_40]))));
 }
out:
 sat->sat_len = var_76;
 free(msa);
 return 0;
out3:
 errno = EINVAL;
out2:
 free(msa);
out1:
 free(sat->sat_tab);
 return -1;
}

size_t
fn_40(const cdf_sat_t *sat, cdf_secid_t var_49, size_t var_44)
{
 size_t var_76, j;
 cdf_secid_t var_44 = var_76(cdf_secid_t, (sat->sat_len * var_44)
     / sizeof(var_44));

                    ;
 if (var_49 == CDF_SECID_END_OF_CHAIN) {

                       ;
  return 0;
 }

 for (j = var_76 = 0; var_49 >= 0; var_76++, j++) {
                       ;
  if (j >= CDF_LOOP_LIMIT) {
                                         ;
   goto out;
  }
  if (var_49 >= var_44) {
                                                 ;
   goto out;
  }
  var_49 = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, sat->sat_tab[var_49])) : var_76(uint32_t, var_76(uint32_t, sat->sat_tab[var_49]))));
 }
 if (var_76 == 0) {
                                    ;
  goto out;

 }
                ;
 return var_76;
out:
 errno = EINVAL;
 return var_76(size_t, -1);
}

int
fn_44(const cdf_info_t *info, const cdf_header_t *h,
    const cdf_sat_t *sat, cdf_secid_t var_49, size_t var_76, cdf_stream_t *scn)
{
 size_t var_69 = CDF_SEC_SIZE(h), var_76, j;
 ssize_t nr;
 scn->sst_tab = NULL;
 scn->sst_len = cdf_count_chain(sat, var_49, var_69);
 scn->sst_dirlen = MAX(h->h_min_size_standard_stream, var_76);
 scn->sst_ss = var_69;

 if (var_49 == CDF_SECID_END_OF_CHAIN || var_76 == 0)
  return cdf_zero_stream(scn);

 if (scn->sst_len == var_76(size_t, -1))
  goto out;

 scn->sst_tab = cdf_calloc("/tmp/tmp6t83cgcw.c", 590, (scn->sst_len), (var_69));
 if (scn->sst_tab == NULL)
  return cdf_zero_stream(scn);

 for (j = var_76 = 0; var_49 >= 0; var_76++, j++) {
  if (j >= CDF_LOOP_LIMIT) {
                                                 ;
   goto out;
  }
  if (var_76 >= scn->sst_len) {


                     ;
   goto out;
  }
  if ((nr = cdf_read_sector(info, scn->sst_tab, var_76 * var_69, var_69, h,
      var_49)) != var_76(ssize_t, var_69)) {
   if (var_76 == scn->sst_len - 1 && nr > 0) {

    return 0;
   }
                                                 ;
   goto out;
  }
  var_49 = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, sat->sat_tab[var_49])) : var_76(uint32_t, var_76(uint32_t, sat->sat_tab[var_49]))));
 }
 return 0;
out:
 errno = EINVAL;
 return cdf_zero_stream(scn);
}

int
fn_45(const cdf_header_t *h,
    const cdf_sat_t *ssat, const cdf_stream_t *sst,
    cdf_secid_t var_49, size_t var_76, cdf_stream_t *scn)
{
 size_t var_69 = CDF_SHORT_SEC_SIZE(h), var_76, j;
 scn->sst_tab = NULL;
 scn->sst_len = cdf_count_chain(ssat, var_49, CDF_SEC_SIZE(h));
 scn->sst_dirlen = var_76;
 scn->sst_ss = var_69;

 if (scn->sst_len == var_76(size_t, -1))
  goto out;

 scn->sst_tab = cdf_calloc("/tmp/tmp6t83cgcw.c", 636, (scn->sst_len), (var_69));
 if (scn->sst_tab == NULL)
  return cdf_zero_stream(scn);

 for (j = var_76 = 0; var_49 >= 0; var_76++, j++) {
  if (j >= CDF_LOOP_LIMIT) {
                                                  ;
   goto out;
  }
  if (var_76 >= scn->sst_len) {


                        ;
   goto out;
  }
  if (cdf_read_short_sector(sst, scn->sst_tab, var_76 * var_69, var_69, h,
      var_49) != var_76(ssize_t, var_69)) {
                                                  ;
   goto out;
  }
  var_49 = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, ssat->sat_tab[var_49])) : var_76(uint32_t, var_76(uint32_t, ssat->sat_tab[var_49]))));
 }
 return 0;
out:
 errno = EINVAL;
 return cdf_zero_stream(scn);
}

int
fn_46(const cdf_info_t *info, const cdf_header_t *h,
    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,
    cdf_secid_t var_49, size_t var_76, cdf_stream_t *scn)
{

 if (var_76 < h->h_min_size_standard_stream && sst->sst_tab != NULL)
  return cdf_read_short_sector_chain(h, ssat, sst, var_49, var_76,
      scn);
 else
  return cdf_read_long_sector_chain(info, h, sat, var_49, var_76, scn);
}

int
fn_47(const cdf_info_t *info, const cdf_header_t *h,
    const cdf_sat_t *sat, cdf_dir_t *dir)
{
 size_t var_76, j;
 size_t var_69 = CDF_SEC_SIZE(h), ns, nd;
 char *buf;
 cdf_secid_t var_49 = h->h_secid_first_directory;

 ns = cdf_count_chain(sat, var_49, var_69);
 if (ns == var_76(size_t, -1))
  return -1;

 nd = var_69 / CDF_DIRECTORY_SIZE;

 dir->dir_len = ns * nd;
 dir->dir_tab = var_76(cdf_directory_t *,
     cdf_calloc("/tmp/tmp6t83cgcw.c", 694, (dir->dir_len), (sizeof(dir->dir_tab[0]))));
 if (dir->dir_tab == NULL)
  return -1;

 if ((buf = var_76(char *, cdf_malloc("/tmp/tmp6t83cgcw.c", 698, (var_69)))) == NULL) {
  free(dir->dir_tab);
  return -1;
 }

 for (j = var_76 = 0; var_76 < ns; var_76++, j++) {
  if (j >= CDF_LOOP_LIMIT) {
                                   ;
   goto out;
  }
  if (cdf_read_sector(info, buf, 0, var_69, h, var_49) !=
      var_76(ssize_t, var_69)) {
                                                ;
   goto out;
  }
  for (j = 0; j < nd; j++) {
   cdf_unpack_dir(&dir->dir_tab[var_76 * nd + j],
       &buf[j * CDF_DIRECTORY_SIZE]);
  }
  var_49 = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, sat->sat_tab[var_49])) : var_76(uint32_t, var_76(uint32_t, sat->sat_tab[var_49]))));
 }
 if ((cdf_bo.u == var_76(uint32_t, 0x01020304)))
  for (var_76 = 0; var_76 < dir->dir_len; var_76++)
   cdf_swap_dir(&dir->dir_tab[var_76]);
 free(buf);
 return 0;
out:
 free(dir->dir_tab);
 free(buf);
 errno = EINVAL;
 return -1;
}


int
fn_48(const cdf_info_t *info, const cdf_header_t *h,
    const cdf_sat_t *sat, cdf_sat_t *ssat)
{
 size_t var_76, j;
 size_t var_69 = CDF_SEC_SIZE(h);
 cdf_secid_t var_49 = h->h_secid_first_sector_in_short_sat;

 ssat->sat_tab = NULL;
 ssat->sat_len = cdf_count_chain(sat, var_49, var_69);
 if (ssat->sat_len == var_76(size_t, -1))
  goto out;

 ssat->sat_tab = var_76(cdf_secid_t *, cdf_calloc("/tmp/tmp6t83cgcw.c", 745, (ssat->sat_len), (var_69)));
 if (ssat->sat_tab == NULL)
  goto out1;

 for (j = var_76 = 0; var_49 >= 0; var_76++, j++) {
  if (j >= CDF_LOOP_LIMIT) {
                                                ;
   goto out;
  }
  if (var_76 >= ssat->sat_len) {


                      ;
   goto out;
  }
  if (cdf_read_sector(info, ssat->sat_tab, var_76 * var_69, var_69, h, var_49) !=
      var_76(ssize_t, var_69)) {
                                                ;
   goto out1;
  }
  var_49 = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, sat->sat_tab[var_49])) : var_76(uint32_t, var_76(uint32_t, sat->sat_tab[var_49]))));
 }
 return 0;
out:
 errno = EINVAL;
out1:
 free(ssat->sat_tab);
 return -1;
}

int
fn_49(const cdf_info_t *info, const cdf_header_t *h,
    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,
    const cdf_directory_t **root)
{
 size_t var_76;
 const cdf_directory_t *d;

 *root = NULL;
 for (var_76 = 0; var_76 < dir->dir_len; var_76++)
  if (dir->dir_tab[var_76].d_type == CDF_DIR_TYPE_ROOT_STORAGE)
   break;


 if (var_76 == dir->dir_len) {
                                             ;
  goto out;
 }
 d = &dir->dir_tab[var_76];
 *root = d;


 if (d->d_stream_first_sector < 0) {
                                       ;
  goto out;
 }

 return cdf_read_long_sector_chain(info, h, sat,
     d->d_stream_first_sector, d->d_size, scn);
out:
 scn->sst_tab = NULL;
 (void)cdf_zero_stream(scn);
 return 0;
}

static int
fn_50(const char *d, const uint16_t *s, size_t var_66)
{
 for (; var_66--; d++, s++)
  if (*d != (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(*s) : var_76(uint16_t, *s))))
   return var_76(unsigned char, *d) - (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(*s) : var_76(uint16_t, *s)));
 return 0;
}

int
fn_52(const cdf_info_t *info, const cdf_header_t *h,
    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,
    const cdf_dir_t *dir, cdf_stream_t *scn)
{
 return cdf_read_user_stream(info, h, sat, ssat, sst, dir,
     "\05DocumentSummaryInformation", scn);
}

int
fn_53(const cdf_info_t *info, const cdf_header_t *h,
    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,
    const cdf_dir_t *dir, cdf_stream_t *scn)
{
 return cdf_read_user_stream(info, h, sat, ssat, sst, dir,
     "\05SummaryInformation", scn);
}

int
fn_54(const cdf_info_t *info, const cdf_header_t *h,
    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,
    const cdf_dir_t *dir, const char *name, cdf_stream_t *scn)
{
 const cdf_directory_t *d;
 int var_76 = cdf_find_stream(dir, name, CDF_DIR_TYPE_USER_STREAM);

 if (var_76 <= 0) {
  memset(scn, 0, sizeof(*scn));
  return -1;
 }

 d = &dir->dir_tab[var_76 - 1];
 return cdf_read_sector_chain(info, h, sat, ssat, sst,
     d->d_stream_first_sector, d->d_size, scn);
}

int
fn_55(const cdf_dir_t *dir, const char *name, int var_58)
{
 size_t var_76, var_58 = strlen(name) + 1;

 for (var_76 = dir->dir_len; var_76 > 0; var_76--)
  if (dir->dir_tab[var_76 - 1].d_type == var_58 &&
      cdf_namecmp(name, dir->dir_tab[var_76 - 1].d_name, var_58)
      == 0)
   break;
 if (var_76 > 0)
  return var_76(int, var_76);

                                                    ;
 errno = ESRCH;
 return 0;
}




static const void *
fn_58(const void *var_76, size_t var_66)
{
 return var_76(const void *, var_76(const uint8_t *, var_76) + var_66);
}

static const uint8_t *
fn_59(const cdf_stream_t *sst, const cdf_header_t *h,
    const uint8_t *var_76, const uint8_t *e, size_t var_76)
{
 size_t var_60 = (var_76 << 1) + 1;
 size_t ofs;
 const uint8_t *q;

 if (var_76 >= e) {
                                       ;
  return NULL;
 }
 if (cdf_check_stream_offset(sst, h, var_76, (var_60 + 1) * sizeof(uint32_t),
     895) == -1)
  return NULL;
 ofs = cdf_getuint32(var_76, var_60);
 q = var_76(const uint8_t *, cdf_offset(var_76(const void *, var_76),
     ofs - 2 * sizeof(uint32_t)));

 if (q < var_76) {
                                             ;
  return NULL;
 }

 if (q >= e) {
                                               ;
  return NULL;
 }
 return q;
}

static cdf_property_info_t *
fn_60(cdf_property_info_t **info, size_t *maxcount, size_t var_63)
{
 cdf_property_info_t *inp;
 size_t var_63 = *maxcount + var_63;

 if (var_63 > (UINT32_MAX / (64 * sizeof(cdf_property_info_t)))) {

                                                     ;
  goto out;
 }
 inp = var_76(cdf_property_info_t *,
     cdf_realloc("/tmp/tmp6t83cgcw.c", 925, (*info), (var_63 * sizeof(*inp))));
 if (inp == NULL)
  goto out;

 *info = inp;
 *maxcount = var_63;
 return inp;
out:
 free(*info);
 *maxcount = 0;
 *info = NULL;
 return NULL;
}

static int
fn_63(cdf_property_info_t *inp, const void *var_76, const void *e,
    size_t var_76)
{
 if (inp->pi_type & CDF_VECTOR)
  return 0;

 if (var_76(size_t, var_76(const char *, e) - var_76(const char *, var_76)) < var_76)
  return 0;

 (void)memcpy(&inp->pi_val, var_76, var_76);

 switch (var_76) {
 case 2:
  inp->pi_u16 = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(inp->pi_u16) : var_76(uint16_t, inp->pi_u16)));
  break;
 case 4:
  inp->pi_u32 = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(inp->pi_u32) : var_76(uint32_t, inp->pi_u32)));
  break;
 case 8:
  inp->pi_u64 = (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(inp->pi_u64) : var_76(uint64_t, inp->pi_u64)));
  break;
 default:
  abort();
 }
 return 1;
}

int
fn_64(const cdf_stream_t *sst, const cdf_header_t *h,
    uint32_t var_65, cdf_property_info_t **info, size_t *count, size_t *maxcount)
{
 const cdf_section_header_t *shp;
 cdf_section_header_t sh;
 const uint8_t *var_76, *q, *e;
 size_t var_76, o4, nelements, j, slen, left;
 cdf_property_info_t *inp;

 if (var_65 > UINT32_MAX / 4) {
  errno = EINVAL;
  goto out;
 }
 shp = var_76(const cdf_section_header_t *,
     cdf_offset(sst->sst_tab, var_65));
 if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), 983) == -1)
  goto out;
 sh.sh_len = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(shp->sh_len) : var_76(uint32_t, shp->sh_len)));
 if (sh.sh_len > (UINT32_MAX / 64)) {
  errno = EINVAL;
  goto out;
 }

 if (cdf_check_stream_offset(sst, h, shp, sh.sh_len, 991) == -1)
  goto out;

 sh.sh_properties = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(shp->sh_properties) : var_76(uint32_t, shp->sh_properties)));

                       ;
 if (sh.sh_properties > (UINT32_MAX / (64 * sizeof(cdf_property_info_t))))
  goto out;
 inp = cdf_grow_info(info, maxcount, sh.sh_properties);
 if (inp == NULL)
  goto out;
 inp += *count;
 *count += sh.sh_properties;
 var_76 = var_76(const uint8_t *, cdf_offset(sst->sst_tab, var_65 + sizeof(sh)));
 e = var_76(const uint8_t *, cdf_offset(shp, sh.sh_len));
 if (var_76 >= e || cdf_check_stream_offset(sst, h, e, 0, 1006) == -1)
  goto out;

 for (var_76 = 0; var_76 < sh.sh_properties; var_76++) {
  if ((q = cdf_get_property_info_pos(sst, h, var_76, e, var_76)) == NULL)
   goto out;
  inp[var_76].pi_id = cdf_getuint32(var_76, var_76 << 1);
  left = var_76(size_t, e - q);
  if (left < sizeof(uint32_t)) {
                                       ;
   goto out;
  }
  inp[var_76].pi_type = cdf_getuint32(q, 0);

                                                    ;
  if (inp[var_76].pi_type & CDF_VECTOR) {
   if (left < sizeof(uint32_t) * 2) {
                                            ;
    goto out;
   }
   nelements = cdf_getuint32(q, 1);
   if (nelements == 0) {
                                                 ;
    goto out;
   }
   slen = 2;
  } else {
   nelements = 1;
   slen = 1;
  }
  o4 = slen * sizeof(uint32_t);
  if (inp[var_76].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))
   goto unknown;
  switch (inp[var_76].pi_type & CDF_TYPEMASK) {
  case CDF_NULL:
  case CDF_EMPTY:
   break;
  case CDF_SIGNED16:
   if (!cdf_copy_info(&inp[var_76], &q[o4], e, sizeof(int16_t)))
    goto unknown;
   break;
  case CDF_SIGNED32:
  case CDF_BOOL:
  case CDF_UNSIGNED32:
  case CDF_FLOAT:
   if (!cdf_copy_info(&inp[var_76], &q[o4], e, sizeof(int32_t)))
    goto unknown;
   break;
  case CDF_SIGNED64:
  case CDF_UNSIGNED64:
  case CDF_DOUBLE:
  case CDF_FILETIME:
   if (!cdf_copy_info(&inp[var_76], &q[o4], e, sizeof(int64_t)))
    goto unknown;
   break;
  case CDF_LENGTH32_STRING:
  case CDF_LENGTH32_WSTRING:
   if (nelements > 1) {
    size_t var_66 = inp - *info;
    inp = cdf_grow_info(info, maxcount, nelements);
    if (inp == NULL)
     goto out;
    inp += var_66;
   }

                  ;
   for (j = 0; j < nelements && var_76 < sh.sh_properties;
       j++, var_76++)
   {
    uint32_t var_66;

    if (o4 + sizeof(uint32_t) > left)
     goto out;

    var_66 = cdf_getuint32(q, slen);
    o4 += sizeof(uint32_t);
    if (o4 + var_66 > left)
     goto out;

    inp[var_76].pi_str.s_len = var_66;
    inp[var_76].pi_str.s_buf = var_76(const char *,
        var_76(const void *, &q[o4]));




                                   ;

    if (var_66 & 1)
     var_66++;

    slen += var_66 >> 1;
    o4 = slen * sizeof(uint32_t);
   }
   var_76--;
   break;
  case CDF_CLIPBOARD:
   if (inp[var_76].pi_type & CDF_VECTOR)
    goto unknown;
   break;
  default:
  unknown:
   memset(&inp[var_76].pi_val, 0, sizeof(inp[var_76].pi_val));

                       ;
   break;
  }
 }
 return 0;
out:
 free(*info);
 *info = NULL;
 *count = 0;
 *maxcount = 0;
 errno = EINVAL;
 return -1;
}

int
fn_66(const cdf_stream_t *sst, const cdf_header_t *h,
    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)
{
 size_t maxcount;
 const cdf_summary_info_header_t *si =
     var_76(const cdf_summary_info_header_t *, sst->sst_tab);
 const cdf_section_declaration_t *sd =
     var_76(const cdf_section_declaration_t *, fn_67(const void *,
     RCAST(const char *, sst->var_67)
     + CDF_SECTION_DECLARATION_OFFSET));

 if (cdf_check_stream_offset(sst, h, si, sizeof(*si), 1136) == -1 ||
     cdf_check_stream_offset(sst, h, sd, sizeof(*sd), 1137) == -1)
  return -1;
 ssi->si_byte_order = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(si->si_byte_order) : var_76(uint16_t, si->si_byte_order)));
 ssi->si_os_version = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(si->si_os_version) : var_76(uint16_t, si->si_os_version)));
 ssi->si_os = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(si->si_os) : var_76(uint16_t, si->si_os)));
 ssi->si_class = si->si_class;
 cdf_swap_class(&ssi->si_class);
 ssi->si_count = (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(si->si_count) : var_76(uint32_t, si->si_count)));
 *count = 0;
 maxcount = 0;
 *info = NULL;
 if (cdf_read_property_info(sst, h, (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(sd->sd_offset) : var_76(uint32_t, sd->sd_offset))), info,
     count, &maxcount) == -1)
  return -1;
 return 0;
}

int
fn_68(const cdf_header_t *h, const cdf_stream_t *sst,
    cdf_catalog_t **cat)
{
 size_t var_69 = cdf_check_stream(sst, h);
 const char *b = var_76(const char *, sst->sst_tab);
 const char *nb, *eb = b + var_69 * sst->sst_len;
 size_t nr, var_76, j, k;
 cdf_catalog_entry_t *ce;
 uint16_t reclen;
 const uint16_t *np;

 for (nr = 0;; nr++) {
  memcpy(&reclen, b, sizeof(reclen));
  reclen = (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(reclen) : var_76(uint16_t, reclen)));
  if (reclen == 0)
   break;
  b += reclen;
  if (b > eb)
      break;
 }
 if (nr == 0)
  return -1;
 nr--;
 *cat = var_76(cdf_catalog_t *,
     cdf_malloc("/tmp/tmp6t83cgcw.c", 1188, (sizeof(cdf_catalog_t) + nr * sizeof(*ce))));
 if (*cat == NULL)
  return -1;
 ce = (*cat)->cat_e;
 memset(ce, 0, nr * sizeof(*ce));
 b = var_76(const char *, sst->sst_tab);
 for (j = var_76 = 0; var_76 < nr; b += reclen) {
  cdf_catalog_entry_t *cep = &ce[j];
  uint16_t rlen;

  if (b + 0 + sizeof(cep->ce_namlen) > eb) { cep->ce_namlen = 0; break; } memcpy(&cep->ce_namlen, b + 0, sizeof(cep->ce_namlen)); ce[var_76].ce_namlen = var_76(uint16_t, ( sizeof(cep->ce_namlen) == 2 ? (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(var_76(uint16_t, cep->ce_namlen)) : var_76(uint16_t, var_76(uint16_t, cep->ce_namlen)))) : ( sizeof(cep->ce_namlen) == 4 ? (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, cep->ce_namlen)) : var_76(uint32_t, var_76(uint32_t, cep->ce_namlen)))) : (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(var_76(uint64_t, cep->ce_namlen)) : var_76(uint64_t, var_76(uint64_t, cep->ce_namlen)))))));
  if (b + 4 + sizeof(cep->ce_num) > eb) { cep->ce_namlen = 0; break; } memcpy(&cep->ce_num, b + 4, sizeof(cep->ce_num)); ce[var_76].ce_num = var_76(uint16_t, ( sizeof(cep->ce_num) == 2 ? (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(var_76(uint16_t, cep->ce_num)) : var_76(uint16_t, var_76(uint16_t, cep->ce_num)))) : ( sizeof(cep->ce_num) == 4 ? (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, cep->ce_num)) : var_76(uint32_t, var_76(uint32_t, cep->ce_num)))) : (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(var_76(uint64_t, cep->ce_num)) : var_76(uint64_t, var_76(uint64_t, cep->ce_num)))))));
  if (b + 8 + sizeof(cep->ce_timestamp) > eb) { cep->ce_namlen = 0; break; } memcpy(&cep->ce_timestamp, b + 8, sizeof(cep->ce_timestamp)); ce[var_76].ce_timestamp = var_76(uint64_t, ( sizeof(cep->ce_timestamp) == 2 ? (var_76(uint16_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole2(var_76(uint16_t, cep->ce_timestamp)) : var_76(uint16_t, var_76(uint16_t, cep->ce_timestamp)))) : ( sizeof(cep->ce_timestamp) == 4 ? (var_76(uint32_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole4(var_76(uint32_t, cep->ce_timestamp)) : var_76(uint32_t, var_76(uint32_t, cep->ce_timestamp)))) : (var_76(uint64_t, (cdf_bo.u == var_76(uint32_t, 0x01020304)) ? _cdf_tole8(var_76(uint64_t, cep->ce_timestamp)) : var_76(uint64_t, var_76(uint64_t, cep->ce_timestamp)))))));
  reclen = cep->ce_namlen;

  if (reclen < 14) {
   cep->ce_namlen = 0;
   continue;
  }

  cep->ce_namlen = __arraycount(cep->ce_name) - 1;
  rlen = reclen - 14;
  if (cep->ce_namlen > rlen)
   cep->ce_namlen = rlen;

  np = var_76(const uint16_t *, var_76(const void *, (b + 16)));
  nb = var_76(const char *, var_76(const void *,
      (np + cep->ce_namlen)));
  if (nb > eb) {
   cep->ce_namlen = 0;
   break;
  }

  for (k = 0; k < cep->ce_namlen; k++)
   cep->ce_name[k] = np[k];
  cep->ce_name[cep->ce_namlen] = 0;
  j = var_76;
  var_76++;
 }
 (*cat)->cat_num = j;
 return 0;
}

int
fn_69(char *buf, size_t var_71, const cdf_classid_t *var_71)
{
 return snprintf(buf, var_71, "%.8x-%.4x-%.4x-%.2x%.2x-"
     "%.2x%.2x%.2x%.2x%.2x%.2x", var_71->cl_dword, var_71->cl_word[0],
     var_71->cl_word[1], var_71->cl_two[0], var_71->cl_two[1], var_71->cl_six[0],
     var_71->cl_six[1], var_71->cl_six[2], var_71->cl_six[3], var_71->cl_six[4],
     var_71->cl_six[5]);
}

static const struct {
 uint32_t v;
 const char *n;
} vn[] = {
 { CDF_PROPERTY_CODE_PAGE, "Code page" },
 { CDF_PROPERTY_TITLE, "Title" },
 { CDF_PROPERTY_SUBJECT, "Subject" },
 { CDF_PROPERTY_AUTHOR, "Author" },
 { CDF_PROPERTY_KEYWORDS, "Keywords" },
 { CDF_PROPERTY_COMMENTS, "Comments" },
 { CDF_PROPERTY_TEMPLATE, "Template" },
 { CDF_PROPERTY_LAST_SAVED_BY, "Last Saved By" },
 { CDF_PROPERTY_REVISION_NUMBER, "Revision Number" },
 { CDF_PROPERTY_TOTAL_EDITING_TIME, "Total Editing Time" },
 { CDF_PROPERTY_LAST_PRINTED, "Last Printed" },
 { CDF_PROPERTY_CREATE_TIME, "Create Time/Date" },
 { CDF_PROPERTY_LAST_SAVED_TIME, "Last Saved Time/Date" },
 { CDF_PROPERTY_NUMBER_OF_PAGES, "Number of Pages" },
 { CDF_PROPERTY_NUMBER_OF_WORDS, "Number of Words" },
 { CDF_PROPERTY_NUMBER_OF_CHARACTERS, "Number of Characters" },
 { CDF_PROPERTY_THUMBNAIL, "Thumbnail" },
 { CDF_PROPERTY_NAME_OF_APPLICATION, "Name of Creating Application" },
 { CDF_PROPERTY_SECURITY, "Security" },
 { CDF_PROPERTY_LOCALE_ID, "Locale ID" },
};

int
fn_71(char *buf, size_t var_75, uint32_t var_76)
{
 size_t var_76;

 for (var_76 = 0; var_76 < __arraycount(vn); var_76++)
  if (vn[var_76].v == var_76)
   return snprintf(buf, var_75, "%s", vn[var_76].n);
 return snprintf(buf, var_75, "%#x", var_76);
}

int
fn_73(char *buf, size_t var_75, cdf_timestamp_t var_75)
{
 int var_76 = 0;
 int days, hours, mins, secs;

 var_75 /= CDF_TIME_PREC;
 secs = var_76(int, var_75 % 60);
 var_75 /= 60;
 mins = var_76(int, var_75 % 60);
 var_75 /= 60;
 hours = var_76(int, var_75 % 24);
 var_75 /= 24;
 days = var_76(int, var_75);

 if (days) {
  var_76 += snprintf(buf + var_76, var_75 - var_76, "%dd+", days);
  if (var_76(size_t, var_76) >= var_75)
   return var_76;
 }

 if (days || hours) {
  var_76 += snprintf(buf + var_76, var_75 - var_76, "%.2d:", hours);
  if (var_76(size_t, var_76) >= var_75)
   return var_76;
 }

 var_76 += snprintf(buf + var_76, var_75 - var_76, "%.2d:", mins);
 if (var_76(size_t, var_76) >= var_75)
  return var_76;

 var_76 += snprintf(buf + var_76, var_75 - var_76, "%.2d", secs);
 return var_76;
}

char *
fn_75(char *buf, size_t var_76, const uint16_t *var_76)
{
 size_t var_76;
 for (var_76 = 0; var_76 < var_76 && var_76[var_76]; var_76++)
  buf[var_76] = var_76(char, var_76[var_76]);
 buf[var_76] = '\0';
 return buf;
}
