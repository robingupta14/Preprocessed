







static void fn_23(opj_bio_t *bio, OPJ_INT32 var_53);

static OPJ_UINT32 fn_23(opj_bio_t *bio);





static void fn_23(opj_bio_t *bio, OPJ_UINT32 var_53);
static OPJ_UINT32 fn_23(opj_bio_t *bio);

static OPJ_BOOL fn_45(OPJ_UINT32 var_52,
                                     opj_tcd_tile_t *tile,
                                     opj_tcp_t *tcp,
                                     opj_pi_iterator_t *pi,
                                     OPJ_BYTE *var_52,
                                     OPJ_UINT32 * p_data_written,
                                     OPJ_UINT32 var_52,
                                     opj_codestream_info_t *cstr_info,
                                     J2K_T2_MODE var_52,
                                     opj_event_mgr_t *p_manager);

static OPJ_BOOL fn_44(opj_t2_t* t2,
                                     opj_tcd_tile_t *tile,
                                     opj_tcp_t *tcp,
                                     opj_pi_iterator_t *pi,
                                     OPJ_BYTE *src,
                                     OPJ_UINT32 * data_read,
                                     OPJ_UINT32 var_11,
                                     opj_packet_info_t *pack_info,
                                     opj_event_mgr_t *p_manager);

static OPJ_BOOL fn_52(opj_t2_t* p_t2,
                                   opj_tcd_tile_t *p_tile,
                                   opj_tcp_t *p_tcp,
                                   opj_pi_iterator_t *p_pi,
                                   OPJ_BYTE *var_52,
                                   OPJ_UINT32 * p_data_read,
                                   OPJ_UINT32 var_54,
                                   opj_packet_info_t *p_pack_info,
                                   opj_event_mgr_t *p_manager);

static OPJ_BOOL fn_52(opj_t2_t* p_t2,
        opj_tcd_tile_t *p_tile,
        opj_tcp_t *p_tcp,
        opj_pi_iterator_t *p_pi,
        OPJ_BOOL * p_is_data_present,
        OPJ_BYTE *var_54,
        OPJ_UINT32 * p_data_read,
        OPJ_UINT32 var_54,
        opj_packet_info_t *p_pack_info,
        opj_event_mgr_t *p_manager);

static OPJ_BOOL fn_53(opj_t2_t* p_t2,
                                        opj_tcd_tile_t *p_tile,
                                        opj_pi_iterator_t *p_pi,
                                        OPJ_BYTE *var_54,
                                        OPJ_UINT32 * p_data_read,
                                        OPJ_UINT32 var_54,
                                        opj_packet_info_t *pack_info,
                                        opj_event_mgr_t *p_manager);

static OPJ_BOOL fn_54(opj_t2_t* p_t2,
                                        opj_tcd_tile_t *p_tile,
                                        opj_pi_iterator_t *p_pi,
                                        OPJ_UINT32 * p_data_read,
                                        OPJ_UINT32 var_54,
                                        opj_packet_info_t *pack_info,
                                        opj_event_mgr_t *p_manager);







static OPJ_BOOL fn_54(opj_tcd_cblk_dec_t* cblk,
                                OPJ_UINT32 var_56,
                                OPJ_UINT32 var_56,
                                OPJ_UINT32 var_56);

static void fn_23(opj_bio_t *bio, OPJ_INT32 var_53)
{
    while (--var_53 >= 0) {
        opj_bio_write(bio, 1, 1);
    }
    opj_bio_write(bio, 0, 1);
}

static OPJ_UINT32 fn_23(opj_bio_t *bio)
{
    OPJ_UINT32 var_53 = 0;
    while (opj_bio_read(bio, 1)) {
        ++var_53;
    }
    return var_53;
}

static void fn_23(opj_bio_t *bio, OPJ_UINT32 var_53)
{
    if (var_53 == 1) {
        opj_bio_write(bio, 0, 1);
    } else if (var_53 == 2) {
        opj_bio_write(bio, 2, 2);
    } else if (var_53 <= 5) {
        opj_bio_write(bio, 0xc | (var_53 - 3), 4);
    } else if (var_53 <= 36) {
        opj_bio_write(bio, 0x1e0 | (var_53 - 6), 9);
    } else if (var_53 <= 164) {
        opj_bio_write(bio, 0xff80 | (var_53 - 37), 16);
    }
}

static OPJ_UINT32 fn_23(opj_bio_t *bio)
{
    OPJ_UINT32 var_53;
    if (!opj_bio_read(bio, 1)) {
        return 1;
    }
    if (!opj_bio_read(bio, 1)) {
        return 2;
    }
    if ((var_53 = opj_bio_read(bio, 2)) != 3) {
        return (3 + var_53);
    }
    if ((var_53 = opj_bio_read(bio, 5)) != 31) {
        return (6 + var_53);
    }
    return (37 + opj_bio_read(bio, 7));
}



OPJ_BOOL fn_23(opj_t2_t* p_t2,
                               OPJ_UINT32 var_42,
                               opj_tcd_tile_t *p_tile,
                               OPJ_UINT32 var_38,
                               OPJ_BYTE *var_31,
                               OPJ_UINT32 * p_data_written,
                               OPJ_UINT32 var_42,
                               opj_codestream_info_t *cstr_info,
                               OPJ_UINT32 var_38,
                               OPJ_INT32 var_38,
                               OPJ_UINT32 var_38,
                               J2K_T2_MODE var_52,
                               opj_event_mgr_t *p_manager)
{
    OPJ_BYTE *l_current_data = var_31;
    OPJ_UINT32 var_52 = 0;
    OPJ_UINT32 var_49;
    OPJ_UINT32 poc;
    opj_pi_iterator_t *l_pi = 0;
    opj_pi_iterator_t *l_current_pi = 0;
    opj_image_t *l_image = p_t2->image;
    opj_cp_t *l_cp = p_t2->cp;
    opj_tcp_t *l_tcp = &l_cp->tcps[var_42];
    OPJ_UINT32 var_37 = (l_cp->rsiz == OPJ_PROFILE_CINEMA_4K) ? 2 : 1;
    OPJ_UINT32 var_36 = l_cp->m_specific_param.m_enc.m_max_comp_size > 0 ?
                            l_image->numcomps : 1;
    OPJ_UINT32 var_42 = l_tcp->numpocs + 1;

    l_pi = opj_pi_initialise_encode(l_image, l_cp, var_42, var_52);
    if (!l_pi) {
        return OPJ_FALSE;
    }

    * p_data_written = 0;

    if (var_52 == THRESH_CALC) {
        l_current_pi = l_pi;

        for (var_49 = 0; var_49 < var_36; ++var_49) {
            OPJ_UINT32 var_38 = 0;
            l_current_pi = l_pi;

            for (poc = 0; poc < var_37 ; ++poc) {
                OPJ_UINT32 var_38 = var_49;


                opj_pi_create_encode(l_pi, l_cp, var_42, poc, var_38, var_38, var_52);

                if (l_current_pi->poc.prg == OPJ_PROG_UNKNOWN) {

                    opj_pi_destroy(l_pi, var_42);
                    return OPJ_FALSE;
                }
                while (opj_pi_next(l_current_pi)) {
                    if (l_current_pi->layno < var_38) {
                        var_52 = 0;

                        if (! opj_t2_encode_packet(var_42, p_tile, l_tcp, l_current_pi,
                                                   l_current_data, &var_52,
                                                   var_42, cstr_info,
                                                   var_52,
                                                   p_manager)) {
                            opj_pi_destroy(l_pi, var_42);
                            return OPJ_FALSE;
                        }

                        var_38 += var_52;
                        l_current_data += var_52;
                        var_42 -= var_52;

                        * p_data_written += var_52;
                    }
                }

                if (l_cp->m_specific_param.m_enc.m_max_comp_size) {
                    if (var_38 > l_cp->m_specific_param.m_enc.m_max_comp_size) {
                        opj_pi_destroy(l_pi, var_42);
                        return OPJ_FALSE;
                    }
                }

                ++l_current_pi;
            }
        }
    } else {
        opj_pi_create_encode(l_pi, l_cp, var_42, var_38, var_38, var_38,
                             var_52);

        l_current_pi = &l_pi[var_38];
        if (l_current_pi->poc.prg == OPJ_PROG_UNKNOWN) {

            opj_pi_destroy(l_pi, var_42);
            return OPJ_FALSE;
        }
        while (opj_pi_next(l_current_pi)) {
            if (l_current_pi->layno < var_38) {
                var_52 = 0;

                if (! opj_t2_encode_packet(var_42, p_tile, l_tcp, l_current_pi,
                                           l_current_data, &var_52, var_42,
                                           cstr_info, var_52, p_manager)) {
                    opj_pi_destroy(l_pi, var_42);
                    return OPJ_FALSE;
                }

                l_current_data += var_52;
                var_42 -= var_52;

                * p_data_written += var_52;


                if (cstr_info) {
                    if (cstr_info->index_write) {
                        opj_tile_info_t *info_TL = &cstr_info->tile[var_42];
                        opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
                        if (!cstr_info->packno) {
                            info_PK->start_pos = info_TL->end_header + 1;
                        } else {
                            info_PK->start_pos = ((l_cp->m_specific_param.m_enc.m_tp_on | l_tcp->POC) &&
                                                  info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno -
                                                                            1].end_pos + 1;
                        }
                        info_PK->end_pos = info_PK->start_pos + var_52 - 1;
                        info_PK->end_ph_pos += info_PK->start_pos -
                                               1;

                    }

                    cstr_info->packno++;
                }

                ++p_tile->packno;
            }
        }
    }

    opj_pi_destroy(l_pi, var_42);

    return var_56;
}






static void fn_39(FILE* file, const char * format, ...)
{
    (void)file;
    (void)format;
}



OPJ_BOOL fn_40(opj_t2_t *p_t2,
                               OPJ_UINT32 var_42,
                               opj_tcd_tile_t *p_tile,
                               OPJ_BYTE *var_52,
                               OPJ_UINT32 * p_data_read,
                               OPJ_UINT32 var_42,
                               opj_codestream_index_t *p_cstr_index,
                               opj_event_mgr_t *p_manager)
{
    OPJ_BYTE *l_current_data = var_52;
    opj_pi_iterator_t *l_pi = 0;
    OPJ_UINT32 pino;
    opj_image_t *l_image = p_t2->image;
    opj_cp_t *l_cp = p_t2->cp;
    opj_tcp_t *l_tcp = &(p_t2->cp->tcps[var_42]);
    OPJ_UINT32 var_52;
    OPJ_UINT32 var_42 = l_tcp->numpocs + 1;
    opj_pi_iterator_t *l_current_pi = 0;




    opj_packet_info_t *l_pack_info = 0;
    opj_image_comp_t* l_img_comp = 0;

    OPJ_ARG_NOT_USED(p_cstr_index);

    l_pi = opj_pi_create_decode(l_image, l_cp, var_42);
    if (!l_pi) {
        return OPJ_FALSE;
    }


    l_current_pi = l_pi;

    for (pino = 0; pino <= l_tcp->numpocs; ++pino) {






        OPJ_BOOL* first_pass_failed = NULL;

        if (l_current_pi->poc.prg == OPJ_PROG_UNKNOWN) {

            opj_pi_destroy(l_pi, var_42);
            return OPJ_FALSE;
        }

        first_pass_failed = (OPJ_BOOL*)opj_malloc(l_image->numcomps * sizeof(OPJ_BOOL));
        if (!first_pass_failed) {
            opj_pi_destroy(l_pi, var_42);
            return OPJ_FALSE;
        }
        memset(first_pass_failed, var_56, l_image->numcomps * sizeof(OPJ_BOOL));

        while (opj_pi_next(l_current_pi)) {
            opj_null_jas_fprintf(stderr,
                        "packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n\n",
                        l_current_pi->poc.prg1, l_current_pi->compno, l_current_pi->resno,
                        l_current_pi->precno, l_current_pi->layno);

            if (l_tcp->num_layers_to_decode > l_current_pi->layno
                    && l_current_pi->resno <
                    p_tile->comps[l_current_pi->compno].minimum_num_resolutions) {
                var_52 = 0;

                first_pass_failed[l_current_pi->compno] = OPJ_FALSE;

                if (! opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                           &var_52, var_42, l_pack_info, p_manager)) {
                    opj_pi_destroy(l_pi, var_42);
                    opj_free(first_pass_failed);
                    return OPJ_FALSE;
                }

                l_img_comp = &(l_image->comps[l_current_pi->compno]);
                l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno,
                                            l_img_comp->resno_decoded);
            } else {
                var_52 = 0;
                if (! opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                         &var_52, var_42, l_pack_info, p_manager)) {
                    opj_pi_destroy(l_pi, var_42);
                    opj_free(first_pass_failed);
                    return OPJ_FALSE;
                }
            }

            if (first_pass_failed[l_current_pi->compno]) {
                l_img_comp = &(l_image->comps[l_current_pi->compno]);
                if (l_img_comp->resno_decoded == 0) {
                    l_img_comp->resno_decoded =
                        p_tile->comps[l_current_pi->compno].minimum_num_resolutions - 1;
                }
            }

            l_current_data += var_52;
            var_42 -= var_52;

        }
        ++l_current_pi;

        opj_free(first_pass_failed);
    }

    opj_pi_destroy(l_pi, var_42);
    *p_data_read = (OPJ_UINT32)(l_current_data - var_52);
    return var_56;
}

opj_t2_t* fn_42(opj_image_t *p_image, opj_cp_t *p_cp)
{

    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}

void fn_43(opj_t2_t *t2)
{
    if (t2) {
        opj_free(t2);
    }
}

static OPJ_BOOL fn_44(opj_t2_t* p_t2,
                                     opj_tcd_tile_t *p_tile,
                                     opj_tcp_t *p_tcp,
                                     opj_pi_iterator_t *p_pi,
                                     OPJ_BYTE *var_52,
                                     OPJ_UINT32 * p_data_read,
                                     OPJ_UINT32 var_54,
                                     opj_packet_info_t *p_pack_info,
                                     opj_event_mgr_t *p_manager)
{
    OPJ_BOOL l_read_data;
    OPJ_UINT32 var_52 = 0;
    OPJ_UINT32 var_52 = 0;

    *p_data_read = 0;

    if (! opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, &l_read_data, var_52,
                                    &var_52, var_54, p_pack_info, p_manager)) {
        return OPJ_FALSE;
    }

    var_52 += var_52;
    var_52 += var_52;
    var_54 -= var_52;


    if (l_read_data) {
        var_52 = 0;

        if (! opj_t2_read_packet_data(p_t2, p_tile, p_pi, var_52, &var_52,
                                      var_54, p_pack_info, p_manager)) {
            return OPJ_FALSE;
        }

        var_52 += var_52;
    }

    *p_data_read = var_52;

    return var_56;
}

static OPJ_BOOL fn_45(OPJ_UINT32 var_52,
                                     opj_tcd_tile_t * tile,
                                     opj_tcp_t * tcp,
                                     opj_pi_iterator_t *pi,
                                     OPJ_BYTE *var_52,
                                     OPJ_UINT32 * p_data_written,
                                     OPJ_UINT32 var_52,
                                     opj_codestream_info_t *cstr_info,
                                     J2K_T2_MODE var_52,
                                     opj_event_mgr_t *p_manager)
{
    OPJ_UINT32 bandno, cblkno;
    OPJ_BYTE* c = var_52;
    OPJ_UINT32 var_52;
    OPJ_UINT32 var_49 = pi->compno;
    OPJ_UINT32 var_49 = pi->resno;
    OPJ_UINT32 var_52 = pi->precno;
    OPJ_UINT32 var_52 = pi->layno;
    OPJ_UINT32 l_nb_blocks;
    opj_tcd_band_t *band = 0;
    opj_tcd_cblk_enc_t* cblk = 0;
    opj_tcd_pass_t *pass = 0;

    opj_tcd_tilecomp_t *tilec = &tile->comps[var_49];
    opj_tcd_resolution_t *res = &tilec->resolutions[var_49];

    opj_bio_t *bio = 0;
    OPJ_BOOL var_52 = var_56;


    if (tcp->csty & J2K_CP_CSTY_SOP) {
        if (var_52 < 6) {
            if (var_52 == FINAL_PASS) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "opj_t2_encode_packet(): only %u bytes remaining in "
                              "output buffer. %u needed.\n",
                              var_52, 6);
            }
            return OPJ_FALSE;
        }
        c[0] = 255;
        c[1] = 145;
        c[2] = 0;
        c[3] = 4;




        c[4] = (tile->packno >> 8) & 0xff;
        c[5] = tile->packno & 0xff;

        c += 6;
        var_52 -= 6;
    }


    if (!var_52) {
        band = res->bands;

        for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {
            opj_tcd_precinct_t *prc;


            if (opj_tcd_is_band_empty(band)) {
                continue;
            }

            prc = &band->precincts[var_52];
            opj_tgt_reset(prc->incltree);
            opj_tgt_reset(prc->imsbtree);

            l_nb_blocks = prc->cw * prc->ch;
            for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
                cblk = &prc->cblks.enc[cblkno];

                cblk->numpasses = 0;
                opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32)cblk->numbps);
            }
        }
    }

    bio = opj_bio_create();
    if (!bio) {

        return OPJ_FALSE;
    }
    opj_bio_init_enc(bio, c, var_52);



    band = res->bands;
    for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {
        opj_tcd_precinct_t *prc;

        if (opj_tcd_is_band_empty(band)) {
            continue;
        }

        prc = &band->precincts[var_52];
        l_nb_blocks = prc->cw * prc->ch;
        cblk = prc->cblks.enc;
        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++, ++cblk) {
            opj_tcd_layer_t *layer = &cblk->layers[var_52];


            if (!layer->numpasses) {
                continue;
            }
            var_52 = OPJ_FALSE;
            break;
        }
        if (!var_52) {
            break;
        }
    }

    opj_bio_write(bio, var_52 ? 0 : 1, 1);



    band = res->bands;
    for (bandno = 0; !var_52 &&
            bandno < res->numbands; ++bandno, ++band) {
        opj_tcd_precinct_t *prc;


        if (opj_tcd_is_band_empty(band)) {
            continue;
        }

        prc = &band->precincts[var_52];
        l_nb_blocks = prc->cw * prc->ch;
        cblk = prc->cblks.enc;

        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
            opj_tcd_layer_t *layer = &cblk->layers[var_52];

            if (!cblk->numpasses && layer->numpasses) {
                opj_tgt_setvalue(prc->incltree, cblkno, (OPJ_INT32)var_52);
            }

            ++cblk;
        }

        cblk = prc->cblks.enc;
        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++) {
            opj_tcd_layer_t *layer = &cblk->layers[var_52];
            OPJ_UINT32 var_52 = 0;
            OPJ_UINT32 var_52 = 0;
            OPJ_UINT32 var_52 = 0, passno;
            OPJ_UINT32 l_nb_passes;


            if (!cblk->numpasses) {
                opj_tgt_encode(bio, prc->incltree, cblkno, (OPJ_INT32)(var_52 + 1));
            } else {
                opj_bio_write(bio, layer->numpasses != 0, 1);
            }


            if (!layer->numpasses) {
                ++cblk;
                continue;
            }


            if (!cblk->numpasses) {
                cblk->numlenbits = 3;
                opj_tgt_encode(bio, prc->imsbtree, cblkno, 999);
            }


            opj_t2_putnumpasses(bio, layer->numpasses);
            l_nb_passes = cblk->numpasses + layer->numpasses;
            pass = cblk->passes + cblk->numpasses;


            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {
                ++var_52;
                var_52 += pass->len;

                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
                    var_52 = (OPJ_UINT32)opj_int_max((OPJ_INT32)var_52,
                                                        opj_int_floorlog2((OPJ_INT32)var_52) + 1
                                                        - ((OPJ_INT32)cblk->numlenbits + opj_int_floorlog2((OPJ_INT32)var_52)));
                    var_52 = 0;
                    var_52 = 0;
                }

                ++pass;
            }
            opj_t2_putcommacode(bio, (OPJ_INT32)var_52);


            cblk->numlenbits += var_52;

            pass = cblk->passes + cblk->numpasses;

            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {
                var_52++;
                var_52 += pass->len;

                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
                    opj_bio_write(bio, (OPJ_UINT32)var_52,
                                  cblk->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)var_52));
                    var_52 = 0;
                    var_52 = 0;
                }
                ++pass;
            }

            ++cblk;
        }
    }

    if (!opj_bio_flush(bio)) {
        opj_bio_destroy(bio);
        return OPJ_FALSE;
    }

    var_52 = (OPJ_UINT32)opj_bio_numbytes(bio);
    c += var_52;
    var_52 -= var_52;

    opj_bio_destroy(bio);


    if (tcp->csty & J2K_CP_CSTY_EPH) {
        if (var_52 < 2) {
            if (var_52 == FINAL_PASS) {
                opj_event_msg(p_manager, EVT_ERROR,
                              "opj_t2_encode_packet(): only %u bytes remaining in "
                              "output buffer. %u needed.\n",
                              var_52, 2);
            }
            return OPJ_FALSE;
        }
        c[0] = 255;
        c[1] = 146;
        c += 2;
        var_52 -= 2;
    }





    if (cstr_info && cstr_info->index_write) {
        opj_packet_info_t *info_PK = &cstr_info->tile[var_52].packet[cstr_info->packno];
        info_PK->end_ph_pos = (OPJ_INT32)(c - var_52);
    }



    band = res->bands;
    for (bandno = 0; !var_52 && bandno < res->numbands; bandno++, ++band) {
        opj_tcd_precinct_t *prc;


        if (opj_tcd_is_band_empty(band)) {
            continue;
        }

        prc = &band->precincts[var_52];
        l_nb_blocks = prc->cw * prc->ch;
        cblk = prc->cblks.enc;

        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
            opj_tcd_layer_t *layer = &cblk->layers[var_52];

            if (!layer->numpasses) {
                ++cblk;
                continue;
            }

            if (layer->len > var_52) {
                if (var_52 == FINAL_PASS) {
                    opj_event_msg(p_manager, EVT_ERROR,
                                  "opj_t2_encode_packet(): only %u bytes remaining in "
                                  "output buffer. %u needed.\n",
                                  var_52, layer->len);
                }
                return OPJ_FALSE;
            }

            memcpy(c, layer->data, layer->len);
            cblk->numpasses += layer->numpasses;
            c += layer->len;
            var_52 -= layer->len;


            if (cstr_info && cstr_info->index_write) {
                opj_packet_info_t *info_PK = &cstr_info->tile[var_52].packet[cstr_info->packno];
                info_PK->disto += layer->disto;
                if (cstr_info->D_max < info_PK->disto) {
                    cstr_info->D_max = info_PK->disto;
                }
            }

            ++cblk;

        }
    }

    assert(c >= var_52);
    * p_data_written += (OPJ_UINT32)(c - var_52);

    return var_56;
}

static OPJ_BOOL fn_52(opj_t2_t* p_t2,
                                   opj_tcd_tile_t *p_tile,
                                   opj_tcp_t *p_tcp,
                                   opj_pi_iterator_t *p_pi,
                                   OPJ_BYTE *var_52,
                                   OPJ_UINT32 * p_data_read,
                                   OPJ_UINT32 var_54,
                                   opj_packet_info_t *p_pack_info,
                                   opj_event_mgr_t *p_manager)
{
    OPJ_BOOL l_read_data;
    OPJ_UINT32 var_52 = 0;
    OPJ_UINT32 var_52 = 0;

    *p_data_read = 0;

    if (! opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, &l_read_data, var_52,
                                    &var_52, var_54, p_pack_info, p_manager)) {
        return OPJ_FALSE;
    }

    var_52 += var_52;
    var_52 += var_52;
    var_54 -= var_52;


    if (l_read_data) {
        var_52 = 0;

        if (! opj_t2_skip_packet_data(p_t2, p_tile, p_pi, &var_52,
                                      var_54, p_pack_info, p_manager)) {
            return OPJ_FALSE;
        }

        var_52 += var_52;
    }
    *p_data_read = var_52;

    return var_56;
}


static OPJ_BOOL fn_52(opj_t2_t* p_t2,
        opj_tcd_tile_t *p_tile,
        opj_tcp_t *p_tcp,
        opj_pi_iterator_t *p_pi,
        OPJ_BOOL * p_is_data_present,
        OPJ_BYTE *var_54,
        OPJ_UINT32 * p_data_read,
        OPJ_UINT32 var_54,
        opj_packet_info_t *p_pack_info,
        opj_event_mgr_t *p_manager)

{

    OPJ_UINT32 bandno, cblkno;
    OPJ_UINT32 l_nb_code_blocks;
    OPJ_UINT32 l_remaining_length;
    OPJ_UINT32 l_header_length;
    OPJ_UINT32 * l_modified_length_ptr = 0;
    OPJ_BYTE *l_current_data = var_54;
    opj_cp_t *l_cp = p_t2->cp;
    opj_bio_t *l_bio = 0;
    opj_tcd_band_t *l_band = 0;
    opj_tcd_cblk_dec_t* l_cblk = 0;
    opj_tcd_resolution_t* l_res =
        &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];

    OPJ_BYTE *l_header_data = 0;
    OPJ_BYTE **l_header_data_start = 0;

    OPJ_UINT32 l_present;

    if (p_pi->layno == 0) {
        l_band = l_res->bands;


        for (bandno = 0; bandno < l_res->numbands; ++bandno) {
            if (!opj_tcd_is_band_empty(l_band)) {
                opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];
                if (!(p_pi->precno < (l_band->precincts_data_size / sizeof(
                                          opj_tcd_precinct_t)))) {
                    opj_event_msg(p_manager, EVT_ERROR, "Invalid precinct\n");
                    return OPJ_FALSE;
                }


                opj_tgt_reset(l_prc->incltree);
                opj_tgt_reset(l_prc->imsbtree);
                l_cblk = l_prc->cblks.dec;

                l_nb_code_blocks = l_prc->cw * l_prc->ch;
                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
                    l_cblk->numsegs = 0;
                    l_cblk->real_num_segs = 0;
                    ++l_cblk;
                }
            }

            ++l_band;
        }
    }



    if (p_tcp->csty & J2K_CP_CSTY_SOP) {
        if (var_54 < 6) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "Not enough space for expected SOP marker\n");
        } else if ((*l_current_data) != 0xff || (*(l_current_data + 1) != 0x91)) {
            opj_event_msg(p_manager, EVT_WARNING, "Expected SOP marker\n");
        } else {
            l_current_data += 6;
        }


    }

    l_bio = opj_bio_create();
    if (! l_bio) {
        return OPJ_FALSE;
    }

    if (l_cp->ppm == 1) {
        l_header_data_start = &l_cp->ppm_data;
        l_header_data = *l_header_data_start;
        l_modified_length_ptr = &(l_cp->ppm_len);

    } else if (p_tcp->ppt == 1) {
        l_header_data_start = &(p_tcp->ppt_data);
        l_header_data = *l_header_data_start;
        l_modified_length_ptr = &(p_tcp->ppt_len);
    } else {
        l_header_data_start = &(l_current_data);
        l_header_data = *l_header_data_start;
        l_remaining_length = (OPJ_UINT32)(var_54 + var_54 - l_header_data);
        l_modified_length_ptr = &(l_remaining_length);
    }

    opj_bio_init_dec(l_bio, l_header_data, *l_modified_length_ptr);

    l_present = opj_bio_read(l_bio, 1);
    opj_null_jas_fprintf(stderr, "present=%d \n", l_present);
    if (!l_present) {

        opj_bio_inalign(l_bio);
        l_header_data += opj_bio_numbytes(l_bio);
        opj_bio_destroy(l_bio);


        if (p_tcp->csty & J2K_CP_CSTY_EPH) {
            if ((*l_modified_length_ptr - (OPJ_UINT32)(l_header_data -
                    *l_header_data_start)) < 2U) {
                opj_event_msg(p_manager, EVT_WARNING,
                              "Not enough space for expected EPH marker\n");
            } else if ((*l_header_data) != 0xff || (*(l_header_data + 1) != 0x92)) {
                opj_event_msg(p_manager, EVT_WARNING, "Expected EPH marker\n");
            } else {
                l_header_data += 2;
            }
        }

        l_header_length = (OPJ_UINT32)(l_header_data - *l_header_data_start);
        *l_modified_length_ptr -= l_header_length;
        *l_header_data_start += l_header_length;




        if (p_pack_info) {
            p_pack_info->end_ph_pos = (OPJ_INT32)(l_current_data - var_54);
        }


        * p_is_data_present = OPJ_FALSE;
        *p_data_read = (OPJ_UINT32)(l_current_data - var_54);
        return var_56;
    }

    l_band = l_res->bands;
    for (bandno = 0; bandno < l_res->numbands; ++bandno, ++l_band) {
        opj_tcd_precinct_t *l_prc = &(l_band->precincts[p_pi->precno]);

        if (opj_tcd_is_band_empty(l_band)) {
            continue;
        }

        l_nb_code_blocks = l_prc->cw * l_prc->ch;
        l_cblk = l_prc->cblks.dec;
        for (cblkno = 0; cblkno < l_nb_code_blocks; cblkno++) {
            OPJ_UINT32 l_included, l_increment, l_segno;
            OPJ_INT32 var_53;


            if (!l_cblk->numsegs) {
                l_included = opj_tgt_decode(l_bio, l_prc->incltree, cblkno,
                                            (OPJ_INT32)(p_pi->layno + 1));

            } else {
                l_included = opj_bio_read(l_bio, 1);
            }


            if (!l_included) {
                l_cblk->numnewpasses = 0;
                ++l_cblk;
                opj_null_jas_fprintf(stderr, "included=%d \n", l_included);
                continue;
            }


            if (!l_cblk->numsegs) {
                OPJ_UINT32 var_53 = 0;

                while (!opj_tgt_decode(l_bio, l_prc->imsbtree, cblkno, (OPJ_INT32)var_53)) {
                    ++var_53;
                }

                l_cblk->numbps = (OPJ_UINT32)l_band->numbps + 1 - var_53;
                l_cblk->numlenbits = 3;
            }


            l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);
            l_increment = opj_t2_getcommacode(l_bio);


            l_cblk->numlenbits += l_increment;
            l_segno = 0;

            if (!l_cblk->numsegs) {
                if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 1)) {
                    opj_bio_destroy(l_bio);
                    return OPJ_FALSE;
                }
            } else {
                l_segno = l_cblk->numsegs - 1;
                if (l_cblk->segs[l_segno].numpasses == l_cblk->segs[l_segno].maxpasses) {
                    ++l_segno;
                    if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 0)) {
                        opj_bio_destroy(l_bio);
                        return OPJ_FALSE;
                    }
                }
            }
            var_53 = (OPJ_INT32)l_cblk->numnewpasses;

            do {
                OPJ_UINT32 bit_number;
                l_cblk->segs[l_segno].numnewpasses = (OPJ_UINT32)opj_int_min((OPJ_INT32)(
                        l_cblk->segs[l_segno].maxpasses - l_cblk->segs[l_segno].numpasses), var_53);
                bit_number = l_cblk->numlenbits + opj_uint_floorlog2(
                                 l_cblk->segs[l_segno].numnewpasses);
                if (bit_number > 32) {
                    opj_event_msg(p_manager, EVT_ERROR,
                                  "Invalid bit number %d in opj_t2_read_packet_header()\n",
                                  bit_number);
                    opj_bio_destroy(l_bio);
                    return OPJ_FALSE;
                }
                l_cblk->segs[l_segno].newlen = opj_bio_read(l_bio, bit_number);
                opj_null_jas_fprintf(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n",
                            l_included, l_cblk->segs[l_segno].numnewpasses, l_increment,
                            l_cblk->segs[l_segno].newlen);

                var_53 -= (OPJ_INT32)l_cblk->segs[l_segno].numnewpasses;
                if (var_53 > 0) {
                    ++l_segno;

                    if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 0)) {
                        opj_bio_destroy(l_bio);
                        return OPJ_FALSE;
                    }
                }
            } while (var_53 > 0);

            ++l_cblk;
        }
    }

    if (!opj_bio_inalign(l_bio)) {
        opj_bio_destroy(l_bio);
        return OPJ_FALSE;
    }

    l_header_data += opj_bio_numbytes(l_bio);
    opj_bio_destroy(l_bio);


    if (p_tcp->csty & J2K_CP_CSTY_EPH) {
        if ((*l_modified_length_ptr - (OPJ_UINT32)(l_header_data -
                *l_header_data_start)) < 2U) {
            opj_event_msg(p_manager, EVT_WARNING,
                          "Not enough space for expected EPH marker\n");
        } else if ((*l_header_data) != 0xff || (*(l_header_data + 1) != 0x92)) {
            opj_event_msg(p_manager, EVT_WARNING, "Expected EPH marker\n");
        } else {
            l_header_data += 2;
        }
    }

    l_header_length = (OPJ_UINT32)(l_header_data - *l_header_data_start);
    opj_null_jas_fprintf(stderr, "hdrlen=%d \n", l_header_length);
    opj_null_jas_fprintf(stderr, "packet body\n");
    *l_modified_length_ptr -= l_header_length;
    *l_header_data_start += l_header_length;




    if (p_pack_info) {
        p_pack_info->end_ph_pos = (OPJ_INT32)(l_current_data - var_54);
    }


    *p_is_data_present = var_56;
    *p_data_read = (OPJ_UINT32)(l_current_data - var_54);

    return var_56;
}

static OPJ_BOOL fn_53(opj_t2_t* p_t2,
                                        opj_tcd_tile_t *p_tile,
                                        opj_pi_iterator_t *p_pi,
                                        OPJ_BYTE *var_54,
                                        OPJ_UINT32 * p_data_read,
                                        OPJ_UINT32 var_54,
                                        opj_packet_info_t *pack_info,
                                        opj_event_mgr_t* p_manager)
{
    OPJ_UINT32 bandno, cblkno;
    OPJ_UINT32 l_nb_code_blocks;
    OPJ_BYTE *l_current_data = var_54;
    opj_tcd_band_t *l_band = 0;
    opj_tcd_cblk_dec_t* l_cblk = 0;
    opj_tcd_resolution_t* l_res =
        &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];

    OPJ_ARG_NOT_USED(p_t2);
    OPJ_ARG_NOT_USED(pack_info);

    l_band = l_res->bands;
    for (bandno = 0; bandno < l_res->numbands; ++bandno) {
        opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];

        if ((l_band->x1 - l_band->x0 == 0) || (l_band->y1 - l_band->y0 == 0)) {
            ++l_band;
            continue;
        }

        l_nb_code_blocks = l_prc->cw * l_prc->ch;
        l_cblk = l_prc->cblks.dec;

        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
            opj_tcd_seg_t *l_seg = 0;

            if (!l_cblk->numnewpasses) {

                ++l_cblk;
                continue;
            }

            if (!l_cblk->numsegs) {
                l_seg = l_cblk->segs;
                ++l_cblk->numsegs;
            } else {
                l_seg = &l_cblk->segs[l_cblk->numsegs - 1];

                if (l_seg->numpasses == l_seg->maxpasses) {
                    ++l_seg;
                    ++l_cblk->numsegs;
                }
            }

            do {

                if ((((OPJ_SIZE_T)l_current_data + (OPJ_SIZE_T)l_seg->newlen) <
                        (OPJ_SIZE_T)l_current_data) ||
                        (l_current_data + l_seg->newlen > var_54 + var_54)) {
                    opj_event_msg(p_manager, EVT_ERROR,
                                  "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
                                  l_seg->newlen, var_54, cblkno, p_pi->precno, bandno, p_pi->resno,
                                  p_pi->compno);
                    return OPJ_FALSE;
                }

                if (l_cblk->numchunks == l_cblk->numchunksalloc) {
                    OPJ_UINT32 var_54 = l_cblk->numchunksalloc * 2 + 1;
                    opj_tcd_seg_data_chunk_t* l_chunks =
                        (opj_tcd_seg_data_chunk_t*)opj_realloc(l_cblk->chunks,
                                var_54 * sizeof(opj_tcd_seg_data_chunk_t));
                    if (l_chunks == NULL) {
                        opj_event_msg(p_manager, EVT_ERROR,
                                      "cannot allocate opj_tcd_seg_data_chunk_t* array");
                        return OPJ_FALSE;
                    }
                    l_cblk->chunks = l_chunks;
                    l_cblk->numchunksalloc = var_54;
                }

                l_cblk->chunks[l_cblk->numchunks].data = l_current_data;
                l_cblk->chunks[l_cblk->numchunks].len = l_seg->newlen;
                l_cblk->numchunks ++;

                l_current_data += l_seg->newlen;
                l_seg->len += l_seg->newlen;
                l_seg->numpasses += l_seg->numnewpasses;
                l_cblk->numnewpasses -= l_seg->numnewpasses;

                l_seg->real_num_passes = l_seg->numpasses;

                if (l_cblk->numnewpasses > 0) {
                    ++l_seg;
                    ++l_cblk->numsegs;
                }
            } while (l_cblk->numnewpasses > 0);

            l_cblk->real_num_segs = l_cblk->numsegs;
            ++l_cblk;
        }

        ++l_band;
    }

    *(p_data_read) = (OPJ_UINT32)(l_current_data - var_54);


    return var_56;
}

static OPJ_BOOL fn_54(opj_t2_t* p_t2,
                                        opj_tcd_tile_t *p_tile,
                                        opj_pi_iterator_t *p_pi,
                                        OPJ_UINT32 * p_data_read,
                                        OPJ_UINT32 var_54,
                                        opj_packet_info_t *pack_info,
                                        opj_event_mgr_t *p_manager)
{
    OPJ_UINT32 bandno, cblkno;
    OPJ_UINT32 l_nb_code_blocks;
    opj_tcd_band_t *l_band = 0;
    opj_tcd_cblk_dec_t* l_cblk = 0;
    opj_tcd_resolution_t* l_res =
        &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];

    OPJ_ARG_NOT_USED(p_t2);
    OPJ_ARG_NOT_USED(pack_info);

    *p_data_read = 0;
    l_band = l_res->bands;

    for (bandno = 0; bandno < l_res->numbands; ++bandno) {
        opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];

        if ((l_band->x1 - l_band->x0 == 0) || (l_band->y1 - l_band->y0 == 0)) {
            ++l_band;
            continue;
        }

        l_nb_code_blocks = l_prc->cw * l_prc->ch;
        l_cblk = l_prc->cblks.dec;

        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
            opj_tcd_seg_t *l_seg = 0;

            if (!l_cblk->numnewpasses) {

                ++l_cblk;
                continue;
            }

            if (!l_cblk->numsegs) {
                l_seg = l_cblk->segs;
                ++l_cblk->numsegs;
            } else {
                l_seg = &l_cblk->segs[l_cblk->numsegs - 1];

                if (l_seg->numpasses == l_seg->maxpasses) {
                    ++l_seg;
                    ++l_cblk->numsegs;
                }
            }

            do {

                if (((*p_data_read + l_seg->newlen) < (*p_data_read)) ||
                        ((*p_data_read + l_seg->newlen) > var_54)) {
                    opj_event_msg(p_manager, EVT_ERROR,
                                  "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
                                  l_seg->newlen, var_54, cblkno, p_pi->precno, bandno, p_pi->resno,
                                  p_pi->compno);
                    return OPJ_FALSE;
                }

                opj_null_jas_fprintf(stderr, "p_data_read (%d) newlen (%d) \n", *p_data_read,
                            l_seg->newlen);
                *(p_data_read) += l_seg->newlen;

                l_seg->numpasses += l_seg->numnewpasses;
                l_cblk->numnewpasses -= l_seg->numnewpasses;
                if (l_cblk->numnewpasses > 0) {
                    ++l_seg;
                    ++l_cblk->numsegs;
                }
            } while (l_cblk->numnewpasses > 0);

            ++l_cblk;
        }

        ++l_band;
    }

    return var_56;
}


static OPJ_BOOL fn_54(opj_tcd_cblk_dec_t* cblk,
                                OPJ_UINT32 var_56,
                                OPJ_UINT32 var_56,
                                OPJ_UINT32 var_56)
{
    opj_tcd_seg_t* seg = 0;
    OPJ_UINT32 var_55 = var_56 + 1;

    if (var_55 > cblk->m_current_max_segs) {
        opj_tcd_seg_t* new_segs;
        OPJ_UINT32 var_56 = cblk->m_current_max_segs +
                                          OPJ_J2K_DEFAULT_NB_SEGS;

        new_segs = (opj_tcd_seg_t*) opj_realloc(cblk->segs,
                                                var_56 * sizeof(opj_tcd_seg_t));
        if (! new_segs) {

            return OPJ_FALSE;
        }
        cblk->segs = new_segs;
        memset(new_segs + cblk->m_current_max_segs,
               0, OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));
        cblk->m_current_max_segs = var_56;
    }

    seg = &cblk->segs[var_56];
    opj_tcd_reinit_segment(seg);

    if (var_56 & J2K_CCP_CBLKSTY_TERMALL) {
        seg->maxpasses = 1;
    } else if (var_56 & J2K_CCP_CBLKSTY_LAZY) {
        if (var_56) {
            seg->maxpasses = 10;
        } else {
            seg->maxpasses = (((seg - 1)->maxpasses == 1) ||
                              ((seg - 1)->maxpasses == 10)) ? 2 : 1;
        }
    } else {




        seg->maxpasses = 109;
    }

    return var_56;
}
