







static int le_gd, le_gd_font;

int fn_0(int var_70, int var_70);

static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS);


static gdImagePtr fn_51 (zval **Data, char *tn, gdImagePtr (*ioctx_func_p)() var_61);
static void fn_51(INTERNAL_FUNCTION_PARAMETERS, int var_70, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)());
static void fn_52(INTERNAL_FUNCTION_PARAMETERS, int var_70, char *tn, void (*func_p)());
static int fn_51(char data[8]);
static void fn_70(INTERNAL_FUNCTION_PARAMETERS, int var_70);
static void fn_68(gdImagePtr var_70, gdIOCtx *out, int var_71);


ZEND_BEGIN_ARG_INFO(arginfo_gd_info, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageloadfont, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetstyle, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, styles)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatetruecolor, 0)
 ZEND_ARG_INFO(0, x_size)
 ZEND_ARG_INFO(0, y_size)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageistruecolor, 0)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagetruecolortopalette, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, ditherFlag)
 ZEND_ARG_INFO(0, colorsWanted)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagepalettetotruecolor, 0)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolormatch, 0)
 ZEND_ARG_INFO(0, im1)
 ZEND_ARG_INFO(0, im2)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetthickness, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, thickness)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilledellipse, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, cx)
 ZEND_ARG_INFO(0, cy)
 ZEND_ARG_INFO(0, w)
 ZEND_ARG_INFO(0, h)
 ZEND_ARG_INFO(0, var_71)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilledarc, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, cx)
 ZEND_ARG_INFO(0, cy)
 ZEND_ARG_INFO(0, w)
 ZEND_ARG_INFO(0, h)
 ZEND_ARG_INFO(0, s)
 ZEND_ARG_INFO(0, e)
 ZEND_ARG_INFO(0, col)
 ZEND_ARG_INFO(0, style)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagealphablending, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, blend)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesavealpha, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, save)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagelayereffect, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, effect)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorallocatealpha, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, var_56)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorresolvealpha, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, var_56)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorclosestalpha, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, var_56)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorexactalpha, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, var_56)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopyresampled, 0)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, dst_w)
 ZEND_ARG_INFO(0, dst_h)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagerotate, 0, 0, 3)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, angle)
 ZEND_ARG_INFO(0, bgdcolor)
 ZEND_ARG_INFO(0, var_48)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesettile, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, tile)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetbrush, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, brush)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreate, 0)
 ZEND_ARG_INFO(0, x_size)
 ZEND_ARG_INFO(0, y_size)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagetypes, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromstring, 0)
 ZEND_ARG_INFO(0, image)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgif, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromxbm, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()







ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromwbmp, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgd, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgd2, 0)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecreatefromgd2part, 0)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, srcX)
 ZEND_ARG_INFO(0, srcY)
 ZEND_ARG_INFO(0, width)
 ZEND_ARG_INFO(0, height)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagexbm, 0, 0, 2)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, foreground)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegif, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagewbmp, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, foreground)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegd, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, filename)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagegd2, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, chunk_size)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagedestroy, 0)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorallocate, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagepalettecopy, 0)
 ZEND_ARG_INFO(0, dst)
 ZEND_ARG_INFO(0, src)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorat, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorclosest, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorclosesthwb, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolordeallocate, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorresolve, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorexact, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagecolorset, 0, 0, 5)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_71)
 ZEND_ARG_INFO(0, red)
 ZEND_ARG_INFO(0, green)
 ZEND_ARG_INFO(0, blue)
 ZEND_ARG_INFO(0, var_56)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorsforindex, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagegammacorrect, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, inputgamma)
 ZEND_ARG_INFO(0, outputgamma)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetpixel, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageline, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, x1)
 ZEND_ARG_INFO(0, y1)
 ZEND_ARG_INFO(0, x2)
 ZEND_ARG_INFO(0, y2)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagedashedline, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, x1)
 ZEND_ARG_INFO(0, y1)
 ZEND_ARG_INFO(0, x2)
 ZEND_ARG_INFO(0, y2)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagerectangle, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, x1)
 ZEND_ARG_INFO(0, y1)
 ZEND_ARG_INFO(0, x2)
 ZEND_ARG_INFO(0, y2)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilledrectangle, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, x1)
 ZEND_ARG_INFO(0, y1)
 ZEND_ARG_INFO(0, x2)
 ZEND_ARG_INFO(0, y2)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagearc, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, cx)
 ZEND_ARG_INFO(0, cy)
 ZEND_ARG_INFO(0, w)
 ZEND_ARG_INFO(0, h)
 ZEND_ARG_INFO(0, s)
 ZEND_ARG_INFO(0, e)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageellipse, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, cx)
 ZEND_ARG_INFO(0, cy)
 ZEND_ARG_INFO(0, w)
 ZEND_ARG_INFO(0, h)
 ZEND_ARG_INFO(0, var_71)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilltoborder, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, border)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefill, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecolorstotal, 0)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagecolortransparent, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imageinterlace, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, interlace)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagepolygon, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, points)
 ZEND_ARG_INFO(0, num_pos)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefilledpolygon, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, points)
 ZEND_ARG_INFO(0, num_pos)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefontwidth, 0)
 ZEND_ARG_INFO(0, font)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagefontheight, 0)
 ZEND_ARG_INFO(0, font)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagechar, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, font)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_65)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecharup, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, font)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_65)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagestring, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, font)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, str)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagestringup, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, font)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, str)
 ZEND_ARG_INFO(0, col)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopy, 0)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopymerge, 0)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
 ZEND_ARG_INFO(0, pct)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopymergegray, 0)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
 ZEND_ARG_INFO(0, pct)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecopyresized, 0)
 ZEND_ARG_INFO(0, dst_im)
 ZEND_ARG_INFO(0, src_im)
 ZEND_ARG_INFO(0, dst_x)
 ZEND_ARG_INFO(0, dst_y)
 ZEND_ARG_INFO(0, src_x)
 ZEND_ARG_INFO(0, src_y)
 ZEND_ARG_INFO(0, dst_w)
 ZEND_ARG_INFO(0, dst_h)
 ZEND_ARG_INFO(0, src_w)
 ZEND_ARG_INFO(0, src_h)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesx, 0)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesy, 0)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_image2wbmp, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, filename)
 ZEND_ARG_INFO(0, var_71)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagefilter, 0, 0, 2)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, filtertype)
 ZEND_ARG_INFO(0, arg1)
 ZEND_ARG_INFO(0, arg2)
 ZEND_ARG_INFO(0, arg3)
 ZEND_ARG_INFO(0, arg4)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageconvolution, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, matrix3x3)
 ZEND_ARG_INFO(0, div)
 ZEND_ARG_INFO(0, offset)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageflip, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_71)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagecrop, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, rect)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagecropauto, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_71)
 ZEND_ARG_INFO(0, var_71)
 ZEND_ARG_INFO(0, var_71)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imagescale, 0, 0, 2)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, new_width)
 ZEND_ARG_INFO(0, new_height)
 ZEND_ARG_INFO(0, var_71)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imageaffine, 0, 0, 2)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, affine)
 ZEND_ARG_INFO(0, clip)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_imageaffinematrixget, 0, 0, 1)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imageaffinematrixconcat, 0)
 ZEND_ARG_INFO(0, m1)
 ZEND_ARG_INFO(0, m2)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO(arginfo_imagesetinterpolation, 0)
 ZEND_ARG_INFO(0, var_76)
 ZEND_ARG_INFO(0, var_76)
ZEND_END_ARG_INFO()





const zend_function_entry gd_functions[] = {
 PHP_FE(gd_info, arginfo_gd_info)
 PHP_FE(imagearc, arginfo_imagearc)
 PHP_FE(imageellipse, arginfo_imageellipse)
 PHP_FE(imagechar, arginfo_imagechar)
 PHP_FE(imagecharup, arginfo_imagecharup)
 PHP_FE(imagecolorat, arginfo_imagecolorat)
 PHP_FE(imagecolorallocate, arginfo_imagecolorallocate)
 PHP_FE(imagepalettecopy, arginfo_imagepalettecopy)
 PHP_FE(imagecreatefromstring, arginfo_imagecreatefromstring)
 PHP_FE(imagecolorclosest, arginfo_imagecolorclosest)
 PHP_FE(imagecolorclosesthwb, arginfo_imagecolorclosesthwb)
 PHP_FE(imagecolordeallocate, arginfo_imagecolordeallocate)
 PHP_FE(imagecolorresolve, arginfo_imagecolorresolve)
 PHP_FE(imagecolorexact, arginfo_imagecolorexact)
 PHP_FE(imagecolorset, arginfo_imagecolorset)
 PHP_FE(imagecolortransparent, arginfo_imagecolortransparent)
 PHP_FE(imagecolorstotal, arginfo_imagecolorstotal)
 PHP_FE(imagecolorsforindex, arginfo_imagecolorsforindex)
 PHP_FE(imagecopy, arginfo_imagecopy)
 PHP_FE(imagecopymerge, arginfo_imagecopymerge)
 PHP_FE(imagecopymergegray, arginfo_imagecopymergegray)
 PHP_FE(imagecopyresized, arginfo_imagecopyresized)
 PHP_FE(imagecreate, arginfo_imagecreate)
 PHP_FE(imagecreatetruecolor, arginfo_imagecreatetruecolor)
 PHP_FE(imageistruecolor, arginfo_imageistruecolor)
 PHP_FE(imagetruecolortopalette, arginfo_imagetruecolortopalette)
 PHP_FE(imagepalettetotruecolor, arginfo_imagepalettetotruecolor)
 PHP_FE(imagesetthickness, arginfo_imagesetthickness)
 PHP_FE(imagefilledarc, arginfo_imagefilledarc)
 PHP_FE(imagefilledellipse, arginfo_imagefilledellipse)
 PHP_FE(imagealphablending, arginfo_imagealphablending)
 PHP_FE(imagesavealpha, arginfo_imagesavealpha)
 PHP_FE(imagecolorallocatealpha, arginfo_imagecolorallocatealpha)
 PHP_FE(imagecolorresolvealpha, arginfo_imagecolorresolvealpha)
 PHP_FE(imagecolorclosestalpha, arginfo_imagecolorclosestalpha)
 PHP_FE(imagecolorexactalpha, arginfo_imagecolorexactalpha)
 PHP_FE(imagecopyresampled, arginfo_imagecopyresampled)






 PHP_FE(imagerotate, arginfo_imagerotate)
 PHP_FE(imageflip, arginfo_imageflip)




 PHP_FE(imagecrop, arginfo_imagecrop)
 PHP_FE(imagecropauto, arginfo_imagecropauto)
 PHP_FE(imagescale, arginfo_imagescale)
 PHP_FE(imageaffine, arginfo_imageaffine)
 PHP_FE(imageaffinematrixconcat, arginfo_imageaffinematrixconcat)
 PHP_FE(imageaffinematrixget, arginfo_imageaffinematrixget)
 PHP_FE(imagesetinterpolation, arginfo_imagesetinterpolation)
 PHP_FE(imagesettile, arginfo_imagesettile)
 PHP_FE(imagesetbrush, arginfo_imagesetbrush)
 PHP_FE(imagesetstyle, arginfo_imagesetstyle)







 PHP_FE(imagecreatefromgif, arginfo_imagecreatefromgif)



 PHP_FE(imagecreatefromwbmp, arginfo_imagecreatefromwbmp)
 PHP_FE(imagecreatefromxbm, arginfo_imagecreatefromxbm)



 PHP_FE(imagecreatefromgd, arginfo_imagecreatefromgd)
 PHP_FE(imagecreatefromgd2, arginfo_imagecreatefromgd2)
 PHP_FE(imagecreatefromgd2part, arginfo_imagecreatefromgd2part)






 PHP_FE(imagegif, arginfo_imagegif)



 PHP_FE(imagewbmp, arginfo_imagewbmp)
 PHP_FE(imagegd, arginfo_imagegd)
 PHP_FE(imagegd2, arginfo_imagegd2)

 PHP_FE(imagedestroy, arginfo_imagedestroy)
 PHP_FE(imagegammacorrect, arginfo_imagegammacorrect)
 PHP_FE(imagefill, arginfo_imagefill)
 PHP_FE(imagefilledpolygon, arginfo_imagefilledpolygon)
 PHP_FE(imagefilledrectangle, arginfo_imagefilledrectangle)
 PHP_FE(imagefilltoborder, arginfo_imagefilltoborder)
 PHP_FE(imagefontwidth, arginfo_imagefontwidth)
 PHP_FE(imagefontheight, arginfo_imagefontheight)
 PHP_FE(imageinterlace, arginfo_imageinterlace)
 PHP_FE(imageline, arginfo_imageline)
 PHP_FE(imageloadfont, arginfo_imageloadfont)
 PHP_FE(imagepolygon, arginfo_imagepolygon)
 PHP_FE(imagerectangle, arginfo_imagerectangle)
 PHP_FE(imagesetpixel, arginfo_imagesetpixel)
 PHP_FE(imagestring, arginfo_imagestring)
 PHP_FE(imagestringup, arginfo_imagestringup)
 PHP_FE(imagesx, arginfo_imagesx)
 PHP_FE(imagesy, arginfo_imagesy)
 PHP_FE(imagedashedline, arginfo_imagedashedline)

 PHP_FE(imagetypes, arginfo_imagetypes)







 PHP_FE(image2wbmp, arginfo_image2wbmp)
 PHP_FE(imagelayereffect, arginfo_imagelayereffect)
 PHP_FE(imagexbm, arginfo_imagexbm)

 PHP_FE(imagecolormatch, arginfo_imagecolormatch)


 PHP_FE(imagefilter, arginfo_imagefilter)
 PHP_FE(imageconvolution, arginfo_imageconvolution)

 PHP_FE_END
};


zend_module_entry var_35 = {
 STANDARD_MODULE_HEADER,
 "gd",
 gd_functions,
 PHP_MINIT(gd),



 NULL,

 NULL,



 NULL,

 PHP_MINFO(gd),
 NO_VERSION_YET,
 STANDARD_MODULE_PROPERTIES
};






PHP_INI_BEGIN()
 PHP_INI_ENTRY("gd.jpeg_ignore_warning", "0", PHP_INI_ALL, NULL)
PHP_INI_END()




static void fn_36(zend_rsrc_list_entry *rsrc var_61)
{
 gdImageDestroy((gdImagePtr) rsrc->ptr);
}




static void fn_37(zend_rsrc_list_entry *rsrc var_61)
{
 gdFontPtr var_56 = (gdFontPtr) rsrc->ptr;

 if (var_56->data) {
  efree(var_56->data);
 }

 efree(var_56);
}





void fn_39(int var_76, const char *format, va_list var_41)
{
 TSRMLS_FETCH();

 switch (var_76) {
  case GD_DEBUG:
  case GD_INFO:
  case GD_NOTICE:
   var_76 = E_NOTICE;
   break;
  case GD_WARNING:
   var_76 = E_WARNING;
   break;
  default:
   var_76 = E_ERROR;
 }
 php_verror(NULL, "", var_76, format, var_41 TSRMLS_CC);
}

PHP_MINIT_FUNCTION(gd)
{
 le_gd = zend_register_list_destructors_ex(php_free_gd_image, NULL, "gd", module_number);
 le_gd_font = zend_register_list_destructors_ex(php_free_gd_font, NULL, "gd font", module_number);

 gdSetErrorMethod(php_gd_error_method);

 REGISTER_INI_ENTRIES();

 REGISTER_LONG_CONSTANT("IMG_GIF", 1, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_JPG", 2, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_JPEG", 2, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_PNG", 4, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_WBMP", 8, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_XPM", 16, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_WEBP", 32, CONST_CS | CONST_PERSISTENT);


 REGISTER_LONG_CONSTANT("IMG_COLOR_TILED", gdTiled, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_COLOR_STYLED", gdStyled, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_COLOR_BRUSHED", gdBrushed, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_COLOR_STYLEDBRUSHED", gdStyledBrushed, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_COLOR_TRANSPARENT", gdTransparent, CONST_CS | CONST_PERSISTENT);


 REGISTER_LONG_CONSTANT("IMG_ARC_ROUNDED", gdArc, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_ARC_PIE", gdPie, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_ARC_CHORD", gdChord, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_ARC_NOFILL", gdNoFill, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_ARC_EDGED", gdEdged, CONST_CS | CONST_PERSISTENT);


 REGISTER_LONG_CONSTANT("IMG_GD2_RAW", GD2_FMT_RAW, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_GD2_COMPRESSED", GD2_FMT_COMPRESSED, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FLIP_HORIZONTAL", GD_FLIP_HORINZONTAL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FLIP_VERTICAL", GD_FLIP_VERTICAL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FLIP_BOTH", GD_FLIP_BOTH, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_EFFECT_REPLACE", gdEffectReplace, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_EFFECT_ALPHABLEND", gdEffectAlphaBlend, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_EFFECT_NORMAL", gdEffectNormal, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_EFFECT_OVERLAY", gdEffectOverlay, CONST_CS | CONST_PERSISTENT);

 REGISTER_LONG_CONSTANT("IMG_CROP_DEFAULT", GD_CROP_DEFAULT, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_TRANSPARENT", GD_CROP_TRANSPARENT, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_BLACK", GD_CROP_BLACK, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_WHITE", GD_CROP_WHITE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_SIDES", GD_CROP_SIDES, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CROP_THRESHOLD", GD_CROP_THRESHOLD, CONST_CS | CONST_PERSISTENT);


 REGISTER_LONG_CONSTANT("IMG_BELL", GD_BELL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BESSEL", GD_BESSEL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BILINEAR_FIXED", var_76, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BICUBIC", GD_BICUBIC, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BICUBIC_FIXED", GD_BICUBIC_FIXED, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BLACKMAN", GD_BLACKMAN, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BOX", GD_BOX, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_BSPLINE", GD_BSPLINE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_CATMULLROM", GD_CATMULLROM, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_GAUSSIAN", GD_GAUSSIAN, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_GENERALIZED_CUBIC", GD_GENERALIZED_CUBIC, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_HERMITE", GD_HERMITE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_HAMMING", GD_HAMMING, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_HANNING", GD_HANNING, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_MITCHELL", GD_MITCHELL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_POWER", GD_POWER, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_QUADRATIC", GD_QUADRATIC, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_SINC", GD_SINC, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_NEAREST_NEIGHBOUR", GD_NEAREST_NEIGHBOUR, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_WEIGHTED4", GD_WEIGHTED4, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_TRIANGLE", GD_TRIANGLE, CONST_CS | CONST_PERSISTENT);

 REGISTER_LONG_CONSTANT("IMG_AFFINE_TRANSLATE", GD_AFFINE_TRANSLATE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_AFFINE_SCALE", GD_AFFINE_SCALE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_AFFINE_ROTATE", GD_AFFINE_ROTATE, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_AFFINE_SHEAR_HORIZONTAL", GD_AFFINE_SHEAR_HORIZONTAL, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_AFFINE_SHEAR_VERTICAL", GD_AFFINE_SHEAR_VERTICAL, CONST_CS | CONST_PERSISTENT);




 REGISTER_LONG_CONSTANT("GD_BUNDLED", 0, CONST_CS | CONST_PERSISTENT);



 REGISTER_LONG_CONSTANT("IMG_FILTER_NEGATE", 0, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_GRAYSCALE", 1, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_BRIGHTNESS", 2, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_CONTRAST", 3, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_COLORIZE", 4, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_EDGEDETECT", 5, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_GAUSSIAN_BLUR", 7, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_SELECTIVE_BLUR", 8, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_EMBOSS", 6, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_MEAN_REMOVAL", 9, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_SMOOTH", 10, CONST_CS | CONST_PERSISTENT);
 REGISTER_LONG_CONSTANT("IMG_FILTER_PIXELATE", 11, CONST_CS | CONST_PERSISTENT);

 return SUCCESS;
}

PHP_MINFO_FUNCTION(gd)
{
 php_info_print_table_start();
 php_info_print_table_row(2, "GD Support", "enabled");






 php_info_print_table_row(2, "GD headers Version", GD_VERSION_STRING);

 php_info_print_table_row(2, "GIF Read Support", "enabled");
 php_info_print_table_row(2, "GIF Create Support", "enabled");

 php_info_print_table_row(2, "WBMP Support", "enabled");

 php_info_print_table_row(2, "XBM Support", "enabled");






 php_info_print_table_end();
 DISPLAY_INI_ENTRIES();
}




PHP_FUNCTION(gd_info)
{
 if (zend_parse_parameters_none() == FAILURE) {
  RETURN_FALSE;
 }

 array_init(return_value);

 add_assoc_string(return_value, "GD Version", GD_VERSION_STRING, 1);

 add_assoc_bool(return_value, "FreeType Support", 0);





 add_assoc_bool(return_value, "T1Lib Support", 0);

 add_assoc_bool(return_value, "GIF Read Support", 1);
 add_assoc_bool(return_value, "GIF Create Support", 1);



 add_assoc_bool(return_value, "JPEG Support", 0);




 add_assoc_bool(return_value, "PNG Support", 0);

 add_assoc_bool(return_value, "WBMP Support", 1);



 add_assoc_bool(return_value, "XPM Support", 0);

 add_assoc_bool(return_value, "XBM Support", 1);



 add_assoc_bool(return_value, "WebP Support", 0);




 add_assoc_bool(return_value, "JIS-mapped Japanese Font Support", 0);

}



PHP_GD_API int fn_42(void)
{
 return le_gd;
}






PHP_FUNCTION(imageloadfont)
{
 char *file;
 int file_name, var_45 = sizeof(gdFont) - sizeof(char *);
 int ind, body_size, var_46 = 0, var_70, i, body_size_check;
 gdFontPtr font;
 php_stream *stream;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "p", &file, &file_name) == FAILURE) {
  return;
 }

 stream = php_stream_open_wrapper(file, "rb", IGNORE_PATH | IGNORE_URL_WIN | REPORT_ERRORS, NULL);
 if (stream == NULL) {
  RETURN_FALSE;
 }

 font = (gdFontPtr) emalloc(sizeof(gdFont));
 var_70 = 0;
 while (var_70 < var_45 && (var_46 = php_stream_read(stream, (char*)&font[var_70], var_45 - var_70))) {
  var_70 += var_46;
 }

 if (!var_46) {
  efree(font);
  if (php_stream_eof(stream)) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "End of file while reading header");
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading header");
  }
  php_stream_close(stream);
  RETURN_FALSE;
 }
 i = php_stream_tell(stream);
 php_stream_seek(stream, 0, SEEK_END);
 body_size_check = php_stream_tell(stream) - var_45;
 php_stream_seek(stream, i, SEEK_SET);

 body_size = font->w * font->h * font->nchars;
 if (body_size != body_size_check) {
  font->w = (((font->w & 0xff000000) >> 24) | ((font->w & 0x00ff0000) >> 8) | ((font->w & 0x0000ff00) << 8) | ((font->w & 0x000000ff) << 24));
  font->h = (((font->h & 0xff000000) >> 24) | ((font->h & 0x00ff0000) >> 8) | ((font->h & 0x0000ff00) << 8) | ((font->h & 0x000000ff) << 24));
  font->nchars = (((font->nchars & 0xff000000) >> 24) | ((font->nchars & 0x00ff0000) >> 8) | ((font->nchars & 0x0000ff00) << 8) | ((font->nchars & 0x000000ff) << 24));
  body_size = font->w * font->h * font->nchars;
 }

 if (overflow2(font->nchars, font->h) || overflow2(font->nchars * font->h, font->w )) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error reading font, invalid font header");
  efree(font);
  php_stream_close(stream);
  RETURN_FALSE;
 }

 if (body_size != body_size_check) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error reading font");
  fn_45(font);
  php_stream_close(stream);
  RETURN_FALSE;
 }

 font->data = emalloc(body_size);
 var_70 = 0;
 while (var_70 < body_size && (var_46 = php_stream_read(stream, &font->data[var_70], body_size - var_70))) {
  var_70 += var_46;
 }

 if (!var_46) {
  efree(font->data);
  efree(font);
  if (php_stream_eof(stream)) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "End of file while reading body");
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error while reading body");
  }
  php_stream_close(stream);
  RETURN_FALSE;
 }
 php_stream_close(stream);





 ind = 5 + zend_list_insert(font, le_gd_font TSRMLS_CC);

 RETURN_LONG(ind);
}




PHP_FUNCTION(imagesetstyle)
{
 zval *IM, *styles;
 gdImagePtr var_76;
 int * stylearr;
 int index;
 HashPosition pos;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ra", &IM, &styles) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);


 stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

 zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

 for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos)) {
  zval ** item;

  if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
   break;
  }

  if (Z_TYPE_PP(item) != IS_LONG) {
   zval lval;
   lval = **item;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   stylearr[index++] = Z_LVAL(lval);
  } else {
   stylearr[index++] = Z_LVAL_PP(item);
  }
 }

 gdImageSetStyle(var_76, stylearr, index);

 efree(stylearr);

 RETURN_TRUE;
}




PHP_FUNCTION(imagecreatetruecolor)
{
 long x_size, y_size;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &x_size, &y_size) == FAILURE) {
  return;
 }

 if (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid image dimensions");
  RETURN_FALSE;
 }

 var_76 = gdImageCreateTrueColor(x_size, y_size);

 if (!var_76) {
  RETURN_FALSE;
 }

 ZEND_REGISTER_RESOURCE(return_value, var_76, le_gd);
}




PHP_FUNCTION(imageistruecolor)
{
 zval *IM;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_BOOL(var_76->trueColor);
}




PHP_FUNCTION(imagetruecolortopalette)
{
 zval *IM;
 zend_bool dither;
 long ncolors;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rbl", &IM, &dither, &ncolors) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (ncolors <= 0) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number of colors has to be greater than zero");
  RETURN_FALSE;
 }
 gdImageTrueColorToPalette(var_76, dither, ncolors);

 RETURN_TRUE;
}






PHP_FUNCTION(imagepalettetotruecolor)
{
 zval *IM;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (gdImagePaletteToTrueColor(var_76) == 0) {
  RETURN_FALSE;
 }

 RETURN_TRUE;
}




PHP_FUNCTION(imagecolormatch)
{
 zval *IM1, *IM2;
 gdImagePtr im1, im2;
 int result;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rr", &IM1, &IM2) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im1, gdImagePtr, &IM1, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im2, gdImagePtr, &IM2, -1, "Image", le_gd);

 result = gdImageColorMatch(im1, im2);
 switch (result) {
  case -1:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Image1 must be TrueColor" );
   RETURN_FALSE;
   break;
  case -2:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Image2 must be Palette" );
   RETURN_FALSE;
   break;
  case -3:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Image1 and Image2 must be the same size" );
   RETURN_FALSE;
   break;
  case -4:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Image2 must have at least one color" );
   RETURN_FALSE;
   break;
 }

 RETURN_TRUE;
}




PHP_FUNCTION(imagesetthickness)
{
 zval *IM;
 long thick;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &thick) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 gdImageSetThickness(var_76, thick);

 RETURN_TRUE;
}




PHP_FUNCTION(imagefilledellipse)
{
 zval *IM;
 long cx, cy, w, h, var_71;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &cx, &cy, &w, &h, &var_71) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 gdImageFilledEllipse(var_76, cx, cy, w, h, var_71);

 RETURN_TRUE;
}




PHP_FUNCTION(imagefilledarc)
{
 zval *IM;
 long cx, cy, w, h, ST, E, col, style;
 gdImagePtr var_76;
 int e, st;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllllllll", &IM, &cx, &cy, &w, &h, &ST, &E, &col, &style) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 e = E;
 if (e < 0) {
  e %= 360;
 }

 st = ST;
 if (st < 0) {
  st %= 360;
 }

 gdImageFilledArc(var_76, cx, cy, w, h, st, e, col, style);

 RETURN_TRUE;
}




PHP_FUNCTION(imagealphablending)
{
 zval *IM;
 zend_bool blend;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rb", &IM, &blend) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageAlphaBlending(var_76, blend);

 RETURN_TRUE;
}




PHP_FUNCTION(imagesavealpha)
{
 zval *IM;
 zend_bool save;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rb", &IM, &save) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageSaveAlpha(var_76, save);

 RETURN_TRUE;
}




PHP_FUNCTION(imagelayereffect)
{
 zval *IM;
 long effect;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &effect) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageAlphaBlending(var_76, effect);

 RETURN_TRUE;
}




PHP_FUNCTION(imagecolorallocatealpha)
{
 zval *IM;
 long red, green, blue, var_56;
 gdImagePtr var_76;
 int var_56 = -1;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &red, &green, &blue, &var_56) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 var_56 = gdImageColorAllocateAlpha(var_76, red, green, blue, var_56);
 if (var_56 < 0) {
  RETURN_FALSE;
 }
 RETURN_LONG((long)var_56);
}




PHP_FUNCTION(imagecolorresolvealpha)
{
 zval *IM;
 long red, green, blue, var_56;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &red, &green, &blue, &var_56) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorResolveAlpha(var_76, red, green, blue, var_56));
}




PHP_FUNCTION(imagecolorclosestalpha)
{
 zval *IM;
 long red, green, blue, var_56;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &red, &green, &blue, &var_56) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorClosestAlpha(var_76, red, green, blue, var_56));
}




PHP_FUNCTION(imagecolorexactalpha)
{
 zval *IM;
 long red, green, blue, var_56;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &red, &green, &blue, &var_56) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorExactAlpha(var_76, red, green, blue, var_56));
}




PHP_FUNCTION(imagecopyresampled)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY, DW, DH;
 gdImagePtr im_dst, var_71;
 int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrllllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;
 dstH = DH;
 dstW = DW;

 gdImageCopyResampled(im_dst, var_71, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);

 RETURN_TRUE;
}

PHP_FUNCTION(imagerotate)
{
 zval *SIM;
 gdImagePtr im_dst, var_71;
 double degrees;
 long var_71;
 long var_48 = 0;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rdl|l", &SIM, &degrees, &var_71, &var_48) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);

 im_dst = gdImageRotateInterpolated(var_71, (const float)degrees, var_71);

 if (im_dst != NULL) {
  ZEND_REGISTER_RESOURCE(return_value, im_dst, le_gd);
 } else {
  RETURN_FALSE;
 }
}




PHP_FUNCTION(imagesettile)
{
 zval *IM, *TILE;
 gdImagePtr var_76, tile;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rr", &IM, &TILE) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, "Image", le_gd);

 gdImageSetTile(var_76, tile);

 RETURN_TRUE;
}




PHP_FUNCTION(imagesetbrush)
{
 zval *IM, *TILE;
 gdImagePtr var_76, tile;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rr", &IM, &TILE) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, "Image", le_gd);

 gdImageSetBrush(var_76, tile);

 RETURN_TRUE;
}




PHP_FUNCTION(imagecreate)
{
 long x_size, y_size;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &x_size, &y_size) == FAILURE) {
  return;
 }

 if (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid image dimensions");
  RETURN_FALSE;
 }

 var_76 = gdImageCreate(x_size, y_size);

 if (!var_76) {
  RETURN_FALSE;
 }

 ZEND_REGISTER_RESOURCE(return_value, var_76, le_gd);
}




PHP_FUNCTION(imagetypes)
{
 int var_49=0;
 var_49 = 1;






 var_49 |= 8;







 if (zend_parse_parameters_none() == FAILURE) {
  return;
 }

 RETURN_LONG(var_49);
}





static int fn_49(gdIOCtx *ctx)
{
 int i, var_51 = 0;

 do {
  i = (ctx->getC)(ctx);
  if (i < 0) {
   return -1;
  }
  var_51 = (var_51 << 7) | (i & 0x7f);
 } while (i & 0x80);

 return var_51;
}




static const char php_sig_gd2[3] = {'g', 'd', '2'};

static int fn_51 (char data[8])
{


 if (data == NULL) {
  return -1;
 }

 if (!memcmp(data, php_sig_gd2, 3)) {
  return PHP_GDIMG_TYPE_GD2;
 } else if (!memcmp(data, php_sig_jpg, 3)) {
  return PHP_GDIMG_TYPE_JPG;
 } else if (!memcmp(data, php_sig_png, 3)) {
  if (!memcmp(data, php_sig_png, 8)) {
   return PHP_GDIMG_TYPE_PNG;
  }
 } else if (!memcmp(data, php_sig_gif, 3)) {
  return PHP_GDIMG_TYPE_GIF;
 }
 else {
  gdIOCtx *io_ctx;
  io_ctx = gdNewDynamicCtxEx(8, data, 0);
  if (io_ctx) {
   if (_php_ctx_getmbi(io_ctx) == 0 && _php_ctx_getmbi(io_ctx) >= 0) {
    io_ctx->gd_free(io_ctx);
    return PHP_GDIMG_TYPE_WBM;
   } else {
    io_ctx->gd_free(io_ctx);
   }
  }
 }
 return -1;
}




gdImagePtr fn_51(zval **data, char *tn, gdImagePtr (*ioctx_func_p)() var_61)
{
 gdImagePtr var_76;
 gdIOCtx *io_ctx;

 io_ctx = gdNewDynamicCtxEx(Z_STRLEN_PP(data), Z_STRVAL_PP(data), 0);

 if (!io_ctx) {
  return NULL;
 }

 var_76 = (*ioctx_func_p)(io_ctx);
 if (!var_76) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Passed data is not in '%s' format", tn);
  io_ctx->gd_free(io_ctx);
  return NULL;
 }

 io_ctx->gd_free(io_ctx);

 return var_76;
}




PHP_FUNCTION(imagecreatefromstring)
{
 zval **data;
 gdImagePtr var_76;
 int imtype;
 char sig[8];

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Z", &data) == FAILURE) {
  return;
 }

 convert_to_string_ex(data);
 if (Z_STRLEN_PP(data) < 8) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Empty string or invalid image");
  RETURN_FALSE;
 }

 memcpy(sig, Z_STRVAL_PP(data), 8);

 imtype = _php_image_type(sig);

 switch (imtype) {
  case PHP_GDIMG_TYPE_JPG:



   php_error_docref(NULL TSRMLS_CC, E_WARNING, "No JPEG support in this PHP build");
   RETURN_FALSE;

   break;

  case PHP_GDIMG_TYPE_PNG:



   php_error_docref(NULL TSRMLS_CC, E_WARNING, "No PNG support in this PHP build");
   RETURN_FALSE;

   break;

  case PHP_GDIMG_TYPE_GIF:
   var_76 = _php_image_create_from_string(data, "GIF", gdImageCreateFromGifCtx TSRMLS_CC);
   break;

  case PHP_GDIMG_TYPE_WBM:
   var_76 = _php_image_create_from_string(data, "WBMP", gdImageCreateFromWBMPCtx TSRMLS_CC);
   break;

  case PHP_GDIMG_TYPE_GD2:
   var_76 = _php_image_create_from_string(data, "GD2", gdImageCreateFromGd2Ctx TSRMLS_CC);
   break;

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Data is not in a recognized format");
   RETURN_FALSE;
 }

 if (!var_76) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Couldn't create GD Image Stream out of Data");
  RETURN_FALSE;
 }

 ZEND_REGISTER_RESOURCE(return_value, var_76, le_gd);
}




static void fn_51(INTERNAL_FUNCTION_PARAMETERS, int var_70, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())
{
 char *file;
 int var_56;
 long srcx, srcy, width, height;
 gdImagePtr var_76 = NULL;
 php_stream *stream;
 FILE * var_56 = NULL;
 long ignore_warning;

 if (var_70 == PHP_GDIMG_TYPE_GD2PART) {
  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "pllll", &file, &var_56, &srcx, &srcy, &width, &height) == FAILURE) {
   return;
  }
  if (width < 1 || height < 1) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Zero width or height not allowed");
   RETURN_FALSE;
  }
 } else {
  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "p", &file, &var_56) == FAILURE) {
   return;
  }
 }


 stream = php_stream_open_wrapper(file, "rb", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);
 if (stream == NULL) {
  RETURN_FALSE;
 }


 if (php_stream_is(stream, PHP_STREAM_IS_STDIO)) {
  if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&var_56, REPORT_ERRORS)) {
   goto out_err;
  }
 } else if (ioctx_func_p) {

  gdIOCtx* io_ctx;
  size_t buff_size;
  char *buff;


  buff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);

  if (!buff_size) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING,"Cannot read image data");
   goto out_err;
  }

  io_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);
  if (!io_ctx) {
   pefree(buff, 1);
   php_error_docref(NULL TSRMLS_CC, E_WARNING,"Cannot allocate GD IO context");
   goto out_err;
  }

  if (var_70 == PHP_GDIMG_TYPE_GD2PART) {
   var_76 = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);
  } else {
   var_76 = (*ioctx_func_p)(io_ctx);
  }
  io_ctx->gd_free(io_ctx);
  pefree(buff, 1);
 }
 else if (php_stream_can_cast(stream, PHP_STREAM_AS_STDIO)) {

  if (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &var_56, REPORT_ERRORS)) {
   goto out_err;
  }
 }

 if (!var_76 && var_56) {
  switch (var_70) {
   case PHP_GDIMG_TYPE_GD2PART:
    var_76 = (*func_p)(var_56, srcx, srcy, width, height);
    break;

   default:
    var_76 = (*func_p)(var_56);
    break;
  }

  fflush(var_56);
 }


 if (var_76) {
  ZEND_REGISTER_RESOURCE(return_value, var_76, le_gd);
  php_stream_close(stream);
  return;
 }

 php_error_docref(NULL TSRMLS_CC, E_WARNING, "'%s' is not a valid %s file", file, tn);
out_err:
 php_stream_close(stream);
 RETURN_FALSE;

}




PHP_FUNCTION(imagecreatefromgif)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, "GIF", gdImageCreateFromGif, gdImageCreateFromGifCtx);
}

PHP_FUNCTION(imagecreatefromxbm)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, "XBM", gdImageCreateFromXbm, NULL);
}

PHP_FUNCTION(imagecreatefromwbmp)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, "WBMP", gdImageCreateFromWBMP, gdImageCreateFromWBMPCtx);
}




PHP_FUNCTION(imagecreatefromgd)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, "GD", gdImageCreateFromGd, gdImageCreateFromGdCtx);
}




PHP_FUNCTION(imagecreatefromgd2)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, "GD2", gdImageCreateFromGd2, gdImageCreateFromGd2Ctx);
}




PHP_FUNCTION(imagecreatefromgd2part)
{
 _php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2PART, "GD2", gdImageCreateFromGd2Part, gdImageCreateFromGd2PartCtx);
}




static void fn_52(INTERNAL_FUNCTION_PARAMETERS, int var_70, char *tn, void (*func_p)())
{
 zval *imgind;
 char *file = NULL;
 long var_56 = 0, var_76 = 0;
 gdImagePtr var_76;
 char *fn = NULL;
 FILE *var_56;
 int var_56 = 0, var_58 = ZEND_NUM_ARGS();
 int var_56 = -1, i, var_56 = 1;





 if (zend_parse_parameters(var_58 TSRMLS_CC, "r|pll", &imgind, &file, &var_56, &var_56, &var_76) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &imgind, -1, "Image", le_gd);

 if (var_58 > 1) {
  fn = file;
  if (var_58 == 3) {
   var_56 = var_56;
  }
  if (var_58 == 4) {
   var_56 = var_76;
  }
 }

 if (var_58 >= 2 && var_56) {
  PHP_GD_CHECK_OPEN_BASEDIR(fn, "Invalid filename");

  var_56 = VCWD_FOPEN(fn, "wb");
  if (!var_56) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' for writing", fn);
   RETURN_FALSE;
  }

  switch (var_70) {
   case PHP_GDIMG_CONVERT_WBM:
    if (var_56 == -1) {
     var_56 = 0;
    } else if (var_56 < 0 || var_56 > 255) {
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid threshold value '%d'. It must be between 0 and 255", var_56);
     var_56 = 0;
    }
    gdImageWBMP(var_76, var_56, var_56);
    break;
   case PHP_GDIMG_TYPE_JPG:
    (*func_p)(var_76, var_56, var_56);
    break;
   case PHP_GDIMG_TYPE_WBM:
    for (i = 0; i < gdImageColorsTotal(var_76); i++) {
     if (gdImageRed(var_76, i) == 0) break;
    }
    (*func_p)(var_76, i, var_56);
    break;
   case PHP_GDIMG_TYPE_GD:
    if (var_76->trueColor){
     gdImageTrueColorToPalette(var_76,1,256);
    }
    (*func_p)(var_76, var_56);
    break;
   case PHP_GDIMG_TYPE_GD2:
    if (var_56 == -1) {
     var_56 = 128;
    }
    (*func_p)(var_76, var_56, var_56, var_56);
    break;
   default:
    if (var_56 == -1) {
     var_56 = 128;
    }
    (*func_p)(var_76, var_56, var_56, var_56);
    break;
  }
  fflush(var_56);
  fclose(var_56);
 } else {
  int var_70;
  FILE *tmp;
  char buf[4096];
  char *path;

  tmp = php_open_temporary_file(NULL, NULL, &path TSRMLS_CC);
  if (tmp == NULL) {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open temporary file");
   RETURN_FALSE;
  }

  switch (var_70) {
   case PHP_GDIMG_CONVERT_WBM:
     if (var_56 == -1) {
       var_56 = 0;
      } else if (var_56 < 0 || var_56 > 255) {
       php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid threshold value '%d'. It must be between 0 and 255", var_56);
      var_56 = 0;
      }
    gdImageWBMP(var_76, var_56, tmp);
    break;
   case PHP_GDIMG_TYPE_JPG:
    (*func_p)(var_76, tmp, var_56);
    break;
   case PHP_GDIMG_TYPE_WBM:
    for (i = 0; i < gdImageColorsTotal(var_76); i++) {
     if (gdImageRed(var_76, i) == 0) {
      break;
     }
    }
    (*func_p)(var_76, var_56, tmp);
    break;
   case PHP_GDIMG_TYPE_GD:
    if (var_76->trueColor) {
     gdImageTrueColorToPalette(var_76,1,256);
    }
    (*func_p)(var_76, tmp);
    break;
   case PHP_GDIMG_TYPE_GD2:
    if (var_56 == -1) {
     var_56 = 128;
    }
    (*func_p)(var_76, tmp, var_56, var_56);
    break;
   default:
    (*func_p)(var_76, tmp);
    break;
  }

  fseek(tmp, 0, SEEK_SET);







  while ((var_70 = fread(buf, 1, sizeof(buf), tmp)) > 0) {
   php_write(buf, var_70 TSRMLS_CC);
  }

  fclose(tmp);
  VCWD_UNLINK((const char *)path);
  efree(path);
 }
 RETURN_TRUE;
}




PHP_FUNCTION(imagexbm)
{
 _php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, "XBM", gdImageXbmCtx);
}




PHP_FUNCTION(imagegif)
{
 _php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, "GIF", gdImageGifCtx);
}

PHP_FUNCTION(imagewbmp)
{
 _php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, "WBMP", gdImageWBMPCtx);
}




PHP_FUNCTION(imagegd)
{
 _php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, "GD", gdImageGd);
}




PHP_FUNCTION(imagegd2)
{
 _php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, "GD2", gdImageGd2);
}




PHP_FUNCTION(imagedestroy)
{
 zval *IM;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 zend_list_delete(Z_LVAL_P(IM));

 RETURN_TRUE;
}





PHP_FUNCTION(imagecolorallocate)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr var_76;
 int var_56 = -1;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 var_56 = gdImageColorAllocate(var_76, red, green, blue);
 if (var_56 < 0) {
  RETURN_FALSE;
 }
 RETURN_LONG(var_56);
}




PHP_FUNCTION(imagepalettecopy)
{
 zval *dstim, *srcim;
 gdImagePtr dst, src;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rr", &dstim, &srcim) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(dst, gdImagePtr, &dstim, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(src, gdImagePtr, &srcim, -1, "Image", le_gd);

 gdImagePaletteCopy(dst, src);
}




PHP_FUNCTION(imagecolorat)
{
 zval *IM;
 long var_76, var_76;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rll", &IM, &var_76, &var_76) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (gdImageTrueColor(var_76)) {
  if (var_76->tpixels && gdImageBoundsSafe(var_76, var_76, var_76)) {
   RETURN_LONG(gdImageTrueColorPixel(var_76, var_76, var_76));
  } else {
   php_error_docref(NULL TSRMLS_CC, E_NOTICE, "%ld,%ld is out of bounds", var_76, var_76);
   RETURN_FALSE;
  }
 } else {
  if (var_76->pixels && gdImageBoundsSafe(var_76, var_76, var_76)) {
   RETURN_LONG(var_76->pixels[var_76][var_76]);
  } else {
   php_error_docref(NULL TSRMLS_CC, E_NOTICE, "%ld,%ld is out of bounds", var_76, var_76);
   RETURN_FALSE;
  }
 }
}




PHP_FUNCTION(imagecolorclosest)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorClosest(var_76, red, green, blue));
}




PHP_FUNCTION(imagecolorclosesthwb)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorClosestHWB(var_76, red, green, blue));
}




PHP_FUNCTION(imagecolordeallocate)
{
 zval *IM;
 long index;
 int col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &index) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);


 if (gdImageTrueColor(var_76)) {
  RETURN_TRUE;
 }

 col = index;

 if (col >= 0 && col < gdImageColorsTotal(var_76)) {
  gdImageColorDeallocate(var_76, col);
  RETURN_TRUE;
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Color index %d out of range", col);
  RETURN_FALSE;
 }
}




PHP_FUNCTION(imagecolorresolve)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorResolve(var_76, red, green, blue));
}




PHP_FUNCTION(imagecolorexact)
{
 zval *IM;
 long red, green, blue;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &red, &green, &blue) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorExact(var_76, red, green, blue));
}




PHP_FUNCTION(imagecolorset)
{
 zval *IM;
 long var_71, red, green, blue, var_56 = 0;
 int col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll|l", &IM, &var_71, &red, &green, &blue, &var_56) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 col = var_71;

 if (col >= 0 && col < gdImageColorsTotal(var_76)) {
  var_76->red[col] = red;
  var_76->green[col] = green;
  var_76->blue[col] = blue;
  var_76->alpha[col] = var_56;
 } else {
  RETURN_FALSE;
 }
}




PHP_FUNCTION(imagecolorsforindex)
{
 zval *IM;
 long index;
 int col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &index) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 col = index;

 if ((col >= 0 && gdImageTrueColor(var_76)) || (!gdImageTrueColor(var_76) && col >= 0 && col < gdImageColorsTotal(var_76))) {
  array_init(return_value);

  add_assoc_long(return_value,"red", gdImageRed(var_76,col));
  add_assoc_long(return_value,"green", gdImageGreen(var_76,col));
  add_assoc_long(return_value,"blue", gdImageBlue(var_76,col));
  add_assoc_long(return_value,"alpha", gdImageAlpha(var_76,col));
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Color index %d out of range", col);
  RETURN_FALSE;
 }
}




PHP_FUNCTION(imagegammacorrect)
{
 zval *IM;
 gdImagePtr var_76;
 int i;
 double input, output;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rdd", &IM, &input, &output) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (gdImageTrueColor(var_76)) {
  int var_76, var_76, var_65;

  for (var_76 = 0; var_76 < gdImageSY(var_76); var_76++) {
   for (var_76 = 0; var_76 < gdImageSX(var_76); var_76++) {
    var_65 = gdImageGetPixel(var_76, var_76, var_76);
    gdImageSetPixel(var_76, var_76, var_76,
     gdTrueColorAlpha(
      (int) ((pow((pow((gdTrueColorGetRed(var_65) / 255.0), input)), 1.0 / output) * 255) + .5),
      (int) ((pow((pow((gdTrueColorGetGreen(var_65) / 255.0), input)), 1.0 / output) * 255) + .5),
      (int) ((pow((pow((gdTrueColorGetBlue(var_65) / 255.0), input)), 1.0 / output) * 255) + .5),
      gdTrueColorGetAlpha(var_65)
     )
    );
   }
  }
  RETURN_TRUE;
 }

 for (i = 0; i < gdImageColorsTotal(var_76); i++) {
  var_76->red[i] = (int)((pow((pow((var_76->red[i] / 255.0), input)), 1.0 / output) * 255) + .5);
  var_76->green[i] = (int)((pow((pow((var_76->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);
  var_76->blue[i] = (int)((pow((pow((var_76->blue[i] / 255.0), input)), 1.0 / output) * 255) + .5);
 }

 RETURN_TRUE;
}




PHP_FUNCTION(imagesetpixel)
{
 zval *IM;
 long var_76, var_76, col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &var_76, &var_76, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageSetPixel(var_76, var_76, var_76, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imageline)
{
 zval *IM;
 long x1, y1, x2, y2, col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);






 {
  gdImageLine(var_76, x1, y1, x2, y2, col);
 }
 RETURN_TRUE;
}




PHP_FUNCTION(imagedashedline)
{
 zval *IM;
 long x1, y1, x2, y2, col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageDashedLine(var_76, x1, y1, x2, y2, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagerectangle)
{
 zval *IM;
 long x1, y1, x2, y2, col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageRectangle(var_76, x1, y1, x2, y2, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagefilledrectangle)
{
 zval *IM;
 long x1, y1, x2, y2, col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageFilledRectangle(var_76, x1, y1, x2, y2, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagearc)
{
 zval *IM;
 long cx, cy, w, h, ST, E, col;
 gdImagePtr var_76;
 int e, st;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllllll", &IM, &cx, &cy, &w, &h, &ST, &E, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 e = E;
 if (e < 0) {
  e %= 360;
 }

 st = ST;
 if (st < 0) {
  st %= 360;
 }

 gdImageArc(var_76, cx, cy, w, h, st, e, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imageellipse)
{
 zval *IM;
 long cx, cy, w, h, var_71;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllll", &IM, &cx, &cy, &w, &h, &var_71) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 gdImageEllipse(var_76, cx, cy, w, h, var_71);
 RETURN_TRUE;
}




PHP_FUNCTION(imagefilltoborder)
{
 zval *IM;
 long var_76, var_76, border, col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll", &IM, &var_76, &var_76, &border, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageFillToBorder(var_76, var_76, var_76, border, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagefill)
{
 zval *IM;
 long var_76, var_76, col;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlll", &IM, &var_76, &var_76, &col) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);
 gdImageFill(var_76, var_76, var_76, col);
 RETURN_TRUE;
}




PHP_FUNCTION(imagecolorstotal)
{
 zval *IM;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageColorsTotal(var_76));
}




PHP_FUNCTION(imagecolortransparent)
{
 zval *IM;
 long var_68 = 0;
 gdImagePtr var_76;
 int var_58 = ZEND_NUM_ARGS();

 if (zend_parse_parameters(var_58 TSRMLS_CC, "r|l", &IM, &var_68) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (var_58 > 1) {
  gdImageColorTransparent(var_76, var_68);
 }

 RETURN_LONG(gdImageGetTransparent(var_76));
}




PHP_FUNCTION(imageinterlace)
{
 zval *IM;
 int var_58 = ZEND_NUM_ARGS();
 long var_58 = 0;
 gdImagePtr var_76;

 if (zend_parse_parameters(var_58 TSRMLS_CC, "r|l", &IM, &var_58) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (var_58 > 1) {
  gdImageInterlace(var_76, var_58);
 }

 RETURN_LONG(gdImageGetInterlaced(var_76));
}






static void fn_58(INTERNAL_FUNCTION_PARAMETERS, int var_60)
{
 zval *IM, *POINTS;
 long NPOINTS, var_68;
 zval **var = NULL;
 gdImagePtr var_76;
 gdPointPtr points;
 int npoints, col, nelem, i;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rall", &IM, &POINTS, &NPOINTS, &var_68) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 npoints = NPOINTS;
 col = var_68;

 nelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));
 if (nelem < 6) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must have at least 3 points in your array");
  RETURN_FALSE;
 }
 if (npoints <= 0) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must give a positive number of points");
  RETURN_FALSE;
 }
 if (nelem < npoints * 2) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Trying to use %d points in array with only %d points", npoints, nelem/2);
  RETURN_FALSE;
 }

 points = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);

 for (i = 0; i < npoints; i++) {
  if (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {
   if (Z_TYPE_PP(var) != IS_LONG) {
    zval lval;
    lval = **var;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    points[i].x = Z_LVAL(lval);
   } else {
    points[i].x = Z_LVAL_PP(var);
   }
  }
  if (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {
   if (Z_TYPE_PP(var) != IS_LONG) {
    zval lval;
    lval = **var;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    points[i].y = Z_LVAL(lval);
   } else {
    points[i].y = Z_LVAL_PP(var);
   }
  }
 }

 if (var_60) {
  gdImageFilledPolygon(var_76, points, npoints, col);
 } else {
  gdImagePolygon(var_76, points, npoints, col);
 }

 efree(points);
 RETURN_TRUE;
}




PHP_FUNCTION(imagepolygon)
{
 php_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}




PHP_FUNCTION(imagefilledpolygon)
{
 php_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}




static gdFontPtr fn_60(int size var_61)
{
 gdFontPtr font;
 int ind_type;

 switch (size) {
  case 1:
    font = gdFontTiny;
    break;
  case 2:
    font = gdFontSmall;
    break;
  case 3:
    font = gdFontMediumBold;
    break;
  case 4:
    font = gdFontLarge;
    break;
  case 5:
    font = gdFontGiant;
    break;
  default:
   font = zend_list_find(size - 5, &ind_type);
    if (!font || ind_type != le_gd_font) {
      if (size < 1) {
        font = gdFontTiny;
      } else {
        font = gdFontGiant;
      }
    }
    break;
 }

 return font;
}






static void fn_61(INTERNAL_FUNCTION_PARAMETERS, int var_63)
{
 long SIZE;
 gdFontPtr font;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &SIZE) == FAILURE) {
  return;
 }

 font = php_find_gd_font(SIZE TSRMLS_CC);
 RETURN_LONG(var_63 ? font->h : font->w);
}




PHP_FUNCTION(imagefontwidth)
{
 php_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}




PHP_FUNCTION(imagefontheight)
{
 php_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}




static void fn_63(gdImagePtr var_76, gdFontPtr var_65, int var_76, int var_76, int var_65, int var_71)
{
 int cx, cy, px, py, fline;
 cx = 0;
 cy = 0;

 if ((var_65 < var_65->offset) || (var_65 >= (var_65->offset + var_65->nchars))) {
  return;
 }

 fline = (var_65 - var_65->offset) * var_65->h * var_65->w;
 for (py = var_76; (py > (var_76 - var_65->w)); py--) {
  for (px = var_76; (px < (var_76 + var_65->h)); px++) {
   if (var_65->data[fline + cy * var_65->w + cx]) {
    gdImageSetPixel(var_76, px, py, var_71);
   }
   cy++;
  }
  cy = 0;
  cx++;
 }
}

static void fn_65(INTERNAL_FUNCTION_PARAMETERS, int var_71)
{
 zval *IM;
 long SIZE, X, Y, var_68;
 char *C;
 int C_len;
 gdImagePtr var_76;
 int var_68 = 0, col, var_76, var_76, size, i, var_68 = 0;
 unsigned char *str = NULL;
 gdFontPtr font;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rlllsl", &IM, &SIZE, &X, &Y, &C, &C_len, &var_68) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 col = var_68;

 if (var_71 < 2) {
  var_68 = (int)((unsigned char)*C);
 } else {
  str = (unsigned char *) estrndup(C, C_len);
  var_68 = strlen((char *)str);
 }

 var_76 = Y;
 var_76 = X;
 size = SIZE;

 font = php_find_gd_font(size TSRMLS_CC);

 switch (var_71) {
  case 0:
   gdImageChar(var_76, font, var_76, var_76, var_68, col);
   break;
  case 1:
   php_gdimagecharup(var_76, font, var_76, var_76, var_68, col);
   break;
  case 2:
   for (i = 0; (i < var_68); i++) {
    gdImageChar(var_76, font, var_76, var_76, (int) ((unsigned char) str[i]), col);
    var_76 += font->w;
   }
   break;
  case 3: {
   for (i = 0; (i < var_68); i++) {

    gdImageCharUp(var_76, font, var_76, var_76, (int) str[i], col);
    var_76 -= font->w;
   }
   break;
  }
 }
 if (str) {
  efree(str);
 }
 RETURN_TRUE;
}




PHP_FUNCTION(imagechar)
{
 php_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);
}




PHP_FUNCTION(imagecharup)
{
 php_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);
}




PHP_FUNCTION(imagestring)
{
 php_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);
}




PHP_FUNCTION(imagestringup)
{
 php_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);
}




PHP_FUNCTION(imagecopy)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY;
 gdImagePtr im_dst, var_71;
 int srcH, srcW, srcY, srcX, dstY, dstX;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;

 gdImageCopy(im_dst, var_71, dstX, dstY, srcX, srcY, srcW, srcH);
 RETURN_TRUE;
}




PHP_FUNCTION(imagecopymerge)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY, PCT;
 gdImagePtr im_dst, var_71;
 int srcH, srcW, srcY, srcX, dstY, dstX, pct;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrlllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;
 pct = PCT;

 gdImageCopyMerge(im_dst, var_71, dstX, dstY, srcX, srcY, srcW, srcH, pct);
 RETURN_TRUE;
}




PHP_FUNCTION(imagecopymergegray)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY, PCT;
 gdImagePtr im_dst, var_71;
 int srcH, srcW, srcY, srcX, dstY, dstX, pct;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrlllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;
 pct = PCT;

 gdImageCopyMergeGray(im_dst, var_71, dstX, dstY, srcX, srcY, srcW, srcH, pct);
 RETURN_TRUE;
}




PHP_FUNCTION(imagecopyresized)
{
 zval *SIM, *DIM;
 long SX, SY, SW, SH, DX, DY, DW, DH;
 gdImagePtr im_dst, var_71;
 int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rrllllllll", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, "Image", le_gd);
 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);

 srcX = SX;
 srcY = SY;
 srcH = SH;
 srcW = SW;
 dstX = DX;
 dstY = DY;
 dstH = DH;
 dstW = DW;

 if (dstW <= 0 || dstH <= 0 || srcW <= 0 || srcH <= 0) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid image dimensions");
  RETURN_FALSE;
 }

 gdImageCopyResized(im_dst, var_71, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);
 RETURN_TRUE;
}




PHP_FUNCTION(imagesx)
{
 zval *IM;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageSX(var_76));
}




PHP_FUNCTION(imagesy)
{
 zval *IM;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &IM) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 RETURN_LONG(gdImageSY(var_76));
}

PHP_FUNCTION(image2wbmp)
{
 _php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_CONVERT_WBM, "WBMP", _php_image_bw_convert);
}

static void fn_68(gdImagePtr var_70, gdIOCtx *out, int var_71)
{
 gdImagePtr im_dest;
 int white, black;
 int var_71, color_org, median;
 int var_70 = gdImageSY(var_70);
 int var_70 = gdImageSX(var_70);
 int var_76, var_76;
 TSRMLS_FETCH();

 im_dest = gdImageCreate(var_70, var_70);
 if (im_dest == NULL) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate temporary buffer");
  return;
 }

 white = gdImageColorAllocate(im_dest, 255, 255, 255);
 if (white == -1) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate the colors for the destination buffer");
  return;
 }

 black = gdImageColorAllocate(im_dest, 0, 0, 0);
 if (black == -1) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate the colors for the destination buffer");
  return;
 }

 if (var_70->trueColor) {
  gdImageTrueColorToPalette(var_70, 1, 256);
 }

 for (var_76 = 0; var_76 < var_70; var_76++) {
  for (var_76 = 0; var_76 < var_70; var_76++) {
   color_org = gdImageGetPixel(var_70, var_76, var_76);
   median = (var_70->red[color_org] + var_70->green[color_org] + var_70->blue[color_org]) / 3;
   if (median < var_71) {
    var_71 = black;
   } else {
    var_71 = white;
   }
   gdImageSetPixel (im_dest, var_76, var_76, var_71);
  }
 }
 gdImageWBMPCtx (im_dest, black, out);

}




static void fn_70(INTERNAL_FUNCTION_PARAMETERS, int var_70 )
{
 char *f_org, *f_dest;
 int f_org_len, f_dest_len;
 long height, width, var_71;
 gdImagePtr var_70, im_dest, im_tmp;
 char *fn_org = NULL;
 char *fn_dest = NULL;
 FILE *org, *dest;
 int var_70 = -1;
 int var_70 = -1;
 int org_height, org_width;
 int white, black;
 int var_71, color_org, median;
 int int_threshold;
 int var_76, var_76;
 float x_ratio, y_ratio;
    long ignore_warning;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "pplll", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &var_71) == FAILURE) {
  return;
 }

 fn_org = f_org;
 fn_dest = f_dest;
 var_70 = height;
 var_70 = width;
 int_threshold = var_71;


 if (int_threshold < 0 || int_threshold > 8) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid threshold value '%d'", int_threshold);
  RETURN_FALSE;
 }


 PHP_GD_CHECK_OPEN_BASEDIR(fn_org, "Invalid origin filename");


 PHP_GD_CHECK_OPEN_BASEDIR(fn_dest, "Invalid destination filename");


 org = VCWD_FOPEN(fn_org, "rb");
 if (!org) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' for reading", fn_org);
  RETURN_FALSE;
 }


 dest = VCWD_FOPEN(fn_dest, "wb");
 if (!dest) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' for writing", fn_dest);
  RETURN_FALSE;
 }

 switch (var_70) {
  case PHP_GDIMG_TYPE_GIF:
   var_70 = gdImageCreateFromGif(org);
   if (var_70 == NULL) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to open '%s' Not a valid GIF file", fn_dest);
    RETURN_FALSE;
   }
   break;

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Format not supported");
   RETURN_FALSE;
   break;
 }

 org_width = gdImageSX (var_70);
 org_height = gdImageSY (var_70);

 x_ratio = (float) org_width / (float) var_70;
 y_ratio = (float) org_height / (float) var_70;

 if (x_ratio > 1 && y_ratio > 1) {
  if (y_ratio > x_ratio) {
   x_ratio = y_ratio;
  } else {
   y_ratio = x_ratio;
  }
  var_70 = (int) (org_width / x_ratio);
  var_70 = (int) (org_height / y_ratio);
 } else {
  x_ratio = (float) var_70 / (float) org_width;
  y_ratio = (float) var_70 / (float) org_height;

  if (y_ratio < x_ratio) {
   x_ratio = y_ratio;
  } else {
   y_ratio = x_ratio;
  }
  var_70 = (int) (org_width * x_ratio);
  var_70 = (int) (org_height * y_ratio);
 }

 im_tmp = gdImageCreate (var_70, var_70);
 if (im_tmp == NULL ) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate temporary buffer");
  RETURN_FALSE;
 }

 gdImageCopyResized (im_tmp, var_70, 0, 0, 0, 0, var_70, var_70, org_width, org_height);

 gdImageDestroy(var_70);

 fclose(org);

 im_dest = gdImageCreate(var_70, var_70);
 if (im_dest == NULL) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate destination buffer");
  RETURN_FALSE;
 }

 white = gdImageColorAllocate(im_dest, 255, 255, 255);
 if (white == -1) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate the colors for the destination buffer");
  RETURN_FALSE;
 }

 black = gdImageColorAllocate(im_dest, 0, 0, 0);
 if (black == -1) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate the colors for the destination buffer");
  RETURN_FALSE;
 }

 int_threshold = int_threshold * 32;

 for (var_76 = 0; var_76 < var_70; var_76++) {
  for (var_76 = 0; var_76 < var_70; var_76++) {
   color_org = gdImageGetPixel (im_tmp, var_76, var_76);
   median = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;
   if (median < int_threshold) {
    var_71 = black;
   } else {
    var_71 = white;
   }
   gdImageSetPixel (im_dest, var_76, var_76, var_71);
  }
 }

 gdImageDestroy (im_tmp );

 gdImageWBMP(im_dest, black , dest);

 fflush(dest);
 fclose(dest);

 gdImageDestroy(im_dest);

 RETURN_TRUE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr var_71; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd); if (var_71 == NULL) { RETURN_FALSE; }

 if (gdImageNegate(var_71) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr var_71; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd); if (var_71 == NULL) { RETURN_FALSE; }

 if (gdImageGrayScale(var_71) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM;
 gdImagePtr var_71;
 long brightness, tmp;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zll", &SIM, &tmp, &brightness) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);

 if (var_71 == NULL) {
  RETURN_FALSE;
 }

 if (gdImageBrightness(var_71, (int)brightness) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM;
 gdImagePtr var_71;
 long contrast, tmp;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rll", &SIM, &tmp, &contrast) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);

 if (var_71 == NULL) {
  RETURN_FALSE;
 }

 if (gdImageContrast(var_71, (int)contrast) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM;
 gdImagePtr var_71;
 long r,g,var_70,tmp;
 long var_70 = 0;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rllll|l", &SIM, &tmp, &r, &g, &var_70, &var_70) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);

 if (var_71 == NULL) {
  RETURN_FALSE;
 }

 if (gdImageColor(var_71, (int) r, (int) g, (int) var_70, (int) var_70) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr var_71; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd); if (var_71 == NULL) { RETURN_FALSE; }

 if (gdImageEdgeDetectQuick(var_71) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr var_71; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd); if (var_71 == NULL) { RETURN_FALSE; }

 if (gdImageEmboss(var_71) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr var_71; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd); if (var_71 == NULL) { RETURN_FALSE; }

 if (gdImageGaussianBlur(var_71) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr var_71; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd); if (var_71 == NULL) { RETURN_FALSE; }

 if (gdImageSelectiveBlur(var_71) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM; gdImagePtr var_71; if (zend_parse_parameters(1 TSRMLS_CC, "r", &SIM) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd); if (var_71 == NULL) { RETURN_FALSE; }

 if (gdImageMeanRemoval(var_71) == 1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *SIM;
 long tmp;
 gdImagePtr var_71;
 double weight;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rld", &SIM, &tmp, &weight) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);

 if (var_71 == NULL) {
  RETURN_FALSE;
 }

 if (gdImageSmooth(var_71, (float)weight)==1) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}

static void fn_70(INTERNAL_FUNCTION_PARAMETERS)
{
 zval *IM;
 gdImagePtr var_76;
 long tmp, blocksize;
 zend_bool var_71 = 0;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rll|b", &IM, &tmp, &blocksize, &var_71) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (var_76 == NULL) {
  RETURN_FALSE;
 }

 if (gdImagePixelate(var_76, (int) blocksize, (const unsigned int) var_71)) {
  RETURN_TRUE;
 }

 RETURN_FALSE;
}



PHP_FUNCTION(imagefilter)
{
 zval *tmp;

 typedef void (*image_filter)(INTERNAL_FUNCTION_PARAMETERS);
 long filtertype;
 image_filter filters[] =
 {
  php_image_filter_negate ,
  php_image_filter_grayscale,
  php_image_filter_brightness,
  php_image_filter_contrast,
  php_image_filter_colorize,
  php_image_filter_edgedetect,
  php_image_filter_emboss,
  php_image_filter_gaussian_blur,
  php_image_filter_selective_blur,
  php_image_filter_mean_removal,
  php_image_filter_smooth,
  php_image_filter_pixelate
 };

 if (ZEND_NUM_ARGS() < 2 || ZEND_NUM_ARGS() > 6) {
  WRONG_PARAM_COUNT;
 } else if (zend_parse_parameters(2 TSRMLS_CC, "rl", &tmp, &filtertype) == FAILURE) {
  return;
 }

 if (filtertype >= 0 && filtertype <= 11) {
  filters[filtertype](INTERNAL_FUNCTION_PARAM_PASSTHRU);
 }
}




PHP_FUNCTION(imageconvolution)
{
 zval *SIM, *hash_matrix;
 zval **var = NULL, **var2 = NULL;
 gdImagePtr var_71 = NULL;
 double div, offset;
 int nelem, i, j, var_76;
 float matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "radd", &SIM, &hash_matrix, &div, &offset) == FAILURE) {
  RETURN_FALSE;
 }

 ZEND_FETCH_RESOURCE(var_71, gdImagePtr, &SIM, -1, "Image", le_gd);

 nelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));
 if (nelem != 3) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must have 3x3 array");
  RETURN_FALSE;
 }

 for (i=0; i<3; i++) {
  if (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {
   if (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must have 3x3 array");
    RETURN_FALSE;
   }

   for (j=0; j<3; j++) {
    if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {
     if (Z_TYPE_PP(var2) != IS_DOUBLE) {
      zval dval;
      dval = **var2;
      zval_copy_ctor(&dval);
      convert_to_double(&dval);
      matrix[i][j] = (float)Z_DVAL(dval);
     } else {
      matrix[i][j] = (float)Z_DVAL_PP(var2);
     }
    } else {
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "You must have a 3x3 matrix");
     RETURN_FALSE;
    }
   }
  }
 }
 var_76 = gdImageConvolution(var_71, matrix, (float)div, (float)offset);

 if (var_76) {
  RETURN_TRUE;
 } else {
  RETURN_FALSE;
 }
}





PHP_FUNCTION(imageflip)
{
 zval *IM;
 long var_71;
 gdImagePtr var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl", &IM, &var_71) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 switch (var_71) {
  case GD_FLIP_VERTICAL:
   gdImageFlipVertical(var_76);
   break;

  case GD_FLIP_HORINZONTAL:
   gdImageFlipHorizontal(var_76);
   break;

  case GD_FLIP_BOTH:
   gdImageFlipBoth(var_76);
   break;

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown flip var_71");
   RETURN_FALSE;
 }

 RETURN_TRUE;
}

PHP_FUNCTION(imagecrop)
{
 zval *IM;
 gdImagePtr var_76;
 gdImagePtr im_crop;
 gdRect rect;
 zval *z_rect;
 zval **tmp;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ra", &IM, &z_rect) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (zend_hash_find(HASH_OF(z_rect), "x", sizeof("x"), (void **)&tmp) != FAILURE) {
  if (Z_TYPE_PP(tmp) != IS_LONG) {
   zval lval;
   lval = **tmp;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   rect.x = Z_LVAL(lval);
  } else {
   rect.x = Z_LVAL_PP(tmp);
  }
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing var_76 position");
  RETURN_FALSE;
 }

 if (zend_hash_find(HASH_OF(z_rect), "y", sizeof("x"), (void **)&tmp) != FAILURE) {
  if (Z_TYPE_PP(tmp) != IS_LONG) {
   zval lval;
   lval = **tmp;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   rect.y = Z_LVAL(lval);
  } else {
   rect.y = Z_LVAL_PP(tmp);
  }
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing var_76 position");
  RETURN_FALSE;
 }

 if (zend_hash_find(HASH_OF(z_rect), "width", sizeof("width"), (void **)&tmp) != FAILURE) {
  if (Z_TYPE_PP(tmp) != IS_LONG) {
   zval lval;
   lval = **tmp;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   rect.width = Z_LVAL(lval);
  } else {
   rect.width = Z_LVAL_PP(tmp);
  }
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing width");
  RETURN_FALSE;
 }

 if (zend_hash_find(HASH_OF(z_rect), "height", sizeof("height"), (void **)&tmp) != FAILURE) {
  if (Z_TYPE_PP(tmp) != IS_LONG) {
   zval lval;
   lval = **tmp;
   zval_copy_ctor(&lval);
   convert_to_long(&lval);
   rect.height = Z_LVAL(lval);
  } else {
   rect.height = Z_LVAL_PP(tmp);
  }
 } else {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing height");
  RETURN_FALSE;
 }

 im_crop = gdImageCrop(var_76, &rect);

 if (im_crop == NULL) {
  RETURN_FALSE;
 } else {
  ZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);
 }
}




PHP_FUNCTION(imagecropauto)
{
 zval *IM;
 long var_71 = -1;
 long var_71 = -1;
 double var_71 = 0.5f;
 gdImagePtr var_76;
 gdImagePtr im_crop;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r|ldl", &IM, &var_71, &var_71, &var_71) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 switch (var_71) {
  case -1:
   var_71 = GD_CROP_DEFAULT;
  case GD_CROP_DEFAULT:
  case GD_CROP_TRANSPARENT:
  case GD_CROP_BLACK:
  case GD_CROP_WHITE:
  case GD_CROP_SIDES:
   im_crop = gdImageCropAuto(var_76, var_71);
   break;

  case GD_CROP_THRESHOLD:
   if (var_71 < 0 || (!gdImageTrueColor(var_76) && var_71 >= gdImageColorsTotal(var_76))) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Color argument missing with threshold mode");
    RETURN_FALSE;
   }
   im_crop = gdImageCropThreshold(var_76, var_71, (float) var_71);
   break;

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown crop var_71");
   RETURN_FALSE;
 }
 if (im_crop == NULL) {
  RETURN_FALSE;
 } else {
  ZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);
 }
}




PHP_FUNCTION(imagescale)
{
 zval *IM;
 gdImagePtr var_76;
 gdImagePtr var_74 = NULL;
 int new_width, new_height;
 long tmp_w, var_74=-1, var_74 = var_76;
 gdInterpolationMethod var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rl|ll", &IM, &tmp_w, &var_74, &var_74) == FAILURE) {
  return;
 }
 var_76 = var_74;

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (var_74 < 0) {

  long src_x, src_y;

  src_x = gdImageSX(var_76);
  src_y = gdImageSY(var_76);
  if (src_x) {
   var_74 = tmp_w * src_y / src_x;
  }
 }

 if (var_74 <= 0 || tmp_w <= 0) {
  RETURN_FALSE;
 }

 new_width = tmp_w;
 new_height = var_74;

 if (gdImageSetInterpolationMethod(var_76, var_76)) {
  var_74 = gdImageScale(var_76, new_width, new_height);
 }

 if (var_74 == NULL) {
  RETURN_FALSE;
 } else {
  ZEND_REGISTER_RESOURCE(return_value, var_74, le_gd);
 }
}




PHP_FUNCTION(imageaffine)
{
 zval *IM;
 gdImagePtr src;
 gdImagePtr dst;
 gdRect rect;
 gdRectPtr var_75 = NULL;
 zval *z_rect = NULL;
 zval *z_affine;
 zval **tmp;
 double affine[6];
 int i, nelems;
 zval **zval_affine_elem = NULL;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ra|a", &IM, &z_affine, &z_rect) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(src, gdImagePtr, &IM, -1, "Image", le_gd);

 if ((nelems = zend_hash_num_elements(Z_ARRVAL_P(z_affine))) != 6) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Affine array must have six elements");
  RETURN_FALSE;
 }

 for (i = 0; i < nelems; i++) {
  if (zend_hash_index_find(Z_ARRVAL_P(z_affine), i, (void **) &zval_affine_elem) == SUCCESS) {
   switch (Z_TYPE_PP(zval_affine_elem)) {
    case IS_LONG:
     affine[i] = Z_LVAL_PP(zval_affine_elem);
     break;
    case IS_DOUBLE:
     affine[i] = Z_DVAL_PP(zval_affine_elem);
     break;
    case IS_STRING:
     {
      zval dval;
      dval = **zval_affine_elem;
      zval_copy_ctor(&dval);
      convert_to_double(&dval);
      affine[i] = Z_DVAL(dval);
     }
     break;
    default:
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type for element %i", i);
     RETURN_FALSE;
   }
  }
 }

 if (z_rect != NULL) {
  if (zend_hash_find(HASH_OF(z_rect), "x", sizeof("x"), (void **)&tmp) != FAILURE) {
   if (Z_TYPE_PP(tmp) != IS_LONG) {
    zval lval;
    lval = **tmp;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    rect.x = Z_LVAL(lval);
   } else {
    rect.x = Z_LVAL_PP(tmp);
   }
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing var_76 position");
   RETURN_FALSE;
  }

  if (zend_hash_find(HASH_OF(z_rect), "y", sizeof("x"), (void **)&tmp) != FAILURE) {
   if (Z_TYPE_PP(tmp) != IS_LONG) {
    zval lval;
    lval = **tmp;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    rect.y = Z_LVAL(lval);
   } else {
    rect.y = Z_LVAL_PP(tmp);
   }
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing var_76 position");
   RETURN_FALSE;
  }

  if (zend_hash_find(HASH_OF(z_rect), "width", sizeof("width"), (void **)&tmp) != FAILURE) {
   if (Z_TYPE_PP(tmp) != IS_LONG) {
    zval lval;
    lval = **tmp;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    rect.width = Z_LVAL(lval);
   } else {
    rect.width = Z_LVAL_PP(tmp);
   }
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing width");
   RETURN_FALSE;
  }

  if (zend_hash_find(HASH_OF(z_rect), "height", sizeof("height"), (void **)&tmp) != FAILURE) {
   if (Z_TYPE_PP(tmp) != IS_LONG) {
    zval lval;
    lval = **tmp;
    zval_copy_ctor(&lval);
    convert_to_long(&lval);
    rect.height = Z_LVAL(lval);
   } else {
    rect.height = Z_LVAL_PP(tmp);
   }
  } else {
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing height");
   RETURN_FALSE;
  }
  var_75 = &rect;
 } else {
  rect.x = -1;
  rect.y = -1;
  rect.width = gdImageSX(src);
  rect.height = gdImageSY(src);
  var_75 = NULL;
 }

 if (gdTransformAffineGetImage(&dst, src, var_75, affine) != GD_TRUE) {
  RETURN_FALSE;
 }

 if (dst == NULL) {
  RETURN_FALSE;
 } else {
  ZEND_REGISTER_RESOURCE(return_value, dst, le_gd);
 }
}




PHP_FUNCTION(imageaffinematrixget)
{
 double affine[6];
 long var_76;
 zval *options = NULL;
 zval **tmp;
 int var_76 = var_76, i;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|z", &var_76, &options) == FAILURE) {
  return;
 }

 switch((gdAffineStandardMatrix)var_76) {
  case GD_AFFINE_TRANSLATE:
  case GD_AFFINE_SCALE: {
   double var_76, var_76;
   if (!options || Z_TYPE_P(options) != IS_ARRAY) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Array expected as options");
    RETURN_FALSE;
   }
   if (zend_hash_find(HASH_OF(options), "x", sizeof("x"), (void **)&tmp) != FAILURE) {
    if (Z_TYPE_PP(tmp) != IS_DOUBLE) {
     zval dval;
     dval = **tmp;
     zval_copy_ctor(&dval);
     convert_to_double(&dval);
     var_76 = Z_DVAL(dval);
    } else {
     var_76 = Z_DVAL_PP(tmp);
    }
   } else {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing var_76 position");
    RETURN_FALSE;
   }

   if (zend_hash_find(HASH_OF(options), "y", sizeof("y"), (void **)&tmp) != FAILURE) {
    if (Z_TYPE_PP(tmp) != IS_DOUBLE) {
     zval dval;
     dval = **tmp;
     zval_copy_ctor(&dval);
     convert_to_double(&dval);
     var_76 = Z_DVAL(dval);
    } else {
     var_76 = Z_DVAL_PP(tmp);
    }
   } else {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Missing var_76 position");
    RETURN_FALSE;
   }

   if (var_76 == GD_AFFINE_TRANSLATE) {
    var_76 = gdAffineTranslate(affine, var_76, var_76);
   } else {
    var_76 = gdAffineScale(affine, var_76, var_76);
   }
   break;
  }

  case GD_AFFINE_ROTATE:
  case GD_AFFINE_SHEAR_HORIZONTAL:
  case GD_AFFINE_SHEAR_VERTICAL: {
   double angle;

   if (!options) {
    php_error_docref(NULL TSRMLS_CC, E_WARNING, "Number is expected as option");
    RETURN_FALSE;
   }
   if(Z_TYPE_P(options) != IS_DOUBLE) {
    zval dval;
    dval = *options;
    zval_copy_ctor(&dval);
    convert_to_double(&dval);
    angle = Z_DVAL(dval);
   } else {
    angle = Z_DVAL_P(options);
   }

   if (var_76 == GD_AFFINE_SHEAR_HORIZONTAL) {
    var_76 = gdAffineShearHorizontal(affine, angle);
   } else if (var_76 == GD_AFFINE_SHEAR_VERTICAL) {
    var_76 = gdAffineShearVertical(affine, angle);
   } else {
    var_76 = gdAffineRotate(affine, angle);
   }
   break;
  }

  default:
   php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type for element %li", var_76);
   RETURN_FALSE;
 }

 if (var_76 == var_76) {
  RETURN_FALSE;
 } else {
  array_init(return_value);
  for (i = 0; i < 6; i++) {
   add_index_double(return_value, i, affine[i]);
  }
 }
}




PHP_FUNCTION(imageaffinematrixconcat)
{
 double m1[6];
 double m2[6];
 double mr[6];

 zval **tmp;
 zval *z_m1;
 zval *z_m2;
 int i, nelems;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "aa", &z_m1, &z_m2) == FAILURE) {
  return;
 }

 if (((nelems = zend_hash_num_elements(Z_ARRVAL_P(z_m1))) != 6) || (nelems = zend_hash_num_elements(Z_ARRVAL_P(z_m2))) != 6) {
  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Affine arrays must have six elements");
  RETURN_FALSE;
 }

 for (i = 0; i < 6; i++) {
  if (zend_hash_index_find(Z_ARRVAL_P(z_m1), i, (void **) &tmp) == SUCCESS) {
   switch (Z_TYPE_PP(tmp)) {
    case IS_LONG:
     m1[i] = Z_LVAL_PP(tmp);
     break;
    case IS_DOUBLE:
     m1[i] = Z_DVAL_PP(tmp);
     break;
    case IS_STRING:
     {
      zval dval;
      dval = **tmp;
      zval_copy_ctor(&dval);
      convert_to_double(&dval);
      m1[i] = Z_DVAL(dval);
     }
     break;
    default:
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type for element %i", i);
     RETURN_FALSE;
   }
  }
  if (zend_hash_index_find(Z_ARRVAL_P(z_m2), i, (void **) &tmp) == SUCCESS) {
   switch (Z_TYPE_PP(tmp)) {
    case IS_LONG:
     m2[i] = Z_LVAL_PP(tmp);
     break;
    case IS_DOUBLE:
     m2[i] = Z_DVAL_PP(tmp);
     break;
    case IS_STRING:
     {
      zval dval;
      dval = **tmp;
      zval_copy_ctor(&dval);
      convert_to_double(&dval);
      m2[i] = Z_DVAL(dval);
     }
     break;
    default:
     php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid type for element %i", i);
     RETURN_FALSE;
   }
  }
 }

 if (gdAffineConcat (mr, m1, m2) != GD_TRUE) {
  RETURN_FALSE;
 }

 array_init(return_value);
 for (i = 0; i < 6; i++) {
  add_index_double(return_value, i, mr[i]);
 }
}



PHP_FUNCTION(imagesetinterpolation)
{
 zval *IM;
 gdImagePtr var_76;
 long var_76 = var_76;

 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r|l", &IM, &var_76) == FAILURE) {
  return;
 }

 ZEND_FETCH_RESOURCE(var_76, gdImagePtr, &IM, -1, "Image", le_gd);

 if (var_76 == -1) {
   var_76 = var_76;
 }
 RETURN_BOOL(gdImageSetInterpolationMethod(var_76, (gdInterpolationMethod) var_76));
}
