







enum enumtype_30 {
    enum_1,
    enum_2,
    enum_3,
    enum_4,
    enum_5,
    enum_6,
    enum_7,
    enum_8,
    enum_9,
    enum_10,
    enum_11,
};

enum enumtype_128 {
    enum_13,
    enum_14,
    enum_15,
    enum_16,
};

enum enumtype_28 {
    enum_18,
    enum_19,
    enum_20,
    enum_21,
};

enum enumtype_28 {
    enum_23,
    enum_24,
    enum_25,
};

typedef struct struct_26 {
    int xsub, ysub;
    enum enumtype_128 pixel_type;
} EXRChannel;

typedef struct struct_27 {
    int32_t xSize;
    int32_t ySize;
    enum enumtype_28 level_mode;
    enum enumtype_28 level_round;
} EXRTileAttribute;

typedef struct struct_28 {
    uint8_t *uncompressed_data;
    int uncompressed_size;

    uint8_t *tmp;
    int tmp_size;

    uint8_t *bitmap;
    uint16_t *lut;

    int ysize, xsize;

    int channel_line_size;
} EXRThreadData;

typedef struct struct_29 {
    AVClass *class;
    AVFrame *picture;
    AVCodecContext *avctx;
    ExrDSPContext dsp;





    enum enumtype_30 compression;
    enum enumtype_128 pixel_type;
    int channel_offsets[4];
    const AVPixFmtDescriptor *desc;

    int w, h;
    int32_t xmax, xmin;
    int32_t ymax, ymin;
    uint32_t xdelta, ydelta;

    int scan_lines_per_block;

    EXRTileAttribute tile_attr;
    int is_tile;

    int is_luma;

    GetByteContext gb;
    const uint8_t *buf;
    int buf_size;

    EXRChannel *channels;
    int nb_channels;
    int current_channel_offset;

    EXRThreadData *thread_data;

    const char *layer;

    enum enumtype_30 apply_trc_type;
    float gamma;
    union av_intfloat32 gamma_table[65536];
} EXRContext;

static union av_intfloat32 fn_31(uint16_t var_36)
{
    unsigned int var_36 = (unsigned int) (var_36 >> 15);
    unsigned int var_36 = (unsigned int) (var_36 & 1023);
    unsigned int var_36 = (unsigned int) (var_36 & (0x1F << 10));
    union av_intfloat32 f;

    if (var_36 == (0x1F << 10)) {



        var_36 = (0xFF << 23);
        if (var_36)
            var_36 = 8388607;
    } else if (var_36 == 0x0) {

        if (var_36) {
            var_36 <<= 1;
            var_36 = 0x38000000;

            while (!(var_36 & 1024)) {


                var_36 <<= 1;
                var_36 -= 8388608;
            }

            var_36 &= 1023;

            var_36 <<= 13;
        }
    } else {

        var_36 <<= 13;

        var_36 = (var_36 << 13) + 0x38000000;
    }

    f.i = (var_36 << 31) | var_36 | var_36;

    return f;
}

static int fn_36(EXRContext *s, const uint8_t *var_120, int var_107,
                          int var_118, EXRThreadData *td)
{
    unsigned long var_98 = var_118;

    if (uncompress(td->tmp, &var_98, var_120, var_107) != Z_OK ||
        var_98 != var_118)
        return AVERROR_INVALIDDATA;

    av_assert1(var_118 % 2 == 0);

    s->dsp.predictor(td->tmp, var_118);
    s->dsp.reorder_pixels(td->uncompressed_data, td->tmp, var_118);

    return 0;
}

static int fn_41(EXRContext *ctx, const uint8_t *var_120, int var_107,
                          int var_118, EXRThreadData *td)
{
    uint8_t *var_81 = td->tmp;
    const int8_t *s = var_120;
    int var_96 = var_107;
    int var_96 = var_118;
    uint8_t *dend = var_81 + var_96;
    int count;

    while (var_96 > 0) {
        count = *s++;

        if (count < 0) {
            count = -count;

            if ((var_96 -= count) < 0 ||
                (var_96 -= count + 1) < 0)
                return AVERROR_INVALIDDATA;

            while (count--)
                *var_81++ = *s++;
        } else {
            count++;

            if ((var_96 -= count) < 0 ||
                (var_96 -= 2) < 0)
                return AVERROR_INVALIDDATA;

            while (count--)
                *var_81++ = *s;

            s++;
        }
    }

    if (dend != var_81)
        return AVERROR_INVALIDDATA;

    av_assert1(var_118 % 2 == 0);

    ctx->dsp.predictor(td->tmp, var_118);
    ctx->dsp.reorder_pixels(td->uncompressed_data, td->tmp, var_118);

    return 0;
}




static uint16_t fn_45(const uint8_t *bitmap, uint16_t *lut)
{
    int i, var_47 = 0;

    for (i = 0; i < 65536; i++)
        if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))
            lut[var_47++] = i;

    i = var_47 - 1;

    memset(lut + var_47, 0, (65536 - var_47) * 2);

    return i;
}

static void fn_47(const uint16_t *lut, uint16_t *dst, int var_96)
{
    int i;

    for (i = 0; i < var_96; ++i)
        dst[i] = lut[dst[i]];
}

typedef struct struct_48 {
    int len;
    int lit;
    int *p;
} HufDec;

static void fn_49(uint64_t *hcode)
{
    uint64_t var_120, var_90[59] = { 0 };
    int i;

    for (i = 0; i < 65537; ++i)
        var_90[hcode[i]] += 1;

    var_120 = 0;
    for (i = 58; i > 0; --i) {
        uint64_t var_53 = ((var_120 + var_90[i]) >> 1);
        var_90[i] = var_120;
        var_120 = var_53;
    }

    for (i = 0; i < 65537; ++i) {
        int var_79 = hcode[i];

        if (var_79 > 0)
            hcode[i] = var_79 | (var_90[var_79]++ << 6);
    }
}






static int fn_54(GetByteContext *gb,
                                int32_t var_69, int32_t var_69, uint64_t *hcode)
{
    GetBitContext gbit;
    int var_131 = init_get_bits8(&gbit, gb->buffer, bytestream2_get_bytes_left(gb));
    if (var_131 < 0)
        return var_131;

    for (; var_69 <= var_69; var_69++) {
        uint64_t var_79 = hcode[var_69] = get_bits(&gbit, 6);

        if (var_79 == 63) {
            int var_59 = get_bits(&gbit, 8) + 6;

            if (var_69 + var_59 > var_69 + 1)
                return AVERROR_INVALIDDATA;

            while (var_59--)
                hcode[var_69++] = 0;

            var_69--;
        } else if (var_79 >= 59) {
            int var_59 = var_79 - 59 + 2;

            if (var_69 + var_59 > var_69 + 1)
                return AVERROR_INVALIDDATA;

            while (var_59--)
                hcode[var_69++] = 0;

            var_69--;
        }
    }

    bytestream2_skip(gb, (get_bits_count(&gbit) + 7) / 8);
    huf_canonical_code_table(hcode);

    return 0;
}

static int fn_59(const uint64_t *hcode, int var_69,
                               int var_69, HufDec *hdecod)
{
    for (; var_69 <= var_69; var_69++) {
        uint64_t var_120 = hcode[var_69] >> 6;
        int i, var_79 = hcode[var_69] & 63;

        if (var_120 >> var_79)
            return AVERROR_INVALIDDATA;

        if (var_79 > 14) {
            HufDec *var_67 = hdecod + (var_120 >> (var_79 - 14));
            if (var_67->len)
                return AVERROR_INVALIDDATA;

            var_67->lit++;

            var_67->p = av_realloc(var_67->p, var_67->lit * sizeof(int));
            if (!var_67->p)
                return AVERROR(ENOMEM);

            var_67->p[var_67->lit - 1] = var_69;
        } else if (var_79) {
            HufDec *var_67 = hdecod + (var_120 << (14 - var_79));

            for (i = 1 << (14 - var_79); i > 0; i--, var_67++) {
                if (var_67->len || var_67->p)
                    return AVERROR_INVALIDDATA;
                var_67->len = var_79;
                var_67->lit = var_69;
            }
        }
    }

    return 0;
}

static int fn_61(const uint64_t *hcode, const HufDec *hdecod,
                      GetByteContext *gb, int var_67,
                      int var_67, int var_67, uint16_t *var_100)
{
    uint64_t var_120 = 0;
    uint16_t *outb = var_100;
    uint16_t *oe = var_100 + var_67;
    const uint8_t *ie = gb->buffer + (var_67 + 7) / 8;
    uint8_t cs;
    uint16_t s;
    int i, var_67 = 0;

    while (gb->buffer < ie) {
        { var_120 = (var_120 << 8) | bytestream2_get_byte(gb); var_67 += 8; };

        while (var_67 >= 14) {
            const HufDec var_67 = hdecod[(var_120 >> (var_67 - 14)) & 16383];

            if (var_67.len) {
                var_67 -= var_67.len;
                { if (var_67.lit == var_67) { if (var_67 < 8) { var_120 = (var_120 << 8) | bytestream2_get_byte(gb); var_67 += 8; }; var_67 -= 8; cs = var_120 >> var_67; if (var_100 + cs > oe || var_100 == outb) return AVERROR_INVALIDDATA; s = var_100[-1]; while (cs-- > 0) *var_100++ = s; } else if (var_100 < oe) { *var_100++ = var_67.lit; } else { return AVERROR_INVALIDDATA; } };
            } else {
                int j;

                if (!var_67.p)
                    return AVERROR_INVALIDDATA;

                for (j = 0; j < var_67.lit; j++) {
                    int var_79 = hcode[var_67.p[j]] & 63;

                    while (var_67 < var_79 && bytestream2_get_bytes_left(gb) > 0)
                        { var_120 = (var_120 << 8) | bytestream2_get_byte(gb); var_67 += 8; };

                    if (var_67 >= var_79) {
                        if ((hcode[var_67.p[j]] >> 6) ==
                            ((var_120 >> (var_67 - var_79)) & ((1LL << var_79) - 1))) {
                            var_67 -= var_79;
                            { if (var_67.p[j] == var_67) { if (var_67 < 8) { var_120 = (var_120 << 8) | bytestream2_get_byte(gb); var_67 += 8; }; var_67 -= 8; cs = var_120 >> var_67; if (var_100 + cs > oe || var_100 == outb) return AVERROR_INVALIDDATA; s = var_100[-1]; while (cs-- > 0) *var_100++ = s; } else if (var_100 < oe) { *var_100++ = var_67.p[j]; } else { return AVERROR_INVALIDDATA; } };
                            break;
                        }
                    }
                }

                if (j == var_67.lit)
                    return AVERROR_INVALIDDATA;
            }
        }
    }

    i = (8 - var_67) & 7;
    var_120 >>= i;
    var_67 -= i;

    while (var_67 > 0) {
        const HufDec var_67 = hdecod[(var_120 << (14 - var_67)) & 16383];

        if (var_67.len && var_67 >= var_67.len) {
            var_67 -= var_67.len;
            { if (var_67.lit == var_67) { if (var_67 < 8) { var_120 = (var_120 << 8) | bytestream2_get_byte(gb); var_67 += 8; }; var_67 -= 8; cs = var_120 >> var_67; if (var_100 + cs > oe || var_100 == outb) return AVERROR_INVALIDDATA; s = var_100[-1]; while (cs-- > 0) *var_100++ = s; } else if (var_100 < oe) { *var_100++ = var_67.lit; } else { return AVERROR_INVALIDDATA; } };
        } else {
            return AVERROR_INVALIDDATA;
        }
    }

    if (var_100 - outb != var_67)
        return AVERROR_INVALIDDATA;
    return 0;
}

static int fn_67(GetByteContext *gb,
                          uint16_t *dst, int var_69)
{
    int32_t src_size, var_69, var_69;
    uint32_t nBits;
    uint64_t *freq;
    HufDec *hdec;
    int var_131, i;

    src_size = bytestream2_get_le32(gb);
    var_69 = bytestream2_get_le32(gb);
    var_69 = bytestream2_get_le32(gb);
    bytestream2_skip(gb, 4);
    nBits = bytestream2_get_le32(gb);
    if (var_69 < 0 || var_69 >= 65537 ||
        var_69 < 0 || var_69 >= 65537 ||
        src_size < 0)
        return AVERROR_INVALIDDATA;

    bytestream2_skip(gb, 4);

    freq = av_mallocz_array(65537, sizeof(*freq));
    hdec = av_mallocz_array(16384, sizeof(*hdec));
    if (!freq || !hdec) {
        var_131 = AVERROR(ENOMEM);
        goto fail;
    }

    if ((var_131 = huf_unpack_enc_table(gb, var_69, var_69, freq)) < 0)
        goto fail;

    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {
        var_131 = AVERROR_INVALIDDATA;
        goto fail;
    }

    if ((var_131 = huf_build_dec_table(freq, var_69, var_69, hdec)) < 0)
        goto fail;
    var_131 = huf_decode(freq, hdec, gb, nBits, var_69, var_69, dst);

fail:
    for (i = 0; i < 16384; i++)
        if (hdec)
            av_freep(&hdec[i].p);

    av_free(freq);
    av_free(hdec);

    return var_131;
}

static inline void fn_69(uint16_t var_79, uint16_t var_79, uint16_t *a, uint16_t *b)
{
    int16_t var_75 = var_79;
    int16_t var_74 = var_79;
    int var_77 = var_74;
    int var_77 = var_75 + (var_77 & 1) + (var_77 >> 1);
    int16_t var_77 = var_77;
    int16_t var_77 = var_77 - var_77;

    *a = var_77;
    *b = var_77;
}





static inline void fn_77(uint16_t var_79, uint16_t var_79, uint16_t *a, uint16_t *b)
{
    int var_80 = var_79;
    int var_81 = var_79;
    int var_81 = (var_80 - (var_81 >> 1)) & 65535;
    int var_81 = (var_81 + var_81 - 32768) & 65535;
    *b = var_81;
    *a = var_81;
}

static void fn_81(uint16_t *var_100, int var_95, int var_95,
                       int var_95, int var_93, uint16_t var_89)
{
    int var_95 = (var_89 < 16384);
    int var_90 = (var_95 > var_95) ? var_95 : var_95;
    int var_120 = 1;
    int p2;

    while (var_120 <= var_90)
        var_120 <<= 1;

    var_120 >>= 1;
    p2 = var_120;
    var_120 >>= 1;

    while (var_120 >= 1) {
        uint16_t *var_95 = var_100;
        uint16_t *ey = var_100 + var_93 * (var_95 - p2);
        uint16_t i00, i01, i10, i11;
        int var_95 = var_93 * var_120;
        int var_95 = var_93 * p2;
        int var_95 = var_95 * var_120;
        int var_95 = var_95 * p2;

        for (; var_95 <= ey; var_95 += var_95) {
            uint16_t *px = var_95;
            uint16_t *ex = var_95 + var_95 * (var_95 - p2);

            for (; px <= ex; px += var_95) {
                uint16_t *p01 = px + var_95;
                uint16_t *p10 = px + var_95;
                uint16_t *p11 = p10 + var_95;

                if (var_95) {
                    wdec14(*px, *p10, &i00, &i10);
                    wdec14(*p01, *p11, &i01, &i11);
                    wdec14(i00, i01, px, p01);
                    wdec14(i10, i11, p10, p11);
                } else {
                    wdec16(*px, *p10, &i00, &i10);
                    wdec16(*p01, *p11, &i01, &i11);
                    wdec16(i00, i01, px, p01);
                    wdec16(i10, i11, p10, p11);
                }
            }

            if (var_95 & var_120) {
                uint16_t *p10 = px + var_95;

                if (var_95)
                    wdec14(*px, *p10, &i00, p10);
                else
                    wdec16(*px, *p10, &i00, p10);

                *px = i00;
            }
        }

        if (var_95 & var_120) {
            uint16_t *px = var_95;
            uint16_t *ex = var_95 + var_95 * (var_95 - p2);

            for (; px <= ex; px += var_95) {
                uint16_t *p01 = px + var_95;

                if (var_95)
                    wdec14(*px, *p01, &i00, p01);
                else
                    wdec16(*px, *p01, &i00, p01);

                *px = i00;
            }
        }

        p2 = var_120;
        var_120 >>= 1;
    }
}

static int fn_95(EXRContext *s, const uint8_t *var_120, int var_96,
                          int var_96, EXRThreadData *td)
{
    GetByteContext gb;
    uint16_t maxval, min_non_zero, max_non_zero;
    uint16_t *ptr;
    uint16_t *tmp = (uint16_t *)td->tmp;
    uint16_t *var_100;
    uint16_t *var_100;
    int var_131, i, j;
    int pixel_half_size;
    EXRChannel *channel;
    int tmp_offset;

    if (!td->bitmap)
        td->bitmap = av_malloc(8192);
    if (!td->lut)
        td->lut = av_malloc(131072);
    if (!td->bitmap || !td->lut) {
        av_freep(&td->bitmap);
        av_freep(&td->lut);
        return AVERROR(ENOMEM);
    }

    bytestream2_init(&gb, var_120, var_96);
    min_non_zero = bytestream2_get_le16(&gb);
    max_non_zero = bytestream2_get_le16(&gb);

    if (max_non_zero >= 8192)
        return AVERROR_INVALIDDATA;

    memset(td->bitmap, 0, FFMIN(min_non_zero, 8192));
    if (min_non_zero <= max_non_zero)
        bytestream2_get_buffer(&gb, td->bitmap + min_non_zero,
                               max_non_zero - min_non_zero + 1);
    memset(td->bitmap + max_non_zero + 1, 0, 8192 - max_non_zero - 1);

    maxval = reverse_lut(td->bitmap, td->lut);

    var_131 = huf_uncompress(&gb, tmp, var_96 / sizeof(uint16_t));
    if (var_131)
        return var_131;

    ptr = tmp;
    for (i = 0; i < s->nb_channels; i++) {
        channel = &s->channels[i];

        if (channel->pixel_type == EXR_HALF)
            pixel_half_size = 1;
        else
            pixel_half_size = 2;

        for (j = 0; j < pixel_half_size; j++)
            wav_decode(ptr + j, td->xsize, pixel_half_size, td->ysize,
                       td->xsize * pixel_half_size, maxval);
        ptr += td->xsize * td->ysize * pixel_half_size;
    }

    apply_lut(td->lut, tmp, var_96 / sizeof(uint16_t));

    var_100 = (uint16_t *)td->uncompressed_data;
    for (i = 0; i < td->ysize; i++) {
        tmp_offset = 0;
        for (j = 0; j < s->nb_channels; j++) {
            channel = &s->channels[j];
            if (channel->pixel_type == EXR_HALF)
                pixel_half_size = 1;
            else
                pixel_half_size = 2;

            var_100 = tmp + tmp_offset * td->xsize * td->ysize + i * td->xsize * pixel_half_size;
            tmp_offset += pixel_half_size;




            memcpy(var_100, var_100, td->xsize * 2 * pixel_half_size);

            var_100 += td->xsize * pixel_half_size;
        }
    }

    return 0;
}

static int fn_96(EXRContext *s, const uint8_t *var_120,
                            int var_107, int var_118,
                            EXRThreadData *td)
{
    unsigned long var_98, var_98 = 0;
    const uint8_t *var_100 = td->tmp;
    uint8_t *var_100;
    int var_120, i, j;

    for (i = 0; i < s->nb_channels; i++) {
        if (s->channels[i].pixel_type == EXR_FLOAT) {
            var_98 += (td->xsize * td->ysize * 3);
        } else if (s->channels[i].pixel_type == EXR_HALF) {
            var_98 += (td->xsize * td->ysize * 2);
        } else {
            var_98 += (td->xsize * td->ysize * 4);
        }
    }

    var_98 = var_98;

    if (uncompress(td->tmp, &var_98, var_120, var_107) != Z_OK) {
        return AVERROR_INVALIDDATA;
    } else if (var_98 != var_98) {
        return AVERROR_INVALIDDATA;
    }

    var_100 = td->uncompressed_data;
    for (i = 0; i < td->ysize; i++)
        for (var_120 = 0; var_120 < s->nb_channels; var_120++) {
            EXRChannel *channel = &s->channels[var_120];
            const uint8_t *ptr[4];
            uint32_t var_100 = 0;

            switch (channel->pixel_type) {
            case EXR_FLOAT:
                ptr[0] = var_100;
                ptr[1] = ptr[0] + td->xsize;
                ptr[2] = ptr[1] + td->xsize;
                var_100 = ptr[2] + td->xsize;

                for (j = 0; j < td->xsize; ++j) {
                    uint32_t var_100 = ((unsigned)*(ptr[0]++) << 24) |
                                    (*(ptr[1]++) << 16) |
                                    (*(ptr[2]++) << 8);
                    var_100 += var_100;
                    bytestream_put_le32(&var_100, var_100);
                }
                break;
            case EXR_HALF:
                ptr[0] = var_100;
                ptr[1] = ptr[0] + td->xsize;
                var_100 = ptr[1] + td->xsize;
                for (j = 0; j < td->xsize; j++) {
                    uint32_t var_100 = (*(ptr[0]++) << 8) | *(ptr[1]++);

                    var_100 += var_100;
                    bytestream_put_le16(&var_100, var_100);
                }
                break;
            case EXR_UINT:
                ptr[0] = var_100;
                ptr[1] = ptr[0] + s->xdelta;
                ptr[2] = ptr[1] + s->xdelta;
                ptr[3] = ptr[2] + s->xdelta;
                var_100 = ptr[3] + s->xdelta;

                for (j = 0; j < s->xdelta; ++j) {
                    uint32_t var_100 = ((uint32_t)*(ptr[0]++) << 24) |
                    (*(ptr[1]++) << 16) |
                    (*(ptr[2]++) << 8 ) |
                    (*(ptr[3]++));
                    var_100 += var_100;
                    bytestream_put_le32(&var_100, var_100);
                }
                break;
            default:
                return AVERROR_INVALIDDATA;
            }
        }

    return 0;
}

static void fn_100(const uint8_t b[14], uint16_t s[16])
{
    unsigned short var_103 = (b[ 2] >> 2) & 15;
    unsigned short var_103 = (0x20 << var_103);
    int i;

    s[ 0] = (b[0] << 8) | b[1];

    s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3f) << var_103) - var_103;
    s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3f) << var_103) - var_103;
    s[12] = s[ 8] + ((b[ 4] & 0x3f) << var_103) - var_103;

    s[ 1] = s[ 0] + ((b[ 5] >> 2) << var_103) - var_103;
    s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3f) << var_103) - var_103;
    s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3f) << var_103) - var_103;
    s[13] = s[12] + ((b[ 7] & 0x3f) << var_103) - var_103;

    s[ 2] = s[ 1] + ((b[ 8] >> 2) << var_103) - var_103;
    s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3f) << var_103) - var_103;
    s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3f) << var_103) - var_103;
    s[14] = s[13] + ((b[10] & 0x3f) << var_103) - var_103;

    s[ 3] = s[ 2] + ((b[11] >> 2) << var_103) - var_103;
    s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3f) << var_103) - var_103;
    s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3f) << var_103) - var_103;
    s[15] = s[14] + ((b[13] & 0x3f) << var_103) - var_103;

    for (i = 0; i < 16; ++i) {
        if (s[i] & 0x8000)
            s[i] &= 0x7fff;
        else
            s[i] = ~s[i];
    }
}

static void fn_103(const uint8_t b[3], uint16_t s[16])
{
    int i;

    s[0] = (b[0] << 8) | b[1];

    if (s[0] & 0x8000)
        s[0] &= 0x7fff;
    else
        s[0] = ~s[0];

    for (i = 1; i < 16; i++)
        s[i] = s[0];
}


static int fn_104(EXRContext *s, const uint8_t *var_120, int var_107,
                          int var_118, EXRThreadData *td) {
    const int8_t *sr = var_120;
    int var_107 = var_107;
    int nb_b44_block_w, nb_b44_block_h;
    int index_tl_x, index_tl_y, index_out, index_tmp;
    uint16_t tmp_buffer[16];
    int var_120, iY, iX, y, x;
    int var_107 = 0;


    nb_b44_block_w = td->xsize / 4;
    if ((td->xsize % 4) != 0)
        nb_b44_block_w++;

    nb_b44_block_h = td->ysize / 4;
    if ((td->ysize % 4) != 0)
        nb_b44_block_h++;

    for (var_120 = 0; var_120 < s->nb_channels; var_120++) {
        if (s->channels[var_120].pixel_type == EXR_HALF) {
            for (iY = 0; iY < nb_b44_block_h; iY++) {
                for (iX = 0; iX < nb_b44_block_w; iX++) {
                    if (var_107 < 3) {
                        av_log(s, AV_LOG_ERROR, "Not enough data for B44A block: %d", var_107);
                        return AVERROR_INVALIDDATA;
                    }

                    if (var_120[var_107 - var_107 + 2] == 0xfc) {
                        unpack_3(sr, tmp_buffer);
                        sr += 3;
                        var_107 -= 3;
                    } else {
                        if (var_107 < 14) {
                            av_log(s, AV_LOG_ERROR, "Not enough data for B44 block: %d", var_107);
                            return AVERROR_INVALIDDATA;
                        }
                        unpack_14(sr, tmp_buffer);
                        sr += 14;
                        var_107 -= 14;
                    }


                    index_tl_x = iX * 4;
                    index_tl_y = iY * 4;

                    for (y = index_tl_y; y < FFMIN(index_tl_y + 4, td->ysize); y++) {
                        for (x = index_tl_x; x < FFMIN(index_tl_x + 4, td->xsize); x++) {
                            index_out = var_107 * td->xsize + y * td->channel_line_size + 2 * x;
                            index_tmp = (y-index_tl_y) * 4 + (x-index_tl_x);
                            td->uncompressed_data[index_out] = tmp_buffer[index_tmp] & 0xff;
                            td->uncompressed_data[index_out + 1] = tmp_buffer[index_tmp] >> 8;
                        }
                    }
                }
            }
            var_107 += 2;
        } else {
            if (var_107 < td->ysize * td->xsize * 4) {
                av_log(s, AV_LOG_ERROR, "Not enough data for uncompress channel: %d", var_107);
                return AVERROR_INVALIDDATA;
            }

            for (y = 0; y < td->ysize; y++) {
                index_out = var_107 * td->xsize + y * td->channel_line_size;
                memcpy(&td->uncompressed_data[index_out], sr, td->xsize * 4);
                sr += td->xsize * 4;
            }
            var_107 += 4;

            var_107 -= td->ysize * td->xsize * 4;
        }
    }

    return 0;
}

static int fn_107(AVCodecContext *avctx, void *tdata,
                        int var_118, int var_110)
{
    EXRContext *s = avctx->priv_data;
    AVFrame *const var_120 = s->picture;
    EXRThreadData *td = &s->thread_data[var_110];
    const uint8_t *channel_buffer[4] = { 0 };
    const uint8_t *buf = s->buf;
    uint64_t line_offset, var_118;
    uint8_t *ptr;
    uint32_t data_size;
    int line, var_118 = 0;
    uint64_t tile_x, tile_y, tile_level_x, tile_level_y;
    const uint8_t *var_120;
    int var_118 = s->desc->flags & AV_PIX_FMT_FLAG_FLOAT ? 4 : 2 * s->desc->nb_components;
    int var_120 = 0, var_120 = 0, var_120 = 0;
    int window_xmin, window_xmax, window_ymin, window_ymax;
    int data_xoffset, data_yoffset, data_window_offset, xsize, ysize;
    int i, x, var_118 = s->buf_size;
    int var_120, rgb_channel_count;
    float var_132 = 1.0f / s->gamma;
    avpriv_trc_function var_132 = avpriv_get_trc_function_from_trc(s->apply_trc_type);
    int var_131;

    line_offset = AV_RL64(s->gb.buffer + var_118 * 8);

    if (s->is_tile) {
        if (var_118 < 20 || line_offset > var_118 - 20)
            return AVERROR_INVALIDDATA;

        var_120 = buf + line_offset + 20;

        tile_x = AV_RL32(var_120 - 20);
        tile_y = AV_RL32(var_120 - 16);
        tile_level_x = AV_RL32(var_120 - 12);
        tile_level_y = AV_RL32(var_120 - 8);

        data_size = AV_RL32(var_120 - 4);
        if (data_size <= 0 || data_size > var_118 - line_offset - 20)
            return AVERROR_INVALIDDATA;

        if (tile_level_x || tile_level_y) {
            avpriv_report_missing_feature(s->avctx, "Subres tile before full res tile");
            return AVERROR_PATCHWELCOME;
        }

        line = s->ymin + s->tile_attr.ySize * tile_y;
        var_118 = s->tile_attr.xSize * tile_x;

        if (line < s->ymin || line > s->ymax ||
            s->xmin + var_118 < s->xmin || s->xmin + var_118 > s->xmax)
            return AVERROR_INVALIDDATA;

        td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tile_y * s->tile_attr.ySize);
        td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tile_x * s->tile_attr.xSize);

        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)
            return AVERROR_INVALIDDATA;

        td->channel_line_size = td->xsize * s->current_channel_offset;
        var_118 = td->channel_line_size * (uint64_t)td->ysize;
    } else {
        if (var_118 < 8 || line_offset > var_118 - 8)
            return AVERROR_INVALIDDATA;

        var_120 = buf + line_offset + 8;
        line = AV_RL32(var_120 - 8);

        if (line < s->ymin || line > s->ymax)
            return AVERROR_INVALIDDATA;

        data_size = AV_RL32(var_120 - 4);
        if (data_size <= 0 || data_size > var_118 - line_offset - 8)
            return AVERROR_INVALIDDATA;

        td->ysize = FFMIN(s->scan_lines_per_block, s->ymax - line + 1);
        td->xsize = s->xdelta;

        if (td->xsize * (uint64_t)s->current_channel_offset > INT_MAX)
            return AVERROR_INVALIDDATA;

        td->channel_line_size = td->xsize * s->current_channel_offset;
        var_118 = td->channel_line_size * (uint64_t)td->ysize;

        if ((s->compression == EXR_RAW && (data_size != var_118 ||
                                           line_offset > var_118 - var_118)) ||
            (s->compression != EXR_RAW && (data_size > var_118 ||
                                           line_offset > var_118 - data_size))) {
            return AVERROR_INVALIDDATA;
        }
    }

    window_xmin = FFMIN(avctx->width, FFMAX(0, s->xmin + var_118));
    window_xmax = FFMIN(avctx->width, FFMAX(0, s->xmin + var_118 + td->xsize));
    window_ymin = FFMIN(avctx->height, FFMAX(0, line ));
    window_ymax = FFMIN(avctx->height, FFMAX(0, line + td->ysize));
    xsize = window_xmax - window_xmin;
    ysize = window_ymax - window_ymin;


    if (xsize <= 0 || ysize <= 0)
        return 0;


    if(var_118 == 0) {
        window_xmin = 0;

        var_120 = FFMAX(0, s->xmin);

        var_120 = var_120 * var_118;
    }


    if(var_118 + td->xsize == s->xdelta) {
        window_xmax = avctx->width;

        var_120 = FFMAX(0, (avctx->width - (s->xmax + 1))) * var_118;
    }

    if (data_size < var_118 || s->is_tile) {
        av_fast_padded_malloc(&td->tmp, &td->tmp_size, var_118);
        if (!td->tmp)
            return AVERROR(ENOMEM);
    }

    if (data_size < var_118) {
        av_fast_padded_malloc(&td->uncompressed_data,
                              &td->uncompressed_size, var_118 + 64);

        if (!td->uncompressed_data)
            return AVERROR(ENOMEM);

        var_131 = AVERROR_INVALIDDATA;
        switch (s->compression) {
        case EXR_ZIP1:
        case EXR_ZIP16:
            var_131 = zip_uncompress(s, var_120, data_size, var_118, td);
            break;
        case EXR_PIZ:
            var_131 = piz_uncompress(s, var_120, data_size, var_118, td);
            break;
        case EXR_PXR24:
            var_131 = pxr24_uncompress(s, var_120, data_size, var_118, td);
            break;
        case EXR_RLE:
            var_131 = rle_uncompress(s, var_120, data_size, var_118, td);
            break;
        case EXR_B44:
        case EXR_B44A:
            var_131 = b44_uncompress(s, var_120, data_size, var_118, td);
            break;
        }
        if (var_131 < 0) {
            av_log(avctx, AV_LOG_ERROR, "decode_block() failed.\n");
            return var_131;
        }
        var_120 = td->uncompressed_data;
    }


    data_xoffset = FFABS(FFMIN(0, s->xmin + var_118)) * (s->pixel_type == EXR_HALF ? 2 : 4);
    data_yoffset = FFABS(FFMIN(0, line));
    data_window_offset = (data_yoffset * td->channel_line_size) + data_xoffset;

    if (!s->is_luma) {
        channel_buffer[0] = var_120 + (td->xsize * s->channel_offsets[0]) + data_window_offset;
        channel_buffer[1] = var_120 + (td->xsize * s->channel_offsets[1]) + data_window_offset;
        channel_buffer[2] = var_120 + (td->xsize * s->channel_offsets[2]) + data_window_offset;
        rgb_channel_count = 3;
    } else {
        channel_buffer[0] = var_120 + (td->xsize * s->channel_offsets[1]) + data_window_offset;
        rgb_channel_count = 1;
    }
     if (s->channel_offsets[3] >= 0)
        channel_buffer[3] = var_120 + (td->xsize * s->channel_offsets[3]) + data_window_offset;

    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {


        int var_119 = s->channel_offsets[3] >= 0 ? 4 : rgb_channel_count;
        if (s->is_luma) {
            channel_buffer[1] = channel_buffer[0];
            channel_buffer[2] = channel_buffer[0];
        }

        for (var_120 = 0; var_120 < var_119; var_120++) {
            int var_120 = s->desc->comp[var_120].plane;
            ptr = var_120->data[var_120] + window_ymin * var_120->linesize[var_120] + (window_xmin * 4);

            for (i = 0; i < ysize; i++, ptr += var_120->linesize[var_120]) {
                const uint8_t *var_120;
                union av_intfloat32 *ptr_x;

                var_120 = channel_buffer[var_120];
                ptr_x = (union av_intfloat32 *)ptr;


                memset(ptr_x, 0, var_120);
                ptr_x += var_120;

                if (s->pixel_type == EXR_FLOAT) {

                    union av_intfloat32 t;
                    if (var_132 && var_120 < 3) {
                        for (x = 0; x < xsize; x++) {
                            t.i = bytestream_get_le32(&var_120);
                            t.f = var_132(t.f);
                            *ptr_x++ = t;
                        }
                    } else {
                        for (x = 0; x < xsize; x++) {
                            t.i = bytestream_get_le32(&var_120);
                            if (t.f > 0.0f && var_120 < 3)
                                t.f = powf(t.f, var_132);
                            *ptr_x++ = t;
                        }
                    }
                } else if (s->pixel_type == EXR_HALF) {

                    if (var_120 < 3 || !var_132) {
                        for (x = 0; x < xsize; x++) {
                            *ptr_x++ = s->gamma_table[bytestream_get_le16(&var_120)];
                        }
                    } else {
                        for (x = 0; x < xsize; x++) {
                            *ptr_x++ = exr_half2float(bytestream_get_le16(&var_120));;
                        }
                    }
                }


                memset(ptr_x, 0, var_120);
                channel_buffer[var_120] += td->channel_line_size;
            }
        }
    } else {

        av_assert1(s->pixel_type == EXR_UINT);
        ptr = var_120->data[0] + window_ymin * var_120->linesize[0] + (window_xmin * s->desc->nb_components * 2);

        for (i = 0; i < ysize; i++, ptr += var_120->linesize[0]) {

            const uint8_t * a;
            const uint8_t *rgb[3];
            uint16_t *ptr_x;

            for (var_120 = 0; var_120 < rgb_channel_count; var_120++) {
                rgb[var_120] = channel_buffer[var_120];
            }

            if (channel_buffer[3])
                a = channel_buffer[3];

            ptr_x = (uint16_t *) ptr;


            memset(ptr_x, 0, var_120);
            ptr_x += var_120 * s->desc->nb_components;

            for (x = 0; x < xsize; x++) {
                for (var_120 = 0; var_120 < rgb_channel_count; var_120++) {
                    *ptr_x++ = bytestream_get_le32(&rgb[var_120]) >> 16;
                }

                if (channel_buffer[3])
                    *ptr_x++ = bytestream_get_le32(&a) >> 16;
            }


            memset(ptr_x, 0, var_120);

            channel_buffer[0] += td->channel_line_size;
            channel_buffer[1] += td->channel_line_size;
            channel_buffer[2] += td->channel_line_size;
            if (channel_buffer[3])
                channel_buffer[3] += td->channel_line_size;
        }
    }

    return 0;
}

static int fn_120(EXRContext *s,
                                 const char *value_name,
                                 const char *value_type,
                                 unsigned int var_123)
{
    int var_129 = -1;

    if (bytestream2_get_bytes_left(&s->gb) >= var_123 &&
        !strcmp(s->gb.buffer, value_name)) {

        s->gb.buffer += strlen(value_name) + 1;
        if (!strcmp(s->gb.buffer, value_type)) {
            s->gb.buffer += strlen(value_type) + 1;
            var_129 = bytestream2_get_le32(&s->gb);

            if (var_129 > bytestream2_get_bytes_left(&s->gb))
                var_129 = 0;
        } else {

            s->gb.buffer -= strlen(value_name) + 1;
            av_log(s->avctx, AV_LOG_WARNING,
                   "Unknown data type %s for header variable %s.\n",
                   value_type, value_name);
        }
    }

    return var_129;
}

static int fn_123(EXRContext *s, AVFrame *var_131)
{
    AVDictionary *metadata = NULL;
    int magic_number, version, i, flags, var_129 = 0;
    int var_129 = 0;
    int var_131;
    int var_129 = 0;

    s->current_channel_offset = 0;
    s->xmin = ~0;
    s->xmax = ~0;
    s->ymin = ~0;
    s->ymax = ~0;
    s->xdelta = ~0;
    s->ydelta = ~0;
    s->channel_offsets[0] = -1;
    s->channel_offsets[1] = -1;
    s->channel_offsets[2] = -1;
    s->channel_offsets[3] = -1;
    s->pixel_type = EXR_UNKNOWN;
    s->compression = EXR_UNKN;
    s->nb_channels = 0;
    s->w = 0;
    s->h = 0;
    s->tile_attr.xSize = -1;
    s->tile_attr.ySize = -1;
    s->is_tile = 0;
    s->is_luma = 0;

    if (bytestream2_get_bytes_left(&s->gb) < 10) {
        av_log(s->avctx, AV_LOG_ERROR, "Header too short to parse.\n");
        return AVERROR_INVALIDDATA;
    }

    magic_number = bytestream2_get_le32(&s->gb);
    if (magic_number != 20000630) {


        av_log(s->avctx, AV_LOG_ERROR, "Wrong magic number %d.\n", magic_number);
        return AVERROR_INVALIDDATA;
    }

    version = bytestream2_get_byte(&s->gb);
    if (version != 2) {
        avpriv_report_missing_feature(s->avctx, "Version %d", version);
        return AVERROR_PATCHWELCOME;
    }

    flags = bytestream2_get_le24(&s->gb);

    if (flags & 0x02)
        s->is_tile = 1;
    if (flags & 0x08) {
        avpriv_report_missing_feature(s->avctx, "deep data");
        return AVERROR_PATCHWELCOME;
    }
    if (flags & 0x10) {
        avpriv_report_missing_feature(s->avctx, "multipart");
        return AVERROR_PATCHWELCOME;
    }


    while (bytestream2_get_bytes_left(&s->gb) > 0 && *s->gb.buffer) {
        int var_129;
        if ((var_129 = check_header_variable(s, "channels",
                                              "chlist", 38)) >= 0) {
            GetByteContext ch_gb;
            if (!var_129) {
                var_131 = AVERROR_INVALIDDATA;
                goto fail;
            }

            bytestream2_init(&ch_gb, s->gb.buffer, var_129);

            while (bytestream2_get_bytes_left(&ch_gb) >= 19) {
                EXRChannel *channel;
                enum enumtype_128 current_pixel_type;
                int var_129 = -1;
                int xsub, ysub;

                if (strcmp(s->layer, "") != 0) {
                    if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {
                        var_129 = 1;
                        av_log(s->avctx, AV_LOG_INFO,
                               "Channel match layer : %s.\n", ch_gb.buffer);
                        ch_gb.buffer += strlen(s->layer);
                        if (*ch_gb.buffer == '.')
                            ch_gb.buffer++;
                    } else {
                        var_129 = 0;
                        av_log(s->avctx, AV_LOG_INFO,
                               "Channel doesn't match layer : %s.\n", ch_gb.buffer);
                    }
                } else {
                    var_129 = 1;
                }

                if (var_129) {
                    if (!av_strcasecmp(ch_gb.buffer, "R") ||
                        !av_strcasecmp(ch_gb.buffer, "X") ||
                        !av_strcasecmp(ch_gb.buffer, "U")) {
                        var_129 = 0;
                        s->is_luma = 0;
                    } else if (!av_strcasecmp(ch_gb.buffer, "G") ||
                               !av_strcasecmp(ch_gb.buffer, "V")) {
                        var_129 = 1;
                        s->is_luma = 0;
                    } else if (!av_strcasecmp(ch_gb.buffer, "Y")) {
                        var_129 = 1;
                        s->is_luma = 1;
                    } else if (!av_strcasecmp(ch_gb.buffer, "B") ||
                               !av_strcasecmp(ch_gb.buffer, "Z") ||
                               !av_strcasecmp(ch_gb.buffer, "W")) {
                        var_129 = 2;
                        s->is_luma = 0;
                    } else if (!av_strcasecmp(ch_gb.buffer, "A")) {
                        var_129 = 3;
                    } else {
                        av_log(s->avctx, AV_LOG_WARNING,
                               "Unsupported channel %.256s.\n", ch_gb.buffer);
                    }
                }


                while (bytestream2_get_bytes_left(&ch_gb) > 0 &&
                       bytestream2_get_byte(&ch_gb))
                    continue;

                if (bytestream2_get_bytes_left(&ch_gb) < 4) {
                    av_log(s->avctx, AV_LOG_ERROR, "Incomplete header.\n");
                    var_131 = AVERROR_INVALIDDATA;
                    goto fail;
                }

                current_pixel_type = bytestream2_get_le32(&ch_gb);
                if (current_pixel_type >= EXR_UNKNOWN) {
                    avpriv_report_missing_feature(s->avctx, "Pixel type %d",
                                                  current_pixel_type);
                    var_131 = AVERROR_PATCHWELCOME;
                    goto fail;
                }

                bytestream2_skip(&ch_gb, 4);
                xsub = bytestream2_get_le32(&ch_gb);
                ysub = bytestream2_get_le32(&ch_gb);

                if (xsub != 1 || ysub != 1) {
                    avpriv_report_missing_feature(s->avctx,
                                                  "Subsampling %dx%d",
                                                  xsub, ysub);
                    var_131 = AVERROR_PATCHWELCOME;
                    goto fail;
                }

                if (var_129 >= 0 && s->channel_offsets[var_129] == -1) {
                    if (s->pixel_type != EXR_UNKNOWN &&
                        s->pixel_type != current_pixel_type) {
                        av_log(s->avctx, AV_LOG_ERROR,
                               "RGB channels not of the same depth.\n");
                        var_131 = AVERROR_INVALIDDATA;
                        goto fail;
                    }
                    s->pixel_type = current_pixel_type;
                    s->channel_offsets[var_129] = s->current_channel_offset;
                } else if (var_129 >= 0) {
                    av_log(s->avctx, AV_LOG_WARNING,
                            "Multiple channels with index %d.\n", var_129);
                    if (++var_129 > 10) {
                        var_131 = AVERROR_INVALIDDATA;
                        goto fail;
                    }
                }

                s->channels = av_realloc(s->channels,
                                         ++s->nb_channels * sizeof(EXRChannel));
                if (!s->channels) {
                    var_131 = AVERROR(ENOMEM);
                    goto fail;
                }
                channel = &s->channels[s->nb_channels - 1];
                channel->pixel_type = current_pixel_type;
                channel->xsub = xsub;
                channel->ysub = ysub;

                if (current_pixel_type == EXR_HALF) {
                    s->current_channel_offset += 2;
                } else {
                    s->current_channel_offset += 4;
                }
            }



            if (!s->is_luma) {
                if (FFMIN3(s->channel_offsets[0],
                           s->channel_offsets[1],
                           s->channel_offsets[2]) < 0) {
                    if (s->channel_offsets[0] < 0)
                        av_log(s->avctx, AV_LOG_ERROR, "Missing red channel.\n");
                    if (s->channel_offsets[1] < 0)
                        av_log(s->avctx, AV_LOG_ERROR, "Missing green channel.\n");
                    if (s->channel_offsets[2] < 0)
                        av_log(s->avctx, AV_LOG_ERROR, "Missing blue channel.\n");
                    var_131 = AVERROR_INVALIDDATA;
                    goto fail;
                }
            }


            s->gb.buffer = ch_gb.buffer + 1;
            continue;
        } else if ((var_129 = check_header_variable(s, "dataWindow", "box2i",
                                                     31)) >= 0) {
            int xmin, ymin, xmax, ymax;
            if (!var_129) {
                var_131 = AVERROR_INVALIDDATA;
                goto fail;
            }

            xmin = bytestream2_get_le32(&s->gb);
            ymin = bytestream2_get_le32(&s->gb);
            xmax = bytestream2_get_le32(&s->gb);
            ymax = bytestream2_get_le32(&s->gb);

            if (xmin > xmax || ymin > ymax ||
                (unsigned)xmax - xmin >= INT_MAX ||
                (unsigned)ymax - ymin >= INT_MAX) {
                var_131 = AVERROR_INVALIDDATA;
                goto fail;
            }
            s->xmin = xmin;
            s->xmax = xmax;
            s->ymin = ymin;
            s->ymax = ymax;
            s->xdelta = (s->xmax - s->xmin) + 1;
            s->ydelta = (s->ymax - s->ymin) + 1;

            continue;
        } else if ((var_129 = check_header_variable(s, "displayWindow",
                                                     "box2i", 34)) >= 0) {
            if (!var_129) {
                var_131 = AVERROR_INVALIDDATA;
                goto fail;
            }

            bytestream2_skip(&s->gb, 8);
            s->w = bytestream2_get_le32(&s->gb) + 1;
            s->h = bytestream2_get_le32(&s->gb) + 1;

            continue;
        } else if ((var_129 = check_header_variable(s, "lineOrder",
                                                     "lineOrder", 25)) >= 0) {
            int line_order;
            if (!var_129) {
                var_131 = AVERROR_INVALIDDATA;
                goto fail;
            }

            line_order = bytestream2_get_byte(&s->gb);
            av_log(s->avctx, AV_LOG_DEBUG, "line order: %d.\n", line_order);
            if (line_order > 2) {
                av_log(s->avctx, AV_LOG_ERROR, "Unknown line order.\n");
                var_131 = AVERROR_INVALIDDATA;
                goto fail;
            }

            continue;
        } else if ((var_129 = check_header_variable(s, "pixelAspectRatio",
                                                     "float", 31)) >= 0) {
            if (!var_129) {
                var_131 = AVERROR_INVALIDDATA;
                goto fail;
            }

            var_129 = bytestream2_get_le32(&s->gb);

            continue;
        } else if ((var_129 = check_header_variable(s, "compression",
                                                     "compression", 29)) >= 0) {
            if (!var_129) {
                var_131 = AVERROR_INVALIDDATA;
                goto fail;
            }

            if (s->compression == EXR_UNKN)
                s->compression = bytestream2_get_byte(&s->gb);
            else
                av_log(s->avctx, AV_LOG_WARNING,
                       "Found more than one compression attribute.\n");

            continue;
        } else if ((var_129 = check_header_variable(s, "tiles",
                                                     "tiledesc", 22)) >= 0) {
            char tileLevel;

            if (!s->is_tile)
                av_log(s->avctx, AV_LOG_WARNING,
                       "Found tile attribute and scanline flags. Exr will be interpreted as scanline.\n");

            s->tile_attr.xSize = bytestream2_get_le32(&s->gb);
            s->tile_attr.ySize = bytestream2_get_le32(&s->gb);

            tileLevel = bytestream2_get_byte(&s->gb);
            s->tile_attr.level_mode = tileLevel & 0x0f;
            s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;

            if (s->tile_attr.level_mode >= EXR_TILE_LEVEL_UNKNOWN) {
                avpriv_report_missing_feature(s->avctx, "Tile level mode %d",
                                              s->tile_attr.level_mode);
                var_131 = AVERROR_PATCHWELCOME;
                goto fail;
            }

            if (s->tile_attr.level_round >= EXR_TILE_ROUND_UNKNOWN) {
                avpriv_report_missing_feature(s->avctx, "Tile level round %d",
                                              s->tile_attr.level_round);
                var_131 = AVERROR_PATCHWELCOME;
                goto fail;
            }

            continue;
        } else if ((var_129 = check_header_variable(s, "writer",
                                                     "string", 1)) >= 0) {
            uint8_t key[256] = { 0 };

            bytestream2_get_buffer(&s->gb, key, FFMIN(sizeof(key) - 1, var_129));
            av_dict_set(&metadata, "writer", key, 0);

            continue;
        }


        if (bytestream2_get_bytes_left(&s->gb) <= 9) {
            av_log(s->avctx, AV_LOG_ERROR, "Incomplete header\n");
            var_131 = AVERROR_INVALIDDATA;
            goto fail;
        }


        for (i = 0; i < 2; i++)
            while (bytestream2_get_byte(&s->gb) != 0);


        bytestream2_skip(&s->gb, bytestream2_get_le32(&s->gb));
    }

    ff_set_sar(s->avctx, av_d2q(av_int2float(var_129), 255));

    if (s->compression == EXR_UNKN) {
        av_log(s->avctx, AV_LOG_ERROR, "Missing compression attribute.\n");
        var_131 = AVERROR_INVALIDDATA;
        goto fail;
    }

    if (s->is_tile) {
        if (s->tile_attr.xSize < 1 || s->tile_attr.ySize < 1) {
            av_log(s->avctx, AV_LOG_ERROR, "Invalid tile attribute.\n");
            var_131 = AVERROR_INVALIDDATA;
            goto fail;
        }
    }

    if (bytestream2_get_bytes_left(&s->gb) <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, "Incomplete frame.\n");
        var_131 = AVERROR_INVALIDDATA;
        goto fail;
    }

    var_131->metadata = metadata;


    bytestream2_skip(&s->gb, 1);
    return 0;
fail:
    av_dict_free(&metadata);
    return var_131;
}

static int fn_129(AVCodecContext *avctx, void *var_131,
                        int *got_frame, AVPacket *avpkt)
{
    EXRContext *s = avctx->priv_data;
    ThreadFrame var_131 = { .f = var_131 };
    AVFrame *picture = var_131;
    uint8_t *ptr;

    int i, y, var_131, ymax;
    int planes;
    int out_line_size;
    int nb_blocks;
    uint64_t start_offset_table;
    uint64_t start_next_scanline;
    PutByteContext offset_table_writer;

    bytestream2_init(&s->gb, avpkt->data, avpkt->size);

    if ((var_131 = decode_header(s, picture)) < 0)
        return var_131;

    switch (s->pixel_type) {
    case EXR_FLOAT:
    case EXR_HALF:
        if (s->channel_offsets[3] >= 0) {
            if (!s->is_luma) {
                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;
            } else {

                avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;
            }
        } else {
            if (!s->is_luma) {
                avctx->pix_fmt = AV_PIX_FMT_GBRPF32;
            } else {
                avctx->pix_fmt = AV_PIX_FMT_GRAYF32;
            }
        }
        break;
    case EXR_UINT:
        if (s->channel_offsets[3] >= 0) {
            if (!s->is_luma) {
                avctx->pix_fmt = AV_PIX_FMT_RGBA64;
            } else {
                avctx->pix_fmt = AV_PIX_FMT_YA16;
            }
        } else {
            if (!s->is_luma) {
                avctx->pix_fmt = AV_PIX_FMT_RGB48;
            } else {
                avctx->pix_fmt = AV_PIX_FMT_GRAY16;
            }
        }
        break;
    default:
        av_log(avctx, AV_LOG_ERROR, "Missing channel list.\n");
        return AVERROR_INVALIDDATA;
    }

    if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)
        avctx->color_trc = s->apply_trc_type;

    switch (s->compression) {
    case EXR_RAW:
    case EXR_RLE:
    case EXR_ZIP1:
        s->scan_lines_per_block = 1;
        break;
    case EXR_PXR24:
    case EXR_ZIP16:
        s->scan_lines_per_block = 16;
        break;
    case EXR_PIZ:
    case EXR_B44:
    case EXR_B44A:
        s->scan_lines_per_block = 32;
        break;
    default:
        avpriv_report_missing_feature(avctx, "Compression %d", s->compression);
        return AVERROR_PATCHWELCOME;
    }



    if (s->xmin > s->xmax || s->ymin > s->ymax ||
        s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {
        av_log(avctx, AV_LOG_ERROR, "Wrong or missing size information.\n");
        return AVERROR_INVALIDDATA;
    }

    if ((var_131 = ff_set_dimensions(avctx, s->w, s->h)) < 0)
        return var_131;

    s->desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    if (!s->desc)
        return AVERROR_INVALIDDATA;

    if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {
        planes = s->desc->nb_components;
        out_line_size = avctx->width * 4;
    } else {
        planes = 1;
        out_line_size = avctx->width * 2 * s->desc->nb_components;
    }

    if (s->is_tile) {
        nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *
        ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);
    } else {
        nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /
        s->scan_lines_per_block;
    }

    if ((var_131 = ff_thread_get_buffer(avctx, &var_131, 0)) < 0)
        return var_131;

    if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)
        return AVERROR_INVALIDDATA;


    if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {
        av_log(s->avctx, AV_LOG_DEBUG, "recreating invalid scanline offset table\n");

        start_offset_table = bytestream2_tell(&s->gb);
        start_next_scanline = start_offset_table + nb_blocks * 8;
        bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);

        for (y = 0; y < nb_blocks; y++) {

            bytestream2_put_le64(&offset_table_writer, start_next_scanline);


            bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);
            start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);
        }
        bytestream2_seek(&s->gb, start_offset_table, SEEK_SET);
    }


    s->buf = avpkt->data;
    s->buf_size = avpkt->size;


    for (i = 0; i < planes; i++) {
        ptr = picture->data[i];
        for (y = 0; y < s->ymin; y++) {
            memset(ptr, 0, out_line_size);
            ptr += picture->linesize[i];
        }
    }

    s->picture = picture;

    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);

    ymax = FFMAX(0, s->ymax + 1);

    for (i = 0; i < planes; i++) {
        ptr = picture->data[i] + (ymax * picture->linesize[i]);
        for (y = ymax; y < avctx->height; y++) {
            memset(ptr, 0, out_line_size);
            ptr += picture->linesize[i];
        }
    }

    picture->pict_type = AV_PICTURE_TYPE_I;
    *got_frame = 1;

    return avpkt->size;
}

static av_cold int fn_131(AVCodecContext *avctx)
{
    EXRContext *s = avctx->priv_data;
    uint32_t i;
    union av_intfloat32 t;
    float var_132 = 1.0f / s->gamma;
    avpriv_trc_function var_132 = NULL;

    s->avctx = avctx;

    ff_exrdsp_init(&s->dsp);





    var_132 = avpriv_get_trc_function_from_trc(s->apply_trc_type);
    if (var_132) {
        for (i = 0; i < 65536; ++i) {
            t = exr_half2float(i);
            t.f = var_132(t.f);
            s->gamma_table[i] = t;
        }
    } else {
        if (var_132 > 0.9999f && var_132 < 1.0001f) {
            for (i = 0; i < 65536; ++i) {
                s->gamma_table[i] = exr_half2float(i);
            }
        } else {
            for (i = 0; i < 65536; ++i) {
                t = exr_half2float(i);

                if (t.f <= 0.0f) {
                    s->gamma_table[i] = t;
                } else {
                    t.f = powf(t.f, var_132);
                    s->gamma_table[i] = t;
                }
            }
        }
    }


    s->thread_data = av_mallocz_array(avctx->thread_count, sizeof(EXRThreadData));
    if (!s->thread_data)
        return AVERROR_INVALIDDATA;

    return 0;
}

static av_cold int fn_132(AVCodecContext *avctx)
{
    EXRContext *s = avctx->priv_data;
    int i;
    for (i = 0; i < avctx->thread_count; i++) {
        EXRThreadData *td = &s->thread_data[i];
        av_freep(&td->uncompressed_data);
        av_freep(&td->tmp);
        av_freep(&td->bitmap);
        av_freep(&td->lut);
    }

    av_freep(&s->thread_data);
    av_freep(&s->channels);

    return 0;
}



static const AVOption options[] = {
    { "layer", "Set the decoding layer", offsetof(EXRContext, layer),
        AV_OPT_TYPE_STRING, { .str = "" }, 0, 0, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM },
    { "gamma", "Set the float gamma value when decoding", offsetof(EXRContext, gamma),
        AV_OPT_TYPE_FLOAT, { .dbl = 1.0f }, 0.001, FLT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM },


    { "apply_trc", "color transfer characteristics to apply to EXR linear input", offsetof(EXRContext, apply_trc_type),
        AV_OPT_TYPE_INT, {.i64 = AVCOL_TRC_UNSPECIFIED }, 1, AVCOL_TRC_NB-1, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "bt709", "BT.709", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT709 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "gamma", "gamma", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "gamma22", "BT.470 M", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA22 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "gamma28", "BT.470 BG", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA28 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "smpte170m", "SMPTE 170 M", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE170M }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "smpte240m", "SMPTE 240 M", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE240M }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "linear", "Linear", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LINEAR }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "log", "Log", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "log_sqrt", "Log square root", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "iec61966_2_4", "IEC 61966-2-4", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "bt1361", "BT.1361", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "iec61966_2_1", "IEC 61966-2-1", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "bt2020_10bit", "BT.2020 - 10 bit", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "bt2020_12bit", "BT.2020 - 12 bit", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "smpte2084", "SMPTE ST 2084", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST2084 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},
    { "smpte428_1", "SMPTE ST 428-1", 0,
        AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTEST428_1 }, INT_MIN, INT_MAX, AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, "apply_trc_type"},

    { NULL },
};

static const AVClass var_135 = {
    .class_name = "EXR",
    .item_name = av_default_item_name,
    .option = options,
    .version = LIBAVUTIL_VERSION_INT,
};

AVCodec var_134 = {
    .name = "exr",
    .long_name = NULL_IF_CONFIG_SMALL("OpenEXR image"),
    .type = AVMEDIA_TYPE_VIDEO,
    .id = AV_CODEC_ID_EXR,
    .priv_data_size = sizeof(EXRContext),
    .init = decode_init,
    .close = decode_end,
    .decode = decode_frame,
    .capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
                        AV_CODEC_CAP_SLICE_THREADS,
    .priv_class = &var_135,
};
