







void fn_145(GF_Terminal *term);
void fn_145(GF_Terminal *term, u32 var_145, u32 var_145, const char *URL);
void fn_145(GF_Terminal *term, GF_ObjectManager *root_odm, u32 var_145, u32 var_148, char *root_name);

void fn_148(GF_Terminal *term, Bool var_148);
void fn_148();

static u32 var_139 = 0;

static Bool var_132 = var_132;
static Bool var_133 = var_132;

Bool var_132 = 0;






static u32 var_132 = 0;


static Bool var_132 = var_132;
static Bool var_132 = var_132;
static Bool var_132 = var_132;
static u32 var_144 = 0;
static u32 var_145 = 0;
static u32 var_144 = 0;
static Bool var_132 = var_132;
static Bool var_96 = var_139;
Bool var_134 = var_132;
Bool var_132 = var_132;
GF_User user;
GF_Terminal *term;
u64 Duration;
GF_Err var_94 = var_148;
static Bool var_132 = var_139;
static Fixed var_132 = var_132;

static s32 var_132 = var_132;
FILE *playlist = NULL;
static Bool var_132 = var_132;

static GF_Config *cfg_file;
static u32 var_136 = 0;
static Bool Run;
static Bool var_134 = var_132;
static char the_url[GF_MAX_PATH];
static char pl_path[GF_MAX_PATH];
static Bool var_132 = var_139;
static Bool var_132 = var_132;
static u64 var_132 = 0;
static Bool var_132 = var_132;
static Bool var_132 = var_132;
static u32 var_132=0;
static u32 var_132=0;


u32 var_132 = 0;
u32 var_132 = 0;
u32 var_132 = 0;
u32 last_x, last_y;
Bool var_94 = var_132;

void fn_47(GF_Terminal *term, char *rad_path, u32 var_48, u32 var_49);

enum
{
 enum_50 = 0,
 enum_51 = 1,
 enum_52 = 2,
 enum_53 = 3,
 enum_54 = 4,
 enum_55 = 5,


 enum_56 = 65536,
 enum_57 = 131072,
 enum_58 = 262144
};

Bool fn_59(char *the_url, char *out_url, u32 var_132, Double var_132, u32 var_62, u32 var_63, Float var_132, u32 *times, u32 var_132);


static Bool var_94 = var_139;
void fn_67(u32 var_68)
{

}


void fn_69(const char *url)
{
 GF_Event evt;
 memset(&evt, 0, sizeof(GF_Event));
 evt.type = GF_EVENT_NAVIGATE;
 evt.navigate.to_url = url;
 gf_term_send_event(term, &evt);
}

void fn_70()
{
 fprintf(stderr, "Usage MP4Client [options] [filename]\n"
         "\t-c fileName:    user-defined configuration file. Also works with -cfg\n"




         "\t-rti fileName:  logs run-time info (FPS, CPU, Mem usage) to file\n"
         "\t-rtix fileName: same as -rti but driven by GPAC logs\n"
         "\t-quiet:         removes script message, buffering and downloading status\n"
         "\t-strict-error:  exit when the player reports its first error\n"
         "\t-opt option:    Overrides an option in the configuration file. String format is section:key=value. \n"
         "\t                  \"section:key=null\" removes the key\n"
         "\t                  \"section:*=null\" removes the section\n"
         "\t-conf option:   Same as -opt but does not start player.\n"
         "\t-log-file file: sets output log file. Also works with -lf\n"
         "\t-logs log_args: sets log tools and levels, formatted as a ':'-separated list of toolX[:toolZ]@levelX\n"
         "\t                 levelX can be one of:\n"
         "\t        \"quiet\"      : skip logs\n"
         "\t        \"error\"      : logs only error messages\n"
         "\t        \"warning\"    : logs error+warning messages\n"
         "\t        \"info\"       : logs error+warning+info messages\n"
         "\t        \"debug\"      : logs all messages\n"
         "\t                 toolX can be one of:\n"
         "\t        \"core\"       : libgpac core\n"
         "\t        \"coding\"     : bitstream formats (audio, video, scene)\n"
         "\t        \"container\"  : container formats (ISO File, MPEG-2 TS, AVI, ...)\n"
         "\t        \"network\"    : network data exept RTP trafic\n"
         "\t        \"rtp\"        : rtp trafic\n"
         "\t        \"author\"     : authoring tools (hint, import, export)\n"
         "\t        \"sync\"       : terminal sync layer\n"
         "\t        \"codec\"      : terminal codec messages\n"
         "\t        \"parser\"     : scene parsers (svg, xmt, bt) and other\n"
         "\t        \"media\"      : terminal media object management\n"
         "\t        \"scene\"      : scene graph and scene manager\n"
         "\t        \"script\"     : scripting engine messages\n"
         "\t        \"interact\"   : interaction engine (events, scripts, etc)\n"
         "\t        \"smil\"       : SMIL timing engine\n"
         "\t        \"compose\"    : composition engine (2D, 3D, etc)\n"
         "\t        \"mmio\"       : Audio/Video HW I/O management\n"
         "\t        \"rti\"        : various run-time stats\n"
         "\t        \"cache\"      : HTTP cache subsystem\n"
         "\t        \"audio\"      : Audio renderer and mixers\n"




         "\t        \"dash\"       : HTTP streaming logs\n"

         "\t        \"module\"     : GPAC modules debugging\n"
         "\t        \"mutex\"      : mutex\n"
         "\t        \"all\"        : all tools logged - other tools can be specified afterwards.\n"
         "\tThe special value \"ncl\" disables color logs.\n"
         "\n"
         "\t-log-clock or -lc      : logs time in micro sec since start time of GPAC before each log line.\n"
         "\t-log-utc or -lu        : logs UTC time in ms before each log line.\n"
         "\t-ifce IPIFCE           : Sets default Multicast interface\n"
         "\t-size WxH:      specifies visual size (default: scene size)\n"



         "\t-no-thread:     disables thread usage (except for audio)\n"

         "\t-no-cthread:    disables compositor thread (iOS and Android mode)\n"
         "\t-no-audio:      disables audio \n"
         "\t-no-wnd:        uses windowless mode (Win32 only)\n"
         "\t-no-back:       uses transparent background for output window when no background is specified (Win32 only)\n"
         "\t-align vh:      specifies v and h alignment for windowless mode\n"
         "\t                 possible v values: t(op), m(iddle), b(ottom)\n"
         "\t                 possible h values: l(eft), m(iddle), r(ight)\n"
         "\t                 default alignment is top-left\n"
         "\t                 default alignment is top-left\n"
         "\t-pause:         pauses at first frame\n"
         "\t-play-from T:   starts from T seconds in media\n"
         "\t-speed S:       starts with speed S\n"
         "\t-loop:          loops presentation\n"
         "\t-no-regulation: disables framerate regulation\n"
         "\t-bench:         disable a/v output and bench source decoding (as fast as possible)\n"
         "\t-vbench:        disable audio output, video sync bench source decoding/display (as fast as possible)\n"
         "\t-sbench:        disable all decoders and bench systems layer (as fast as possible)\n"
         "\t-fs:            starts in fullscreen mode\n"
         "\t-views v1:.:vN: creates an auto-stereo scene of N views. vN can be any type of URL supported by GPAC.\n"
         "\t                 in this mode, URL argument of GPAC is ignored, GUI as well.\n"
         "\t                 this is equivalent as using views:
         "\t-mosaic v1:.:vN: creates a mosaic of N views. vN can be any var_99 of URL supported by GPAC.\n"
         "\t                 in this mode, URL argument of GPAC is ignored.\n"
         "\t                 this is equivalent as using mosaic:
         "\n"
         "\t-exit:          automatically exits when presentation is over\n"
         "\t-run-for TIME:  runs for TIME seconds and exits\n"
         "\t-service ID:    auto-tune to given service ID in a multiplex\n"
         "\t-noprog:        disable progress report\n"
         "\t-no-save:       disable saving config file on exit\n"
         "\t-no-addon:      disable automatic loading of media addons declared in source URL\n"
         "\t-gui:           starts in GUI mode. The GUI is indicated in GPAC config, section General, by the key [StartupFile]\n"
         "\t-ntp-var_132 T:   shifts NTP clock of T (signed int) milliseconds\n"
         "\n"
         "Dumper Options (times is a formated as start-end, with start being sec, h:m:s:f/var_132 or h:m:s:ms):\n"
         "\t-bmp [times]:   dumps given frames to bmp\n"
         "\t-png [times]:   dumps given frames to png\n"
         "\t-raw [times]:   dumps given frames to raw\n"
         "\t-avi [times]:   dumps given file to raw avi\n"
         "\t-sha [times]:   dumps given file to raw SHA-1 (1 hash per frame)\n"
         "\r-out filename:  name of the output file\n"
         "\t-rgbds:         dumps the RGBDS pixel format texture\n"
         "\t                 with -avi [times]: dumps an rgbds-format .avi\n"
         "\t-rgbd:          dumps the RGBD pixel format texture\n"
         "\t                 with -avi [times]: dumps an rgbd-format .avi\n"
         "\t-depth:         dumps depthmap (z-buffer) frames\n"
         "\t                 with -avi [times]: dumps depthmap in grayscale .avi\n"
         "\t                 with -bmp: dumps depthmap in grayscale .bmp\n"
         "\t                 with -png: dumps depthmap in grayscale .png\n"
         "\t-var_132 var_145:       specifies frame rate for AVI dumping (default: %f)\n"
         "\t-var_132 s:       scales the visual size (default: 1)\n"
         "\t-fill:          uses fill aspect ratio for dumping (default: none)\n"
         "\t-show:          shows window while dumping (default: no)\n"
         "\n"
         "\t-uncache:       Revert all cached items to their original name and location. Does not start player.\n"
         "\n"
         "\t-help:          shows this screen\n"
         "\n"
         "MP4Client - GPAC command line player and dumper - version "GPAC_FULL_VERSION"\n"
         "(c) Telecom ParisTech 2000-2018 - Licence LGPL v2\n"
         "GPAC Configuration: " GPAC_CONFIGURATION "\n"
         "Features: %s\n",
         var_132,
         gpac_features()
        );
}

void fn_75()
{
 fprintf(stderr, "MP4Client command keys:\n"
         "\tq: quit\n"
         "\tX: kill\n"
         "\to: connect to the specified URL\n"
         "\tO: connect to the specified playlist\n"
         "\tN: switch to the next URL in the playlist. Also works with \\n\n"
         "\tP: jumps to a given number ahead in the playlist\n"
         "\tr: reload current presentation\n"
         "\tD: disconnects the current presentation\n"
         "\tG: selects object or service ID\n"
         "\n"
         "\tp: play/pause the presentation\n"
         "\ts: step one frame ahead\n"
         "\tz: seek into presentation by percentage\n"
         "\tT: seek into presentation by time\n"
         "\tt: print current timing\n"
         "\n"
         "\tu: sends a command (BIFS or LASeR) to the main scene\n"
         "\te: evaluates JavaScript code\n"
         "\tZ: dumps output video to PNG\n"
         "\n"
         "\tw: view world info\n"
         "\tv: view Object Descriptor list\n"
         "\ti: view Object Descriptor info (by ID)\n"
         "\tj: view Object Descriptor info (by number)\n"
         "\tb: view media objects timing and buffering info\n"
         "\tm: view media objects buffering and memory info\n"
         "\td: dumps scene graph\n"
         "\n"
         "\tk: turns stress mode on/off\n"
         "\tn: changes navigation mode\n"
         "\tx: reset to last active viewpoint\n"
         "\n"
         "\t3: switch OpenGL on or off for 2D scenes\n"
         "\n"
         "\t4: forces 4/3 Aspect Ratio\n"
         "\t5: forces 16/9 Aspect Ratio\n"
         "\t6: forces no Aspect Ratio (always fill screen)\n"
         "\t7: forces original Aspect Ratio (default)\n"
         "\n"
         "\tL: changes to new log level. CF MP4Client usage for possible values\n"
         "\tT: select new tools to log. CF MP4Client usage for possible values\n"
         "\n"
         "\tl: list available modules\n"
         "\tc: prints some GPAC configuration info\n"
         "\tE: forces reload of GPAC configuration\n"
         "\n"
         "\tR: toggles run-time info display in window title bar on/off\n"
         "\tF: toggle displaying of FPS in stderr on/off\n"
         "\tg: print GPAC allocated memory\n"
         "\th: print this message\n"
         "\n"
         "\tEXPERIMENTAL/UNSTABLE OPTIONS\n"
         "\tC: Enable Streaming Cache\n"
         "\tS: Stops Streaming Cache and save to file\n"
         "\tA: Aborts Streaming Cache\n"
         "\tM: specifies video cache memory for 2D objects\n"
         "\n"
         "MP4Client - GPAC command line player - version %s\n"
         "GPAC Written by Jean Le Feuvre (c) 2001-2005 - ENST (c) 2005-200X\n",

         GPAC_FULL_VERSION
        );
}


static void fn_76(u64 var_134)
{
 u32 ms, h, m, s;
 h = (u32) (var_134 / 1000 / 3600);
 m = (u32) (var_134 / 1000 / 60 - h*60);
 s = (u32) (var_134 / 1000 - h*3600 - m*60);
 ms = (u32) (var_134 - (h*3600 + m*60 + s) * 1000);
 fprintf(stderr, "%02d:%02d:%02d.%03d", h, m, s, ms);
}

void fn_141(Bool var_145);


static u32 var_136 = 200;
static FILE *rti_logs = NULL;

static void fn_81(const char *legend)
{
 GF_SystemRTInfo rti;


 if (!var_136 && !rti_logs) return;
 if (!gf_sys_get_rti(var_136, &rti, 0) && !legend)
  return;

 if (var_136) {
  char szMsg[1024];

  if (rti.total_cpu_usage && (var_144<2) ) {
   sprintf(szMsg, "FPS %02.02f CPU %2d (%02d) Mem %d kB",
           gf_term_get_framerate(term, 0), rti.total_cpu_usage, rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024));
  } else {
   sprintf(szMsg, "FPS %02.02f CPU %02d Mem %d kB",
           gf_term_get_framerate(term, 0), rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024) );
  }

  if (var_136==2) {
   if (var_144>=2) {
    PrintAVInfo(var_132);
   }
   fprintf(stderr, "%s\r", szMsg);
  } else {
   GF_Event evt;
   evt.type = GF_EVENT_SET_CAPTION;
   evt.caption.caption = szMsg;
   gf_term_user_event(term, &evt);
  }
 }
 if (rti_logs) {
  fprintf(rti_logs, "% 8d\t% 8d\t% 8d\t% 4d\t% 8d\t%s",
          gf_sys_clock(),
          gf_term_get_time_in_ms(term),
          rti.total_cpu_usage,
          (u32) gf_term_get_framerate(term, 0),
          (u32) (rti.gpac_memory / 1024),
          legend ? legend : ""
         );
  if (!legend) fprintf(rti_logs, "\n");
 }
}

static void fn_82()
{
 GF_Event event;
 if (var_136) return;
 event.type = GF_EVENT_SET_CAPTION;
 if (var_134) {
  char szName[1024];
  NetInfoCommand com;

  event.caption.caption = NULL;

  if (!var_132 && gf_term_get_service_info(term, gf_term_get_root_object(term), &com) == var_148) {
   strcpy(szName, "");
   if (com.track_info) {
    char szBuf[10];
    sprintf(szBuf, "%02d ", (u32) (com.track_info>>16) );
    strcat(szName, szBuf);
   }
   if (com.artist) {
    strcat(szName, com.artist);
    strcat(szName, " ");
   }
   if (com.name) {
    strcat(szName, com.name);
    strcat(szName, " ");
   }
   if (com.album) {
    strcat(szName, "(");
    strcat(szName, com.album);
    strcat(szName, ")");
   }
   if (com.provider) {
    strcat(szName, "(");
    strcat(szName, com.provider);
    strcat(szName, ")");
   }

   if (strlen(szName)) event.caption.caption = szName;
  }
  if (!event.caption.caption) {
   char *str = strrchr(the_url, '\\');
   if (!str) str = strrchr(the_url, '/');
   event.caption.caption = str ? str+1 : the_url;
  }
 } else {
  event.caption.caption = "GPAC MP4Client " GPAC_FULL_VERSION;
 }
 gf_term_user_event(term, &event);
}

void fn_83(u32 var_85)
{
 var_144 = var_85;
 var_136 = var_85 ? 2 : 0;
 ResetCaption();
 gf_term_set_option(term, GF_OPT_VIDEO_BENCH, var_85);
}



int fn_85() {
 struct struct_87 old;
 struct struct_87 new;
 int rc;
 if (tcgetattr(0, &old) == -1) {
  return -1;
 }
 new = old;
 new.c_lflag &= ~(ICANON | ECHO);
 new.c_cc[VMIN] = 1;
 new.c_cc[VTIME] = 0;
 if (tcsetattr(0, TCSANOW, &new) == -1) {
  return -1;
 }
 rc = getchar();
 (void) tcsetattr(0, TCSANOW, &old);
 return rc;
}

static const char * fn_87(char * line, int var_91, Bool var_91) {
 char read;
 int var_148 = 0;
 if (fflush( stderr ))
  perror("Failed to flush buffer %s");
 do {
  line[var_148] = '\0';
  if (var_148 >= var_91 - 1)
   return line;
  read = getch();
  if (read == 8 || read == 127) {
   if (var_148 > 0) {
    fprintf(stderr, "\b \b");
    var_148--;
   }
  } else if (read > 32) {
   fputc(var_91 ? read : '*', stderr);
   line[var_148++] = read;
  }
  fflush(stderr);
 } while (read != '\n');
 if (!read)
  return 0;
 return line;
}

static void fn_91(Fixed var_93)
{
 if (gf_term_set_speed(term, var_93) == var_148) {
  var_132 = var_93;
  fprintf(stderr, "Playing at %g speed\n", FIX2FLT(var_132));
 } else {
  fprintf(stderr, "Adjusting speed to %g not supported for this content\n", FIX2FLT(var_93));
 }
}

Bool fn_93(void *ptr, GF_Event *evt)
{
 if (!term) return 0;

 if (var_139==1) {
  if (evt->type==GF_EVENT_QUIT) {
   Run = 0;
  } else if (evt->type==GF_EVENT_KEYDOWN) {
   switch (evt->key.key_code) {
   case GF_KEY_C:
    if (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {
     hide_shell(var_94 ? 1 : 0);
     if (var_94) var_139=2;
    }
    break;
   default:
    break;
   }
  }
  return 0;
 }

 switch (evt->type) {
 case GF_EVENT_DURATION:
  Duration = (u64) ( 1000 * (s64) evt->duration.duration);
  var_134 = evt->duration.can_seek;
  break;
 case GF_EVENT_MESSAGE:
 {
  const char *servName;
  if (!evt->message.service || !strcmp(evt->message.service, the_url)) {
   servName = "";
  } else if (!strnicmp(evt->message.service, "data:", 5)) {
   servName = "(embedded data)";
  } else {
   servName = evt->message.service;
  }


  if (!evt->message.message) return 0;

  if (evt->message.error) {
   if (!var_134) var_94 = evt->message.error;
   if (evt->message.error==GF_SCRIPT_INFO) {
    GF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, ("%s\n", evt->message.message));
   } else {
    GF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, ("%s %s: %s\n", servName, evt->message.message, gf_error_to_string(evt->message.error)));
   }
  } else if (!var_132)
   GF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, ("%s %s\n", servName, evt->message.message));
 }
 break;
 case GF_EVENT_PROGRESS:
 {
  char *szTitle = "";
  if (evt->progress.progress_type==0) {
   szTitle = "Buffer ";
   if (var_144 && (var_144!=3) ) {
    if (evt->progress.done >= evt->progress.total) var_144 = 0;
    else var_144 = 1 + 100*evt->progress.done / evt->progress.total;
    break;
   }
  }
  else if (evt->progress.progress_type==1) {
   if (var_144) break;
   szTitle = "Download ";
  }
  else if (evt->progress.progress_type==2) szTitle = "Import ";
  gf_set_progress(szTitle, evt->progress.done, evt->progress.total);
 }
 break;


 case GF_EVENT_DBLCLICK:
  gf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));
  return 0;

 case GF_EVENT_MOUSEDOWN:
  if (evt->mouse.button==GF_MOUSE_RIGHT) {
   var_94 = 1;
   last_x = evt->mouse.x;
   last_y = evt->mouse.y;
  }
  return 0;
 case GF_EVENT_MOUSEUP:
  if (evt->mouse.button==GF_MOUSE_RIGHT) {
   var_94 = 0;
   last_x = evt->mouse.x;
   last_y = evt->mouse.y;
  }
  return 0;
 case GF_EVENT_MOUSEMOVE:
  if (var_94 && (user.init_flags & GF_TERM_WINDOWLESS) ) {
   GF_Event move;
   move.move.x = evt->mouse.x - last_x;
   move.move.y = last_y-evt->mouse.y;
   move.type = GF_EVENT_MOVE;
   move.move.relative = 1;
   gf_term_user_event(term, &move);
  }
  return 0;

 case GF_EVENT_KEYUP:
  switch (evt->key.key_code) {
  case GF_KEY_SPACE:
   if (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!var_144);
   break;
  }
  break;
 case GF_EVENT_KEYDOWN:
  gf_term_process_shortcut(term, evt);
  switch (evt->key.key_code) {
  case GF_KEY_SPACE:
   if (evt->key.flags & GF_KEY_MOD_CTRL) {

    if (!var_144) switch_bench(!var_144);
   }
   break;
  case GF_KEY_PAGEDOWN:
  case GF_KEY_MEDIANEXTTRACK:
   var_132 = 1;
   break;
  case GF_KEY_MEDIAPREVIOUSTRACK:
   break;
  case GF_KEY_ESCAPE:
   gf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));
   break;
  case GF_KEY_C:
   if (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {
    hide_shell(var_94 ? 1 : 0);
    if (!var_94) var_139=1;
   }
   break;
  case GF_KEY_F:
   if (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, "Rendering rate: %f FPS\n", gf_term_get_framerate(term, 0));
   break;
  case GF_KEY_T:
   if (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, "Scene Time: %f \n", gf_term_get_time_in_ms(term)/1000.0);
   break;
  case GF_KEY_D:
   if (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );
   break;
  case GF_KEY_4:
   if (evt->key.flags & GF_KEY_MOD_CTRL)
    gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
   break;
  case GF_KEY_5:
   if (evt->key.flags & GF_KEY_MOD_CTRL)
    gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
   break;
  case GF_KEY_6:
   if (evt->key.flags & GF_KEY_MOD_CTRL)
    gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
   break;
  case GF_KEY_7:
   if (evt->key.flags & GF_KEY_MOD_CTRL)
    gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
   break;
  case GF_KEY_O:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134) {
    if (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {
     fprintf(stderr, "Resuming to main content\n");
     gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);
    } else {
     fprintf(stderr, "Main addon not enabled\n");
    }
   }
   break;
  case GF_KEY_P:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134) {
    u32 var_95 = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;
    fprintf(stderr, "[Status: %s]\n", var_95 ? "Playing" : "Paused");
    if ((var_95 == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {
     gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);
    } else {
     gf_term_set_option(term, GF_OPT_PLAY_STATE, (var_95==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);
    }
   }
   break;
  case GF_KEY_S:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134) {
    gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
    fprintf(stderr, "Step time: ");
    PrintTime(gf_term_get_time_in_ms(term));
    fprintf(stderr, "\n");
   }
   break;
  case GF_KEY_B:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134)
    ViewODs(term, 1);
   break;
  case GF_KEY_M:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134)
    ViewODs(term, 0);
   break;
  case GF_KEY_H:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134) {
    gf_term_switch_quality(term, 1);

   }
   break;
  case GF_KEY_L:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134) {
    gf_term_switch_quality(term, 0);

   }
   break;
  case GF_KEY_F5:
   if (var_134)
    var_133 = 1;
   break;
  case GF_KEY_A:
   var_96 = !var_96;
   gf_term_toggle_addons(term, var_96);
   break;
  case GF_KEY_UP:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134) {
    do_set_speed(var_132 * 2);
   }
   break;
  case GF_KEY_DOWN:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134) {
    do_set_speed(var_132 / 2);
   }
   break;
  case GF_KEY_LEFT:
   if ((evt->key.flags & GF_KEY_MOD_CTRL) && var_134) {
    do_set_speed(-1 * var_132 );
   }
   break;

  }
  break;

 case GF_EVENT_CONNECT:
  if (evt->connect.is_connected) {
   var_134 = 1;
   fprintf(stderr, "Service Connected\n");
   var_132 = var_132;
   if (var_132 != var_132)
    gf_term_set_speed(term, var_132);

  } else if (var_134) {
   fprintf(stderr, "Service %s\n", var_134 ? "Disconnected" : "Connection Failed");
   var_134 = 0;
   Duration = 0;
  }
  if (var_132 && var_132) {
   gf_term_set_size(term, var_132, var_132);
  }
  ResetCaption();
  break;
 case GF_EVENT_EOS:
  var_132 = var_139;
  if (playlist) {
   if (Duration>1500)
    var_132 = var_139;
  }
  else if (var_132) {
   var_132 = 1;
  }
  break;
 case GF_EVENT_SIZE:
  if (user.init_flags & GF_TERM_WINDOWLESS) {
   GF_Event move;
   move.type = GF_EVENT_MOVE;
   move.move.align_x = var_132 & 0xFF;
   move.move.align_y = (var_132>>8) & 0xFF;
   move.move.relative = 2;
   gf_term_user_event(term, &move);
  }
  break;
 case GF_EVENT_SCENE_SIZE:
  if (var_132 && var_132) {
   GF_Event size;
   size.type = GF_EVENT_SIZE;
   size.size.width = var_132;
   size.size.height = var_132;
   gf_term_user_event(term, &size);
  }
  break;

 case GF_EVENT_METADATA:
  ResetCaption();
  break;

 case GF_EVENT_RELOAD:
  if (var_134)
   var_133 = 1;
  break;
 case GF_EVENT_DROPFILE:
 {
  u32 var_148, pos;

  if (var_132) {
   gf_fclose(playlist);
   playlist = NULL;
  }
  var_132 = 0;
  if (!playlist) {
   var_132 = 0;
   playlist = gf_temp_file_new(NULL);
  }
  pos = ftell(playlist);
  var_148=0;
  while (var_148<evt->open_file.nb_files) {
   if (evt->open_file.files[var_148] != NULL) {
    fprintf(playlist, "%s\n", evt->open_file.files[var_148]);
   }
   var_148++;
  }
  fseek(playlist, pos, SEEK_SET);
  var_132 = 1;
 }
 return 1;

 case GF_EVENT_QUIT:
  if (evt->message.error) {
   fprintf(stderr, "A fatal error was encoutered: %s (%s) - exiting ...\n", evt->message.message ? evt->message.message : "no details", gf_error_to_string(evt->message.error) );
  }
  Run = 0;
  break;
 case GF_EVENT_DISCONNECT:
  gf_term_disconnect(term);
  break;
 case GF_EVENT_MIGRATE:
 {
 }
 break;
 case GF_EVENT_NAVIGATE_INFO:
  if (evt->navigate.to_url) fprintf(stderr, "Go to URL: \"%s\"\r", evt->navigate.to_url);
  break;
 case GF_EVENT_NAVIGATE:
  if (gf_term_is_supported_url(term, evt->navigate.to_url, 1, var_132)) {
   strncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);
   the_url[sizeof(the_url) - 1] = 0;
   fprintf(stderr, "Navigating to URL %s\n", the_url);
   gf_term_navigate_to(term, evt->navigate.to_url);
   return 1;
  } else {
   fprintf(stderr, "Navigation destination not supported\nGo to URL: %s\n", evt->navigate.to_url);
  }
  break;
 case GF_EVENT_SET_CAPTION:
  gf_term_user_event(term, evt);
  break;
 case GF_EVENT_AUTHORIZATION:
 {
  int var_96 = 1;
  assert( evt->type == GF_EVENT_AUTHORIZATION);
  assert( evt->auth.user);
  assert( evt->auth.password);
  assert( evt->auth.site_url);
  while ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (var_96--) >= 0) {
   fprintf(stderr, "**** Authorization required for site %s ****\n", evt->auth.site_url);
   fprintf(stderr, "login   : ");
   read_line_input(evt->auth.user, 50, 1);
   fprintf(stderr, "\npassword: ");
   read_line_input(evt->auth.password, 50, 0);
   fprintf(stderr, "*********\n");
  }
  if (var_96 < 0) {
   fprintf(stderr, "**** No User or password has been filled, aborting ***\n");
   return 0;
  }
  return 1;
 }
 case GF_EVENT_ADDON_DETECTED:
  if (var_132) {
   fprintf(stderr, "Media Addon %s detected - enabling it\n", evt->addon_connect.addon_url);
   var_96 = 1;
  }
  return var_132;
 }
 return 0;
}


void fn_96(GF_ModuleManager *modules)
{
 u32 var_148;
 fprintf(stderr, "\rAvailable modules:\n");
 for (var_148=0; var_148<gf_modules_get_count(modules); var_148++) {
  char *str = (char *) gf_modules_get_file_name(modules, var_148);
  if (str) fprintf(stderr, "\t%s\n", str);
 }
 fprintf(stderr, "\n");
}

void fn_97()
{
 GF_Err var_145;
 char nav;
 u32 var_99 = gf_term_get_option(term, GF_OPT_NAVIGATION_TYPE);
 var_145 = var_148;
 fflush(stdin);

 if (!var_99) {
  fprintf(stderr, "Content/compositor doesn't allow user-selectable navigation\n");
 } else if (var_99==1) {
  fprintf(stderr, "Select Navigation (\'N\'one, \'E\'xamine, \'S\'lide): ");
  nav = getch();
  if (nav=='N') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);
  else if (nav=='E') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);
  else if (nav=='S') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);
  else fprintf(stderr, "Unknown selector \'%c\' - only \'N\',\'E\',\'S\' allowed\n", nav);
 } else if (var_99==2) {
  fprintf(stderr, "Select Navigation (\'N\'one, \'W\'alk, \'F\'ly, \'E\'xamine, \'P\'an, \'S\'lide, \'G\'ame, \'V\'R, \'O\'rbit): ");
  nav = getch();
  if (nav=='N') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);
  else if (nav=='W') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_WALK);
  else if (nav=='F') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_FLY);
  else if (nav=='E') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);
  else if (nav=='P') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_PAN);
  else if (nav=='S') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);
  else if (nav=='G') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_GAME);
  else if (nav=='O') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_ORBIT);
  else if (nav=='V') var_145 = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_VR);
  else fprintf(stderr, "Unknown selector %c - only \'N\',\'W\',\'F\',\'E\',\'P\',\'S\',\'G\', \'V\', \'O\' allowed\n", nav);
 }
 if (var_145) fprintf(stderr, "Error setting mode: %s\n", gf_error_to_string(var_145));
}


static Bool fn_99(char *arg, u32 *times, u32 *var_132)
{
 char *str;
 Float var;
 Double sec;
 u32 h, m, s, ms, f, var_132;
 if (!arg || (arg[0]=='-') || !isdigit(arg[0])) return 0;


 if (strchr(arg, ':') && strchr(arg, ';') && strchr(arg, '/')) {
  if (sscanf(arg, "%02ud:%02ud:%02ud;%02ud/%02ud", &h, &m, &s, &f, &var_132)==5) {
   sec = 0;
   if (var_132) sec = ((Double)f) / var_132;
   sec += 3600*h + 60*m + s;
   times[*var_132] = (u32) (1000*sec);
   (*var_132) ++;
   return 1;
  }
 }
 while (arg) {
  str = strchr(arg, '-');
  if (str) str[0] = 0;

  if (strchr(arg, ':') && (sscanf(arg, "%u:%u:%u:%u", &h, &m, &s, &ms)==4)) {
   sec = ms;
   sec /= 1000;
   sec += 3600*h + 60*m + s;
   times[*var_132] = (u32) (1000*sec);
   (*var_132) ++;
  } else if (sscanf(arg, "%f", &var)==1) {
   sec = atof(arg);
   times[*var_132] = (u32) (1000*sec);
   (*var_132) ++;
  }
  if (!str) break;
  str[0] = '-';
  arg = str+1;
 }
 return 1;
}

static u64 var_106=0;
static void fn_101(void *cbk, GF_LOG_Level var_102, GF_LOG_Tool var_105, const char *fmt, va_list var_109)
{
 FILE *logs = cbk ? cbk : stderr;

 if (rti_logs && (var_105 & GF_LOG_RTI)) {
  char szMsg[2048];
  vsprintf(szMsg, fmt, var_109);
  UpdateRTInfo(szMsg + 6 );
 } else {
  if (var_132) {
   u64 var_106 = gf_sys_clock_high_res();
   fprintf(logs, "At "LLD" (diff %d) - ", var_106 - var_132, (u32) (var_106 - var_106) );
   var_106 = var_106;
  }
  if (var_132) {
   u64 var_109 = gf_net_get_utc() ;
   time_t var_109 = var_109/1000;
   struct struct_108 t;
   t = *gmtime(&var_109);
   fprintf(logs, "UTC %d-%02d-%02dT%02d:%02d:%02dZ (TS "LLU") - ", 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, var_109);
  }
  vfprintf(logs, fmt, var_109);
  fflush(logs);
 }
}

static void fn_109(char *rti_file, char *url, Bool var_132)
{
 if (rti_logs) gf_fclose(rti_logs);
 rti_logs = gf_fopen(rti_file, "wt");
 if (rti_logs) {
  fprintf(rti_logs, "!! GPAC RunTime Info ");
  if (url) fprintf(rti_logs, "for file %s", url);
  fprintf(rti_logs, " !!\n");
  fprintf(rti_logs, "SysTime(ms)\tSceneTime(ms)\tCPU\tFPS\tMemory(kB)\tObservation\n");


  if (var_132) {
   gf_log_set_callback(NULL, on_gpac_log);
   gf_log_set_tool_level(GF_LOG_RTI, GF_LOG_DEBUG);

   GF_LOG(GF_LOG_DEBUG, GF_LOG_RTI, ("[RTI] System state when enabling log\n"));
  } else if (var_132) {
   var_132 = gf_sys_clock_high_res();
  }
 }
}

void fn_111(char *opt_string)
{
 char *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];
 sep = strchr(opt_string, ':');
 if (!sep) {
  fprintf(stderr, "Badly formatted option %s - expected Section:Name=Value\n", opt_string);
  return;
 }
 {
  const size_t var_113 = sep - opt_string;
  if (var_113 >= sizeof(szSec)) {
   fprintf(stderr, "Badly formatted option %s - Section name is too long\n", opt_string);
   return;
  }

  strncpy(szSec, opt_string, var_113);
  szSec[var_113] = 0;
 }
 sep ++;
 sep2 = strchr(sep, '=');
 if (!sep2) {
  fprintf(stderr, "Badly formatted option %s - expected Section:Name=Value\n", opt_string);
  return;
 }
 {
  const size_t var_113 = sep2 - sep;
  if (var_113 >= sizeof(szKey)) {
   fprintf(stderr, "Badly formatted option %s - key name is too long\n", opt_string);
   return;
  }
  strncpy(szKey, sep, var_113);
  szKey[var_113] = 0;
  if (strlen(sep2 + 1) >= sizeof(szVal)) {
   fprintf(stderr, "Badly formatted option %s - value is too long\n", opt_string);
   return;
  }
  strcpy(szVal, sep2+1);
 }

 if (!stricmp(szKey, "*")) {
  if (stricmp(szVal, "null")) {
   fprintf(stderr, "Badly formatted option %s - expected Section:*=null\n", opt_string);
   return;
  }
  gf_cfg_del_section(cfg_file, szSec);
  return;
 }

 if (!stricmp(szVal, "null")) {
  szVal[0]=0;
 }
 gf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);
}

Bool fn_113(void *cbck, char *item_name, char *item_path, GF_FileEnumInfo *file_info)
{
 const char *url;
 char *sep;
 GF_Config *cached;
 if (strncmp(item_name, "gpac_cache_", 11)) return var_132;
 cached = gf_cfg_new(NULL, item_path);
 url = gf_cfg_get_key(cached, "cache", "url");
 if (url) url = strstr(url, ":
 if (url) {
  u32 var_148, len, var_116=0, var_116=0;
  char *dst_name;
  sep = strstr(item_path, "gpac_cache_");
  if (sep) {
   sep[0] = 0;
   var_116 = (u32) strlen(item_path);
   sep[0] = 'g';
  }
  url+=3;
  len = (u32) strlen(url);
  dst_name = gf_malloc(len+var_116+1);
  memset(dst_name, 0, len+var_116+1);

  strncpy(dst_name, item_path, var_116);
  var_116=var_116;
  for (var_148=0; var_148<len; var_148++) {
   dst_name[var_116] = url[var_148];
   if (dst_name[var_116]==':') dst_name[var_116]='_';
   else if (dst_name[var_116]=='/') {
    if (!gf_dir_exists(dst_name))
     gf_mkdir(dst_name);
   }
   var_116++;
  }
  sep = strrchr(item_path, '.');
  if (sep) {
   sep[0]=0;
   if (gf_file_exists(item_path)) {
    gf_move_file(item_path, dst_name);
   }
   sep[0]='.';
  }
  gf_free(dst_name);
 }
 gf_cfg_del(cached);
 gf_delete_file(item_path);
 return var_132;
}
void fn_116(const char *cache_dir)
{
 gf_enum_directory(cache_dir, var_132, revert_cache_file, NULL, "*.txt");
}






static void fn_117(const void *cbck, const char *title, u64 var_145, u64 var_145) { }

int fn_120(int var_140, char **argv)
{
 char c;
 const char *str;
 int var_139 = 0;
 u32 var_148, times[100], var_132, var_132;
 u32 var_139 = 0;
 u32 var_132 = 0;
 Bool var_132 = var_132;
 Bool var_132 = var_132;
 Bool var_132 = var_132;
 Bool var_132 = var_132;
 Bool var_132 = var_132;
 Bool var_139 = var_132;
 Bool var_132 = var_132;

 Double var_132 = 0;



 Double var_132 = var_132;
 Bool fill_ar, visible, do_uncache, has_command;
 char *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;
 FILE *logfile = NULL;
 Float var_132 = 1;

 dlopen(NULL, RTLD_NOW|RTLD_GLOBAL);



 strcpy(the_url, ".");

 memset(&user, 0, sizeof(GF_User));

 var_132 = DUMP_NONE;
 fill_ar = visible = do_uncache = has_command = var_132;
 url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;
 var_132 = 0;
 times[0] = 0;


 for (var_148=1; var_148<(u32) var_140; var_148++) {
  char *arg = argv[var_148];
  if (!strcmp(arg, "-c") || !strcmp(arg, "-cfg")) {
   the_cfg = argv[var_148+1];
   var_148++;
  }
  else if (!strcmp(arg, "-mem-track") || !strcmp(arg, "-mem-track-stack")) {



   fprintf(stderr, "WARNING - GPAC not compiled with Memory Tracker - ignoring \"%s\"\n", arg);

  } else if (!strcmp(arg, "-gui")) {
   var_139 = 1;
  } else if (!strcmp(arg, "-guid")) {
   var_139 = 2;
  } else if (!strcmp(arg, "-h") || !strcmp(arg, "-help")) {
   PrintUsage();
   return 0;
  }
 }




 gf_sys_init(GF_MemTrackerNone);

 gf_sys_set_args(var_140, (const char **) argv);

 cfg_file = gf_cfg_init(the_cfg, NULL);
 if (!cfg_file) {
  fprintf(stderr, "Error: Configuration File not found\n");
  return 1;
 }

 if (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, "General", "Logs") ) != var_148) {
  return 1;
 }

 if( gf_cfg_get_key(cfg_file, "General", "Logs") != NULL ) {
  var_132 = var_139;
 }

 if (!var_139) {
  str = gf_cfg_get_key(cfg_file, "General", "ForceGUI");
  if (str && !strcmp(str, "yes")) var_139 = 1;
 }

 for (var_148=1; var_148<(u32) var_140; var_148++) {
  char *arg = argv[var_148];

  if (!strcmp(arg, "-rti")) {
   rti_file = argv[var_148+1];
   var_148++;
  } else if (!strcmp(arg, "-rtix")) {
   rti_file = argv[var_148+1];
   var_148++;
   var_132 = var_139;
  } else if (!stricmp(arg, "-size")) {

   if (sscanf(argv[var_148+1], "%dx%d", &var_132, &var_132) != 2) {
    var_132 = var_132 = 0;
   }
   var_148++;
  } else if (!strcmp(arg, "-quiet")) {
   var_132 = 1;
  } else if (!strcmp(arg, "-strict-error")) {
   gf_log_set_strict_error(1);
  } else if (!strcmp(arg, "-log-file") || !strcmp(arg, "-lf")) {
   logfile = gf_fopen(argv[var_148+1], "wt");
   gf_log_set_callback(logfile, on_gpac_log);
   var_148++;
  } else if (!strcmp(arg, "-logs") ) {
   if (gf_log_set_tools_levels(argv[var_148+1]) != var_148) {
    return 1;
   }
   var_132 = var_139;
   var_148++;
  } else if (!strcmp(arg, "-log-clock") || !strcmp(arg, "-lc")) {
   var_132 = 1;
  } else if (!strcmp(arg, "-log-utc") || !strcmp(arg, "-lu")) {
   var_132 = 1;
  }



  else if (!strcmp(arg, "-no-thread")) var_132 = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;

  else if (!strcmp(arg, "-no-cthread") || !strcmp(arg, "-no-compositor-thread")) var_132 |= GF_TERM_NO_COMPOSITOR_THREAD;
  else if (!strcmp(arg, "-no-audio")) var_132 = 1;
  else if (!strcmp(arg, "-no-regulation")) var_132 = 1;
  else if (!strcmp(arg, "-fs")) var_132 = 1;

  else if (!strcmp(arg, "-opt")) {
   set_cfg_option(argv[var_148+1]);
   var_148++;
  } else if (!strcmp(arg, "-conf")) {
   set_cfg_option(argv[var_148+1]);
   var_132=var_139;
   var_148++;
  }
  else if (!strcmp(arg, "-ifce")) {
   gf_cfg_set_key(cfg_file, "Network", "DefaultMCastInterface", argv[var_148+1]);
   var_148++;
  }
  else if (!stricmp(arg, "-help")) {
   PrintUsage();
   return 1;
  }
  else if (!stricmp(arg, "-noprog")) {
   var_132=1;
   gf_set_progress_callback(NULL, progress_quiet);
  }
  else if (!stricmp(arg, "-no-save") || !stricmp(arg, "--no-save") ) {
   var_139=1;
  }
  else if (!stricmp(arg, "-ntp-shift")) {
   s32 var_132 = atoi(argv[var_148+1]);
   var_148++;
   gf_net_set_ntp_shift(var_132);
  }
  else if (!stricmp(arg, "-run-for")) {
   var_139 = atoi(argv[var_148+1]) * 1000;
   if (!var_139)
    var_139 = 1;
   var_148++;
  }

  else if (!strcmp(arg, "-out")) {
   out_arg = argv[var_148+1];
   var_148++;
  }
  else if (!stricmp(arg, "-fps")) {
   var_132 = atof(argv[var_148+1]);
   var_148++;
  } else if (!strcmp(arg, "-avi") || !strcmp(arg, "-sha")) {
   var_132 &= 0xFFFF0000;

   if (!strcmp(arg, "-sha")) var_132 |= DUMP_SHA1;
   else var_132 |= DUMP_AVI;

   if ((url_arg || (var_148+2<(u32)var_140)) && get_time_list(argv[var_148+1], times, &var_132)) {
    if (!strcmp(arg, "-avi") && (var_132!=2) ) {
     fprintf(stderr, "Only one time arg found for -avi - check usage\n");
     return 1;
    }
    var_148++;
   }
  } else if (!strcmp(arg, "-rgbds")) {
    var_132 |= DUMP_RGB_DEPTH_SHAPE;
  } else if (!strcmp(arg, "-rgbd")) {
    var_132 |= DUMP_RGB_DEPTH;
  } else if (!strcmp(arg, "-depth")) {
    var_132 |= DUMP_DEPTH_ONLY;
  } else if (!strcmp(arg, "-bmp")) {
   var_132 &= 0xFFFF0000;
   var_132 |= DUMP_BMP;
   if ((url_arg || (var_148+2<(u32)var_140)) && get_time_list(argv[var_148+1], times, &var_132)) var_148++;
  } else if (!strcmp(arg, "-png")) {
   var_132 &= 0xFFFF0000;
   var_132 |= DUMP_PNG;
   if ((url_arg || (var_148+2<(u32)var_140)) && get_time_list(argv[var_148+1], times, &var_132)) var_148++;
  } else if (!strcmp(arg, "-raw")) {
   var_132 &= 0xFFFF0000;
   var_132 |= DUMP_RAW;
   if ((url_arg || (var_148+2<(u32)var_140)) && get_time_list(argv[var_148+1], times, &var_132)) var_148++;
  } else if (!stricmp(arg, "-scale")) {
   sscanf(argv[var_148+1], "%f", &var_132);
   var_148++;
  }
  else if (!strcmp(arg, "-c") || !strcmp(arg, "-cfg")) {

   var_148++;
  }


  if (!var_139) {
   if (arg[0] != '-') {
    if (url_arg) {
     fprintf(stderr, "Several input URLs provided (\"%s\", \"%s\"). Check your command-line.\n", url_arg, arg);
     return 1;
    }
    url_arg = arg;
   }
   else if (!strcmp(arg, "-loop")) var_132 = 1;
   else if (!strcmp(arg, "-bench")) var_144 = 1;
   else if (!strcmp(arg, "-vbench")) var_144 = 2;
   else if (!strcmp(arg, "-sbench")) var_144 = 3;
   else if (!strcmp(arg, "-no-addon")) var_132 = var_132;

   else if (!strcmp(arg, "-pause")) var_132 = 1;
   else if (!strcmp(arg, "-play-from")) {
    var_132 = atof((const char *) argv[var_148+1]);
    var_148++;
   }
   else if (!strcmp(arg, "-speed")) {
    var_132 = FLT2FIX( atof((const char *) argv[var_148+1]) );
    if (var_132 <= 0) var_132 = var_132;
    var_148++;
   }
   else if (!strcmp(arg, "-no-wnd")) user.init_flags |= GF_TERM_WINDOWLESS;
   else if (!strcmp(arg, "-no-back")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;
   else if (!strcmp(arg, "-align")) {
    if (argv[var_148+1][0]=='m') var_132 = 1;
    else if (argv[var_148+1][0]=='b') var_132 = 2;
    var_132 <<= 8;
    if (argv[var_148+1][1]=='m') var_132 |= 1;
    else if (argv[var_148+1][1]=='r') var_132 |= 2;
    var_148++;
   } else if (!strcmp(arg, "-fill")) {
    fill_ar = var_139;
   } else if (!strcmp(arg, "-show")) {
    visible = 1;
   } else if (!strcmp(arg, "-uncache")) {
    do_uncache = var_139;
   }
   else if (!strcmp(arg, "-exit")) var_132 = var_139;
   else if (!stricmp(arg, "-views")) {
    views = argv[var_148+1];
    var_148++;
   }
   else if (!stricmp(arg, "-mosaic")) {
    mosaic = argv[var_148+1];
    var_148++;
   }
   else if (!stricmp(arg, "-com")) {
    has_command = var_139;
    var_148++;
   }
   else if (!stricmp(arg, "-service")) {
    var_132 = atoi(argv[var_148+1]);
    var_148++;
   }
  }
 }
 if (var_132) {
  gf_cfg_del(cfg_file);
  fprintf(stderr, "GPAC Config updated\n");
  return 0;
 }
 if (do_uncache) {
  const char *cache_dir = gf_cfg_get_key(cfg_file, "General", "CacheDirectory");
  do_flatten_cache(cache_dir);
  fprintf(stderr, "GPAC Cache dir %s flattened\n", cache_dir);
  gf_cfg_del(cfg_file);
  return 0;
 }

 if (var_132 && !url_arg ) {
  FILE *test;
  url_arg = (char *)gf_cfg_get_key(cfg_file, "General", "StartupFile");
  test = url_arg ? gf_fopen(url_arg, "rt") : NULL;
  if (!test) url_arg = NULL;
  else gf_fclose(test);

  if (!url_arg) {
   fprintf(stderr, "Missing argument for dump\n");
   PrintUsage();
   if (logfile) gf_fclose(logfile);
   return 1;
  }
 }

 if (!var_139 && !url_arg && (gf_cfg_get_key(cfg_file, "General", "StartupFile") != NULL)) {
  var_139=1;
 }

 if (var_139==1) {
  hide_shell(1);
 }
 if (var_139) {
  var_132=1;
  gf_set_progress_callback(NULL, progress_quiet);
 }

 if (!url_arg && var_139)
  var_139 += gf_sys_clock();






 if (var_132) rti_file = NULL;

 if (!var_132) {
  gf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);
 }

 if (rti_file || logfile || var_132 || var_132)
  gf_log_set_callback(NULL, on_gpac_log);

 if (rti_file) init_rti_logs(rti_file, url_arg, var_132);

 {
  GF_SystemRTInfo rti;
  if (gf_sys_get_rti(0, &rti, 0))
   fprintf(stderr, "System info: %d MB RAM - %d cores\n", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);
 }



 if (var_132) {
  user.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;
  if (!visible)
   user.init_flags |= GF_TERM_INIT_HIDE;

  gf_cfg_set_key(cfg_file, "Audio", "DriverName", "Raw Audio Output");
  var_139=var_139;
 } else {
  var_132 = var_132;
  var_132 = var_132;
 }

 user.modules = gf_modules_new(NULL, cfg_file);
 if (user.modules) var_148 = gf_modules_get_count(user.modules);
 if (!var_148 || !user.modules) {
  fprintf(stderr, "Error: no modules found - exiting\n");
  if (user.modules) gf_modules_del(user.modules);
  gf_cfg_del(cfg_file);
  gf_sys_close();
  if (logfile) gf_fclose(logfile);
  return 1;
 }
 fprintf(stderr, "Modules Found : %d \n", var_148);

 str = gf_cfg_get_key(cfg_file, "General", "GPACVersion");
 if (!str || strcmp(str, GPAC_FULL_VERSION)) {
  gf_cfg_del_section(cfg_file, "PluginsCache");
  gf_cfg_set_key(cfg_file, "General", "GPACVersion", GPAC_FULL_VERSION);
 }

 user.config = cfg_file;
 user.EventProc = GPAC_EventProc;

 user.opaque = user.modules;
 if (var_132) user.init_flags |= var_132;
 if (var_132) user.init_flags |= GF_TERM_NO_AUDIO;
 if (var_132) user.init_flags |= GF_TERM_NO_REGULATION;

 if (var_132 & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) var_132 = var_139;


 if (var_132) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;

 if (var_144) {
  gf_cfg_discard_changes(user.config);
  var_132 = var_139;
  gf_cfg_set_key(user.config, "Audio", "DriverName", "Raw Audio Output");
  if (var_144!=2) {
   gf_cfg_set_key(user.config, "Video", "DriverName", "Raw Video Output");
   gf_cfg_set_key(user.config, "RAWVideo", "RawOutput", "null");
   gf_cfg_set_key(user.config, "Compositor", "OpenGLMode", "disable");
  } else {
   gf_cfg_set_key(user.config, "Video", "DisableVSync", "yes");
  }
 }

 {
  char dim[50];
  sprintf(dim, "%d", var_132);
  gf_cfg_set_key(user.config, "Compositor", "DefaultWidth", var_132 ? dim : NULL);
  sprintf(dim, "%d", var_132);
  gf_cfg_set_key(user.config, "Compositor", "DefaultHeight", var_132 ? dim : NULL);
 }

 fprintf(stderr, "Loading GPAC Terminal\n");
 var_148 = gf_sys_clock();
 term = gf_term_new(&user);
 if (!term) {
  fprintf(stderr, "\nInit error - check you have at least one video out and one rasterizer...\nFound modules:\n");
  list_modules(user.modules);
  gf_modules_del(user.modules);
  gf_cfg_discard_changes(cfg_file);
  gf_cfg_del(cfg_file);
  gf_sys_close();
  if (logfile) gf_fclose(logfile);
  return 1;
 }
 fprintf(stderr, "Terminal Loaded in %d ms\n", gf_sys_clock()-var_148);

 if (var_144) {
  var_136 = 2;
  gf_term_set_option(term, GF_OPT_VIDEO_BENCH, (var_144==3) ? 2 : 1);
  if (var_144==1) var_144=2;
 }

 if (var_132) {

  if (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
 } else {

  str = gf_cfg_get_key(cfg_file, "Video", "DriverName");
  if (!var_144 && !strcmp(str, "Raw Video Output")) fprintf(stderr, "WARNING: using raw output video (memory only) - no display used\n");

  str = gf_cfg_get_key(cfg_file, "Audio", "DriverName");
  if (!str || !strcmp(str, "No Audio Output Available")) fprintf(stderr, "WARNING: no audio output available - make sure no other program is locking the sound card\n");

  str = gf_cfg_get_key(cfg_file, "General", "NoMIMETypeFetch");
  var_132 = (str && !stricmp(str, "yes")) ? 1 : 0;
 }

 str = gf_cfg_get_key(cfg_file, "HTTPProxy", "Enabled");
 if (str && !strcmp(str, "yes")) {
  str = gf_cfg_get_key(cfg_file, "HTTPProxy", "Name");
  if (str) fprintf(stderr, "HTTP Proxy %s enabled\n", str);
 }

 if (rti_file) {
  str = gf_cfg_get_key(cfg_file, "General", "RTIRefreshPeriod");
  if (str) {
   var_136 = atoi(str);
  } else {
   gf_cfg_set_key(cfg_file, "General", "RTIRefreshPeriod", "200");
  }
  UpdateRTInfo("At GPAC load time\n");
 }

 Run = 1;

 if (var_132) {
  if (!var_132) {
   times[0] = 0;
   var_132++;
  }
  var_139 = dump_file(url_arg, out_arg, var_132, var_132, var_132, var_132, var_132, times, var_132);
  Run = 0;
 }
 else if (views) {
 }

 else if (!var_139 && url_arg) {
  char *ext;

  if (strlen(url_arg) >= sizeof(the_url)) {
   fprintf(stderr, "Input url %s is too long, truncating to %d chars.\n", url_arg, (int)(sizeof(the_url) - 1));
   strncpy(the_url, url_arg, sizeof(the_url)-1);
   the_url[sizeof(the_url) - 1] = 0;
  }
  else {
   strcpy(the_url, url_arg);
  }
  ext = strrchr(the_url, '.');
  if (ext && (!stricmp(ext, ".m3u") || !stricmp(ext, ".pls"))) {
   GF_Err var_145 = var_148;
   fprintf(stderr, "Opening Playlist %s\n", the_url);

   strcpy(pl_path, the_url);

   if (!strncmp("http:", the_url, 5)) {
    GF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &var_145);
    if (sess) {
     var_145 = gf_dm_sess_process(sess);
     if (!var_145) {
      strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
      the_url[sizeof(the_cfg) - 1] = 0;
     }
     gf_dm_sess_del(sess);
    }
   }

   playlist = var_145 ? NULL : gf_fopen(the_url, "rt");
   var_132 = 1;
   if (playlist) {
    var_132 = var_139;
   } else {
    if (var_145)
     fprintf(stderr, "Failed to open playlist %s: %s\n", the_url, gf_error_to_string(var_145) );
    fprintf(stderr, "Hit 'h' for help\n\n");
   }
  } else {
   fprintf(stderr, "Opening URL %s\n", the_url);
   if (var_132) fprintf(stderr, "[Status: Paused]\n");
   gf_term_connect_from_time(term, the_url, (u64) (var_132*1000), var_132);
  }
 } else {
  fprintf(stderr, "Hit 'h' for help\n\n");
  str = gf_cfg_get_key(cfg_file, "General", "StartupFile");
  if (str) {
   strncpy(the_url, "MP4Client "GPAC_FULL_VERSION , sizeof(the_url)-1);
   the_url[sizeof(the_url) - 1] = 0;
   gf_term_connect(term, str);
   var_132 = 1;
   var_134 = 1;
  }
 }
 if (var_139==2) var_139=0;

 if (var_132) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);

 if (views) {
  char szTemp[4046];
  sprintf(szTemp, "views:
  gf_term_connect(term, szTemp);
 }
 if (mosaic) {
  char szTemp[4046];
  sprintf(szTemp, "mosaic:
  gf_term_connect(term, szTemp);
 }
 if (var_144) {
  var_136 = 500;
  var_145 = gf_sys_clock();
 }


 while (Run) {


  if ((var_139==1) || !gf_prompt_has_input()) {
   if (var_133) {
    var_133 = 0;
    gf_term_disconnect(term);
    gf_term_connect(term, var_132 ? gf_cfg_get_key(cfg_file, "General", "StartupFile") : the_url);
   }
   if (var_132 && gf_term_get_option(term, GF_OPT_IS_OVER)) {
    var_132 = 0;
    gf_term_play_from_time(term, 0, 0);
   }
   if (var_132) {
    c = '\n';
    var_132 = 0;
    goto force_input;
   }

   if (has_command && var_134) {
    has_command = var_132;
    for (var_148=0; var_148<(u32)var_140; var_148++) {
     if (!strcmp(argv[var_148], "-com")) {
      gf_term_scene_update(term, NULL, argv[var_148+1]);
      var_148++;
     }
    }
   }
   if (var_132 && var_134) {
    GF_ObjectManager *root_od = gf_term_get_root_object(term);
    if (root_od) {
     gf_term_select_service(term, root_od, var_132);
     var_132 = 0;
    }
   }

   if (!var_132 || var_136) UpdateRTInfo(NULL);
   if (var_132) {
    gf_term_process_step(term);
   } else {
    gf_sleep(var_136);
   }
   if (var_132 && var_132 && gf_term_get_option(term, GF_OPT_IS_OVER)) {
    Run = var_132;
   }


   if (var_139
           && ( (gf_term_get_elapsed_time_in_ms(term)>var_139) || (!url_arg && gf_sys_clock()>var_139))
      ) {
    Run = var_132;
   }
   continue;
  }
  c = gf_prompt_get_char();

force_input:
  switch (c) {
  case 'q':
  {
   GF_Event evt;
   memset(&evt, 0, sizeof(GF_Event));
   evt.type = GF_EVENT_QUIT;
   gf_term_send_event(term, &evt);
  }

  break;
  case 'X':
   exit(0);
   break;
  case 'Q':
   break;
  case 'o':
   var_132 = 0;
   gf_term_disconnect(term);
   fprintf(stderr, "Enter the absolute URL\n");
   if (1 > scanf("%s", the_url)) {
    fprintf(stderr, "Cannot read absolute URL, aborting\n");
    break;
   }
   if (rti_file) init_rti_logs(rti_file, the_url, var_132);
   gf_term_connect(term, the_url);
   break;
  case 'O':
   gf_term_disconnect(term);
   fprintf(stderr, "Enter the absolute URL to the playlist\n");
   if (1 > scanf("%s", the_url)) {
    fprintf(stderr, "Cannot read the absolute URL, aborting.\n");
    break;
   }
   playlist = gf_fopen(the_url, "rt");
   if (playlist) {
    if (1 > fscanf(playlist, "%s", the_url)) {
     fprintf(stderr, "Cannot read any URL from playlist, aborting.\n");
     gf_fclose( playlist);
     break;
    }
    fprintf(stderr, "Opening URL %s\n", the_url);
    gf_term_connect(term, the_url);
   }
   break;
  case '\n':
  case 'N':
   if (playlist) {
    int res;
    gf_term_disconnect(term);

    res = fscanf(playlist, "%s", the_url);
    if ((res == EOF) && var_132) {
     fseek(playlist, 0, SEEK_SET);
     res = fscanf(playlist, "%s", the_url);
    }
    if (res == EOF) {
     fprintf(stderr, "No more items - exiting\n");
     Run = 0;
    } else if (the_url[0] == '#') {
     var_132 = var_139;
    } else {
     fprintf(stderr, "Opening URL %s\n", the_url);
     gf_term_connect_with_path(term, the_url, pl_path);
    }
   }
   break;
  case 'P':
   if (playlist) {
    u32 var_148;
    gf_term_disconnect(term);
    if (1 > scanf("%u", &var_148)) {
     fprintf(stderr, "Cannot read number, aborting.\n");
     break;
    }
    while (var_148) {
     if (fscanf(playlist, "%s", the_url)) {
      fprintf(stderr, "Failed to read line, aborting\n");
      break;
     }
     var_148--;
    }
    fprintf(stderr, "Opening URL %s\n", the_url);
    gf_term_connect(term, the_url);
   }
   break;
  case 'r':
   if (var_134)
    var_133 = 1;
   break;

  case 'D':
   if (var_134) gf_term_disconnect(term);
   break;

  case 'p':
   if (var_134) {
    Bool var_134 = gf_term_get_option(term, GF_OPT_PLAY_STATE);
    fprintf(stderr, "[Status: %s]\n", var_134 ? "Playing" : "Paused");
    gf_term_set_option(term, GF_OPT_PLAY_STATE, var_134 ? GF_STATE_PLAYING : GF_STATE_PAUSED);
   }
   break;
  case 's':
   if (var_134) {
    gf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);
    fprintf(stderr, "Step time: ");
    PrintTime(gf_term_get_time_in_ms(term));
    fprintf(stderr, "\n");
   }
   break;

  case 'z':
  case 'T':
   if (!var_134 || (Duration<=2000)) {
    fprintf(stderr, "scene not seekable\n");
   } else {
    Double res;
    s32 seekTo;
    fprintf(stderr, "Duration: ");
    PrintTime(Duration);
    res = gf_term_get_time_in_ms(term);
    if (c=='z') {
     res *= 100;
     res /= (s64)Duration;
     fprintf(stderr, " (current %.2f %%)\nEnter Seek percentage:\n", res);
     if (scanf("%d", &seekTo) == 1) {
      if (seekTo > 100) seekTo = 100;
      res = (Double)(s64)Duration;
      res /= 100;
      res *= seekTo;
      gf_term_play_from_time(term, (u64) (s64) res, 0);
     }
    } else {
     u32 r, h, m, s;
     fprintf(stderr, " - Current Time: ");
     PrintTime((u64) res);
     fprintf(stderr, "\nEnter seek time (Format: s, m:s or h:m:s):\n");
     h = m = s = 0;
     r =scanf("%d:%d:%d", &h, &m, &s);
     if (r==2) {
      s = m;
      m = h;
      h = 0;
     }
     else if (r==1) {
      s = h;
      m = h = 0;
     }

     if (r && (r<=3)) {
      u64 var_134 = h*3600 + m*60 + s;
      gf_term_play_from_time(term, var_134*1000, 0);
     }
    }
   }
   break;

  case 't':
  {
   if (var_134) {
    fprintf(stderr, "Current Time: ");
    PrintTime(gf_term_get_time_in_ms(term));
    fprintf(stderr, " - Duration: ");
    PrintTime(Duration);
    fprintf(stderr, "\n");
   }
  }
  break;
  case 'w':
   if (var_134) PrintWorldInfo(term);
   break;
  case 'v':
   if (var_134) PrintODList(term, NULL, 0, 0, "Root");
   break;
  case 'i':
   if (var_134) {
    u32 ID;
    fprintf(stderr, "Enter OD ID (0 for main OD): ");
    fflush(stderr);
    if (scanf("%ud", &ID) == 1) {
     ViewOD(term, ID, (u32)-1, NULL);
    } else {
     char str_url[GF_MAX_PATH];
     if (scanf("%s", str_url) == 1)
      ViewOD(term, 0, (u32)-1, str_url);
    }
   }
   break;
  case 'j':
   if (var_134) {
    u32 var_145;
    do {
     fprintf(stderr, "Enter OD number (0 for main OD): ");
     fflush(stderr);
    } while( 1 > scanf("%ud", &var_145));
    ViewOD(term, (u32)-1, var_145, NULL);
   }
   break;
  case 'b':
   if (var_134) ViewODs(term, 1);
   break;

  case 'm':
   if (var_134) ViewODs(term, 0);
   break;

  case 'l':
   list_modules(user.modules);
   break;

  case 'n':
   if (var_134) set_navigation();
   break;
  case 'x':
   if (var_134) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
   break;

  case 'd':
   if (var_134) {
    GF_ObjectManager *odm = NULL;
    char radname[GF_MAX_PATH], *sExt;
    GF_Err var_145;
    u32 var_148, var_148, odid;
    Bool xml_dump, std_out;
    radname[0] = 0;
    do {
     fprintf(stderr, "Enter Inline OD ID if any or 0 : ");
     fflush(stderr);
    } while( 1 > scanf("%ud", &odid));
    if (odid) {
     GF_ObjectManager *root_odm = gf_term_get_root_object(term);
     if (!root_odm) break;
     var_148 = gf_term_get_object_count(term, root_odm);
     for (var_148=0; var_148<var_148; var_148++) {
      GF_MediaInfo info;
      odm = gf_term_get_object(term, root_odm, var_148);
      if (gf_term_get_object_info(term, odm, &info) == var_148) {
       if (info.od->objectDescriptorID==odid) break;
      }
      odm = NULL;
     }
    }
    do {
     fprintf(stderr, "Enter file radical name (+\'.x\' for XML dumping) - \"std\" for stderr: ");
     fflush(stderr);
    } while( 1 > scanf("%s", radname));
    sExt = strrchr(radname, '.');
    xml_dump = 0;
    if (sExt) {
     if (!stricmp(sExt, ".x")) xml_dump = 1;
     sExt[0] = 0;
    }
    std_out = strnicmp(radname, "std", 3) ? 0 : 1;
    var_145 = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);
    fprintf(stderr, "Dump done (%s)\n", gf_error_to_string(var_145));
   }
   break;

  case 'c':
   PrintGPACConfig();
   break;
  case '3':
  {
   Bool var_135 = !gf_term_get_option(term, GF_OPT_USE_OPENGL);
   if (gf_term_set_option(term, GF_OPT_USE_OPENGL, var_135)==var_148) {
    fprintf(stderr, "Using %s for 2D drawing\n", var_135 ? "OpenGL" : "2D rasterizer");
   }
  }
  break;
  case 'k':
  {
   Bool var_136 = gf_term_get_option(term, GF_OPT_STRESS_MODE);
   var_136 = !var_136;
   fprintf(stderr, "Turning stress mode %s\n", var_136 ? "on" : "off");
   gf_term_set_option(term, GF_OPT_STRESS_MODE, var_136);
  }
  break;
  case '4':
   gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);
   break;
  case '5':
   gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);
   break;
  case '6':
   gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);
   break;
  case '7':
   gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);
   break;

  case 'C':
   switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
   case GF_MEDIA_CACHE_DISABLED:
    gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);
    break;
   case GF_MEDIA_CACHE_ENABLED:
    gf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);
    break;
   case GF_MEDIA_CACHE_RUNNING:
    fprintf(stderr, "Streaming Cache is running - please stop it first\n");
    continue;
   }
   switch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {
   case GF_MEDIA_CACHE_ENABLED:
    fprintf(stderr, "Streaming Cache Enabled\n");
    break;
   case GF_MEDIA_CACHE_DISABLED:
    fprintf(stderr, "Streaming Cache Disabled\n");
    break;
   case GF_MEDIA_CACHE_RUNNING:
    fprintf(stderr, "Streaming Cache Running\n");
    break;
   }
   break;
  case 'S':
  case 'A':
   if (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {
    gf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);
    fprintf(stderr, "Streaming Cache stopped\n");
   } else {
    fprintf(stderr, "Streaming Cache not running\n");
   }
   break;
  case 'R':
   var_136 = !var_136;
   ResetCaption();
   break;
  case 'F':
   if (var_136) var_136 = 0;
   else var_136 = 2;
   ResetCaption();
   break;

  case 'u':
  {
   GF_Err var_145;
   char szCom[8192];
   fprintf(stderr, "Enter command to send:\n");
   fflush(stdin);
   szCom[0] = 0;
   if (1 > scanf("%[^\t\n]", szCom)) {
    fprintf(stderr, "Cannot read command to send, aborting.\n");
    break;
   }
   var_145 = gf_term_scene_update(term, NULL, szCom);
   if (var_145) fprintf(stderr, "Processing command failed: %s\n", gf_error_to_string(var_145));
  }
  break;
  case 'e':
  {
   GF_Err var_145;
   char jsCode[8192];
   fprintf(stderr, "Enter JavaScript code to evaluate:\n");
   fflush(stdin);
   jsCode[0] = 0;
   if (1 > scanf("%[^\t\n]", jsCode)) {
    fprintf(stderr, "Cannot read code to evaluate, aborting.\n");
    break;
   }
   var_145 = gf_term_scene_update(term, "application/ecmascript", jsCode);
   if (var_145) fprintf(stderr, "Processing JS code failed: %s\n", gf_error_to_string(var_145));
  }
  break;

  case 'L':
  {
   char szLog[1024], *cur_logs;
   cur_logs = gf_log_get_tools_levels();
   fprintf(stderr, "Enter new log level (current tools %s):\n", cur_logs);
   gf_free(cur_logs);
   if (scanf("%s", szLog) < 1) {
    fprintf(stderr, "Cannot read new log level, aborting.\n");
    break;
   }
   gf_log_modify_tools_levels(szLog);
  }
  break;

  case 'g':
  {
   GF_SystemRTInfo rti;
   gf_sys_get_rti(var_136, &rti, 0);
   fprintf(stderr, "GPAC allocated memory "LLD"\n", rti.gpac_memory);
  }
  break;
  case 'M':
  {
   u32 size;
   do {
    fprintf(stderr, "Enter new video cache memory in kBytes (current %ud):\n", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));
   } while (1 > scanf("%ud", &size));
   gf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);
  }
  break;

  case 'H':
  {
   u32 var_137 = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);
   do {
    fprintf(stderr, "Enter new http bitrate in bps (0 for none) - current limit: %d\n", var_137);
   } while (1 > scanf("%ud", &var_137));

   gf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, var_137);
  }
  break;

  case 'E':
   gf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);
   break;

  case 'B':
   switch_bench(!var_144);
   break;

  case 'Y':
  {
   char szOpt[8192];
   fprintf(stderr, "Enter option to set (Section:Name=Value):\n");
   fflush(stdin);
   szOpt[0] = 0;
   if (1 > scanf("%[^\t\n]", szOpt)) {
    fprintf(stderr, "Cannot read option\n");
    break;
   }
   set_cfg_option(szOpt);
  }
  break;


  case 'Z':
  {
   char szFileName[100];
   u32 nb_pass, nb_views, var_138 = 0;
   GF_VideoSurface fb;
   GF_Err var_145;
   nb_pass = 1;
   nb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);
   if (nb_views>1) {
    fprintf(stderr, "Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\n", nb_views, nb_views+1, nb_views+2);
    if (scanf("%d", &var_138) != 1) {
     var_138 = 0;
    }
    if (var_138==nb_views+1) {
     var_138 = 1;
     nb_pass = nb_views;
    }
    else if (var_138==nb_views+2) {
     var_138 = 0;
     nb_pass = nb_views+1;
    }
   }
   while (nb_pass) {
    nb_pass--;
    if (var_138) {
     sprintf(szFileName, "view%d_dump.png", var_138);
     var_145 = gf_term_get_offscreen_buffer(term, &fb, var_138-1, 0);
    } else {
     sprintf(szFileName, "gpac_video_dump_"LLU".png", gf_net_get_utc() );
     var_145 = gf_term_get_screen_buffer(term, &fb);
    }
    var_138++;
    if (var_145) {
     fprintf(stderr, "Error dumping screen buffer %s\n", gf_error_to_string(var_145) );
     nb_pass = 0;
    } else {

     u32 var_139 = fb.width*fb.height*4;
     char *dst = (char*)gf_malloc(sizeof(char)*var_139);

     var_145 = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &var_139);
     if (var_145) {
      fprintf(stderr, "Error encoding PNG %s\n", gf_error_to_string(var_145) );
      nb_pass = 0;
     } else {
      FILE *png = gf_fopen(szFileName, "wb");
      if (!png) {
       fprintf(stderr, "Error writing file %s\n", szFileName);
       nb_pass = 0;
      } else {
       gf_fwrite(dst, var_139, 1, png);
       gf_fclose(png);
       fprintf(stderr, "Dump to %s\n", szFileName);
      }
     }
     if (dst) gf_free(dst);
     gf_term_release_screen_buffer(term, &fb);

    }
   }
   fprintf(stderr, "Done: %s\n", szFileName);
  }
  break;

  case 'G':
  {
   GF_ObjectManager *root_od, *odm;
   u32 index;
   char szOpt[8192];
   fprintf(stderr, "Enter 0-based index of object to select or service ID:\n");
   fflush(stdin);
   szOpt[0] = 0;
   if (1 > scanf("%[^\t\n]", szOpt)) {
    fprintf(stderr, "Cannot read OD ID\n");
    break;
   }
   index = atoi(szOpt);
   odm = NULL;
   root_od = gf_term_get_root_object(term);
   if (root_od) {
    if ( gf_term_find_service(term, root_od, index)) {
     gf_term_select_service(term, root_od, index);
    } else {
     fprintf(stderr, "Cannot find service %d - trying with object index\n", index);
     odm = gf_term_get_object(term, root_od, index);
     if (odm) {
      gf_term_select_object(term, odm);
     } else {
      fprintf(stderr, "Cannot find object at index %d\n", index);
     }
    }
   }
  }
  break;

  case 'h':
   PrintHelp();
   break;
  default:
   break;
  }
 }

 if (var_144) {
  PrintAVInfo(var_139);
 }


 if (var_139) {
  gf_log_set_strict_error(0);
 }


 var_148 = gf_sys_clock();
 gf_term_disconnect(term);
 if (rti_file) UpdateRTInfo("Disconnected\n");

 fprintf(stderr, "Deleting terminal... ");
 if (playlist) gf_fclose(playlist);





 gf_term_del(term);
 fprintf(stderr, "done (in %d ms) - ran for %d ms\n", gf_sys_clock() - var_148, gf_sys_clock());

 fprintf(stderr, "GPAC cleanup ...\n");
 gf_modules_del(user.modules);

 if (var_139)
  gf_cfg_discard_changes(cfg_file);

 gf_cfg_del(cfg_file);

 gf_sys_close();

 if (rti_logs) gf_fclose(rti_logs);
 if (logfile) gf_fclose(logfile);

 if (var_139) {
  hide_shell(2);
 }

 return var_139;
}

int fn_139(int var_140, char** argv)
{
 return mp4client_main(var_140, argv);
}

static GF_ObjectManager *video_odm = NULL;
static GF_ObjectManager *audio_odm = NULL;
static GF_ObjectManager *scene_odm = NULL;
static u32 var_144 = 0;
void fn_141(Bool var_145)
{
 GF_MediaInfo a_odi, v_odi, s_odi;
 Double var_148=0;
 u32 var_145=0;
 Bool var_145 = var_145;

 if (scene_odm) {
  GF_ObjectManager *root_odm = gf_term_get_root_object(term);
  u32 var_148 = gf_term_get_object_count(term, root_odm);
  if (var_144 != var_148) {
   var_144 = var_148;
   scene_odm = NULL;
  }
 }
 if (!video_odm && !audio_odm && !scene_odm) {
  u32 var_148, var_148;
  GF_ObjectManager *root_odm = root_odm = gf_term_get_root_object(term);
  if (!root_odm) return;

  if (gf_term_get_object_info(term, root_odm, &v_odi)==var_148) {
   if (!scene_odm && (v_odi.generated_scene== 0)) {
    scene_odm = root_odm;
   }
  }

  var_148 = gf_term_get_object_count(term, root_odm);
  for (var_148=0; var_148<var_148; var_148++) {
   GF_ObjectManager *odm = gf_term_get_object(term, root_odm, var_148);
   if (!odm) break;
   if (gf_term_get_object_info(term, odm, &v_odi) == var_148) {
    if (!video_odm && (v_odi.od_type == GF_STREAM_VISUAL) && (v_odi.raw_media || (v_odi.cb_max_count>1) || v_odi.direct_video_memory || (var_144 == 3) )) {
     video_odm = odm;
    }
    else if (!audio_odm && (v_odi.od_type == GF_STREAM_AUDIO)) {
     audio_odm = odm;
    }
    else if (!scene_odm && (v_odi.od_type == GF_STREAM_SCENE)) {
     scene_odm = odm;
    }
   }
  }
 }

 if (0 && var_144) {
  fprintf(stderr, "Buffering %d %% ", var_144-1);
  return;
 }

 if (video_odm) {
  if (gf_term_get_object_info(term, video_odm, &v_odi)!= var_148) {
   video_odm = NULL;
   return;
  }
 } else {
  memset(&v_odi, 0, sizeof(v_odi));
 }
 if (var_145 && audio_odm) {
  gf_term_get_object_info(term, audio_odm, &a_odi);
 } else {
  memset(&a_odi, 0, sizeof(a_odi));
 }
 if ((var_145 || !video_odm) && scene_odm) {
  gf_term_get_object_info(term, scene_odm, &s_odi);
 } else {
  memset(&s_odi, 0, sizeof(s_odi));
 }

 if (var_145) {
  var_145 = gf_sys_clock() - var_145;
  fprintf(stderr, "                                                                                     \r");
  fprintf(stderr, "************** Bench Mode Done in %d ms ********************\n", var_145);
  if (var_144==3) fprintf(stderr, "** Systems layer only (no decoding) **\n");

  if (!video_odm) {
   u32 nb_frames_drawn;
   Double var_145 = gf_term_get_simulation_frame_rate(term, &nb_frames_drawn);
   fprintf(stderr, "Drawn %d frames FPS %.2f (simulation FPS %.2f) - duration %d ms\n", nb_frames_drawn, ((Float)nb_frames_drawn*1000)/var_145,(Float) var_145, gf_term_get_time_in_ms(term) );
  }
 }
 if (var_145) {
  if (video_odm) {
   fprintf(stderr, "%s %dx%d sar=%d:%d duration %.2fs\n", v_odi.codec_name, v_odi.width, v_odi.height, v_odi.par ? (v_odi.par>>16)&0xFF : 1, v_odi.par ? (v_odi.par)&0xFF : 1, v_odi.duration);
   if (var_145) {
    u32 var_145 = v_odi.last_frame_time - v_odi.first_frame_time;
    if (!var_145) var_145 = 1;
    if (v_odi.duration) fprintf(stderr, "%d%% ", (u32) (100*v_odi.current_time / v_odi.duration ) );
    fprintf(stderr, "%d frames FPS %.2f (max %d us/f) rate avg %d max %d", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / var_145, v_odi.max_dec_time, (u32) v_odi.avg_bitrate/1000, (u32) v_odi.max_bitrate/1000);
    if (v_odi.nb_dropped) {
     fprintf(stderr, " (Error during bench: %d frames drop)", v_odi.nb_dropped);
    }
    fprintf(stderr, "\n");
   }
  }
  if (audio_odm) {
   fprintf(stderr, "%s SR %d num channels %d bpp %d duration %.2fs\n", a_odi.codec_name, a_odi.sample_rate, a_odi.num_channels, a_odi.bits_per_sample, a_odi.duration);
   if (var_145) {
    u32 var_145 = a_odi.last_frame_time - a_odi.first_frame_time;
    if (!var_145) var_145 = 1;
    if (a_odi.duration) fprintf(stderr, "%d%% ", (u32) (100*a_odi.current_time / a_odi.duration ) );
    fprintf(stderr, "%d frames (ms/f %.2f avg %.2f max) rate avg %d max %d", a_odi.nb_dec_frames, ((Float)var_145)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0, (u32) a_odi.avg_bitrate/1000, (u32) a_odi.max_bitrate/1000);
    if (a_odi.nb_dropped) {
     fprintf(stderr, " (Error during bench: %d frames drop)", a_odi.nb_dropped);
    }
    fprintf(stderr, "\n");
   }
  }
  if (scene_odm) {
   u32 w, h;
   gf_term_get_visual_output_size(term, &w, &h);
   fprintf(stderr, "%s scene size %dx%d rastered to %dx%d duration %.2fs\n", s_odi.codec_name ? s_odi.codec_name : "", s_odi.width, s_odi.height, w, h, s_odi.duration);
   if (var_145) {
    if (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {
     u32 var_145 = s_odi.last_frame_time - s_odi.first_frame_time;
     if (!var_145) var_145 = 1;
     fprintf(stderr, "%d frames FPS %.2f (max %d us/f) rate avg %d max %d", s_odi.nb_dec_frames, ((Float)s_odi.nb_dec_frames*1000) / var_145, s_odi.max_dec_time, (u32) s_odi.avg_bitrate/1000, (u32) s_odi.max_bitrate/1000);
     fprintf(stderr, "\n");
    } else {
     u32 nb_frames_drawn;
     Double var_145;
     gf_term_get_simulation_frame_rate(term, &nb_frames_drawn);
     var_145 = gf_sys_clock() - var_145;
     var_145 = gf_term_get_framerate(term, 0);
     fprintf(stderr, "%d frames FPS %.2f (abs %.2f)\n", nb_frames_drawn, (1000.0*nb_frames_drawn / var_145), var_145);
    }
   }
  }
  if (var_145) {
   fprintf(stderr, "**********************************************************\n\n");
   return;
  }
 }

 if (video_odm) {
  var_145 = v_odi.last_frame_time - v_odi.first_frame_time;
  if (!var_145) var_145=1;
  if (v_odi.duration) fprintf(stderr, "%d%% ", (u32) (100*v_odi.current_time / v_odi.duration ) );
  fprintf(stderr, "%d f FPS %.2f (%.2f ms max) rate %d ", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / var_145, v_odi.max_dec_time/1000.0, (u32) v_odi.instant_bitrate/1000);
 }
 else if (scene_odm) {

  if (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {
   var_148 = (Float) 1000000 * s_odi.nb_dec_frames;
   var_148 /= s_odi.total_dec_time;
   if (s_odi.duration) fprintf(stderr, "%d%% ", (u32) (100*s_odi.current_time / s_odi.duration ) );
   fprintf(stderr, "%d f %.2f (%d us max) - rate %d ", s_odi.nb_dec_frames, var_148, s_odi.max_dec_time, (u32) s_odi.instant_bitrate/1000);
  } else {
   u32 nb_frames_drawn;
   Double var_145;
   gf_term_get_simulation_frame_rate(term, &nb_frames_drawn);
   var_145 = gf_sys_clock() - var_145;
   var_145 = gf_term_get_framerate(term, 1);
   fprintf(stderr, "%d f FPS %.2f (abs %.2f) ", nb_frames_drawn, (1000.0*nb_frames_drawn / var_145), var_145);
  }
 }
 else if (audio_odm) {
  if (!var_145) {
   gf_term_get_object_info(term, audio_odm, &a_odi);
  }
  var_145 = a_odi.last_frame_time - a_odi.first_frame_time;
  if (!var_145) var_145=1;
  if (a_odi.duration) fprintf(stderr, "%d%% ", (u32) (100*a_odi.current_time / a_odi.duration ) );
  fprintf(stderr, "%d frames (ms/f %.2f avg %.2f max)", a_odi.nb_dec_frames, ((Float)var_145)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0);
 }
}

void fn_145(GF_Terminal *term)
{
 u32 var_148;
 const char *title;
 GF_List *descs;
 descs = gf_list_new();
 title = gf_term_get_world_info(term, NULL, descs);
 if (!title && !gf_list_count(descs)) {
  fprintf(stderr, "No World Info available\n");
 } else {
  fprintf(stderr, "\t%s\n", title ? title : "No title available");
  for (var_148=0; var_148<gf_list_count(descs); var_148++) {
   char *str = gf_list_get(descs, var_148);
   fprintf(stderr, "%s\n", str);
  }
 }
 gf_list_del(descs);
}

void fn_145(GF_Terminal *term, GF_ObjectManager *root_odm, u32 var_145, u32 var_148, char *root_name)
{
 GF_MediaInfo odi;
 u32 var_148, var_148;
 char szIndent[50];
 GF_ObjectManager *odm;

 if (!root_odm) {
  fprintf(stderr, "Currently loaded objects:\n");
  root_odm = gf_term_get_root_object(term);
 }
 if (!root_odm) return;

 var_148 = gf_term_get_current_service_id(term);
 if (var_148)
  fprintf(stderr, "Current service ID %d\n", var_148);

 if (gf_term_get_object_info(term, root_odm, &odi) != var_148) return;
 if (!odi.od) {
  fprintf(stderr, "Service not attached\n");
  return;
 }

 for (var_148=0; var_148<var_148; var_148++) szIndent[var_148]=' ';
 szIndent[var_148]=0;

 fprintf(stderr, "%s", szIndent);
 fprintf(stderr, "#%d %s - ", var_145, root_name);
 if (odi.od->ServiceID) fprintf(stderr, "Service ID %d ", odi.od->ServiceID);
 if (odi.media_url) {
  fprintf(stderr, "%s\n", odi.media_url);
 } else {
  fprintf(stderr, "OD ID %d\n", odi.od->objectDescriptorID);
 }

 szIndent[var_148]=' ';
 szIndent[var_148+1]=0;
 var_148++;

 var_148 = gf_term_get_object_count(term, root_odm);
 for (var_148=0; var_148<var_148; var_148++) {
  odm = gf_term_get_object(term, root_odm, var_148);
  if (!odm) break;
  var_145++;
  if (gf_term_get_object_info(term, odm, &odi) == var_148) {
   switch (gf_term_object_subscene_type(term, odm)) {
   case 1:
    PrintODList(term, odm, var_145, var_148, "Root");
    break;
   case 2:
    PrintODList(term, odm, var_145, var_148, "Inline Scene");
    break;
   case 3:
    PrintODList(term, odm, var_145, var_148, "EXTERNPROTO Library");
    break;
   default:
    fprintf(stderr, "%s", szIndent);
    fprintf(stderr, "#%d - ", var_145);
    if (odi.media_url) {
     fprintf(stderr, "%s", odi.media_url);
    } else if (odi.od) {
      if (odi.od->URLString) {
      fprintf(stderr, "%s", odi.od->URLString);
     } else {
      fprintf(stderr, "ID %d", odi.od->objectDescriptorID);
     }
    } else if (odi.service_url) {
     fprintf(stderr, "%s", odi.service_url);
    } else {
     fprintf(stderr, "unknown");
    }
    fprintf(stderr, " - %s", (odi.od_type==GF_STREAM_VISUAL) ? "Video" : (odi.od_type==GF_STREAM_AUDIO) ? "Audio" : "Systems");
    if (odi.od && odi.od->ServiceID) fprintf(stderr, " - Service ID %d", odi.od->ServiceID);
    fprintf(stderr, "\n");
    break;
   }
  }
 }
}

void fn_145(GF_Terminal *term, u32 var_145, u32 var_145, const char *szURL)
{
 GF_MediaInfo odi;
 u32 var_148, j, var_148, d_enum,id;
 GF_Err var_145;
 NetStatCommand com;
 GF_ObjectManager *odm, *root_odm = gf_term_get_root_object(term);
 if (!root_odm) return;

 odm = NULL;
 if (!szURL && ((!var_145 && (var_145 == (u32)-1)) || ((var_145 == (u32)(-1)) && !var_145))) {
  odm = root_odm;
  if ((gf_term_get_object_info(term, odm, &odi) != var_148)) odm=NULL;
 } else {
  var_148 = gf_term_get_object_count(term, root_odm);
  for (var_148=0; var_148<var_148; var_148++) {
   odm = gf_term_get_object(term, root_odm, var_148);
   if (!odm) break;
   if (gf_term_get_object_info(term, odm, &odi) == var_148) {
    if (szURL && strstr(odi.service_url, szURL)) break;
    if ((var_145 == (u32)(-1)) && odi.od && (odi.od->objectDescriptorID == var_145)) break;
    else if (var_148 == (u32)(var_145-1)) break;
   }
   odm = NULL;
  }
 }
 if (!odm) {
  if (szURL) fprintf(stderr, "cannot find OD for URL %s\n", szURL);
  if (var_145 == (u32)-1) fprintf(stderr, "cannot find OD with ID %d\n", var_145);
  else fprintf(stderr, "cannot find OD with number %d\n", var_145);
  return;
 }
 if (!odi.od) {
  if (var_145 == (u32)-1) fprintf(stderr, "Object %d not attached yet\n", var_145);
  else fprintf(stderr, "Object #%d not attached yet\n", var_145);
  return;
 }

 if (!odi.od) {
  fprintf(stderr, "Service not attached\n");
  return;
 }

 if (odi.od->tag==GF_ODF_IOD_TAG) {
  fprintf(stderr, "InitialObjectDescriptor %d\n", odi.od->objectDescriptorID);
  fprintf(stderr, "Profiles and Levels: Scene %x - Graphics %x - Visual %x - Audio %x - OD %x\n",
          odi.scene_pl, odi.graphics_pl, odi.visual_pl, odi.audio_pl, odi.OD_pl);
  fprintf(stderr, "Inline Profile Flag %d\n", odi.inline_pl);
 } else {
  fprintf(stderr, "ObjectDescriptor %d\n", odi.od->objectDescriptorID);
 }

 fprintf(stderr, "Object Duration: ");
 if (odi.duration) {
  PrintTime((u32) (odi.duration*1000));
 } else {
  fprintf(stderr, "unknown");
 }
 fprintf(stderr, "\n");

 fprintf(stderr, "Service Handler: %s\n", odi.service_handler);
 fprintf(stderr, "Service URL: %s\n", odi.service_url);

 if (odi.codec_name) {
  Float var_148;
  switch (odi.od_type) {
  case GF_STREAM_VISUAL:
   fprintf(stderr, "Video Object: Width %d - Height %d\r\n", odi.width, odi.height);
   fprintf(stderr, "Media Codec: %s\n", odi.codec_name);
   if (odi.par) fprintf(stderr, "Pixel Aspect Ratio: %d:%d\n", (odi.par>>16)&0xFF, (odi.par)&0xFF);
   break;
  case GF_STREAM_AUDIO:
   fprintf(stderr, "Audio Object: Sample Rate %d - %d channels\r\n", odi.sample_rate, odi.num_channels);
   fprintf(stderr, "Media Codec: %s\n", odi.codec_name);
   break;
  case GF_STREAM_SCENE:
  case GF_STREAM_PRIVATE_SCENE:
   if (odi.width && odi.height) {
    fprintf(stderr, "Scene Description - Width %d - Height %d\n", odi.width, odi.height);
   } else {
    fprintf(stderr, "Scene Description - no size specified\n");
   }
   fprintf(stderr, "Scene Codec: %s\n", odi.codec_name);
   break;
  case GF_STREAM_TEXT:
   if (odi.width && odi.height) {
    fprintf(stderr, "Text Object: Width %d - Height %d\n", odi.width, odi.height);
   } else {
    fprintf(stderr, "Text Object: No size specified\n");
   }
   fprintf(stderr, "Text Codec %s\n", odi.codec_name);
   break;
  }

  var_148 = 0;
  if (odi.nb_dec_frames) {
   var_148 = (Float) odi.total_dec_time;
   var_148 /= odi.nb_dec_frames;
  }
  fprintf(stderr, "\tBitrate over last second: %d kbps\n\tMax bitrate over one second: %d kbps\n\tAverage Decoding Time %.2f us %d max)\n\tTotal decoded frames %d\n",
          (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, var_148, odi.max_dec_time, odi.nb_dec_frames);
 }
 if (odi.protection) fprintf(stderr, "Encrypted Media%s\n", (odi.protection==2) ? " NOT UNLOCKED" : "");

 var_148 = gf_list_count(odi.od->ESDescriptors);
 fprintf(stderr, "%d streams in OD\n", var_148);
 for (var_148=0; var_148<var_148; var_148++) {
  GF_ESD *esd = (GF_ESD *) gf_list_get(odi.od->ESDescriptors, var_148);

  fprintf(stderr, "\nStream ID %d - Clock ID %d\n", esd->ESID, esd->OCRESID);
  if (esd->dependsOnESID) fprintf(stderr, "\tDepends on Stream ID %d for decoding\n", esd->dependsOnESID);

  switch (esd->decoderConfig->streamType) {
  case GF_STREAM_OD:
   fprintf(stderr, "\tOD Stream - version %d\n", esd->decoderConfig->objectTypeIndication);
   break;
  case GF_STREAM_OCR:
   fprintf(stderr, "\tOCR Stream\n");
   break;
  case GF_STREAM_SCENE:
   fprintf(stderr, "\tScene Description Stream - version %d\n", esd->decoderConfig->objectTypeIndication);
   break;
  case GF_STREAM_VISUAL:
   fprintf(stderr, "\tVisual Stream - media type: %s", gf_esd_get_textual_description(esd));
   break;
  case GF_STREAM_AUDIO:
   fprintf(stderr, "\tAudio Stream - media type: %s", gf_esd_get_textual_description(esd));
   break;
  case GF_STREAM_MPEG7:
   fprintf(stderr, "\tMPEG-7 Stream - version %d\n", esd->decoderConfig->objectTypeIndication);
   break;
  case GF_STREAM_IPMP:
   fprintf(stderr, "\tIPMP Stream - version %d\n", esd->decoderConfig->objectTypeIndication);
   break;
  case GF_STREAM_OCI:
   fprintf(stderr, "\tOCI Stream - version %d\n", esd->decoderConfig->objectTypeIndication);
   break;
  case GF_STREAM_MPEGJ:
   fprintf(stderr, "\tMPEGJ Stream - version %d\n", esd->decoderConfig->objectTypeIndication);
   break;
  case GF_STREAM_INTERACT:
   fprintf(stderr, "\tUser Interaction Stream - version %d\n", esd->decoderConfig->objectTypeIndication);
   break;
  case GF_STREAM_TEXT:
   fprintf(stderr, "\tStreaming Text Stream - version %d\n", esd->decoderConfig->objectTypeIndication);
   break;
  default:
   fprintf(stderr, "\tUnknown Stream\n");
   break;
  }

  fprintf(stderr, "\tBuffer Size %d\n\tAverage Bitrate %d bps\n\tMaximum Bitrate %d bps\n", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate, esd->decoderConfig->maxBitrate);
  if (esd->slConfig->predefined==SLPredef_SkipSL) {
   fprintf(stderr, "\tNot using MPEG-4 Synchronization Layer\n");
  } else {
   fprintf(stderr, "\tStream Clock Resolution %d\n", esd->slConfig->timestampResolution);
  }
  if (esd->URLString) fprintf(stderr, "\tStream Location: %s\n", esd->URLString);


  if (esd->langDesc) {
   s32 lang_idx;
   char lan[4];
   lan[0] = esd->langDesc->langCode>>16;
   lan[1] = (esd->langDesc->langCode>>8)&0xFF;
   lan[2] = (esd->langDesc->langCode)&0xFF;
   lan[3] = 0;

   lang_idx = gf_lang_find(lan);
   if (lang_idx>=0) {
    fprintf(stderr, "\tStream Language: %s\n", gf_lang_get_name(lang_idx));
   }
  }
 }
 fprintf(stderr, "\n");

 var_148 = gf_list_count(odi.od->OCIDescriptors);
 if (var_148) {
  fprintf(stderr, "%d Object Content Information descriptors in OD\n", var_148);
  for (var_148=0; var_148<var_148; var_148++) {
   GF_Descriptor *desc = (GF_Descriptor *) gf_list_get(odi.od->OCIDescriptors, var_148);
   switch (desc->tag) {
   case GF_ODF_SEGMENT_TAG:
   {
    GF_Segment *sd = (GF_Segment *) desc;
    fprintf(stderr, "Segment Descriptor: Name: %s - start time %g sec - duration %g sec\n", sd->SegmentName, sd->startTime, sd->Duration);
   }
   break;
   case GF_ODF_CC_NAME_TAG:
   {
    GF_CC_Name *ccn = (GF_CC_Name *)desc;
    fprintf(stderr, "Content Creators:\n");
    for (j=0; j<gf_list_count(ccn->ContentCreators); j++) {
     GF_ContentCreatorInfo *ci = (GF_ContentCreatorInfo *) gf_list_get(ccn->ContentCreators, j);
     if (!ci->isUTF8) continue;
     fprintf(stderr, "\t%s\n", ci->contentCreatorName);
    }
   }
   break;

   case GF_ODF_SHORT_TEXT_TAG:
   {
    GF_ShortTextual *std = (GF_ShortTextual *)desc;
    fprintf(stderr, "Description:\n\tEvent: %s\n\t%s\n", std->eventName, std->eventText);
   }
   break;
   default:
    break;
   }
  }
  fprintf(stderr, "\n");
 }

 switch (odi.status) {
 case 0:
  fprintf(stderr, "Stopped - ");
  break;
 case 1:
  fprintf(stderr, "Playing - ");
  break;
 case 2:
  fprintf(stderr, "Paused - ");
  break;
 case 3:
  fprintf(stderr, "Not setup yet\n");
  return;
 default:
  fprintf(stderr, "Setup Failed\n");
  return;
 }
 if (odi.buffer>=0) fprintf(stderr, "Buffer: %d ms - ", odi.buffer);
 else fprintf(stderr, "Not buffering - ");
 fprintf(stderr, "Clock drift: %d ms\n", odi.clock_drift);
 if (odi.db_unit_count) fprintf(stderr, "%d AU in DB\n", odi.db_unit_count);
 if (odi.cb_max_count) fprintf(stderr, "Composition Buffer: %d CU (%d max)\n", odi.cb_unit_count, odi.cb_max_count);
 fprintf(stderr, "\n");

 if (odi.owns_service) {
  const char *url;
  u32 var_145, var_145, bps;
  d_enum = 0;
  while (gf_term_get_download_info(term, odm, &d_enum, &url, NULL, &var_145, &var_145, &bps)) {
   if (d_enum==1) fprintf(stderr, "Current Downloads in service:\n");
   if (var_145 && var_145) {
    fprintf(stderr, "%s: %d / %d bytes (%.2f %%) - %.2f kBps\n", url, var_145, var_145, (100.0f*var_145)/var_145, ((Float)bps)/1024.0f);
   } else {
    fprintf(stderr, "%s: %.2f kbps\n", url, ((Float)8*bps)/1024.0f);
   }
  }
  if (!d_enum) fprintf(stderr, "No Downloads in service\n");
  fprintf(stderr, "\n");
 }
 d_enum = 0;
 while (gf_term_get_channel_net_info(term, odm, &d_enum, &id, &com, &var_145)) {
  if (var_145) continue;
  if (!com.bw_down && !com.bw_up) continue;

  fprintf(stderr, "Stream ID %d statistics:\n", id);
  if (com.multiplex_port) {
   fprintf(stderr, "\tMultiplex Port %d - multiplex ID %d\n", com.multiplex_port, com.port);
  } else {
   fprintf(stderr, "\tPort %d\n", com.port);
  }
  fprintf(stderr, "\tPacket Loss Percentage: %.4f\n", com.pck_loss_percentage);
  fprintf(stderr, "\tDown Bandwidth: %d bps\n", com.bw_down);
  if (com.bw_up) fprintf(stderr, "\tUp Bandwidth: %d bps\n", com.bw_up);
  if (com.ctrl_port) {
   if (com.multiplex_port) {
    fprintf(stderr, "\tControl Multiplex Port: %d - Control Multiplex ID %d\n", com.multiplex_port, com.ctrl_port);
   } else {
    fprintf(stderr, "\tControl Port: %d\n", com.ctrl_port);
   }
   fprintf(stderr, "\tDown Bandwidth: %d bps\n", com.ctrl_bw_down);
   fprintf(stderr, "\tUp Bandwidth: %d bps\n", com.ctrl_bw_up);
  }
  fprintf(stderr, "\n");
 }
}

void fn_145(GF_Terminal *term, GF_ObjectManager *odm, u32 var_148)
{
 GF_MediaInfo odi;
 u32 var_148 = var_148;
 u32 var_148, var_148;
 if (!odm) return;

 if (gf_term_get_object_info(term, odm, &odi) != var_148) return;
 if (!odi.od) {
  fprintf(stderr, "Service not attached\n");
  return;
 }
 while (var_148) {
  fprintf(stderr, " ");
  var_148--;
 }

 if (! odi.generated_scene) {

  fprintf(stderr, "- OD %d: ", odi.od->objectDescriptorID);
  switch (odi.status) {
  case 1:
   fprintf(stderr, "Playing - ");
   break;
  case 2:
   fprintf(stderr, "Paused - ");
   break;
  default:
   fprintf(stderr, "Stopped - ");
   break;
  }
  if (odi.buffer>=0) fprintf(stderr, "Buffer: %d ms - ", odi.buffer);
  else fprintf(stderr, "Not buffering - ");
  fprintf(stderr, "Clock drift: %d ms", odi.clock_drift);
  fprintf(stderr, " - time: ");
  PrintTime((u32) (odi.current_time*1000));
  fprintf(stderr, "\n");

 } else {
  fprintf(stderr, "+ Service %s:\n", odi.service_url);
 }

 var_148 = gf_term_get_object_count(term, odm);
 for (var_148=0; var_148<var_148; var_148++) {
  GF_ObjectManager *an_odm = gf_term_get_object(term, odm, var_148);
  PrintODTiming(term, an_odm, var_148+1);
 }
 return;

}

void fn_147(GF_Terminal *term, GF_ObjectManager *odm, u32 var_148)
{
 Float var_148;
 GF_MediaInfo odi;
 u32 var_148, var_148, var_148;
 if (!odm) return;

 if (gf_term_get_object_info(term, odm, &odi) != var_148) return;
 if (!odi.od) {
  fprintf(stderr, "Service not attached\n");
  return;
 }

 var_148 = var_148;
 while (var_148) {
  fprintf(stderr, " ");
  var_148--;
 }

 if (odi.generated_scene) {
  fprintf(stderr, "+ Service %s:\n", odi.service_url);
 } else {
  fprintf(stderr, "- OD %d: ", odi.od->objectDescriptorID);
  switch (odi.status) {
  case 1:
   fprintf(stderr, "Playing");
   break;
  case 2:
   fprintf(stderr, "Paused");
   break;
  default:
   fprintf(stderr, "Stopped");
   break;
  }
  if (odi.buffer>=0) fprintf(stderr, " - Buffer: %d ms", odi.buffer);
  if (odi.db_unit_count) fprintf(stderr, " - DB: %d AU", odi.db_unit_count);
  if (odi.cb_max_count) fprintf(stderr, " - CB: %d/%d CUs", odi.cb_unit_count, odi.cb_max_count);

  fprintf(stderr, "\n");
  var_148 = var_148;
  while (var_148) {
   fprintf(stderr, " ");
   var_148--;
  }

  fprintf(stderr, " %d decoded frames - %d dropped frames\n", odi.nb_dec_frames, odi.nb_dropped);

  var_148 = var_148;
  while (var_148) {
   fprintf(stderr, " ");
   var_148--;
  }

  var_148 = 0;
  if (odi.nb_dec_frames) {
   var_148 = (Float) odi.total_dec_time;
   var_148 /= odi.nb_dec_frames;
  }
  fprintf(stderr, " Avg Bitrate %d kbps (%d max) - Avg Decoding Time %.2f us (%d max)\n",
          (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, var_148, odi.max_dec_time);
 }

 var_148 = gf_term_get_object_count(term, odm);
 for (var_148=0; var_148<var_148; var_148++) {
  GF_ObjectManager *an_odm = gf_term_get_object(term, odm, var_148);
  PrintODBuffer(term, an_odm, var_148+1);
 }

}

void fn_148(GF_Terminal *term, Bool var_148)
{
 GF_ObjectManager *root_odm = gf_term_get_root_object(term);
 if (!root_odm) return;

 if (var_148) {
  PrintODTiming(term, root_odm, 0);
 } else {
  PrintODBuffer(term, root_odm, 0);
 }
 fprintf(stderr, "\n");
}


void fn_148()
{
 u32 var_148, j, cfg_count, key_count;
 char szName[200];
 char *secName = NULL;

 fprintf(stderr, "Enter section name (\"*\" for complete dump):\n");
 if (1 > scanf("%s", szName)) {
  fprintf(stderr, "No section name, aborting.\n");
  return;
 }
 if (strcmp(szName, "*")) secName = szName;

 fprintf(stderr, "\n\n*** GPAC Configuration ***\n\n");

 cfg_count = gf_cfg_get_section_count(cfg_file);
 for (var_148=0; var_148<cfg_count; var_148++) {
  const char *sec = gf_cfg_get_section_name(cfg_file, var_148);
  if (secName) {
   if (stricmp(sec, secName)) continue;
  } else {
   if (!stricmp(sec, "General")) continue;
   if (!stricmp(sec, "MimeTypes")) continue;
   if (!stricmp(sec, "RecentFiles")) continue;
  }
  fprintf(stderr, "[%s]\n", sec);
  key_count = gf_cfg_get_key_count(cfg_file, sec);
  for (j=0; j<key_count; j++) {
   const char *key = gf_cfg_get_key_name(cfg_file, sec, j);
   const char *val = gf_cfg_get_key(cfg_file, sec, key);
   fprintf(stderr, "%s=%s\n", key, val);
  }
  fprintf(stderr, "\n");
 }
}
