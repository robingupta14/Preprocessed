







char updateBuf[UPDATE_BUF_SIZE];
int ublen;

rfbClientPtr var_115 = NULL;
rfbClientPtr var_85 = NULL;

Bool var_81 = FALSE;
Bool var_81 = FALSE;
Bool var_81 = TRUE;
Bool var_118 = FALSE;
Bool var_86 = TRUE;
Bool var_94 = TRUE;
double var_107 = 0.0;
int var_63 = -1;
int var_63 = var_11;
int var_94 = 100;
int var_102 = 256;
Bool var_107 = FALSE;
int var_15 = var_18, var_17 = var_18;
int var_86 = var_19;
Bool var_89 = FALSE;
Bool var_78 = TRUE;
int var_78 = 0;

static rfbClientPtr fn_71(int var_118);
static void fn_80(rfbClientPtr var_116);
static void fn_81(rfbClientPtr var_116);
static void fn_81(rfbClientPtr var_116);
static void fn_81(rfbClientPtr var_116);
static Bool fn_107(rfbClientPtr var_116, RegionPtr var_107, int var_107, int var_107);
static Bool fn_109(rfbClientPtr var_116);
Bool fn_115(rfbClientPtr var_116);
Bool fn_115(rfbClientPtr var_116);






char *captureFile = NULL;

static void fn_37(int var_40, char *buf, int var_115)
{
  if (write(var_40, buf, var_115) < var_115)
    rfbLogPerror("WriteCapture: Could not write to capture file");
}






CARD32 var_40 = 0;
CARD32 var_79 = 0;
static double var_46 = -1.0;

void fn_43(void)
{
  var_46 = gettime() + (double)var_79;
}

static void fn_44(void)
{
  var_46 = -1.0;
}

void fn_45(void)
{
  if (var_46 >= 0.0 && gettime() >= var_46)
    FatalError("TurboVNC session has been idle for %u seconds.  Exiting.",
               (unsigned int)var_79);
}






static BOOL var_107 = FALSE;
static double var_107 = 0., var_107 = -1., tElapsed, var_107 = 0.,
  var_107 = 0.;
static unsigned long var_116 = 0;
unsigned long long var_107 = 0;

double fn_53(void)
{
  struct struct_54 __tv;

  gettimeofday(&__tv, (struct struct_55 *)NULL);
  return (double)__tv.tv_sec + (double)__tv.tv_usec * 0.000001;
}






static Bool var_107 = TRUE, var_107 = TRUE;

static CARD32 fn_58(OsTimerPtr var_64, CARD32 var_64, pointer var_64)
{
  RegionRec copyRegionSave, modifiedRegionSave, requestedRegionSave,
    ifRegionSave;
  rfbClientPtr var_116 = (rfbClientPtr)var_64;
  int tightCompressLevelSave, tightQualityLevelSave, copyDXSave, copyDYSave,
    tightSubsampLevelSave;
  RegionRec tmpRegion;

  REGION_INIT(var_107, &tmpRegion, NullBox, 0);
  if (var_107 && !var_116->firstUpdate)
    REGION_INTERSECT(var_107, &tmpRegion, &var_116->alrRegion, &var_116->lossyRegion);
  else
    REGION_COPY(var_107, &tmpRegion, &var_116->lossyRegion);
  if (var_116->firstUpdate) var_116->firstUpdate = FALSE;

  if (REGION_NOTEMPTY(var_107, &tmpRegion)) {

    tightCompressLevelSave = var_116->tightCompressLevel;
    tightQualityLevelSave = var_116->tightQualityLevel;
    tightSubsampLevelSave = var_116->tightSubsampLevel;
    copyDXSave = var_116->copyDX;
    copyDYSave = var_116->copyDY;
    REGION_INIT(var_107, &copyRegionSave, NullBox, 0);
    REGION_COPY(var_107, &copyRegionSave, &var_116->copyRegion);
    REGION_INIT(var_107, &modifiedRegionSave, NullBox, 0);
    REGION_COPY(var_107, &modifiedRegionSave, &var_116->modifiedRegion);
    REGION_INIT(var_107, &requestedRegionSave, NullBox, 0);
    REGION_COPY(var_107, &requestedRegionSave, &var_116->requestedRegion);
    REGION_INIT(var_107, &ifRegionSave, NullBox, 0);
    REGION_COPY(var_107, &ifRegionSave, &var_116->ifRegion);

    var_116->tightCompressLevel = 1;
    var_116->tightQualityLevel = var_63;
    var_116->tightSubsampLevel = var_63;
    var_116->copyDX = var_116->copyDY = 0;
    REGION_EMPTY(var_107, &var_116->copyRegion);
    REGION_EMPTY(var_107, &var_116->modifiedRegion);
    REGION_UNION(var_107, &var_116->modifiedRegion, &var_116->modifiedRegion,
                 &tmpRegion);
    REGION_EMPTY(var_107, &var_116->requestedRegion);
    REGION_UNION(var_107, &var_116->requestedRegion, &var_116->requestedRegion,
                 &tmpRegion);
    if (var_116->compareFB) {
      REGION_EMPTY(var_107, &var_116->ifRegion);
      REGION_UNION(var_107, &var_116->ifRegion, &var_116->ifRegion, &tmpRegion);
    }

    if (!rfbSendFramebufferUpdate(var_116)) return 0;

    REGION_EMPTY(var_107, &var_116->lossyRegion);
    REGION_EMPTY(var_107, &var_116->alrRegion);
    var_116->tightCompressLevel = tightCompressLevelSave;
    var_116->tightQualityLevel = tightQualityLevelSave;
    var_116->tightSubsampLevel = tightSubsampLevelSave;
    var_116->copyDX = copyDXSave;
    var_116->copyDY = copyDYSave;
    REGION_COPY(var_107, &var_116->copyRegion, &copyRegionSave);
    REGION_COPY(var_107, &var_116->modifiedRegion, &modifiedRegionSave);
    REGION_COPY(var_107, &var_116->requestedRegion, &requestedRegionSave);
    REGION_UNINIT(var_107, &copyRegionSave);
    REGION_UNINIT(var_107, &modifiedRegionSave);
    REGION_UNINIT(var_107, &requestedRegionSave);
    if (var_116->compareFB) {
      REGION_COPY(var_107, &var_116->ifRegion, &ifRegionSave);
      REGION_UNINIT(var_107, &ifRegionSave);
    }
  }

  REGION_UNINIT(var_107, &tmpRegion);
  return 0;
}


static CARD32 fn_63(OsTimerPtr var_64, CARD32 var_64, pointer var_64)
{
  rfbClientPtr var_116 = (rfbClientPtr)var_64;

  rfbSendFramebufferUpdate(var_116);
  return 0;
}






int var_85 = -1;

Bool fn_65(rfbClientPtr var_116)
{
  if (!var_116->compareFB) {
    if (!(var_116->compareFB =
          (char *)malloc(rfbFB.paddedWidthInBytes * rfbFB.height))) {
      rfbLogPerror("InterframeOn: couldn't allocate comparison buffer");
      return FALSE;
    }
    memset(var_116->compareFB, 0, rfbFB.paddedWidthInBytes * rfbFB.height);
    REGION_INIT(var_107, &var_116->ifRegion, NullBox, 0);
    var_116->firstCompare = TRUE;
    rfbLog("Interframe comparison enabled\n");
  }
  var_116->fb = var_116->compareFB;
  return TRUE;
}

void fn_66(rfbClientPtr var_116)
{
  if (var_116->compareFB) {
    free(var_116->compareFB);
    REGION_UNINIT(var_107, &var_116->ifRegion);
    rfbLog("Interframe comparison disabled\n");
  }
  var_116->compareFB = NULL;
  var_116->fb = rfbFB.pfbMemory;
}







static int JPEG_QUAL[10] = {
  15, 29, 41, 42, 62, 77, 79, 86, 92, 100
};

static int JPEG_SUBSAMP[10] = {
  1, 1, 1, 2, 2, 2, 0, 0, 0, 0
};







void fn_67(int var_118)
{
  rfbNewClient(var_118);
}







rfbClientPtr fn_68(char *host, int var_71, int var_71)
{
  int var_118;
  rfbClientPtr var_116;

  if (rfbAuthDisableRevCon) {
    rfbLog("Reverse connections disabled\n");
    return (rfbClientPtr)NULL;
  }

  if ((var_118 = rfbConnect(host, var_71)) < 0)
    return (rfbClientPtr)NULL;

  if (var_71 > 0) {
    rfbClientRec var_116;
    char temps[250];
    memset(temps, 0, 250);
    snprintf(temps, 250, "ID:%d", var_71);
    rfbLog("UltraVNC Repeater Mode II ID is %d\n", var_71);
    var_116.sock = var_118;
    if (WriteExact(&var_116, temps, 250) < 0) {
      rfbLogPerror("rfbReverseConnection: write");
      rfbCloseSock(var_118);
      return NULL;
    }
  }

  var_116 = rfbNewClient(var_118);

  if (var_116)
    var_116->reverseConnection = TRUE;

  return var_116;
}







static rfbClientPtr fn_71(int var_118)
{
  rfbProtocolVersionMsg pv;
  rfbClientPtr var_116;
  BoxRec box;
  rfbSockAddr addr;
  socklen_t var_74 = sizeof(struct struct_72);
  char addrStr[INET6_ADDRSTRLEN];
  char *env = NULL;
  int var_78 = sysconf(_SC_NPROCESSORS_CONF);

  if (var_115 == NULL)

    KbdReleaseAllKeys();

  var_116 = (rfbClientPtr)rfbAlloc0(sizeof(rfbClientRec));

  if (var_115 == NULL && captureFile) {
    var_116->captureFD = open(captureFile, O_CREAT | O_EXCL | O_WRONLY,
                         S_IRUSR | S_IWUSR);
    if (var_116->captureFD < 0)
      rfbLogPerror("Could not open capture file");
    else
      rfbLog("Opened capture file %s\n", captureFile);
  } else
    var_116->captureFD = -1;

  var_116->sock = var_118;
  getpeername(var_118, &addr.u.sa, &var_74);
  var_116->host = strdup(sockaddr_string(&addr, addrStr, INET6_ADDRSTRLEN));


  var_116->state = RFB_PROTOCOL_VERSION;

  var_116->preferredEncoding = rfbEncodingTight;
  var_116->correMaxWidth = 48;
  var_116->correMaxHeight = 48;

  REGION_INIT(var_107, &var_116->copyRegion, NullBox, 0);

  box.x1 = box.y1 = 0;
  box.x2 = rfbFB.width;
  box.y2 = rfbFB.height;
  REGION_INIT(var_107, &var_116->modifiedRegion, &box, 0);

  REGION_INIT(var_107, &var_116->requestedRegion, NullBox, 0);

  var_116->deferredUpdateStart = gettime();

  var_116->format = rfbServerFormat;
  var_116->translateFn = rfbTranslateNone;

  var_116->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;
  var_116->tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP;
  var_116->tightQualityLevel = -1;
  var_116->imageQualityLevel = -1;

  var_116->next = var_115;
  var_116->prev = NULL;
  if (var_115)
    var_115->prev = var_116;
  var_115 = var_116;

  rfbResetStats(var_116);

  var_116->zlibCompressLevel = 5;

  sprintf(pv, rfbProtocolVersionFormat, 3, 8);

  if (WriteExact(var_116, pv, sz_rfbProtocolVersionMsg) < 0) {
    rfbLogPerror("rfbNewClient: write");
    rfbCloseClient(var_116);
    return NULL;
  }

  if ((env = getenv("TVNC_PROFILE")) != NULL && !strcmp(env, "1"))
    var_107 = TRUE;

  if ((env = getenv("TVNC_ICEDEBUG")) != NULL && !strcmp(env, "1"))
    var_107 = TRUE;

  if ((env = getenv("TVNC_ICEBLOCKSIZE")) != NULL) {
    int var_75 = atoi(env);
    if (var_75 >= 0) var_102 = var_75;
  }

  if ((env = getenv("TVNC_COMBINERECT")) != NULL) {
    int var_76 = atoi(env);
    if (var_76 > 0 && var_76 <= 65000) var_94 = var_76;
  }

  var_116->firstUpdate = TRUE;



  var_116->reason = rfbEDSReasonServer;
  var_116->result = var_116;

  if (var_107 > 0.0) {
    REGION_INIT(var_107, &var_116->lossyRegion, NullBox, 0);
    if ((env = getenv("TVNC_ALRALL")) != NULL && !strcmp(env, "1"))
      var_107 = FALSE;
    if ((env = getenv("TVNC_ALRCOPYRECT")) != NULL && !strcmp(env, "0"))
      var_107 = FALSE;
    REGION_INIT(var_107, &var_116->alrRegion, NullBox, 0);
    REGION_INIT(var_107, &var_116->alrEligibleRegion, NullBox, 0);
  }

  if ((env = getenv("TVNC_MT")) != NULL && !strcmp(env, "0"))
    var_78 = FALSE;

  if ((env = getenv("TVNC_NTHREADS")) != NULL && strlen(env) >= 1) {
    int var_78 = atoi(env);
    if (var_78 >= 1 && var_78 <= MAX_ENCODING_THREADS)
      var_78 = var_78;
    else
      rfbLog("WARNING: Invalid value of TVNC_NTHREADS (%s) ignored\n", env);
  }

  if (var_78 == -1 && var_78) {
    rfbLog("WARNING: Could not determine CPU count.  Multithreaded encoding disabled.\n");
    var_78 = FALSE;
  }
  if (!var_78) var_78 = 1;
  else if (var_78 < 1) var_78 = min(var_78, 4);
  if (var_78 > var_78) {
    rfbLog("NOTICE: Encoding thread count has been clamped to CPU count\n");
    var_78 = var_78;
  }

  if (var_79 > 0)
    IdleTimerCancel();

  var_116->baseRTT = var_116->minRTT = (unsigned)-1;
  gettimeofday(&var_116->lastWrite, NULL);
  REGION_INIT(var_107, &var_116->cuRegion, NullBox, 0);

  if (var_85 == 1) {
    if (!InterframeOn(var_116)) {
      rfbCloseClient(var_116);
      return NULL;
    }
  } else
    InterframeOff(var_116);

  return var_116;
}







void fn_78(rfbClientPtr var_116)
{
  int i;

  if (var_116->prev)
    var_116->prev->next = var_116->next;
  else
    var_115 = var_116->next;
  if (var_116->next)
    var_116->next->prev = var_116->prev;

  TimerFree(var_116->alrTimer);
  TimerFree(var_116->deferredUpdateTimer);
  TimerFree(var_116->updateTimer);
  TimerFree(var_116->congestionTimer);




  if (var_116->login != NULL) {
    rfbLog("Client %s (%s) gone\n", var_116->login, var_116->host);
    free(var_116->login);
  } else {
    rfbLog("Client %s gone\n", var_116->host);
  }
  free(var_116->host);

  ShutdownTightThreads();

  if (var_107 > 0.0) {
    REGION_UNINIT(var_107, &var_116->lossyRegion);
    REGION_UNINIT(var_107, &var_116->alrRegion);
    REGION_UNINIT(var_107, &var_116->alrEligibleRegion);
  }


  if (var_116->compStreamInited == TRUE)
    deflateEnd(&(var_116->compStream));

  for (i = 0; i < 4; i++) {
    if (var_116->zsActive[i])
      deflateEnd(&var_116->zsStruct[i]);
  }

  if (var_85 == var_116)
    var_85 = NULL;

  REGION_UNINIT(var_107, &var_116->copyRegion);
  REGION_UNINIT(var_107, &var_116->modifiedRegion);

  rfbPrintStats(var_116);

  if (var_116->translateLookupTable) free(var_116->translateLookupTable);

  rfbFreeZrleData(var_116);

  if (var_116->cutText)
    free(var_116->cutText);

  InterframeOff(var_116);

  i = var_116->numDevices;
  while (i-- > 0)
    RemoveExtInputDevice(var_116, 0);

  if (var_116->captureFD >= 0)
    close(var_116->captureFD);

  free(var_116);

  if (var_115 == NULL && var_79 > 0)
    IdleTimerSet();
}






void fn_79(rfbClientPtr var_116)
{
  rfbCorkSock(var_116->sock);

  if (var_116->pendingSyncFence) {
    var_116->syncFence = TRUE;
    var_116->pendingSyncFence = FALSE;
  }

  switch (var_116->state) {
    case RFB_PROTOCOL_VERSION:
      rfbProcessClientProtocolVersion(var_116);
      break;
    case RFB_SECURITY_TYPE:
      rfbProcessClientSecurityType(var_116);
      break;
    case RFB_TUNNELING_TYPE:
      rfbProcessClientTunnelingType(var_116);
      break;
    case RFB_AUTH_TYPE:
      rfbProcessClientAuthType(var_116);
      break;





    case RFB_AUTHENTICATION:
      rfbAuthProcessResponse(var_116);
      break;
    case RFB_INITIALISATION:
      rfbInitFlowControl(var_116);
      rfbProcessClientInitMessage(var_116);
      break;
    default:
      rfbProcessClientNormalMessage(var_116);
  }

  CHECK_CLIENT_PTR(var_116, return)

  if (var_116->syncFence) {
    if (!rfbSendFence(var_116, var_116->fenceFlags, var_116->fenceDataLen, var_116->fenceData))
      return;
    var_116->syncFence = FALSE;
  }

  rfbUncorkSock(var_116->sock);
}







static void fn_80(rfbClientPtr var_116)
{
  rfbProtocolVersionMsg pv;
  int var_118, major, minor;

  if ((var_118 = ReadExact(var_116, pv, sz_rfbProtocolVersionMsg)) <= 0) {
    if (var_118 == 0)
      rfbLog("rfbProcessClientProtocolVersion: client gone\n");
    else
      rfbLogPerror("rfbProcessClientProtocolVersion: read");
    rfbCloseClient(var_116);
    return;
  }

  pv[sz_rfbProtocolVersionMsg] = 0;
  if (sscanf(pv, rfbProtocolVersionFormat, &major, &minor) != 2) {
    rfbLog("rfbProcessClientProtocolVersion: not a valid RFB client\n");
    rfbCloseClient(var_116);
    return;
  }
  if (major != 3) {
    rfbLog("Unsupported protocol version %d.%d\n", major, minor);
    rfbCloseClient(var_116);
    return;
  }


  var_116->protocol_minor_ver = minor;

  if (minor > 8)
    var_116->protocol_minor_ver = 8;
  else if (minor > 3 && minor < 7)
    var_116->protocol_minor_ver = 3;
  else if (minor < 3)
    var_116->protocol_minor_ver = 3;

  if (var_116->protocol_minor_ver != minor)
    rfbLog("Non-standard protocol version 3.%d, using 3.%d instead\n", minor,
           var_116->protocol_minor_ver);
  else
    rfbLog("Using protocol version 3.%d\n", var_116->protocol_minor_ver);


  var_116->protocol_tightvnc = FALSE;

  rfbAuthNewClient(var_116);
}







static void fn_81(rfbClientPtr var_116)
{
  rfbClientInitMsg ci;
  char buf[256];
  rfbServerInitMsg *si = (rfbServerInitMsg *)buf;
  int var_115, var_118;
  rfbClientPtr otherCl, nextCl;

  if ((var_118 = ReadExact(var_116, (char *)&ci, sz_rfbClientInitMsg)) <= 0) {
    if (var_118 == 0)
      rfbLog("rfbProcessClientInitMessage: client gone\n");
    else
      rfbLogPerror("rfbProcessClientInitMessage: read");
    rfbCloseClient(var_116);
    return;
  }

  si->framebufferWidth = Swap16IfLE(rfbFB.width);
  si->framebufferHeight = Swap16IfLE(rfbFB.height);
  si->format = rfbServerFormat;
  si->format.redMax = Swap16IfLE(si->format.redMax);
  si->format.greenMax = Swap16IfLE(si->format.greenMax);
  si->format.blueMax = Swap16IfLE(si->format.blueMax);

  if (strlen(desktopName) > 128)
    desktopName[128] = 0;

  sprintf(buf + sz_rfbServerInitMsg, "%s", desktopName);

  var_115 = strlen(buf + sz_rfbServerInitMsg);
  si->nameLength = Swap32IfLE(var_115);

  if (WriteExact(var_116, buf, sz_rfbServerInitMsg + var_115) < 0) {
    rfbLogPerror("rfbProcessClientInitMessage: write");
    rfbCloseClient(var_116);
    return;
  }

  if (var_116->protocol_tightvnc)
    rfbSendInteractionCaps(var_116);


  var_116->state = RFB_NORMAL;

  if (!var_116->reverseConnection &&
      (var_81 || (!var_81 && !ci.shared))) {

    if (var_81) {
      for (otherCl = var_115; otherCl; otherCl = otherCl->next) {
        if ((otherCl != var_116) && (otherCl->state == RFB_NORMAL)) {
          rfbLog("-dontdisconnect: Not shared & existing client\n");
          rfbLog("  refusing new client %s\n", var_116->host);
          rfbCloseClient(var_116);
          return;
        }
      }
    } else {
      for (otherCl = var_115; otherCl; otherCl = nextCl) {
        nextCl = otherCl->next;
        if ((otherCl != var_116) && (otherCl->state == RFB_NORMAL)) {
          rfbLog("Not shared - closing connection to client %s\n",
                 otherCl->host);
          rfbCloseClient(otherCl);
        }
      }
    }
  }
}

void fn_81(rfbClientPtr var_116)
{
  rfbInteractionCapsMsg intr_caps;
  rfbCapabilityInfo enc_list[17];
  int i;


  intr_caps.nServerMessageTypes = Swap16IfLE(0);
  intr_caps.nClientMessageTypes = Swap16IfLE(0);
  intr_caps.nEncodingTypes = Swap16IfLE(17);
  intr_caps.pad = 0;

  i = 0;
  SetCapInfo(&enc_list[i++], rfbEncodingCopyRect, rfbStandardVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingRRE, rfbStandardVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingCoRRE, rfbStandardVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingHextile, rfbStandardVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingZlib, rfbTridiaVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingZRLE, rfbTridiaVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingZYWRLE, rfbTridiaVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingTight, rfbTightVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingCompressLevel0, rfbTightVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingQualityLevel0, rfbTightVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingFineQualityLevel0, rfbTurboVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingSubsamp1X, rfbTurboVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingXCursor, rfbTightVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingRichCursor, rfbTightVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingPointerPos, rfbTightVncVendor);
  SetCapInfo(&enc_list[i++], rfbEncodingLastRect, rfbTightVncVendor);
  SetCapInfo(&enc_list[i++], rfbGIIServer, rfbGIIVendor);
  if (i != 17) {
    rfbLog("rfbSendInteractionCaps: assertion failed, i != N_ENC_CAPS\n");
    rfbCloseClient(var_116);
    return;
  }


  if (WriteExact(var_116, (char *)&intr_caps,
                 sz_rfbInteractionCapsMsg) < 0 ||
      WriteExact(var_116, (char *)&enc_list[0],
                 sz_rfbCapabilityInfo * 17) < 0) {
    rfbLogPerror("rfbSendInteractionCaps: write");
    rfbCloseClient(var_116);
    return;
  }


  var_116->state = RFB_NORMAL;
}

static void fn_81(rfbClientPtr var_116)
{
  int var_118;
  rfbClientToServerMsg msg;
  char *str;

  if ((var_118 = ReadExact(var_116, (char *)&msg, 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

  switch (msg.type) {

    case rfbSetPixelFormat:

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbSetPixelFormatMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      var_116->format.bitsPerPixel = msg.spf.format.bitsPerPixel;
      var_116->format.depth = msg.spf.format.depth;
      var_116->format.bigEndian = (msg.spf.format.bigEndian ? 1 : 0);
      var_116->format.trueColour = (msg.spf.format.trueColour ? 1 : 0);
      var_116->format.redMax = Swap16IfLE(msg.spf.format.redMax);
      var_116->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);
      var_116->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);
      var_116->format.redShift = msg.spf.format.redShift;
      var_116->format.greenShift = msg.spf.format.greenShift;
      var_116->format.blueShift = msg.spf.format.blueShift;

      var_116->readyForSetColourMapEntries = TRUE;

      rfbSetTranslateFunction(var_116);
      return;

    case rfbFixColourMapEntries:
      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbFixColourMapEntriesMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }
      rfbLog("rfbProcessClientNormalMessage: FixColourMapEntries unsupported\n");
      rfbCloseClient(var_116);
      return;

    case rfbSetEncodings:
    {
      int i;
      CARD32 enc;
      Bool var_85 = !var_116->enableFence;
      Bool var_85 = !var_116->enableCU;
      Bool var_85 = !var_116->enableGII;
      Bool var_85 = FALSE;

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbSetEncodingsMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);

      var_116->preferredEncoding = -1;
      var_116->useCopyRect = FALSE;
      var_116->enableCursorShapeUpdates = FALSE;
      var_116->enableCursorPosUpdates = FALSE;
      var_116->enableLastRectEncoding = FALSE;
      var_116->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;
      var_116->tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP;
      var_116->tightQualityLevel = -1;
      var_116->imageQualityLevel = -1;

      for (i = 0; i < msg.se.nEncodings; i++) {
        if ((var_118 = ReadExact(var_116, (char *)&enc, 4)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }
        enc = Swap32IfLE(enc);

        switch (enc) {

          case rfbEncodingCopyRect:
            var_116->useCopyRect = TRUE;
            break;
          case rfbEncodingRaw:
            if (var_116->preferredEncoding == -1) {
              var_116->preferredEncoding = enc;
              rfbLog("Using raw encoding for client %s\n", var_116->host);
            }
            break;
          case rfbEncodingRRE:
            if (var_116->preferredEncoding == -1) {
              var_116->preferredEncoding = enc;
              rfbLog("Using rre encoding for client %s\n", var_116->host);
            }
            break;
          case rfbEncodingCoRRE:
            if (var_116->preferredEncoding == -1) {
              var_116->preferredEncoding = enc;
              rfbLog("Using CoRRE encoding for client %s\n", var_116->host);
            }
            break;
          case rfbEncodingHextile:
            if (var_116->preferredEncoding == -1) {
              var_116->preferredEncoding = enc;
              rfbLog("Using hextile encoding for client %s\n", var_116->host);
            }
            break;
          case rfbEncodingZlib:
            if (var_116->preferredEncoding == -1) {
              var_116->preferredEncoding = enc;
              rfbLog("Using zlib encoding for client %s\n", var_116->host);
            }
            break;
          case rfbEncodingZRLE:
            if (var_116->preferredEncoding == -1) {
              var_116->preferredEncoding = enc;
              rfbLog("Using ZRLE encoding for client %s\n", var_116->host);
            }
            break;
          case rfbEncodingZYWRLE:
            if (var_116->preferredEncoding == -1) {
              var_116->preferredEncoding = enc;
              rfbLog("Using ZYWRLE encoding for client %s\n", var_116->host);
            }
            break;
          case rfbEncodingTight:
            if (var_116->preferredEncoding == -1) {
              var_116->preferredEncoding = enc;
              rfbLog("Using tight encoding for client %s\n", var_116->host);
            }
            break;
          case rfbEncodingXCursor:
            if (!var_116->enableCursorShapeUpdates) {
              rfbLog("Enabling X-style cursor updates for client %s\n",
                     var_116->host);
              var_116->enableCursorShapeUpdates = TRUE;
              var_116->useRichCursorEncoding = FALSE;
              var_116->cursorWasChanged = TRUE;
            }
            break;
          case rfbEncodingRichCursor:
            if (!var_116->enableCursorShapeUpdates) {
              rfbLog("Enabling full-color cursor updates for client %s\n",
                     var_116->host);
              var_116->enableCursorShapeUpdates = TRUE;
              var_116->useRichCursorEncoding = TRUE;
              var_116->cursorWasChanged = TRUE;
            }
            break;
          case rfbEncodingPointerPos:
            if (!var_116->enableCursorPosUpdates) {
              rfbLog("Enabling cursor position updates for client %s\n",
                     var_116->host);
              var_116->enableCursorPosUpdates = TRUE;
              var_116->cursorWasMoved = TRUE;
              var_116->cursorX = -1;
              var_116->cursorY = -1;
            }
            break;
          case rfbEncodingLastRect:
            if (!var_116->enableLastRectEncoding) {
              rfbLog("Enabling LastRect protocol extension for client %s\n",
                     var_116->host);
              var_116->enableLastRectEncoding = TRUE;
            }
            break;
          case rfbEncodingFence:
            if (!var_116->enableFence) {
              rfbLog("Enabling Fence protocol extension for client %s\n",
                     var_116->host);
              var_116->enableFence = TRUE;
            }
            break;
          case rfbEncodingContinuousUpdates:
            if (!var_116->enableCU) {
              rfbLog("Enabling Continuous Updates protocol extension for client %s\n",
                     var_116->host);
              var_116->enableCU = TRUE;
            }
            break;
          case rfbEncodingNewFBSize:
            if (!var_116->enableDesktopSize) {
              if (!rfbAuthDisableRemoteResize) {
                rfbLog("Enabling Desktop Size protocol extension for client %s\n",
                       var_116->host);
                var_116->enableDesktopSize = TRUE;
              } else
                rfbLog("WARNING: Remote desktop resizing disabled per system policy.\n");
            }
            break;
          case rfbEncodingExtendedDesktopSize:
            if (!var_116->enableExtDesktopSize) {
              if (!rfbAuthDisableRemoteResize) {
                rfbLog("Enabling Extended Desktop Size protocol extension for client %s\n",
                       var_116->host);
                var_116->enableExtDesktopSize = TRUE;
              } else
                rfbLog("WARNING: Remote desktop resizing disabled per system policy.\n");
            }
            break;
          case rfbEncodingGII:
            if (!var_116->enableGII) {
              rfbLog("Enabling GII extension for client %s\n", var_116->host);
              var_116->enableGII = TRUE;
            }
            break;
          default:
            if (enc >= (CARD32)rfbEncodingCompressLevel0 &&
                enc <= (CARD32)rfbEncodingCompressLevel9) {
              var_116->zlibCompressLevel = enc & 0x0F;
              var_116->tightCompressLevel = enc & 0x0F;
              if (var_116->preferredEncoding == rfbEncodingTight)
                var_85 = TRUE;
              else
                rfbLog("Using compression level %d for client %s\n",
                       var_116->tightCompressLevel, var_116->host);
              if (var_85 == -1) {
                if (var_116->tightCompressLevel >= 5) {
                  if (!InterframeOn(var_116)) {
                    rfbCloseClient(var_116);
                    return;
                  }
                } else
                  InterframeOff(var_116);
              }
            } else if (enc >= (CARD32)rfbEncodingSubsamp1X &&
                       enc <= (CARD32)rfbEncodingSubsampGray) {
              var_116->tightSubsampLevel = enc & 0xFF;
              rfbLog("Using JPEG subsampling %d for client %s\n",
                     var_116->tightSubsampLevel, var_116->host);
            } else if (enc >= (CARD32)rfbEncodingQualityLevel0 &&
                       enc <= (CARD32)rfbEncodingQualityLevel9) {
              var_116->tightQualityLevel = JPEG_QUAL[enc & 0x0F];
              var_116->tightSubsampLevel = JPEG_SUBSAMP[enc & 0x0F];
              var_116->imageQualityLevel = enc & 0x0F;
              if (var_116->preferredEncoding == rfbEncodingTight)
                rfbLog("Using JPEG subsampling %d, Q%d for client %s\n",
                       var_116->tightSubsampLevel, var_116->tightQualityLevel, var_116->host);
              else
                rfbLog("Using image quality level %d for client %s\n",
                       var_116->imageQualityLevel, var_116->host);
            } else if (enc >= (CARD32)rfbEncodingFineQualityLevel0 + 1 &&
                       enc <= (CARD32)rfbEncodingFineQualityLevel100) {
              var_116->tightQualityLevel = enc & 0xFF;
              rfbLog("Using JPEG quality %d for client %s\n",
                     var_116->tightQualityLevel, var_116->host);
            } else {
              rfbLog("rfbProcessClientNormalMessage: ignoring unknown encoding %d (%x)\n",
                     (int)enc, (int)enc);
            }
        }
      }

      if (var_116->preferredEncoding == -1)
        var_116->preferredEncoding = rfbEncodingTight;

      if (var_116->preferredEncoding == rfbEncodingTight && var_85)
        rfbLog("Using Tight compression level %d for client %s\n",
               rfbTightCompressLevel(var_116), var_116->host);

      if (var_116->enableCursorPosUpdates && !var_116->enableCursorShapeUpdates) {
        rfbLog("Disabling cursor position updates for client %s\n", var_116->host);
        var_116->enableCursorPosUpdates = FALSE;
      }

      if (var_116->enableFence && var_85) {
        if (!rfbSendFence(var_116, rfbFenceFlagRequest, 0, NULL))
          return;
      }

      if (var_116->enableCU && var_116->enableFence && var_85) {
        if (!rfbSendEndOfCU(var_116))
          return;
      }

      if (var_116->enableGII && var_85) {

        rfbGIIServerVersionMsg msg;

        msg.type = rfbGIIServer;


        msg.endianAndSubType = rfbGIIVersion | rfbGIIBE;
        msg.length = Swap16IfLE(sz_rfbGIIServerVersionMsg - 4);
        msg.maximumVersion = msg.minimumVersion = Swap16IfLE(1);

        if (WriteExact(var_116, (char *)&msg, sz_rfbGIIServerVersionMsg) < 0) {
          rfbLogPerror("rfbProcessClientNormalMessage: write");
          rfbCloseClient(var_116);
          return;
        }
      }

      return;
    }

    case rfbFramebufferUpdateRequest:
    {
      RegionRec tmpRegion;
      BoxRec box;

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbFramebufferUpdateRequestMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      box.x1 = Swap16IfLE(msg.fur.x);
      box.y1 = Swap16IfLE(msg.fur.y);
      box.x2 = box.x1 + Swap16IfLE(msg.fur.w);
      box.y2 = box.y1 + Swap16IfLE(msg.fur.h);
      SAFE_REGION_INIT(var_107, &tmpRegion, &box, 0);

      if (!msg.fur.incremental || !var_116->continuousUpdates)
        REGION_UNION(var_107, &var_116->requestedRegion, &var_116->requestedRegion,
                     &tmpRegion);

      if (!var_116->readyForSetColourMapEntries) {

        var_116->readyForSetColourMapEntries = TRUE;
        if (!var_116->format.trueColour) {
          if (!rfbSetClientColourMap(var_116, 0, 0)) {
            REGION_UNINIT(var_107, &tmpRegion);
            return;
          }
        }
      }

      if (!msg.fur.incremental) {
        REGION_UNION(var_107, &var_116->modifiedRegion, &var_116->modifiedRegion,
                     &tmpRegion);
        REGION_SUBTRACT(var_107, &var_116->copyRegion, &var_116->copyRegion, &tmpRegion);
        REGION_UNION(var_107, &var_116->ifRegion, &var_116->ifRegion, &tmpRegion);
        var_116->pendingExtDesktopResize = TRUE;
      }

      if (FB_UPDATE_PENDING(var_116) &&
          (!var_116->deferredUpdateScheduled || rfbDeferUpdateTime == 0 ||
           gettime() - var_116->deferredUpdateStart >=
           (double)rfbDeferUpdateTime)) {
        if (rfbSendFramebufferUpdate(var_116))
          var_116->deferredUpdateScheduled = FALSE;
      }

      REGION_UNINIT(var_107, &tmpRegion);
      return;
    }

    case rfbKeyEvent:

      var_116->rfbKeyEventsRcvd++;

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbKeyEventMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      if (!var_118 && !var_116->viewOnly)
        KeyEvent((KeySym)Swap32IfLE(msg.ke.key), msg.ke.down);

      return;

    case rfbPointerEvent:

      var_116->rfbPointerEventsRcvd++;

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbPointerEventMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      if (var_85 && (var_85 != var_116))
        return;

      if (msg.pe.buttonMask == 0)
        var_85 = NULL;
      else
        var_85 = var_116;

      if (!var_118 && !var_116->viewOnly) {
        var_116->cursorX = (int)Swap16IfLE(msg.pe.x);
        var_116->cursorY = (int)Swap16IfLE(msg.pe.y);
        PtrAddEvent(msg.pe.buttonMask, var_116->cursorX, var_116->cursorY, var_116);
      }
      return;

    case rfbClientCutText:
    {
      int var_86 = 0;

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbClientCutTextMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      msg.cct.length = Swap32IfLE(msg.cct.length);
      if (msg.cct.length > var_86) {
        rfbLog("Truncating %d-byte clipboard update to %d bytes.\n",
               msg.cct.length, var_86);
        var_86 = msg.cct.length - var_86;
        msg.cct.length = var_86;
      }

      if (msg.cct.length <= 0) return;
      str = (char *)malloc(msg.cct.length);
      if (str == NULL) {
        rfbLogPerror("rfbProcessClientNormalMessage: rfbClientCutText out of memory");
        rfbCloseClient(var_116);
        return;
      }

      if ((var_118 = ReadExact(var_116, str, msg.cct.length)) <= 0) {
        if (var_118 != 0)
          rfbLogPerror("rfbProcessClientNormalMessage: read");
        free(str);
        rfbCloseClient(var_116);
        return;
      }

      if (var_86 > 0) {
        if ((var_118 = SkipExact(var_116, var_86)) <= 0) {
          if (var_118 != 0)
            rfbLogPerror("rfbProcessClientNormalMessage: read");
          free(str);
          rfbCloseClient(var_116);
          return;
        }
      }


      if (!var_118 && !var_116->viewOnly && !rfbAuthDisableCBRecv) {
        vncClientCutText(str, msg.cct.length);
        if (var_86) rfbSetXCutText(str, msg.cct.length);
      }

      free(str);
      return;
    }

    case rfbEnableContinuousUpdates:
    {
      BoxRec box;

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbEnableContinuousUpdatesMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      if (!var_116->enableFence || !var_116->enableCU) {
        rfbLog("Ignoring request to enable continuous updates because the client does not\n");
        rfbLog("support the flow control extensions.\n");
        return;
      }

      box.x1 = Swap16IfLE(msg.ecu.x);
      box.y1 = Swap16IfLE(msg.ecu.y);
      box.x2 = box.x1 + Swap16IfLE(msg.ecu.w);
      box.y2 = box.y1 + Swap16IfLE(msg.ecu.h);
      SAFE_REGION_INIT(var_107, &var_116->cuRegion, &box, 0);

      var_116->continuousUpdates = msg.ecu.enable;
      if (var_116->continuousUpdates) {
        REGION_EMPTY(var_107, &var_116->requestedRegion);
        if (!rfbSendFramebufferUpdate(var_116))
          return;
      } else {
        if (!rfbSendEndOfCU(var_116))
          return;
      }

      rfbLog("Continuous updates %s\n",
             var_116->continuousUpdates ? "enabled" : "disabled");
      return;
    }

    case rfbFence:
    {
      CARD32 flags;
      char data[64];

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbFenceMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      flags = Swap32IfLE(msg.f.flags);

      if ((var_118 = ReadExact(var_116, data, msg.f.length)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      if (msg.f.length > sizeof(data))
        rfbLog("Ignoring fence.  Payload of %d bytes is too large.\n",
               msg.f.length);
      else
        HandleFence(var_116, flags, msg.f.length, data);
      return;
    }







    case rfbSetDesktopSize:
    {
      int i;
      struct struct_86 newScreens;
      rfbClientPtr cl2;
      int var_89 = var_116;
      char errMsg[256] = "\0";
      ScreenPtr var_107 = screenInfo.screens[0];

      if ((var_118 = ReadExact(var_116, ((char *)&msg) + 1, sz_rfbSetDesktopSizeMsg - 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }

      if (msg.sds.numScreens < 1)
        { if (!strlen(errMsg)) snprintf(errMsg, 256, "Desktop resize ERROR: ""Requested number of screens %d is invalid""\n", msg.sds.numScreens); var_89 = rfbEDSResultInvalid; };


      msg.sds.w = Swap16IfLE(msg.sds.w);
      msg.sds.h = Swap16IfLE(msg.sds.h);
      if (msg.sds.w < 1 || msg.sds.h < 1)
        { if (!strlen(errMsg)) snprintf(errMsg, 256, "Desktop resize ERROR: ""Requested framebuffer dimensions %dx%d are invalid""\n", msg.sds.w, msg.sds.h); var_89 = rfbEDSResultInvalid; };


      xorg_list_init(&newScreens);
      for (i = 0; i < msg.sds.numScreens; i++) {
        rfbScreenInfo *var_116 = rfbNewScreen(0, 0, 0, 0, 0, 0);

        if ((var_118 = ReadExact(var_116, (char *)&var_116->s, sizeof(rfbScreenDesc))) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; }
        var_116->s.id = Swap32IfLE(var_116->s.id);
        var_116->s.x = Swap16IfLE(var_116->s.x);
        var_116->s.y = Swap16IfLE(var_116->s.y);
        var_116->s.w = Swap16IfLE(var_116->s.w);
        var_116->s.h = Swap16IfLE(var_116->s.h);
        var_116->s.flags = Swap32IfLE(var_116->s.flags);
        if (var_116->s.w < 1 || var_116->s.h < 1)
          { if (!strlen(errMsg)) snprintf(errMsg, 256, "Desktop resize ERROR: ""Screen 0x%.8x requested dimensions %dx%d are invalid""\n", (unsigned int)var_116->s.id, var_116->s.w, var_116->s.h); var_89 = rfbEDSResultInvalid; };

        if (var_116->s.x >= msg.sds.w || var_116->s.y >= msg.sds.h ||
            var_116->s.x + var_116->s.w > msg.sds.w ||
            var_116->s.y + var_116->s.h > msg.sds.h)
          { if (!strlen(errMsg)) snprintf(errMsg, 256, "Desktop resize ERROR: ""Screen 0x%.8x requested geometry %dx%d+%d+%d exceeds requested framebuffer dimensions""\n", (unsigned int)var_116->s.id, var_116->s.w, var_116->s.h, var_116->s.x, var_116->s.y); var_89 = rfbEDSResultInvalid; };


        if (rfbFindScreenID(&newScreens, var_116->s.id)) {
          { if (!strlen(errMsg)) snprintf(errMsg, 256, "Desktop resize ERROR: ""Screen 0x%.8x duplicate ID""\n", (unsigned int)var_116->s.id); var_89 = rfbEDSResultInvalid; };
          free(var_116);
        } else
          rfbAddScreen(&newScreens, var_116);
      }

      if (var_116->viewOnly) {
        rfbLog("NOTICE: Ignoring remote desktop resize request from a view-only client.\n");
        var_89 = rfbEDSResultProhibited;
      } else if (var_89 == var_116) {
        var_89 = ResizeDesktop(var_107, var_116, msg.sds.w, msg.sds.h, &newScreens);
        if (var_89 == var_116)
          return;
      } else
        rfbLog(errMsg);

      rfbRemoveScreens(&newScreens);




      for (cl2 = var_115; cl2; cl2 = cl2->next) {
        if (cl2 == var_116) {
          cl2->pendingExtDesktopResize = TRUE;
          cl2->reason = rfbEDSReasonClient;
          cl2->result = var_89;
          rfbSendFramebufferUpdate(cl2);
          break;
        }
      }

      return;
    }

    case rfbGIIClient:
    {
      CARD8 endianAndSubType, littleEndian, subType;

      if ((var_118 = ReadExact(var_116, (char *)&endianAndSubType, 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
      littleEndian = (endianAndSubType & rfbGIIBE) ? 0 : 1;
      subType = endianAndSubType & ~rfbGIIBE;

      switch (subType) {

        case rfbGIIVersion:

          if ((var_118 = ReadExact(var_116, (char *)&msg.giicv.length, sz_rfbGIIClientVersionMsg - 2)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
          if (littleEndian != *(const char *)&rfbEndianTest) {
            msg.giicv.length = Swap16(msg.giicv.length);
            msg.giicv.version = Swap16(msg.giicv.version);
          }
          if (msg.giicv.length != sz_rfbGIIClientVersionMsg - 4 ||
              msg.giicv.version < 1) {
            rfbLog("ERROR: Malformed GII client version message\n");
            rfbCloseClient(var_116);
            return;
          }
          rfbLog("Client supports GII version %d\n", msg.giicv.version);
          break;

        case rfbGIIDeviceCreate:
        {
          int i;
          rfbDevInfo dev;
          rfbGIIDeviceCreatedMsg dcmsg;

          memset(&dev, 0, sizeof(dev));
          dcmsg.deviceOrigin = 0;

          if ((var_118 = ReadExact(var_116, (char *)&msg.giidc.length, sz_rfbGIIDeviceCreateMsg - 2)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
          if (littleEndian != *(const char *)&rfbEndianTest) {
            msg.giidc.length = Swap16(msg.giidc.length);
            msg.giidc.vendorID = Swap32(msg.giidc.vendorID);
            msg.giidc.productID = Swap32(msg.giidc.productID);
            msg.giidc.canGenerate = Swap32(msg.giidc.canGenerate);
            msg.giidc.numRegisters = Swap32(msg.giidc.numRegisters);
            msg.giidc.numValuators = Swap32(msg.giidc.numValuators);
            msg.giidc.numButtons = Swap32(msg.giidc.numButtons);
          }

          rfbLog("GII Device Create: %s\n", msg.giidc.deviceName);

          if (msg.giidc.length != sz_rfbGIIDeviceCreateMsg - 4 +
              msg.giidc.numValuators * sz_rfbGIIValuator) {
            rfbLog("ERROR: Malformed GII device create message\n");
            rfbCloseClient(var_116);
            return;
          }

          if (msg.giidc.numButtons > MAX_BUTTONS) {
            rfbLog("GII device create ERROR: %d buttons exceeds max of %d\n",
                   msg.giidc.numButtons, MAX_BUTTONS);
            if ((var_118 = SkipExact(var_116, msg.giidc.numValuators * sz_rfbGIIValuator)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: skip"); rfbCloseClient(var_116); return; };
            goto sendMessage;
          }
          if (msg.giidc.numValuators > MAX_VALUATORS) {
            rfbLog("GII device create ERROR: %d valuators exceeds max of %d\n",
                   msg.giidc.numValuators, MAX_VALUATORS);
            if ((var_118 = SkipExact(var_116, msg.giidc.numValuators * sz_rfbGIIValuator)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: skip"); rfbCloseClient(var_116); return; };
            goto sendMessage;
          }

          memcpy(&dev.name, msg.giidc.deviceName, 32);
          dev.numButtons = msg.giidc.numButtons;
          dev.numValuators = msg.giidc.numValuators;
          dev.eventMask = msg.giidc.canGenerate;
          dev.mode =
            (dev.eventMask & rfbGIIValuatorAbsoluteMask) ? Absolute : Relative;
          dev.productID = msg.giidc.productID;

          if (dev.mode == Relative) {
            rfbLog("GII device create ERROR: relative valuators not supported (yet)\n");
            if ((var_118 = SkipExact(var_116, msg.giidc.numValuators * sz_rfbGIIValuator)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: skip"); rfbCloseClient(var_116); return; };
            goto sendMessage;
          }

          for (i = 0; i < dev.numValuators; i++) {
            rfbGIIValuator *v = &dev.valuators[i];
            if ((var_118 = ReadExact(var_116, (char *)v, sz_rfbGIIValuator)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
            if (littleEndian != *(const char *)&rfbEndianTest) {
              v->index = Swap32(v->index);
              v->rangeMin = Swap32((CARD32)v->rangeMin);
              v->rangeCenter = Swap32((CARD32)v->rangeCenter);
              v->rangeMax = Swap32((CARD32)v->rangeMax);
              v->siUnit = Swap32(v->siUnit);
              v->siAdd = Swap32((CARD32)v->siAdd);
              v->siMul = Swap32((CARD32)v->siMul);
              v->siDiv = Swap32((CARD32)v->siDiv);
              v->siShift = Swap32((CARD32)v->siShift);
            }

          }

          for (i = 0; i < var_116->numDevices; i++) {
            if (!strcmp(dev.name, var_116->devices[i].name)) {
              rfbLog("Device \'%s\' already exists with GII device ID %d\n",
                     dev.name, i + 1);
              dcmsg.deviceOrigin = Swap32IfLE(i + 1);
              goto sendMessage;
            }
          }

          if (var_89 || AddExtInputDevice(&dev)) {
            memcpy(&var_116->devices[var_116->numDevices], &dev, sizeof(dev));
            var_116->numDevices++;
            dcmsg.deviceOrigin = Swap32IfLE(var_116->numDevices);
          }
          rfbLog("GII device ID = %d\n", var_116->numDevices);

          sendMessage:

          dcmsg.type = rfbGIIServer;


          dcmsg.endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE;
          dcmsg.length = Swap16IfLE(sz_rfbGIIDeviceCreatedMsg - 4);

          if (WriteExact(var_116, (char *)&dcmsg, sz_rfbGIIDeviceCreatedMsg) < 0) {
            rfbLogPerror("rfbProcessClientNormalMessage: write");
            rfbCloseClient(var_116);
            return;
          }

          break;
        }

        case rfbGIIDeviceDestroy:

          if ((var_118 = ReadExact(var_116, (char *)&msg.giidd.length, sz_rfbGIIDeviceDestroyMsg - 2)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
          if (littleEndian != *(const char *)&rfbEndianTest) {
            msg.giidd.length = Swap16(msg.giidd.length);
            msg.giidd.deviceOrigin = Swap32(msg.giidd.deviceOrigin);
          }
          if (msg.giidd.length != sz_rfbGIIDeviceDestroyMsg - 4) {
            rfbLog("ERROR: Malformed GII device create message\n");
            rfbCloseClient(var_116);
            return;
          }

          RemoveExtInputDevice(var_116, msg.giidd.deviceOrigin - 1);

          break;

        case rfbGIIEvent:
        {
          CARD16 length;

          if ((var_118 = ReadExact(var_116, (char *)&length, sizeof(CARD16))) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
          if (littleEndian != *(const char *)&rfbEndianTest)
            length = Swap16(length);

          while (length > 0) {
            CARD8 eventSize, eventType;

            if ((var_118 = ReadExact(var_116, (char *)&eventSize, 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
            if ((var_118 = ReadExact(var_116, (char *)&eventType, 1)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };

            switch (eventType) {

              case rfbGIIButtonPress:
              case rfbGIIButtonRelease:
              {
                rfbGIIButtonEvent b;
                rfbDevInfo *dev;

                if ((var_118 = ReadExact(var_116, (char *)&b.pad, sz_rfbGIIButtonEvent - 2)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
                if (littleEndian != *(const char *)&rfbEndianTest) {
                  b.deviceOrigin = Swap32(b.deviceOrigin);
                  b.buttonNumber = Swap32(b.buttonNumber);
                }
                if (eventSize != sz_rfbGIIButtonEvent || b.deviceOrigin <= 0 ||
                    b.buttonNumber < 1) {
                  rfbLog("ERROR: Malformed GII button event\n");
                  rfbCloseClient(var_116);
                  return;
                }
                if (eventSize > length) {
                  rfbLog("ERROR: Malformed GII event message\n");
                  rfbCloseClient(var_116);
                  return;
                }
                length -= eventSize;
                if (b.deviceOrigin < 1 || b.deviceOrigin > var_116->numDevices) {
                  rfbLog("ERROR: GII button event from non-existent device %d\n",
                         b.deviceOrigin);
                  rfbCloseClient(var_116);
                  return;
                }
                dev = &var_116->devices[b.deviceOrigin - 1];
                if ((eventType == rfbGIIButtonPress &&
                     (dev->eventMask & rfbGIIButtonPressMask) == 0) ||
                    (eventType == rfbGIIButtonRelease &&
                     (dev->eventMask & rfbGIIButtonReleaseMask) == 0)) {
                  rfbLog("ERROR: Device %d can't generate GII button events\n",
                         b.deviceOrigin);
                  rfbCloseClient(var_116);
                  return;
                }
                if (b.buttonNumber > dev->numButtons) {
                  rfbLog("ERROR: GII button %d event for device %d exceeds button count (%d)\n",
                         b.buttonNumber, b.deviceOrigin, dev->numButtons);
                  rfbCloseClient(var_116);
                  return;
                }






                ExtInputAddEvent(dev, eventType == rfbGIIButtonPress ?
                                 ButtonPress : ButtonRelease, b.buttonNumber);
                break;
              }

              case rfbGIIValuatorRelative:
              case rfbGIIValuatorAbsolute:
              {
                rfbGIIValuatorEvent v;
                int i;
                rfbDevInfo *dev;

                if ((var_118 = ReadExact(var_116, (char *)&v.pad, sz_rfbGIIValuatorEvent - 2)) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
                if (littleEndian != *(const char *)&rfbEndianTest) {
                  v.deviceOrigin = Swap32(v.deviceOrigin);
                  v.first = Swap32(v.first);
                  v.count = Swap32(v.count);
                }
                if (eventSize !=
                    sz_rfbGIIValuatorEvent + sizeof(int) * v.count) {
                  rfbLog("ERROR: Malformed GII valuator event\n");
                  rfbCloseClient(var_116);
                  return;
                }
                if (eventSize > length) {
                  rfbLog("ERROR: Malformed GII event message\n");
                  rfbCloseClient(var_116);
                  return;
                }
                length -= eventSize;
                if (v.deviceOrigin < 1 || v.deviceOrigin > var_116->numDevices) {
                  rfbLog("ERROR: GII valuator event from non-existent device %d\n",
                         v.deviceOrigin);
                  rfbCloseClient(var_116);
                  return;
                }
                dev = &var_116->devices[v.deviceOrigin - 1];
                if ((eventType == rfbGIIValuatorRelative &&
                     (dev->eventMask & rfbGIIValuatorRelativeMask) == 0) ||
                    (eventType == rfbGIIValuatorAbsolute &&
                     (dev->eventMask & rfbGIIValuatorAbsoluteMask) == 0)) {
                  rfbLog("ERROR: Device %d cannot generate GII valuator events\n",
                         v.deviceOrigin);
                  rfbCloseClient(var_116);
                  return;
                }
                if (v.first + v.count > dev->numValuators) {
                  rfbLog("ERROR: GII valuator event for device %d exceeds valuator count (%d)\n",
                         v.deviceOrigin, dev->numValuators);
                  rfbCloseClient(var_116);
                  return;
                }






                for (i = v.first; i < v.first + v.count; i++) {
                  if ((var_118 = ReadExact(var_116, (char *)&dev->values[i], sizeof(int))) <= 0) { if (var_118 != 0) rfbLogPerror("rfbProcessClientNormalMessage: read"); rfbCloseClient(var_116); return; };
                  if (littleEndian != *(const char *)&rfbEndianTest)
                    dev->values[i] = Swap32((CARD32)dev->values[i]);



                }



                if (v.count > 0) {
                  dev->valFirst = v.first;
                  dev->valCount = v.count;
                  dev->mode = eventType == rfbGIIValuatorAbsolute ?
                              Absolute : Relative;
                  ExtInputAddEvent(dev, MotionNotify, 0);
                }
                break;
              }
              default:
                rfbLog("ERROR: This server cannot handle GII event type %d\n",
                       eventType);
                rfbCloseClient(var_116);
                return;
            }
          }
          if (length != 0) {
            rfbLog("ERROR: Malformed GII event message\n");
            rfbCloseClient(var_116);
            return;
          }
          break;
        }
      }
      return;
    }

    default:

      rfbLog("rfbProcessClientNormalMessage: unknown message type %d\n",
             msg.type);
      rfbLog(" ... closing connection\n");
      rfbCloseClient(var_116);
      return;
  }
}







Bool fn_89(rfbClientPtr var_116)
{
  ScreenPtr var_107 = screenInfo.screens[0];
  int i;
  int nUpdateRegionRects;
  rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)updateBuf;
  RegionRec _updateRegion, *updateRegion = &_updateRegion, updateCopyRegion,
    idRegion;
  Bool var_107 = FALSE;
  rfbClientPtr cl2;
  int var_107, var_107;
  Bool var_107 = FALSE;
  Bool var_107 = FALSE;
  double var_107 = 0.0;

  TimerCancel(var_116->updateTimer);







  if (var_116->syncFence) return TRUE;

  if (var_116->state != RFB_NORMAL) return TRUE;

  if (var_107) {
    var_107 = gettime();
    if (var_107 < 0.) var_107 = var_107;
  }




  if (var_94 && rfbIsCongested(var_116)) {
    var_116->updateTimer = TimerSet(var_116->updateTimer, 0, 50, updateCallback, var_116);
    return TRUE;
  }





  rfbCorkSock(var_116->sock);

  if (var_116->pendingExtDesktopResize) {
    if (!rfbSendExtDesktopSize(var_116)) return FALSE;
    var_116->pendingExtDesktopResize = FALSE;
  }

  if (var_116->pendingDesktopResize) {
    if (!rfbSendDesktopSize(var_116)) return FALSE;
    var_116->pendingDesktopResize = FALSE;
  }

  if (rfbFB.blockUpdates) {
    rfbUncorkSock(var_116->sock);
    return TRUE;
  }






  if (var_116->enableCursorShapeUpdates) {
    if (rfbFB.cursorIsDrawn)
      rfbSpriteRemoveCursorAllDev(var_107);
    if (!rfbFB.cursorIsDrawn && var_116->cursorWasChanged)
      var_107 = TRUE;
  } else {
    if (!rfbFB.cursorIsDrawn)
      rfbSpriteRestoreCursorAllDev(var_107);
  }





  if (var_116->enableCursorPosUpdates && var_116->cursorWasMoved)
    var_107 = TRUE;







  REGION_SUBTRACT(var_107, &var_116->copyRegion, &var_116->copyRegion,
                  &var_116->modifiedRegion);

  REGION_INIT(var_107, updateRegion, NullBox, 0);
  REGION_UNION(var_107, updateRegion, &var_116->copyRegion, &var_116->modifiedRegion);

  if (var_116->continuousUpdates)
    REGION_UNION(var_107, &var_116->requestedRegion, &var_116->requestedRegion,
                 &var_116->cuRegion);

  REGION_INTERSECT(var_107, updateRegion, &var_116->requestedRegion, updateRegion);

  if (!REGION_NOTEMPTY(var_107, updateRegion) && !var_107 &&
      !var_107) {
    REGION_UNINIT(var_107, updateRegion);
    return TRUE;
  }

  REGION_INIT(var_107, &updateCopyRegion, NullBox, 0);
  REGION_INTERSECT(var_107, &updateCopyRegion, &var_116->copyRegion,
                   &var_116->requestedRegion);
  REGION_TRANSLATE(var_107, &var_116->requestedRegion, var_116->copyDX, var_116->copyDY);
  REGION_INTERSECT(var_107, &updateCopyRegion, &updateCopyRegion,
                   &var_116->requestedRegion);
  var_107 = var_116->copyDX;
  var_107 = var_116->copyDY;







  REGION_SUBTRACT(var_107, updateRegion, updateRegion, &updateCopyRegion);

  REGION_UNION(var_107, &var_116->modifiedRegion, &var_116->modifiedRegion,
               &var_116->copyRegion);
  REGION_SUBTRACT(var_107, &var_116->modifiedRegion, &var_116->modifiedRegion,
                  updateRegion);
  REGION_SUBTRACT(var_107, &var_116->modifiedRegion, &var_116->modifiedRegion,
                  &updateCopyRegion);

  REGION_EMPTY(var_107, &var_116->requestedRegion);
  REGION_EMPTY(var_107, &var_116->copyRegion);
  var_116->copyDX = 0;
  var_116->copyDY = 0;





  if (REGION_NUM_RECTS(updateRegion) > var_94) {
    RegionRec combinedUpdateRegion;
    REGION_INIT(var_107, &combinedUpdateRegion,
                REGION_EXTENTS(var_107, updateRegion), 1);
    REGION_UNINIT(var_107, updateRegion);
    REGION_INIT(var_107, updateRegion,
                REGION_EXTENTS(var_107, &combinedUpdateRegion), 1);
    REGION_UNINIT(var_107, &combinedUpdateRegion);
  }

  if ((updateRegion->extents.x2 > var_107->width ||
       updateRegion->extents.y2 > var_107->height) &&
      REGION_NUM_RECTS(updateRegion) > 0) {
    rfbLog("WARNING: Framebuffer update at %d,%d with dimensions %dx%d has been clipped to the screen boundaries\n",
           updateRegion->extents.x1, updateRegion->extents.y1,
           updateRegion->extents.x2 - updateRegion->extents.x1,
           updateRegion->extents.y2 - updateRegion->extents.y1);
    ClipToScreen(var_107, updateRegion);
  }

  if (var_116->compareFB) {
    if ((var_116->ifRegion.extents.x2 > var_107->width ||
         var_116->ifRegion.extents.y2 > var_107->height) &&
        REGION_NUM_RECTS(&var_116->ifRegion) > 0)
      ClipToScreen(var_107, &var_116->ifRegion);

    updateRegion = &var_116->ifRegion;
    var_107 = TRUE;
    if (var_107)
      REGION_INIT(var_107, &idRegion, NullBox, 0);
    for (i = 0; i < REGION_NUM_RECTS(&_updateRegion); i++) {
      int var_109 = REGION_RECTS(&_updateRegion)[i].x1;
      int var_109 = REGION_RECTS(&_updateRegion)[i].y1;
      int var_109 = REGION_RECTS(&_updateRegion)[i].x2 - var_109;
      int var_109 = REGION_RECTS(&_updateRegion)[i].y2 - var_109;
      int var_107 = rfbFB.paddedWidthInBytes;
      int var_107 = rfbServerFormat.bitsPerPixel / 8;
      char *src = &rfbFB.pfbMemory[var_109 * var_107 + var_109 * var_107];
      char *dst = &var_116->compareFB[var_109 * var_107 + var_109 * var_107];
      int row, col;
      int var_104 = var_102 == 0 ? var_109 : var_102;
      int var_105 = var_102 == 0 ? var_109 : var_102;

      for (row = 0; row < var_109; row += var_105) {
        for (col = 0; col < var_109; col += var_104) {

          Bool var_107 = FALSE;
          int var_107 = min(var_104, var_109 - col);
          int var_107 = min(var_105, var_109 - row);
          int var_107 = var_107;
          char *srcPtr = &src[row * var_107 + col * var_107];
          char *dstPtr = &dst[row * var_107 + col * var_107];

          while (var_107--) {
            if (var_116->firstCompare ||
                memcmp(srcPtr, dstPtr, var_107 * var_107)) {
              memcpy(dstPtr, srcPtr, var_107 * var_107);
              var_107 = TRUE;
            }
            srcPtr += var_107;
            dstPtr += var_107;
          }
          if (var_107 || var_107) {
            RegionRec tmpRegion;
            BoxRec box;
            box.x1 = var_109 + col;
            box.y1 = var_109 + row;
            box.x2 = box.x1 + var_107;
            box.y2 = box.y1 + var_107;

            REGION_INIT(var_107, &tmpRegion, &box, 1);
            if (!var_107 && var_107 &&
                !RECT_IN_REGION(var_107, &var_116->ifRegion, &box)) {
              int var_107 = var_107 - var_107 * var_107;

              dstPtr = &dst[row * var_107 + col * var_107];
              REGION_UNION(var_107, &idRegion, &idRegion, &tmpRegion);
              var_107 = var_107;

              while (var_107--) {
                char *endOfRow = &dstPtr[var_107 * var_107];
                while (dstPtr < endOfRow)
                  *dstPtr++ ^= 0xFF;
                dstPtr += var_107;
              }
            }
            REGION_UNION(var_107, &var_116->ifRegion, &var_116->ifRegion, &tmpRegion);
            REGION_UNINIT(var_107, &tmpRegion);
          }
          if (!var_107 && var_107) {
            var_107 += (double)(var_107 * var_107) / 1000000.;
            if (!var_107)
              var_107 += (double)(var_107 * var_107) / 1000000.;
          }
        }
      }
    }
    REGION_UNINIT(var_107, &_updateRegion);
    REGION_NULL(var_107, &_updateRegion);
    var_116->firstCompare = FALSE;

    if (REGION_NUM_RECTS(updateRegion) == 0) {
      BoxRec box;
      box.x1 = box.y1 = 0;
      box.x2 = box.y2 = 1;
      REGION_UNINIT(var_107, updateRegion);
      REGION_INIT(var_107, updateRegion, &box, 1);
    }
  }

  if (!rfbSendRTTPing(var_116))
    goto abort;

  var_116->rfbFramebufferUpdateMessagesSent++;

  if (var_116->preferredEncoding == rfbEncodingCoRRE) {
    nUpdateRegionRects = 0;

    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {
      int var_109 = REGION_RECTS(updateRegion)[i].x1;
      int var_109 = REGION_RECTS(updateRegion)[i].y1;
      int var_109 = REGION_RECTS(updateRegion)[i].x2 - var_109;
      int var_109 = REGION_RECTS(updateRegion)[i].y2 - var_109;
      nUpdateRegionRects += (((var_109 - 1) / var_116->correMaxWidth + 1) *
                             ((var_109 - 1) / var_116->correMaxHeight + 1));
    }
  } else if (var_116->preferredEncoding == rfbEncodingZlib) {
    nUpdateRegionRects = 0;

    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {
      int var_109 = REGION_RECTS(updateRegion)[i].x1;
      int var_109 = REGION_RECTS(updateRegion)[i].y1;
      int var_109 = REGION_RECTS(updateRegion)[i].x2 - var_109;
      int var_109 = REGION_RECTS(updateRegion)[i].y2 - var_109;
      nUpdateRegionRects += (((var_109 - 1) / (ZLIB_MAX_SIZE(var_109) / var_109)) + 1);
    }
  } else if (var_116->preferredEncoding == rfbEncodingTight) {
    nUpdateRegionRects = 0;

    for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {
      int var_109 = REGION_RECTS(updateRegion)[i].x1;
      int var_109 = REGION_RECTS(updateRegion)[i].y1;
      int var_109 = REGION_RECTS(updateRegion)[i].x2 - var_109;
      int var_109 = REGION_RECTS(updateRegion)[i].y2 - var_109;
      int var_118 = rfbNumCodedRectsTight(var_116, var_109, var_109, var_109, var_109);
      if (var_118 == 0) {
        nUpdateRegionRects = 0xFFFF;
        break;
      }
      nUpdateRegionRects += var_118;
    }
  } else {
    nUpdateRegionRects = REGION_NUM_RECTS(updateRegion);
  }

  fu->type = rfbFramebufferUpdate;
  if (nUpdateRegionRects != 0xFFFF) {
    fu->nRects = Swap16IfLE(REGION_NUM_RECTS(&updateCopyRegion) +
                            nUpdateRegionRects +
                            !!var_107 + !!var_107);
  } else {
    fu->nRects = 0xFFFF;
  }
  ublen = sz_rfbFramebufferUpdateMsg;

  var_116->captureEnable = TRUE;

  if (var_107) {
    var_116->cursorWasChanged = FALSE;
    if (!rfbSendCursorShape(var_116, var_107))
      goto abort;
  }

  if (var_107) {
    var_116->cursorWasMoved = FALSE;
    if (!rfbSendCursorPos(var_116, var_107))
      goto abort;
  }

  if (REGION_NOTEMPTY(var_107, &updateCopyRegion)) {
    if (!rfbSendCopyRegion(var_116, &updateCopyRegion, var_107, var_107))
      goto abort;
  }

  REGION_UNINIT(var_107, &updateCopyRegion);
  REGION_NULL(var_107, &updateCopyRegion);

  for (i = 0; i < REGION_NUM_RECTS(updateRegion); i++) {
    int var_109 = REGION_RECTS(updateRegion)[i].x1;
    int var_109 = REGION_RECTS(updateRegion)[i].y1;
    int var_109 = REGION_RECTS(updateRegion)[i].x2 - var_109;
    int var_109 = REGION_RECTS(updateRegion)[i].y2 - var_109;

    var_116->rfbRawBytesEquivalent += (sz_rfbFramebufferUpdateRectHeader +
                                 var_109 * (var_116->format.bitsPerPixel / 8) * var_109);

    if (var_107) var_107 += (double)var_109 * (double)var_109 / 1000000.;

    switch (var_116->preferredEncoding) {
      case rfbEncodingRaw:
        if (!rfbSendRectEncodingRaw(var_116, var_109, var_109, var_109, var_109))
          goto abort;
        break;
      case rfbEncodingRRE:
        if (!rfbSendRectEncodingRRE(var_116, var_109, var_109, var_109, var_109))
          goto abort;
        break;
      case rfbEncodingCoRRE:
        if (!rfbSendRectEncodingCoRRE(var_116, var_109, var_109, var_109, var_109))
          goto abort;
        break;
      case rfbEncodingHextile:
        if (!rfbSendRectEncodingHextile(var_116, var_109, var_109, var_109, var_109))
          goto abort;
        break;
      case rfbEncodingZlib:
        if (!rfbSendRectEncodingZlib(var_116, var_109, var_109, var_109, var_109))
          goto abort;
        break;
      case rfbEncodingZRLE:
      case rfbEncodingZYWRLE:
        if (!rfbSendRectEncodingZRLE(var_116, var_109, var_109, var_109, var_109))
          goto abort;
        break;
      case rfbEncodingTight:
        if (!rfbSendRectEncodingTight(var_116, var_109, var_109, var_109, var_109))
          goto abort;
        break;
    }
  }

  if (var_116->compareFB) {
    if (var_107) {
      for (i = 0; i < REGION_NUM_RECTS(&idRegion); i++) {
        int var_109 = REGION_RECTS(&idRegion)[i].x1;
        int var_109 = REGION_RECTS(&idRegion)[i].y1;
        int var_109 = REGION_RECTS(&idRegion)[i].x2 - var_109;
        int var_109 = REGION_RECTS(&idRegion)[i].y2 - var_109, var_107;
        int var_107 = rfbFB.paddedWidthInBytes;
        int var_107 = rfbServerFormat.bitsPerPixel / 8;
        char *src = &rfbFB.pfbMemory[var_109 * var_107 + var_109 * var_107];
        char *dst = &var_116->compareFB[var_109 * var_107 + var_109 * var_107];
        var_107 = var_109;
        while (var_107--) {
          memcpy(dst, src, var_109 * var_107);
          src += var_107;
          dst += var_107;
        }
      }
      REGION_UNINIT(var_107, &idRegion);
      REGION_NULL(var_107, &idRegion);
    }
    REGION_EMPTY(var_107, updateRegion);
  } else {
    REGION_UNINIT(var_107, updateRegion);
    REGION_NULL(var_107, updateRegion);
  }

  if (nUpdateRegionRects == 0xFFFF && !rfbSendLastRectMarker(var_116))
    goto abort;

  if (!rfbSendUpdateBuf(var_116))
    goto abort;

  var_116->captureEnable = FALSE;

  if (!rfbSendRTTPing(var_116))
    goto abort;

  if (var_107) {
    var_107 += gettime() - var_107;
    tElapsed = gettime() - var_107;
    var_116++;

    if (tElapsed > 5.) {
      rfbLog("%.2f updates/sec,  %.2f Mpixels/sec,  %.3f Mbits/sec\n",
             (double)var_116 / tElapsed, var_107 / tElapsed,
             (double)var_107 / 125000. / tElapsed);
      rfbLog("Time/update:  Encode = %.3f ms,  Other = %.3f ms\n",
             var_107 / (double)var_116 * 1000.,
             (tElapsed - var_107) / (double)var_116 * 1000.);
      if (var_116->compareFB) {
        rfbLog("Identical Mpixels/sec:  %.2f  (%f %%)\n",
               (double)var_107 / tElapsed, var_107 / var_107 * 100.0);
        var_107 = 0.;
      }
      var_107 = 0.;
      var_116 = 0;
      var_107 = 0.;
      var_107 = 0;
      var_107 = gettime();
    }
  }

  if (var_107 > 0.0 &&
      (!var_107 || REGION_NOTEMPTY(var_107, &var_116->alrEligibleRegion) ||
       var_116->firstUpdate)) {
    if (var_107)
      REGION_UNION(var_107, &var_116->alrRegion, &var_116->alrRegion,
                   &var_116->alrEligibleRegion);
    REGION_EMPTY(var_107, &var_116->alrEligibleRegion);
    var_116->alrTimer = TimerSet(var_116->alrTimer, 0,
                            (CARD32)(var_107 * 1000.0),
                            alrCallback, var_116);
  }

  rfbUncorkSock(var_116->sock);
  return TRUE;

  abort:
  if (!REGION_NIL(&updateCopyRegion))
    REGION_UNINIT(var_107, &updateCopyRegion);
  if (var_107 && !REGION_NIL(&idRegion))
    REGION_UNINIT(var_107, &idRegion);
  if (var_107) {

    for (cl2 = var_115; cl2; cl2 = cl2->next) {
      if (cl2 == var_116) {
        REGION_EMPTY(var_107, updateRegion);
        break;
      }
    }
  } else if (!REGION_NIL(&_updateRegion)) {
    REGION_UNINIT(var_107, &_updateRegion);
  }
  return FALSE;
}

static Bool fn_107(rfbClientPtr var_116, RegionPtr var_107, int var_107, int var_107)
{
  int nrects, nrectsInBand, x_inc, y_inc, thisRect, firstInNextBand;
  int var_109, var_109, var_109, var_109;
  rfbFramebufferUpdateRectHeader rect;
  rfbCopyRect cr;
  ScreenPtr var_107 = screenInfo.screens[0];

  nrects = REGION_NUM_RECTS(var_107);

  if (var_107 <= 0)
    x_inc = 1;
  else
    x_inc = -1;

  if (var_107 <= 0) {
    thisRect = 0;
    y_inc = 1;
  } else {
    thisRect = nrects - 1;
    y_inc = -1;
  }




  if (var_107 > 0.0 && var_107 &&
      REGION_NOTEMPTY(var_107, var_107)) {
    RegionRec tmpRegion;
    REGION_INIT(var_107, &tmpRegion, NullBox, 0);
    REGION_COPY(var_107, &tmpRegion, var_107);
    REGION_TRANSLATE(var_107, &tmpRegion, -var_107, -var_107);
    REGION_INTERSECT(var_107, &tmpRegion, &var_116->lossyRegion, &tmpRegion);
    if (REGION_NOTEMPTY(var_107, &tmpRegion)) {
      REGION_UNION(var_107, &var_116->lossyRegion, &var_116->lossyRegion, var_107);
      REGION_UNION(var_107, &var_116->alrEligibleRegion, &var_116->alrEligibleRegion,
                   var_107);
    }
    REGION_UNINIT(var_107, &tmpRegion);
  }

  if (var_107->extents.x2 > var_107->width || var_107->extents.y2 > var_107->height)
    rfbLog("WARNING: CopyRect dest at %d,%d with dimensions %dx%d exceeds screen boundaries\n",
           var_107->extents.x1, var_107->extents.y1,
           var_107->extents.x2 - var_107->extents.x1,
           var_107->extents.y2 - var_107->extents.y1);

  while (nrects > 0) {

    firstInNextBand = thisRect;
    nrectsInBand = 0;

    while ((nrects > 0) &&
           (REGION_RECTS(var_107)[firstInNextBand].y1 ==
            REGION_RECTS(var_107)[thisRect].y1)) {
      firstInNextBand += y_inc;
      nrects--;
      nrectsInBand++;
    }

    if (x_inc != y_inc)
      thisRect = firstInNextBand - y_inc;

    while (nrectsInBand > 0) {
      if ((ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect) >
          UPDATE_BUF_SIZE) {
        if (!rfbSendUpdateBuf(var_116))
          return FALSE;
      }

      var_109 = REGION_RECTS(var_107)[thisRect].x1;
      var_109 = REGION_RECTS(var_107)[thisRect].y1;
      var_109 = REGION_RECTS(var_107)[thisRect].x2 - var_109;
      var_109 = REGION_RECTS(var_107)[thisRect].y2 - var_109;

      if (var_116->compareFB) {
        int var_107 = rfbFB.paddedWidthInBytes;
        int var_107 = rfbServerFormat.bitsPerPixel / 8, var_107 = var_109;
        char *src = &rfbFB.pfbMemory[var_109 * var_107 + var_109 * var_107];
        char *dst = &var_116->compareFB[var_109 * var_107 + var_109 * var_107];
        while (var_107--) {
          memcpy(dst, src, var_109 * var_107);
          src += var_107;
          dst += var_107;
        }
        src = &rfbFB.pfbMemory[(var_109 - var_107) * var_107 + (var_109 - var_107) * var_107];
        dst = &var_116->compareFB[(var_109 - var_107) * var_107 + (var_109 - var_107) * var_107];
        var_107 = var_109;
        while (var_107--) {
          memcpy(dst, src, var_109 * var_107);
          src += var_107;
          dst += var_107;
        }
      }

      rect.r.x = Swap16IfLE(var_109);
      rect.r.y = Swap16IfLE(var_109);
      rect.r.w = Swap16IfLE(var_109);
      rect.r.h = Swap16IfLE(var_109);
      rect.encoding = Swap32IfLE(rfbEncodingCopyRect);

      memcpy(&updateBuf[ublen], (char *)&rect,
             sz_rfbFramebufferUpdateRectHeader);
      ublen += sz_rfbFramebufferUpdateRectHeader;

      cr.srcX = Swap16IfLE(var_109 - var_107);
      cr.srcY = Swap16IfLE(var_109 - var_107);

      memcpy(&updateBuf[ublen], (char *)&cr, sz_rfbCopyRect);
      ublen += sz_rfbCopyRect;

      var_116->rfbRectanglesSent[rfbEncodingCopyRect]++;
      var_116->rfbBytesSent[rfbEncodingCopyRect] +=
        sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect;

      thisRect += x_inc;
      nrectsInBand--;
    }

    thisRect = firstInNextBand;
  }

  return TRUE;
}






Bool fn_107(rfbClientPtr var_116, int var_109, int var_109, int var_109, int var_109)
{
  rfbFramebufferUpdateRectHeader rect;
  int nlines;
  int var_109 = var_109 * (var_116->format.bitsPerPixel / 8);
  char *fbptr =
    (var_116->fb + (rfbFB.paddedWidthInBytes * var_109) + (var_109 * (rfbFB.bitsPerPixel / 8)));


  if (ublen > 0) {
    if (!rfbSendUpdateBuf(var_116))
      return FALSE;
  }

  rect.r.x = Swap16IfLE(var_109);
  rect.r.y = Swap16IfLE(var_109);
  rect.r.w = Swap16IfLE(var_109);
  rect.r.h = Swap16IfLE(var_109);
  rect.encoding = Swap32IfLE(rfbEncodingRaw);

  memcpy(&updateBuf[ublen], (char *)&rect, sz_rfbFramebufferUpdateRectHeader);
  ublen += sz_rfbFramebufferUpdateRectHeader;

  var_116->rfbRectanglesSent[rfbEncodingRaw]++;
  var_116->rfbBytesSent[rfbEncodingRaw] +=
    sz_rfbFramebufferUpdateRectHeader + var_109 * var_109;

  nlines = (UPDATE_BUF_SIZE - ublen) / var_109;

  while (TRUE) {
    if (nlines > var_109)
      nlines = var_109;

    (*var_116->translateFn) (var_116->translateLookupTable, &rfbServerFormat,
                        &var_116->format, fbptr, &updateBuf[ublen],
                        rfbFB.paddedWidthInBytes, var_109, nlines);

    ublen += nlines * var_109;
    var_109 -= nlines;

    if (var_109 == 0)
      return TRUE;



    if (!rfbSendUpdateBuf(var_116))
      return FALSE;

    fbptr += (rfbFB.paddedWidthInBytes * nlines);

    nlines = (UPDATE_BUF_SIZE - ublen) / var_109;
    if (nlines == 0) {
      rfbLog("rfbSendRectEncodingRaw: send buffer too small for %d bytes per line\n",
             var_109);
      rfbCloseClient(var_116);
      return FALSE;
    }
  }
}

static Bool fn_109(rfbClientPtr var_116)
{
  rfbFramebufferUpdateRectHeader rect;

  if (ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {
    if (!rfbSendUpdateBuf(var_116))
      return FALSE;
  }

  rect.encoding = Swap32IfLE(rfbEncodingLastRect);
  rect.r.x = 0;
  rect.r.y = 0;
  rect.r.w = 0;
  rect.r.h = 0;

  memcpy(&updateBuf[ublen], (char *)&rect, sz_rfbFramebufferUpdateRectHeader);
  ublen += sz_rfbFramebufferUpdateRectHeader;

  var_116->rfbLastRectMarkersSent++;
  var_116->rfbLastRectBytesSent += sz_rfbFramebufferUpdateRectHeader;

  return TRUE;
}







Bool fn_109(rfbClientPtr var_116)
{

  if (ublen > 0 && WriteExact(var_116, updateBuf, ublen) < 0) {
    rfbLogPerror("rfbSendUpdateBuf: write");
    rfbCloseClient(var_116);
    return FALSE;
  }

  if (var_116->captureEnable && var_116->captureFD >= 0 && ublen > 0)
    WriteCapture(var_116->captureFD, updateBuf, ublen);

  ublen = 0;
  return TRUE;
}







Bool fn_110(rfbClientPtr var_116, int var_113, int var_113)
{
  char buf[sz_rfbSetColourMapEntriesMsg + 1536];
  rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;
  CARD16 *rgb = (CARD16 *)(&buf[sz_rfbSetColourMapEntriesMsg]);
  EntryPtr pent;
  int i, var_115;

  scme->type = rfbSetColourMapEntries;

  scme->firstColour = Swap16IfLE(var_113);
  scme->nColours = Swap16IfLE(var_113);

  var_115 = sz_rfbSetColourMapEntriesMsg;

  pent = (EntryPtr)&rfbInstalledColormap->red[var_113];
  for (i = 0; i < var_113; i++) {
    if (pent->fShared) {
      rgb[i * 3] = Swap16IfLE(pent->co.shco.red->color);
      rgb[i * 3 + 1] = Swap16IfLE(pent->co.shco.green->color);
      rgb[i * 3 + 2] = Swap16IfLE(pent->co.shco.blue->color);
    } else {
      rgb[i * 3] = Swap16IfLE(pent->co.local.red);
      rgb[i * 3 + 1] = Swap16IfLE(pent->co.local.green);
      rgb[i * 3 + 2] = Swap16IfLE(pent->co.local.blue);
    }
    pent++;
  }

  var_115 += var_113 * 3 * 2;

  if (WriteExact(var_116, buf, var_115) < 0) {
    rfbLogPerror("rfbSendSetColourMapEntries: write");
    rfbCloseClient(var_116);
    return FALSE;
  }

  if (var_116->captureFD >= 0)
    WriteCapture(var_116->captureFD, buf, var_115);

  return TRUE;
}






void fn_113(void)
{
  rfbClientPtr var_116, nextCl;
  rfbBellMsg b;

  for (var_116 = var_115; var_116; var_116 = nextCl) {
    nextCl = var_116->next;
    if (var_116->state != RFB_NORMAL)
      continue;
    b.type = rfbBell;
    if (WriteExact(var_116, (char *)&b, sz_rfbBellMsg) < 0) {
      rfbLogPerror("rfbSendBell: write");
      rfbCloseClient(var_116);
      continue;
    }
    if (var_116->captureFD >= 0)
      WriteCapture(var_116->captureFD, (char *)&b, sz_rfbBellMsg);
  }
}






void fn_114(char *str, int var_115)
{
  rfbClientPtr var_116, nextCl;
  rfbServerCutTextMsg sct;

  if (var_118 || rfbAuthDisableCBSend || !str || var_115 <= 0)
    return;

  for (var_116 = var_115; var_116; var_116 = nextCl) {
    nextCl = var_116->next;
    if (var_116->state != RFB_NORMAL || var_116->viewOnly)
      continue;
    if (var_116->cutTextLen == var_115 && var_116->cutText && !memcmp(var_116->cutText, str, var_115))
      continue;
    if (var_116->cutText)
      free(var_116->cutText);
    var_116->cutText = rfbAlloc(var_115);
    memcpy(var_116->cutText, str, var_115);
    var_116->cutTextLen = var_115;
    memset(&sct, 0, sz_rfbServerCutTextMsg);
    sct.type = rfbServerCutText;
    sct.length = Swap32IfLE(var_115);
    if (WriteExact(var_116, (char *)&sct, sz_rfbServerCutTextMsg) < 0) {
      rfbLogPerror("rfbSendServerCutText: write");
      rfbCloseClient(var_116);
      continue;
    }
    if (WriteExact(var_116, str, var_115) < 0) {
      rfbLogPerror("rfbSendServerCutText: write");
      rfbCloseClient(var_116);
      continue;
    }
    if (var_116->captureFD >= 0)
      WriteCapture(var_116->captureFD, str, var_115);
  }
  LogMessage(X_DEBUG, "Sent server clipboard: '%.*s%s' (%d bytes)\n",
             var_115 <= 20 ? var_115 : 20, str, var_115 <= 20 ? "" : "...", var_115);
}






Bool fn_115(rfbClientPtr var_116)
{
  rfbFramebufferUpdateRectHeader rh;
  rfbFramebufferUpdateMsg fu;

  if (!var_116->enableDesktopSize)
    return TRUE;

  memset(&fu, 0, sz_rfbFramebufferUpdateMsg);
  fu.type = rfbFramebufferUpdate;
  fu.nRects = Swap16IfLE(1);
  if (WriteExact(var_116, (char *)&fu, sz_rfbFramebufferUpdateMsg) < 0) {
    rfbLogPerror("rfbSendDesktopSize: write");
    rfbCloseClient(var_116);
    return FALSE;
  }

  rh.encoding = Swap32IfLE(rfbEncodingNewFBSize);
  rh.r.x = rh.r.y = 0;
  rh.r.w = Swap16IfLE(rfbFB.width);
  rh.r.h = Swap16IfLE(rfbFB.height);
  if (WriteExact(var_116, (char *)&rh, sz_rfbFramebufferUpdateRectHeader) < 0) {
    rfbLogPerror("rfbSendDesktopSize: write");
    rfbCloseClient(var_116);
    return FALSE;
  }

  return TRUE;
}







Bool fn_115(rfbClientPtr var_116)
{
  rfbFramebufferUpdateRectHeader rh;
  rfbFramebufferUpdateMsg fu;
  CARD8 numScreens[4] = { 0, 0, 0, 0 };
  rfbScreenInfo *var_116;
  BOOL var_116 = FALSE;

  if (!var_116->enableExtDesktopSize)
    return TRUE;

  if (!var_116->enableExtDesktopSize && var_116->result != var_116)
    return TRUE;

  memset(&fu, 0, sz_rfbFramebufferUpdateMsg);
  fu.type = rfbFramebufferUpdate;
  fu.nRects = Swap16IfLE(1);
  if (WriteExact(var_116, (char *)&fu, sz_rfbFramebufferUpdateMsg) < 0) {
    rfbLogPerror("rfbSendExtDesktopSize: write");
    rfbCloseClient(var_116);
    return FALSE;
  }




  rh.encoding = Swap32IfLE(rfbEncodingExtendedDesktopSize);
  rh.r.x = Swap16IfLE(var_116->reason);
  rh.r.y = Swap16IfLE(var_116->result);
  rh.r.w = Swap16IfLE(rfbFB.width);
  rh.r.h = Swap16IfLE(rfbFB.height);
  if (WriteExact(var_116, (char *)&rh, sz_rfbFramebufferUpdateRectHeader) < 0) {
    rfbLogPerror("rfbSendExtDesktopSize: write");
    rfbCloseClient(var_116);
    return FALSE;
  }

  xorg_list_for_each_entry(var_116, &rfbScreens, entry) {
    if (var_116->output->crtc && var_116->output->crtc->mode)
      numScreens[0]++;
  }
  if (numScreens[0] < 1) {
    numScreens[0] = 1;
    var_116 = TRUE;
  }

  if (WriteExact(var_116, (char *)numScreens, 4) < 0) {
    rfbLogPerror("rfbSendExtDesktopSize: write");
    rfbCloseClient(var_116);
    return FALSE;
  }

  if (var_116) {
    rfbScreenInfo var_116 = *xorg_list_first_entry(&rfbScreens, rfbScreenInfo,
                                                  entry);
    var_116.s.id = Swap32IfLE(var_116.s.id);
    var_116.s.x = var_116.s.y = 0;
    var_116.s.w = Swap16IfLE(rfbFB.width);
    var_116.s.h = Swap16IfLE(rfbFB.height);
    var_116.s.flags = Swap32IfLE(var_116.s.flags);
    if (WriteExact(var_116, (char *)&var_116.s, sz_rfbScreenDesc) < 0) {
      rfbLogPerror("rfbSendExtDesktopSize: write");
      rfbCloseClient(var_116);
      return FALSE;
    }
  } else {
    xorg_list_for_each_entry(var_116, &rfbScreens, entry) {
      rfbScreenInfo var_116 = *var_116;

      if (var_116.output->crtc && var_116.output->crtc->mode) {
        var_116.s.id = Swap32IfLE(var_116.s.id);
        var_116.s.x = Swap16IfLE(var_116.s.x);
        var_116.s.y = Swap16IfLE(var_116.s.y);
        var_116.s.w = Swap16IfLE(var_116.s.w);
        var_116.s.h = Swap16IfLE(var_116.s.h);
        var_116.s.flags = Swap32IfLE(var_116.s.flags);
        if (WriteExact(var_116, (char *)&var_116.s, sz_rfbScreenDesc) < 0) {
          rfbLogPerror("rfbSendExtDesktopSize: write");
          rfbCloseClient(var_116);
          return FALSE;
        }
      }
    }
  }

  return TRUE;
}

void fn_116(int var_118)
{
  if (write(var_118, &ptrAcceleration, 1) < 0)
    rfbLogPerror("rfbNewUDPConnection: write");
}

void fn_117(int var_118)
{
  int var_118;
  rfbClientToServerMsg msg;

  if ((var_118 = read(var_118, (char *)&msg, sizeof(msg))) <= 0) {
    if (var_118 < 0)
      rfbLogPerror("rfbProcessUDPInput: read");
    rfbDisconnectUDPSock();
    return;
  }

  switch (msg.type) {
    case rfbKeyEvent:
      if (var_118 != sz_rfbKeyEventMsg) {
        rfbLog("rfbProcessUDPInput: key event incorrect length\n");
        rfbDisconnectUDPSock();
        return;
      }
      if (!var_118)
        KeyEvent((KeySym)Swap32IfLE(msg.ke.key), msg.ke.down);
      break;

    case rfbPointerEvent:
      if (var_118 != sz_rfbPointerEventMsg) {
        rfbLog("rfbProcessUDPInput: ptr event incorrect length\n");
        rfbDisconnectUDPSock();
        return;
      }
      if (!var_118)
        PtrAddEvent(msg.pe.buttonMask, Swap16IfLE(msg.pe.x),
                    Swap16IfLE(msg.pe.y), 0);
      break;

    default:
      rfbLog("rfbProcessUDPInput: unknown message type %d\n", msg.type);
      rfbDisconnectUDPSock();
  }
}
