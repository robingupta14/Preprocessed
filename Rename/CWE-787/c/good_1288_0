







static char *lyp_ublock2urange[][2] = {
    {"BasicLatin", "[\\x{0000}-\\x{007F}]"},
    {"Latin-1Supplement", "[\\x{0080}-\\x{00FF}]"},
    {"LatinExtended-A", "[\\x{0100}-\\x{017F}]"},
    {"LatinExtended-B", "[\\x{0180}-\\x{024F}]"},
    {"IPAExtensions", "[\\x{0250}-\\x{02AF}]"},
    {"SpacingModifierLetters", "[\\x{02B0}-\\x{02FF}]"},
    {"CombiningDiacriticalMarks", "[\\x{0300}-\\x{036F}]"},
    {"Greek", "[\\x{0370}-\\x{03FF}]"},
    {"Cyrillic", "[\\x{0400}-\\x{04FF}]"},
    {"Armenian", "[\\x{0530}-\\x{058F}]"},
    {"Hebrew", "[\\x{0590}-\\x{05FF}]"},
    {"Arabic", "[\\x{0600}-\\x{06FF}]"},
    {"Syriac", "[\\x{0700}-\\x{074F}]"},
    {"Thaana", "[\\x{0780}-\\x{07BF}]"},
    {"Devanagari", "[\\x{0900}-\\x{097F}]"},
    {"Bengali", "[\\x{0980}-\\x{09FF}]"},
    {"Gurmukhi", "[\\x{0A00}-\\x{0A7F}]"},
    {"Gujarati", "[\\x{0A80}-\\x{0AFF}]"},
    {"Oriya", "[\\x{0B00}-\\x{0B7F}]"},
    {"Tamil", "[\\x{0B80}-\\x{0BFF}]"},
    {"Telugu", "[\\x{0C00}-\\x{0C7F}]"},
    {"Kannada", "[\\x{0C80}-\\x{0CFF}]"},
    {"Malayalam", "[\\x{0D00}-\\x{0D7F}]"},
    {"Sinhala", "[\\x{0D80}-\\x{0DFF}]"},
    {"Thai", "[\\x{0E00}-\\x{0E7F}]"},
    {"Lao", "[\\x{0E80}-\\x{0EFF}]"},
    {"Tibetan", "[\\x{0F00}-\\x{0FFF}]"},
    {"Myanmar", "[\\x{1000}-\\x{109F}]"},
    {"Georgian", "[\\x{10A0}-\\x{10FF}]"},
    {"HangulJamo", "[\\x{1100}-\\x{11FF}]"},
    {"Ethiopic", "[\\x{1200}-\\x{137F}]"},
    {"Cherokee", "[\\x{13A0}-\\x{13FF}]"},
    {"UnifiedCanadianAboriginalSyllabics", "[\\x{1400}-\\x{167F}]"},
    {"Ogham", "[\\x{1680}-\\x{169F}]"},
    {"Runic", "[\\x{16A0}-\\x{16FF}]"},
    {"Khmer", "[\\x{1780}-\\x{17FF}]"},
    {"Mongolian", "[\\x{1800}-\\x{18AF}]"},
    {"LatinExtendedAdditional", "[\\x{1E00}-\\x{1EFF}]"},
    {"GreekExtended", "[\\x{1F00}-\\x{1FFF}]"},
    {"GeneralPunctuation", "[\\x{2000}-\\x{206F}]"},
    {"SuperscriptsandSubscripts", "[\\x{2070}-\\x{209F}]"},
    {"CurrencySymbols", "[\\x{20A0}-\\x{20CF}]"},
    {"CombiningMarksforSymbols", "[\\x{20D0}-\\x{20FF}]"},
    {"LetterlikeSymbols", "[\\x{2100}-\\x{214F}]"},
    {"NumberForms", "[\\x{2150}-\\x{218F}]"},
    {"Arrows", "[\\x{2190}-\\x{21FF}]"},
    {"MathematicalOperators", "[\\x{2200}-\\x{22FF}]"},
    {"MiscellaneousTechnical", "[\\x{2300}-\\x{23FF}]"},
    {"ControlPictures", "[\\x{2400}-\\x{243F}]"},
    {"OpticalCharacterRecognition", "[\\x{2440}-\\x{245F}]"},
    {"EnclosedAlphanumerics", "[\\x{2460}-\\x{24FF}]"},
    {"BoxDrawing", "[\\x{2500}-\\x{257F}]"},
    {"BlockElements", "[\\x{2580}-\\x{259F}]"},
    {"GeometricShapes", "[\\x{25A0}-\\x{25FF}]"},
    {"MiscellaneousSymbols", "[\\x{2600}-\\x{26FF}]"},
    {"Dingbats", "[\\x{2700}-\\x{27BF}]"},
    {"BraillePatterns", "[\\x{2800}-\\x{28FF}]"},
    {"CJKRadicalsSupplement", "[\\x{2E80}-\\x{2EFF}]"},
    {"KangxiRadicals", "[\\x{2F00}-\\x{2FDF}]"},
    {"IdeographicDescriptionCharacters", "[\\x{2FF0}-\\x{2FFF}]"},
    {"CJKSymbolsandPunctuation", "[\\x{3000}-\\x{303F}]"},
    {"Hiragana", "[\\x{3040}-\\x{309F}]"},
    {"Katakana", "[\\x{30A0}-\\x{30FF}]"},
    {"Bopomofo", "[\\x{3100}-\\x{312F}]"},
    {"HangulCompatibilityJamo", "[\\x{3130}-\\x{318F}]"},
    {"Kanbun", "[\\x{3190}-\\x{319F}]"},
    {"BopomofoExtended", "[\\x{31A0}-\\x{31BF}]"},
    {"EnclosedCJKLettersandMonths", "[\\x{3200}-\\x{32FF}]"},
    {"CJKCompatibility", "[\\x{3300}-\\x{33FF}]"},
    {"CJKUnifiedIdeographsExtensionA", "[\\x{3400}-\\x{4DB5}]"},
    {"CJKUnifiedIdeographs", "[\\x{4E00}-\\x{9FFF}]"},
    {"YiSyllables", "[\\x{A000}-\\x{A48F}]"},
    {"YiRadicals", "[\\x{A490}-\\x{A4CF}]"},
    {"HangulSyllables", "[\\x{AC00}-\\x{D7A3}]"},
    {"PrivateUse", "[\\x{E000}-\\x{F8FF}]"},
    {"CJKCompatibilityIdeographs", "[\\x{F900}-\\x{FAFF}]"},
    {"AlphabeticPresentationForms", "[\\x{FB00}-\\x{FB4F}]"},
    {"ArabicPresentationForms-A", "[\\x{FB50}-\\x{FDFF}]"},
    {"CombiningHalfMarks", "[\\x{FE20}-\\x{FE2F}]"},
    {"CJKCompatibilityForms", "[\\x{FE30}-\\x{FE4F}]"},
    {"SmallFormVariants", "[\\x{FE50}-\\x{FE6F}]"},
    {"ArabicPresentationForms-B", "[\\x{FE70}-\\x{FEFE}]"},
    {"HalfwidthandFullwidthForms", "[\\x{FF00}-\\x{FFEF}]"},
    {NULL, NULL}
};

const char *ly_stmt_str[] = {
    [LY_STMT_UNKNOWN] = "",
    [LY_STMT_ARGUMENT] = "argument",
    [LY_STMT_BASE] = "base",
    [LY_STMT_BELONGSTO] = "belongs-to",
    [LY_STMT_CONTACT] = "contact",
    [LY_STMT_DEFAULT] = "default",
    [LY_STMT_DESCRIPTION] = "description",
    [LY_STMT_ERRTAG] = "error-app-tag",
    [LY_STMT_ERRMSG] = "error-message",
    [LY_STMT_KEY] = "key",
    [LY_STMT_NAMESPACE] = "namespace",
    [LY_STMT_ORGANIZATION] = "organization",
    [LY_STMT_PATH] = "path",
    [LY_STMT_PREFIX] = "prefix",
    [LY_STMT_PRESENCE] = "presence",
    [LY_STMT_REFERENCE] = "reference",
    [LY_STMT_REVISIONDATE] = "revision-date",
    [LY_STMT_UNITS] = "units",
    [LY_STMT_VALUE] = "value",
    [LY_STMT_VERSION] = "yang-version",
    [LY_STMT_MODIFIER] = "modifier",
    [LY_STMT_REQINSTANCE] = "require-instance",
    [LY_STMT_YINELEM] = "yin-element",
    [LY_STMT_CONFIG] = "config",
    [LY_STMT_MANDATORY] = "mandatory",
    [LY_STMT_ORDEREDBY] = "ordered-by",
    [LY_STMT_STATUS] = "status",
    [LY_STMT_DIGITS] = "fraction-digits",
    [LY_STMT_MAX] = "max-elements",
    [LY_STMT_MIN] = "min-elements",
    [LY_STMT_POSITION] = "position",
    [LY_STMT_UNIQUE] = "unique",
    [LY_STMT_MODULE] = "module",
    [LY_STMT_SUBMODULE] = "submodule",
    [LY_STMT_ACTION] = "action",
    [LY_STMT_ANYDATA] = "anydata",
    [LY_STMT_ANYXML] = "anyxml",
    [LY_STMT_CASE] = "case",
    [LY_STMT_CHOICE] = "choice",
    [LY_STMT_CONTAINER] = "container",
    [LY_STMT_GROUPING] = "grouping",
    [LY_STMT_INPUT] = "input",
    [LY_STMT_LEAF] = "leaf",
    [LY_STMT_LEAFLIST] = "leaf-list",
    [LY_STMT_LIST] = "list",
    [LY_STMT_NOTIFICATION] = "notification",
    [LY_STMT_OUTPUT] = "output",
    [LY_STMT_RPC] = "rpc",
    [LY_STMT_USES] = "uses",
    [LY_STMT_TYPEDEF] = "typedef",
    [LY_STMT_TYPE] = "type",
    [LY_STMT_BIT] = "bit",
    [LY_STMT_ENUM] = "enum",
    [LY_STMT_REFINE] = "refine",
    [LY_STMT_AUGMENT] = "augment",
    [LY_STMT_DEVIATE] = "deviate",
    [LY_STMT_DEVIATION] = "deviation",
    [LY_STMT_EXTENSION] = "extension",
    [LY_STMT_FEATURE] = "feature",
    [LY_STMT_IDENTITY] = "identity",
    [LY_STMT_IFFEATURE] = "if-feature",
    [LY_STMT_IMPORT] = "import",
    [LY_STMT_INCLUDE] = "include",
    [LY_STMT_LENGTH] = "length",
    [LY_STMT_MUST] = "must",
    [LY_STMT_PATTERN] = "pattern",
    [LY_STMT_RANGE] = "range",
    [LY_STMT_WHEN] = "when",
    [LY_STMT_REVISION] = "revision"
};

int
fn_0(struct struct_139 *node)
{
    assert(node);

    while (lys_parent(node)) {
        node = lys_parent(node);
        if (node->nodetype == LYS_ACTION) {
            break;
        }
    }

    if (node->nodetype & (LYS_RPC | LYS_ACTION)) {
        return 1;
    } else {
        return 0;
    }
}

int
fn_2(struct struct_131 *ctx, int var_67, const char *func)
{
    int var_6 = var_67 & LYD_OPT_TYPEMASK;


    if (var_67 & LYD_OPT_WHENAUTODEL) {
        if ((var_6 == LYD_OPT_EDIT) || (var_6 == LYD_OPT_NOTIF_FILTER)) {
            LOGERR(ctx, LY_EINVAL, "%s: Invalid options 0x%x (LYD_OPT_DATA_WHENAUTODEL can be used only with LYD_OPT_DATA or LYD_OPT_CONFIG)",
                   func, var_67);
            return 1;
        }
    }

    if (var_67 & (LYD_OPT_DATA_ADD_YANGLIB | LYD_OPT_DATA_NO_YANGLIB)) {
        if (var_6 != LYD_OPT_DATA) {
            LOGERR(ctx, LY_EINVAL, "%s: Invalid options 0x%x (LYD_OPT_DATA_*_YANGLIB can be used only with LYD_OPT_DATA)",
                   func, var_67);
            return 1;
        }
    }


    if (var_6 && !(var_6 && !(var_6 & (var_6 - 1)))) {
        LOGERR(ctx, LY_EINVAL, "%s: Invalid options 0x%x (multiple data type flags set).", func, var_67);
        return 1;
    }

    return 0;
}

int
fn_6(struct struct_131 *ctx, int var_11, size_t var_11, size_t *var_12, void **addr)
{
    struct struct_10 sb;
    long pagesize;
    size_t m;

    assert(var_11 >= 0);
    if (fstat(var_11, &sb) == -1) {
        LOGERR(ctx, LY_ESYS, "Failed to stat the file descriptor (%s) for the mmap().", strerror(errno));
        return 1;
    }
    if (!S_ISREG(sb.st_mode)) {
        LOGERR(ctx, LY_EINVAL, "File to mmap() is not a regular file.");
        return 1;
    }
    if (!sb.st_size) {
        *addr = NULL;
        return 0;
    }
    pagesize = sysconf(_SC_PAGESIZE);
    ++var_11;

    m = sb.st_size % pagesize;
    if (m && pagesize - m >= var_11) {

        *var_12 = sb.st_size + var_11;
        *addr = mmap(NULL, *var_12, PROT_READ | PROT_WRITE, MAP_PRIVATE, var_11, 0);
    } else {






        *var_12 = sb.st_size + pagesize;
        *addr = mmap(NULL, *var_12, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        *addr = mmap(*addr, sb.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, var_11, 0);
    }
    if (*addr == MAP_FAILED) {
        LOGERR(ctx, LY_ESYS, "mmap() failed (%s).", strerror(errno));
        return 1;
    }

    return 0;
}

int
fn_11(void *addr, size_t var_12)
{
    return munmap(addr, var_12);
}

int
fn_12(struct struct_138 *mod)
{
    void *reallocated;
    struct struct_137 *op;
    struct struct_67 **var_98;
    struct struct_17 *anyxml;
    int i;
    struct struct_131 *ctx = mod->ctx;

    reallocated = realloc(mod->ext, (mod->ext_size + 3) * sizeof *mod->ext);
    LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), var_126);
    mod->ext = reallocated;

    op = calloc(1, (sizeof(struct struct_137) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));
    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), var_126);
    mod->ext[mod->ext_size] = (struct struct_125 *)op;
    op->arg_value = lydict_insert(ctx, "operation", 9);
    op->def = &ctx->models.list[0]->extensions[0];
    op->ext_type = LYEXT_COMPLEX;
    op->module = op->parent = mod;
    op->parent_type = LYEXT_PAR_MODULE;
    op->substmt = ((struct struct_23 *)op->def->plugin)->substmt;
    op->nodetype = LYS_EXT;
    var_98 = (struct struct_67**)&op->content;
    *var_98 = calloc(1, sizeof(struct struct_67));
    LY_CHECK_ERR_RETURN(!*var_98, LOGMEM(ctx), var_126);
    (*var_98)->base = LY_TYPE_ENUM;
    (*var_98)->der = ly_types[LY_TYPE_ENUM];
    (*var_98)->parent = (struct struct_76 *)op;
    (*var_98)->info.enums.count = 5;
    (*var_98)->info.enums.enm = calloc(5, sizeof *(*var_98)->info.enums.enm);
    LY_CHECK_ERR_RETURN(!(*var_98)->info.enums.enm, LOGMEM(ctx), var_126);
    (*var_98)->info.enums.enm[0].value = 0;
    (*var_98)->info.enums.enm[0].name = lydict_insert(ctx, "merge", 5);
    (*var_98)->info.enums.enm[1].value = 1;
    (*var_98)->info.enums.enm[1].name = lydict_insert(ctx, "replace", 7);
    (*var_98)->info.enums.enm[2].value = 2;
    (*var_98)->info.enums.enm[2].name = lydict_insert(ctx, "create", 6);
    (*var_98)->info.enums.enm[3].value = 3;
    (*var_98)->info.enums.enm[3].name = lydict_insert(ctx, "delete", 6);
    (*var_98)->info.enums.enm[4].value = 4;
    (*var_98)->info.enums.enm[4].name = lydict_insert(ctx, "remove", 6);
    mod->ext_size++;


    op = calloc(1, (sizeof(struct struct_137) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));
    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), var_126);
    mod->ext[mod->ext_size] = (struct struct_125 *)op;
    op->arg_value = lydict_insert(ctx, "type", 4);
    op->def = &ctx->models.list[0]->extensions[0];
    op->ext_type = LYEXT_COMPLEX;
    op->module = op->parent = mod;
    op->parent_type = LYEXT_PAR_MODULE;
    op->substmt = ((struct struct_23 *)op->def->plugin)->substmt;
    op->nodetype = LYS_EXT;
    var_98 = (struct struct_67**)&op->content;
    *var_98 = calloc(1, sizeof(struct struct_67));
    LY_CHECK_ERR_RETURN(!*var_98, LOGMEM(ctx), var_126);
    (*var_98)->base = LY_TYPE_ENUM;
    (*var_98)->der = ly_types[LY_TYPE_ENUM];
    (*var_98)->parent = (struct struct_76 *)op;
    (*var_98)->info.enums.count = 2;
    (*var_98)->info.enums.enm = calloc(2, sizeof *(*var_98)->info.enums.enm);
    LY_CHECK_ERR_RETURN(!(*var_98)->info.enums.enm, LOGMEM(ctx), var_126);
    (*var_98)->info.enums.enm[0].value = 0;
    (*var_98)->info.enums.enm[0].name = lydict_insert(ctx, "subtree", 7);
    (*var_98)->info.enums.enm[1].value = 1;
    (*var_98)->info.enums.enm[1].name = lydict_insert(ctx, "xpath", 5);
    for (i = mod->features_size; i > 0; i--) {
        if (!strcmp(mod->features[i - 1].name, "xpath")) {
            (*var_98)->info.enums.enm[1].iffeature_size = 1;
            (*var_98)->info.enums.enm[1].iffeature = calloc(1, sizeof(struct struct_23));
            LY_CHECK_ERR_RETURN(!(*var_98)->info.enums.enm[1].iffeature, LOGMEM(ctx), var_126);
            (*var_98)->info.enums.enm[1].iffeature[0].expr = malloc(sizeof(uint8_t));
            LY_CHECK_ERR_RETURN(!(*var_98)->info.enums.enm[1].iffeature[0].expr, LOGMEM(ctx), var_126);
            *(*var_98)->info.enums.enm[1].iffeature[0].expr = 3;
            (*var_98)->info.enums.enm[1].iffeature[0].features = malloc(sizeof(struct struct_23*));
            LY_CHECK_ERR_RETURN(!(*var_98)->info.enums.enm[1].iffeature[0].features, LOGMEM(ctx), var_126);
            (*var_98)->info.enums.enm[1].iffeature[0].features[0] = &mod->features[i - 1];
            break;
        }
    }
    mod->ext_size++;


    op = calloc(1, (sizeof(struct struct_137) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));
    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), var_126);
    mod->ext[mod->ext_size] = (struct struct_125 *)op;
    op->arg_value = lydict_insert(ctx, "select", 6);
    op->def = &ctx->models.list[0]->extensions[0];
    op->ext_type = LYEXT_COMPLEX;
    op->module = op->parent = mod;
    op->parent_type = LYEXT_PAR_MODULE;
    op->substmt = ((struct struct_23 *)op->def->plugin)->substmt;
    op->nodetype = LYS_EXT;
    var_98 = (struct struct_67**)&op->content;
    *var_98 = calloc(1, sizeof(struct struct_67));
    LY_CHECK_ERR_RETURN(!*var_98, LOGMEM(ctx), var_126);
    (*var_98)->base = LY_TYPE_STRING;
    (*var_98)->der = ly_types[LY_TYPE_STRING];
    (*var_98)->parent = (struct struct_76 *)op;
    mod->ext_size++;


    anyxml = calloc(1, sizeof *anyxml);
    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), var_126);
    anyxml->nodetype = LYS_ANYXML;
    anyxml->prev = (struct struct_139 *)anyxml;
    anyxml->name = lydict_insert(ctx, "config", 0);
    anyxml->module = mod;
    anyxml->flags = LYS_CONFIG_W;
    if (lys_node_addchild(NULL, mod, (struct struct_139 *)anyxml, 0)) {
        return var_126;
    }

    return EXIT_SUCCESS;
}





static int
fn_23(const char *val_str, int64_t var_29, int64_t var_31, int var_41, int64_t *var_139, struct struct_137 *node)
{
    char *strptr;

    assert(node);

    if (!val_str || !val_str[0]) {
        goto error;
    }


    errno = 0;
    strptr = NULL;


    *var_139 = strtoll(val_str, &strptr, var_41);
    if (errno || (*var_139 < var_29) || (*var_139 > var_31)) {
        goto error;
    } else if (strptr && *strptr) {
        while (isspace(*strptr)) {
            ++strptr;
        }
        if (*strptr) {
            goto error;
        }
    }

    return EXIT_SUCCESS;

error:
    LOGVAL(node->schema->module->ctx, LYE_INVAL, LY_VLOG_LYD, node, val_str ? val_str : "", node->schema->name);
    return var_126;
}





static int
fn_29(const char *val_str, uint64_t var_31, int var_41, uint64_t *var_139, struct struct_137 *node)
{
    char *strptr;
    uint64_t var_64;

    assert(node);

    if (!val_str || !val_str[0]) {
        goto error;
    }

    errno = 0;
    strptr = NULL;
    var_64 = strtoull(val_str, &strptr, var_41);
    if (errno || (var_64 > var_31)) {
        goto error;
    } else if (strptr && *strptr) {
        while (isspace(*strptr)) {
            ++strptr;
        }
        if (*strptr) {
            goto error;
        }
    } else if (var_64 != 0 && val_str[0] == '-') {
        goto error;
    }

    *var_139 = var_64;
    return EXIT_SUCCESS;

error:
    LOGVAL(node->schema->module->ctx, LYE_INVAL, LY_VLOG_LYD, node, val_str ? val_str : "", node->schema->name);
    return var_126;
}





static int
fn_31(uint8_t var_39, uint64_t var_64, int64_t var_39, int64_t var_39, uint8_t var_39, struct struct_67 *var_98,
                      const char *val_str, struct struct_137 *node)
{
    struct struct_37 *restr = NULL;
    struct struct_43 *intv = NULL, *tmp_intv;
    struct struct_67 *cur_type;
    struct struct_131 *ctx = var_98->parent->module->ctx;
    int match;

    if (resolve_len_ran_interval(ctx, NULL, var_98, &intv)) {

        LOGINT(ctx);
        return var_126;
    }
    if (!intv) {
        return EXIT_SUCCESS;
    }


    tmp_intv = intv;
    cur_type = intv->type;
    do {
        match = 0;
        for (; tmp_intv && (tmp_intv->type == cur_type); tmp_intv = tmp_intv->next) {
            if (match) {

                continue;
            }

            if (((var_39 == 0) && (var_64 < tmp_intv->value.uval.min))
                    || ((var_39 == 1) && (var_39 < tmp_intv->value.sval.min))
                    || ((var_39 == 2) && (dec64cmp(var_39, var_39, tmp_intv->value.fval.min, cur_type->info.dec64.dig) < 0))) {
                break;
            }

            if (((var_39 == 0) && (var_64 >= tmp_intv->value.uval.min) && (var_64 <= tmp_intv->value.uval.max))
                    || ((var_39 == 1) && (var_39 >= tmp_intv->value.sval.min) && (var_39 <= tmp_intv->value.sval.max))
                    || ((var_39 == 2) && (dec64cmp(var_39, var_39, tmp_intv->value.fval.min, cur_type->info.dec64.dig) > -1)
                    && (dec64cmp(var_39, var_39, tmp_intv->value.fval.max, cur_type->info.dec64.dig) < 1))) {
                match = 1;
            }
        }

        if (!match) {
            break;
        } else if (tmp_intv) {
            cur_type = tmp_intv->type;
        }
    } while (tmp_intv);

    while (intv) {
        tmp_intv = intv->next;
        free(intv);
        intv = tmp_intv;
    }

    if (!match) {
        switch (cur_type->base) {
        case LY_TYPE_BINARY:
            restr = cur_type->info.binary.length;
            break;
        case LY_TYPE_DEC64:
            restr = cur_type->info.dec64.range;
            break;
        case LY_TYPE_INT8:
        case LY_TYPE_INT16:
        case LY_TYPE_INT32:
        case LY_TYPE_INT64:
        case LY_TYPE_UINT8:
        case LY_TYPE_UINT16:
        case LY_TYPE_UINT32:
        case LY_TYPE_UINT64:
            restr = cur_type->info.num.range;
            break;
        case LY_TYPE_STRING:
            restr = cur_type->info.str.length;
            break;
        default:
            LOGINT(ctx);
            return var_126;
        }

        LOGVAL(ctx, LYE_NOCONSTR, LY_VLOG_LYD, node, (val_str ? val_str : ""), restr ? restr->expr : "");
        if (restr && restr->emsg) {
            ly_vlog_str(ctx, LY_VLOG_PREV, restr->emsg);
        }
        if (restr && restr->eapptag) {
            ly_err_last_set_apptag(ctx, restr->eapptag);
        }
        return var_126;
    }
    return EXIT_SUCCESS;
}


static int
fn_39(struct struct_131 *ctx, const char *val_str, struct struct_67 *var_98, struct struct_137 *node)
{
    int rc;
    unsigned int i;

    pcre *precomp;


    assert(ctx && (var_98->base == LY_TYPE_STRING));

    if (!val_str) {
        val_str = "";
    }

    if (var_98->der && validate_pattern(ctx, val_str, &var_98->der->type, node)) {
        return var_126;
    }

    for (i = 0; i < var_98->info.str.pat_count; ++i) {




        if (lyp_check_pattern(ctx, &var_98->info.str.patterns[i].expr[1], &precomp)) {
            return var_126;
        }
        rc = pcre_exec(precomp, NULL, val_str, strlen(val_str), 0, 0, NULL, 0);
        free(precomp);

        if ((rc && var_98->info.str.patterns[i].expr[0] == 0x06) || (!rc && var_98->info.str.patterns[i].expr[0] == 0x15)) {
            LOGVAL(ctx, LYE_NOCONSTR, LY_VLOG_LYD, node, val_str, &var_98->info.str.patterns[i].expr[1]);
            if (var_98->info.str.patterns[i].emsg) {
                ly_vlog_str(ctx, LY_VLOG_PREV, var_98->info.str.patterns[i].emsg);
            }
            if (var_98->info.str.patterns[i].eapptag) {
                ly_err_last_set_apptag(ctx, var_98->info.str.patterns[i].eapptag);
            }
            return var_126;
        }
    }

    return EXIT_SUCCESS;
}

static void
fn_40(const char *str_num, const char **num_end, LY_DATA_TYPE var_41)
{
    if (!isdigit(str_num[0]) && (str_num[0] != '-') && (str_num[0] != '+')) {
        *num_end = str_num;
        return;
    }

    if ((str_num[0] == '-') || (str_num[0] == '+')) {
        ++str_num;
    }

    while (isdigit(str_num[0])) {
        ++str_num;
    }

    if ((var_41 != LY_TYPE_DEC64) || (str_num[0] != '.') || !isdigit(str_num[1])) {
        *num_end = str_num;
        return;
    }

    ++str_num;
    while (isdigit(str_num[0])) {
        ++str_num;
    }

    *num_end = str_num;
}

int
fn_41(struct struct_131 *ctx, const char *var_44, struct struct_67 *var_98)
{
    struct struct_43 *intv = NULL, *tmp_intv;
    const char *c = var_44, *tail;
    int var_139 = var_126, var_44 = 1;

    assert(var_44);

lengthpart:

    while (isspace(*c)) {
        c++;
    }


    if (!strncmp(c, "max", 3)) {
max:
        c += 3;
        while (isspace(*c)) {
            c++;
        }
        if (*c != '\0') {
            goto error;
        }

        goto syntax_ok;

    } else if (!strncmp(c, "min", 3)) {
        if (!var_44) {

            goto error;
        } else {
            var_44 = 0;
        }
        c += 3;
        while (isspace(*c)) {
            c++;
        }

        if (*c == '|') {
            c++;

            goto lengthpart;
        } else if (*c == '\0') {
            goto syntax_ok;
        } else if (!strncmp(c, "..", 2)) {
upper:
            c += 2;
            while (isspace(*c)) {
                c++;
            }
            if (*c == '\0') {
                goto error;
            }


            if (!strncmp(c, "max", 3)) {
                goto max;
            }

            check_number(c, &tail, var_98->base);
            if (c == tail) {
                goto error;
            }
            c = tail;
            while (isspace(*c)) {
                c++;
            }
            if (*c == '\0') {
                goto syntax_ok;
            } else if (*c == '|') {
                c++;

                goto lengthpart;
            } else {
                goto error;
            }
        } else {
            goto error;
        }

    } else if (isdigit(*c) || (*c == '-') || (*c == '+')) {

        check_number(c, &tail, var_98->base);
        if (c == tail) {
            goto error;
        }
        c = tail;

        while (isspace(*c)) {
            c++;
        }

        if (*c == '|') {
            c++;

            goto lengthpart;
        } else if (*c == '\0') {
            goto syntax_ok;
        } else if (!strncmp(c, "..", 2)) {
            goto upper;
        }

    } else {
        goto error;
    }

syntax_ok:
    if (resolve_len_ran_interval(ctx, var_44, var_98, &intv)) {
        goto error;
    }

    var_139 = EXIT_SUCCESS;

error:
    while (intv) {
        tmp_intv = intv->next;
        free(intv);
        intv = tmp_intv;
    }

    return var_139;
}

int
fn_44(struct struct_131 *ctx, const char *pattern, pcre **pcre_precomp)
{
    int idx, idx2, start, end, err_offset, count;
    char *perl_regex, *ptr;
    const char *err_msg, *orig_ptr;
    pcre *precomp;

    for (count = 0, ptr = strchr(pattern, '$'); ptr; ++count, ptr = strchr(ptr + 1, '$'));

    perl_regex = malloc((strlen(pattern) + 4 + count) * sizeof(char));
    LY_CHECK_ERR_RETURN(!perl_regex, LOGMEM(ctx), var_126);
    perl_regex[0] = '\0';

    ptr = perl_regex;

    if (strncmp(pattern + strlen(pattern) - 2, ".*", 2)) {

        ptr[0] = '(';
        ++ptr;
    }

    for (orig_ptr = pattern; orig_ptr[0]; ++orig_ptr) {
        if (orig_ptr[0] == '$') {
            ptr += sprintf(ptr, "\\$");
        } else {
            ptr[0] = orig_ptr[0];
            ++ptr;
        }
    }

    if (strncmp(pattern + strlen(pattern) - 2, ".*", 2)) {
        ptr += sprintf(ptr, ")$");
    } else {
        ptr[0] = '\0';
        ++ptr;
    }


    while ((ptr = strstr(perl_regex, "\\p{Is"))) {
        start = ptr - perl_regex;

        ptr = strchr(ptr, '}');
        if (!ptr) {
            LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + start + 2, "unterminated character property");
            free(perl_regex);
            return var_126;
        }

        end = (ptr - perl_regex) + 1;


        if (end - start < 19) {
            perl_regex = ly_realloc(perl_regex, strlen(perl_regex) + (19 - (end - start)) + 1);
            LY_CHECK_ERR_RETURN(!perl_regex, LOGMEM(ctx); free(perl_regex), var_126);
        }


        for (idx = 0; lyp_ublock2urange[idx][0]; ++idx) {
            if (!strncmp(perl_regex + start + 5, lyp_ublock2urange[idx][0], strlen(lyp_ublock2urange[idx][0]))) {
                break;
            }
        }
        if (!lyp_ublock2urange[idx][0]) {
            LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + start + 5, "unknown block name");
            free(perl_regex);
            return var_126;
        }


        for (idx2 = 0, count = 0; idx2 < start; ++idx2) {
            if ((perl_regex[idx2] == '[') && (!idx2 || (perl_regex[idx2 - 1] != '\\'))) {
                ++count;
            }
            if ((perl_regex[idx2] == ']') && (!idx2 || (perl_regex[idx2 - 1] != '\\'))) {
                --count;
            }
        }
        if (count) {

            memmove(perl_regex + start + 17, perl_regex + end, strlen(perl_regex + end) + 1);
            memcpy(perl_regex + start, lyp_ublock2urange[idx][1] + 1, 17);
        } else {
            memmove(perl_regex + start + 19, perl_regex + end, strlen(perl_regex + end) + 1);
            memcpy(perl_regex + start, lyp_ublock2urange[idx][1], 19);
        }
    }


    precomp = pcre_compile(perl_regex, PCRE_ANCHORED | PCRE_DOLLAR_ENDONLY | PCRE_NO_AUTO_CAPTURE,
                           &err_msg, &err_offset, NULL);
    if (!precomp) {
        LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + err_offset, err_msg);
        free(perl_regex);
        return var_126;
    }
    free(perl_regex);

    if (pcre_precomp) {
        *pcre_precomp = precomp;
    } else {
        free(precomp);
    }

    return EXIT_SUCCESS;
}

int
fn_45(struct struct_131 *ctx, const char *pattern, pcre** pcre_cmp, pcre_extra **pcre_std)
{
    const char *err_msg = NULL;

    if (lyp_check_pattern(ctx, pattern, pcre_cmp)) {
        return var_126;
    }

    if (pcre_std && pcre_cmp) {
        (*pcre_std) = pcre_study(*pcre_cmp, 0, &err_msg);
        if (err_msg) {
            LOGWRN(ctx, "Studying pattern \"%s\" failed (%s).", pattern, err_msg);
        }
    }

    return EXIT_SUCCESS;
}

static int
fn_46(struct struct_131 *ctx, int var_98, const char **var_131, void *data1, void *data2)
{
    const uint16_t var_52 = 511;
    char buf[var_52 + 1];
    struct struct_63 **var_68 = NULL;
    struct struct_51 *exp;
    const char *module_name, *cur_expr, *end;
    int i, j, count;
    int64_t num;
    uint64_t var_64;
    uint8_t c;



    switch (var_98) {
    case LY_TYPE_BITS:
        var_68 = (struct struct_63 **)data1;
        count = *((int *)data2);

        buf[0] = '\0';
        for (i = 0; i < count; i++) {
            if (!var_68[i]) {

                continue;
            }
            if (buf[0]) {
                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(var_68[i]->name) > var_52, LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", var_68[i]->name), -1);
                sprintf(buf + strlen(buf), " %s", var_68[i]->name);
            } else {
                LY_CHECK_ERR_RETURN(strlen(var_68[i]->name) > var_52, LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", var_68[i]->name), -1);
                strcpy(buf, var_68[i]->name);
            }
        }
        break;

    case LY_TYPE_IDENT:
        module_name = (const char *)data1;

        if (!strchr(*var_131, ':')) {
            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*var_131) > var_52, LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", *var_131), -1);
            sprintf(buf, "%s:%s", module_name, *var_131);
        } else {
            LY_CHECK_ERR_RETURN(strlen(*var_131) > var_52, LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", *var_131), -1);
            strcpy(buf, *var_131);
        }
        break;

    case LY_TYPE_INST:
        exp = lyxp_parse_expr(ctx, *var_131);
        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);

        module_name = NULL;
        count = 0;
        for (i = 0; (unsigned)i < exp->used; ++i) {
            cur_expr = &exp->expr[exp->expr_pos[i]];


            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {
                if (count + (cur_expr - end) > var_52) {
                    lyxp_expr_free(exp);
                    LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", end);
                    return -1;
                }
                strncpy(&buf[count], end, cur_expr - end);
                count += cur_expr - end;
            }

            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {

                ++end;
                j = end - cur_expr;

                if (!module_name || strncmp(cur_expr, module_name, j)) {

                    if (count + j > var_52) {
                        lyxp_expr_free(exp);
                        LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", cur_expr);
                        return -1;
                    }
                    strncpy(&buf[count], cur_expr, j);
                    count += j;
                }
                module_name = cur_expr;


                if (count + (exp->tok_len[i] - j) > var_52) {
                    lyxp_expr_free(exp);
                    LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", end);
                    return -1;
                }
                strncpy(&buf[count], end, exp->tok_len[i] - j);
                count += exp->tok_len[i] - j;
            } else {
                if (count + exp->tok_len[i] > var_52) {
                    lyxp_expr_free(exp);
                    LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", &exp->expr[exp->expr_pos[i]]);
                    return -1;
                }
                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);
                count += exp->tok_len[i];
            }
        }
        if (count > var_52) {
            LOGINT(ctx);
            lyxp_expr_free(exp);
            return -1;
        }
        buf[count] = '\0';

        lyxp_expr_free(exp);
        break;

    case LY_TYPE_DEC64:
        num = *((int64_t *)data1);
        c = *((uint8_t *)data2);
        if (num) {
            count = sprintf(buf, "%"PRId64" ", num);
            if ( (num > 0 && (count - 1) <= c)
                 || (count - 2) <= c ) {




                count = sprintf(buf, "%0*"PRId64" ", (num > 0) ? (c + 1) : (c + 2), num);
            }
            for (i = c, j = 1; i > 0 ; i--) {
                if (j && i > 1 && buf[count - 2] == '0') {

                    buf[count - 1] = '\0';
                } else {
                    j = 0;
                    buf[count - 1] = buf[count - 2];
                }
                count--;
            }
            buf[count - 1] = '.';
        } else {

            sprintf(buf, "0.0");
        }
        break;

    case LY_TYPE_INT8:
    case LY_TYPE_INT16:
    case LY_TYPE_INT32:
    case LY_TYPE_INT64:
        num = *((int64_t *)data1);
        sprintf(buf, "%"PRId64, num);
        break;

    case LY_TYPE_UINT8:
    case LY_TYPE_UINT16:
    case LY_TYPE_UINT32:
    case LY_TYPE_UINT64:
        var_64 = *((uint64_t *)data1);
        sprintf(buf, "%"PRIu64, var_64);
        break;

    default:

        return 0;
    }

    if (strcmp(buf, *var_131)) {
        lydict_remove(ctx, *var_131);
        *var_131 = lydict_insert(ctx, buf, 0);
        return 1;
    }

    return 0;


}

static const char *
fn_52(const char *var_131, const struct struct_66 *xml, struct struct_131 *ctx)
{
    const struct struct_55 *ns;
    const struct struct_138 *mod;
    char *str;

    do {
        LY_TREE_FOR((struct struct_55 *)xml->attr, ns) {
            if ((ns->type == LYXML_ATTR_NS) && !ns->prefix) {

                break;
            }
        }
        if (!ns) {
            xml = xml->parent;
        }
    } while (!ns && xml);

    if (!ns) {

        LOGINT(ctx);
        return NULL;
    }


    mod = ly_ctx_get_module_by_ns(ctx, ns->value, NULL, 1);
    if (!mod) {
        LOGINT(ctx);
        return NULL;
    }

    if (asprintf(&str, "%s:%s", mod->name, var_131) == -1) {
        LOGMEM(ctx);
        return NULL;
    }
    lydict_remove(ctx, var_131);

    return lydict_insert_zc(ctx, str);
}

struct struct_67 *
fn_55(struct struct_67 *var_98, const char **value_, struct struct_66 *xml,
                struct struct_56 *leaf, struct struct_68 *attr, struct struct_138 *local_mod,
                int var_64, int var_89, int var_64)
{
    struct struct_67 *var_139 = NULL, *t;
    struct struct_76 *tpdf;
    enum enumtype_61 prev_ilo;
    int c, len, var_123 = 0;
    unsigned int i, j;
    int64_t num;
    uint64_t var_64, uind, var_64 = 0;
    const char *ptr, *var_131 = *value_, *itemname, *old_val_str = NULL;
    struct struct_63 **var_68 = NULL;
    struct struct_69 *ident;
    lyd_val *val, old_val;
    LY_DATA_TYPE *val_type, old_val_type;
    uint8_t *val_flags, old_val_flags;
    struct struct_137 *contextnode;
    struct struct_131 *ctx = var_98->parent->module->ctx;

    assert(leaf || attr);

    if (leaf) {
        assert(!attr);
        if (!local_mod) {
            local_mod = leaf->schema->module;
        }
        val = &leaf->value;
        val_type = &leaf->value_type;
        val_flags = &leaf->value_flags;
        contextnode = (struct struct_137 *)leaf;
        itemname = leaf->schema->name;
    } else {
        assert(!leaf);
        if (!local_mod) {
            local_mod = attr->annotation->module;
        }
        val = &attr->value;
        val_type = &attr->value_type;
        val_flags = &attr->value_flags;
        contextnode = attr->parent;
        itemname = attr->name;
    }


    if (var_64) {
        old_val_str = lydict_insert(ctx, *value_, 0);
        lyd_free_value(*val, *val_type, *val_flags, var_98, old_val_str, &old_val, &old_val_type, &old_val_flags);
        *val_flags &= ~LY_VALUE_UNRES;
    }

    switch (var_98->base) {
    case LY_TYPE_BINARY:

        var_64 = 0;
        ptr = NULL;
        if (var_131) {

            for (uind = 0; isspace(var_131[uind]); ++uind);
            ptr = &var_131[uind];
            var_64 = strlen(ptr);
            while (var_64 && isspace(ptr[var_64 - 1])) {
                --var_64;
            }
            var_64 = var_64;
            for (uind = 0; uind < var_64; ++uind) {
                if (ptr[uind] == '\n') {
                    var_64--;
                } else if ((ptr[uind] < '/' && ptr[uind] != '+') ||
                    (ptr[uind] > '9' && ptr[uind] < 'A') ||
                    (ptr[uind] > 'Z' && ptr[uind] < 'a') || ptr[uind] > 'z') {
                    if (ptr[uind] == '=') {

                        if (uind == var_64 - 2 && ptr[uind + 1] == '=') {
                            var_123 = 2;
                            uind++;
                        } else if (uind == var_64 - 1) {
                            var_123 = 1;
                        }
                    }
                    if (!var_123) {

                        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYD, contextnode, ptr[uind], &ptr[uind]);
                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, "Invalid Base64 character.");
                        goto error;
                    }
                }
            }
        }

        if (var_64 & 3) {

            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131, itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131);
            }
            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, "Base64 encoded value length must be divisible by 4.");
            goto error;
        }


        len = ((var_64 / 4) * 3) - var_123;
        if (!var_64 && validate_length_range(0, len, 0, 0, 0, var_98, var_131, contextnode)) {
            goto error;
        }

        if (var_131 && (ptr != var_131 || ptr[var_64] != '\0')) {

            ptr = lydict_insert(ctx, ptr, var_64);
            lydict_remove(ctx, *value_);
            *value_ = ptr;
        }

        if (var_64) {

            val->binary = var_131;
            *val_type = LY_TYPE_BINARY;
        }
        break;

    case LY_TYPE_BITS:



        for (; !var_98->info.bits.count; var_98 = &var_98->der->type);

        if (var_131 || var_64) {

            var_68 = calloc(var_98->info.bits.count, sizeof *var_68);
            LY_CHECK_ERR_GOTO(!var_68, LOGMEM(ctx), error);
        }

        if (!var_131) {

            if (var_64) {

                val->bit = var_68;
                *val_type = LY_TYPE_BITS;
            }
            break;
        }

        c = 0;
        i = 0;
        while (var_131[c]) {

            while (isspace(var_131[c])) {
                c++;
            }
            if (!var_131[c]) {

                break;
            }


            for (len = 0; var_131[c] && !isspace(var_131[c]); c++, len++);


            c = c - len;


            for (var_123 = i = 0; i < var_98->info.bits.count; i++) {
                if (!strncmp(var_98->info.bits.bit[i].name, &var_131[c], len) && !var_98->info.bits.bit[i].name[len]) {

                    for (j = 0; !var_64 && (j < var_98->info.bits.bit[i].iffeature_size); j++) {
                        if (!resolve_iffeature(&var_98->info.bits.bit[i].iffeature[j])) {
                            if (leaf) {
                                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131, itemname);
                            } else {
                                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131);
                            }
                            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,
                                   "Bit \"%s\" is disabled by its %d. if-feature condition.",
                                   var_98->info.bits.bit[i].name, j + 1);
                            free(var_68);
                            goto error;
                        }
                    }

                    if (var_68[i]) {
                        if (leaf) {
                            LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131, itemname);
                        } else {
                            LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131);
                        }
                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, "Bit \"%s\" used multiple times.",
                               var_98->info.bits.bit[i].name);
                        free(var_68);
                        goto error;
                    }

                    var_68[i] = &var_98->info.bits.bit[i];


                    var_123 = 1;
                    break;
                }
            }

            if (!var_123) {

                if (leaf) {
                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131, itemname);
                } else {
                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131);
                }
                free(var_68);
                goto error;
            }
            c = c + len;
        }

        if (make_canonical(ctx, LY_TYPE_BITS, value_, var_68, &var_98->info.bits.count) == -1) {
            free(var_68);
            goto error;
        }

        if (var_64) {

            val->bit = var_68;
            *val_type = LY_TYPE_BITS;
        } else {
            free(var_68);
        }
        break;

    case LY_TYPE_BOOL:
        if (var_131 && !strcmp(var_131, "true")) {
            if (var_64) {
                val->bln = 1;
            }
        } else if (!var_131 || strcmp(var_131, "false")) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131 ? var_131 : "", itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131 ? var_131 : "");
            }
            goto error;
        } else {
            if (var_64) {
                val->bln = 0;
            }
        }

        if (var_64) {
            *val_type = LY_TYPE_BOOL;
        }
        break;

    case LY_TYPE_DEC64:
        if (!var_131 || !var_131[0]) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, "", itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, "");
            }
            goto error;
        }

        ptr = var_131;
        if (parse_range_dec64(&ptr, var_98->info.dec64.dig, &num) || ptr[0]) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131, itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131);
            }
            goto error;
        }

        if (!var_64 && validate_length_range(2, 0, 0, num, var_98->info.dec64.dig, var_98, var_131, contextnode)) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_DEC64, value_, &num, &var_98->info.dec64.dig) == -1) {
            goto error;
        }

        if (var_64) {

            val->dec64 = num;
            *val_type = LY_TYPE_DEC64;
        }
        break;

    case LY_TYPE_EMPTY:
        if (var_131 && var_131[0]) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131, itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131);
            }
            goto error;
        }

        if (var_64) {
            *val_type = LY_TYPE_EMPTY;
        }
        break;

    case LY_TYPE_ENUM:



        for (; !var_98->info.enums.count; var_98 = &var_98->der->type);


        for (i = var_123 = 0; i < var_98->info.enums.count; i++) {
            if (var_131 && !strcmp(var_131, var_98->info.enums.enm[i].name)) {

                for (j = 0; !var_64 && (j < var_98->info.enums.enm[i].iffeature_size); j++) {
                    if (!resolve_iffeature(&var_98->info.enums.enm[i].iffeature[j])) {
                        if (leaf) {
                            LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131, itemname);
                        } else {
                            LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131);
                        }
                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, "Enum \"%s\" is disabled by its %d. if-feature condition.",
                               var_131, j + 1);
                        goto error;
                    }
                }

                if (var_64) {
                    val->enm = &var_98->info.enums.enm[i];
                    *val_type = LY_TYPE_ENUM;
                }
                var_123 = 1;
                break;
            }
        }

        if (!var_123) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, var_131 ? var_131 : "", itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, var_131 ? var_131 : "");
            }
            goto error;
        }
        break;

    case LY_TYPE_IDENT:
        if (!var_131) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, "", itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, "");
            }
            goto error;
        }

        if (xml) {
            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);

            var_131 = transform_xml2json(ctx, var_131, xml, 0, 0);
            ly_ilo_restore(NULL, prev_ilo, NULL, 0);
            if (!var_131) {

                if (leaf) {
                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);
                } else {
                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, *value_);
                }
                goto error;
            }


            if (!strchr(var_131, ':') && xml->ns->prefix) {
                var_131 = ident_val_add_module_prefix(var_131, xml, ctx);
                if (!var_131) {
                    goto error;
                }
            }
        } else if (var_89) {
            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);


            var_131 = transform_schema2json(local_mod, var_131);
            ly_ilo_restore(NULL, prev_ilo, NULL, 0);
            if (!var_131) {

                var_131 = lydict_insert(ctx, *value_, 0);
            }
        } else {
            var_131 = lydict_insert(ctx, *value_, 0);
        }


        ident = resolve_identref(var_98, var_131, contextnode, local_mod, var_89);
        if (!ident) {
            lydict_remove(ctx, var_131);
            goto error;
        } else if (var_64) {

            val->ident = ident;
            *val_type = LY_TYPE_IDENT;
        }


        if (var_89) {
            var_98->parent->flags |= LYS_DFLTJSON;
        }

        if (make_canonical(ctx, LY_TYPE_IDENT, &var_131, (void*)lys_main_module(local_mod)->name, NULL) == -1) {
            lydict_remove(ctx, var_131);
            goto error;
        }


        lydict_remove(ctx, *value_);
        *value_ = var_131;
        break;

    case LY_TYPE_INST:
        if (!var_131) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, "", itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, "");
            }
            goto error;
        }

        if (xml) {
            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);

            var_131 = transform_xml2json(ctx, var_131, xml, 1, 1);
            ly_ilo_restore(NULL, prev_ilo, NULL, 0);
            if (!var_131) {

                if (leaf) {
                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);
                } else {
                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, *value_);
                }
                goto error;
            } else if (ly_strequal(var_131, *value_, 1)) {


                lydict_remove(ctx, var_131);
            }
        } else if (var_89) {

            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);



            var_131 = transform_schema2json(local_mod, var_131);
            if (!var_131) {

                var_131 = *value_;
            } else if (ly_strequal(var_131, *value_, 1)) {


                lydict_remove(ctx, var_131);
            }

            ly_ilo_restore(NULL, prev_ilo, NULL, 0);
        } else {
            if ((c = make_canonical(ctx, LY_TYPE_INST, &var_131, NULL, NULL))) {
                if (c == -1) {
                    goto error;
                }


                *value_ = var_131;
            }
        }

        if (var_64) {

            val->instance = NULL;
            *val_type = LY_TYPE_INST;
            *val_flags |= LY_VALUE_UNRES;
        }

        if (!ly_strequal(var_131, *value_, 1)) {

            lydict_remove(ctx, *value_);
            *value_ = var_131;


            if (var_89) {
                var_98->parent->flags |= LYS_DFLTJSON;
            }
        }
        break;

    case LY_TYPE_LEAFREF:
        if (!var_131) {
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, "", itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, "");
            }
            goto error;
        }



        t = lyp_parse_value(&var_98->info.lref.target->type, value_, xml, leaf, attr, NULL, var_64, var_89, var_64);
        var_131 = *value_;
        if (!t) {

            goto error;
        }

        if (var_64) {

            *val_flags |= LY_VALUE_UNRES;
        }

        var_98 = t;
        break;

    case LY_TYPE_STRING:
        if (!var_64 && validate_length_range(0, (var_131 ? ly_strlen_utf8(var_131) : 0), 0, 0, 0, var_98, var_131, contextnode)) {
            goto error;
        }

        if (!var_64 && validate_pattern(ctx, var_131, var_98, contextnode)) {
            goto error;
        }


        for (tpdf = var_98->der;
             tpdf->module && (strcmp(tpdf->name, "xpath1.0") || strcmp(tpdf->module->name, "ietf-yang-types"));
             tpdf = tpdf->type.der);
        if (tpdf->module && xml) {

            var_131 = transform_xml2json(ctx, var_131 ? var_131 : "", xml, 1, 1);
            if (!var_131) {

                if (leaf) {
                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);
                } else {
                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, *value_);
                }
                goto error;
            }

            if (!ly_strequal(var_131, *value_, 1)) {

                lydict_remove(ctx, *value_);
                *value_ = var_131;
            }
        }

        if (var_64) {

            val->string = var_131;
            *val_type = LY_TYPE_STRING;
        }
        break;

    case LY_TYPE_INT8:
        if (parse_int(var_131, __INT64_C(-128), __INT64_C(127), var_89 ? 0 : 10, &num, contextnode)
                || (!var_64 && validate_length_range(1, 0, num, 0, 0, var_98, var_131, contextnode))) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_INT8, value_, &num, NULL) == -1) {
            goto error;
        }

        if (var_64) {

            val->int8 = (int8_t)num;
            *val_type = LY_TYPE_INT8;
        }
        break;

    case LY_TYPE_INT16:
        if (parse_int(var_131, __INT64_C(-32768), __INT64_C(32767), var_89 ? 0 : 10, &num, contextnode)
                || (!var_64 && validate_length_range(1, 0, num, 0, 0, var_98, var_131, contextnode))) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_INT16, value_, &num, NULL) == -1) {
            goto error;
        }

        if (var_64) {

            val->int16 = (int16_t)num;
            *val_type = LY_TYPE_INT16;
        }
        break;

    case LY_TYPE_INT32:
        if (parse_int(var_131, __INT64_C(-2147483648), __INT64_C(2147483647), var_89 ? 0 : 10, &num, contextnode)
                || (!var_64 && validate_length_range(1, 0, num, 0, 0, var_98, var_131, contextnode))) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_INT32, value_, &num, NULL) == -1) {
            goto error;
        }

        if (var_64) {

            val->int32 = (int32_t)num;
            *val_type = LY_TYPE_INT32;
        }
        break;

    case LY_TYPE_INT64:
        if (parse_int(var_131, __INT64_C(-9223372036854775807) - __INT64_C(1), __INT64_C(9223372036854775807),
                      var_89 ? 0 : 10, &num, contextnode)
                || (!var_64 && validate_length_range(1, 0, num, 0, 0, var_98, var_131, contextnode))) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_INT64, value_, &num, NULL) == -1) {
            goto error;
        }

        if (var_64) {

            val->int64 = num;
            *val_type = LY_TYPE_INT64;
        }
        break;

    case LY_TYPE_UINT8:
        if (parse_uint(var_131, __UINT64_C(255), var_89 ? 0 : 10, &var_64, contextnode)
                || (!var_64 && validate_length_range(0, var_64, 0, 0, 0, var_98, var_131, contextnode))) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_UINT8, value_, &var_64, NULL) == -1) {
            goto error;
        }

        if (var_64) {

            val->uint8 = (uint8_t)var_64;
            *val_type = LY_TYPE_UINT8;
        }
        break;

    case LY_TYPE_UINT16:
        if (parse_uint(var_131, __UINT64_C(65535), var_89 ? 0 : 10, &var_64, contextnode)
                || (!var_64 && validate_length_range(0, var_64, 0, 0, 0, var_98, var_131, contextnode))) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_UINT16, value_, &var_64, NULL) == -1) {
            goto error;
        }

        if (var_64) {

            val->uint16 = (uint16_t)var_64;
            *val_type = LY_TYPE_UINT16;
        }
        break;

    case LY_TYPE_UINT32:
        if (parse_uint(var_131, __UINT64_C(4294967295), var_89 ? 0 : 10, &var_64, contextnode)
                || (!var_64 && validate_length_range(0, var_64, 0, 0, 0, var_98, var_131, contextnode))) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_UINT32, value_, &var_64, NULL) == -1) {
            goto error;
        }

        if (var_64) {

            val->uint32 = (uint32_t)var_64;
            *val_type = LY_TYPE_UINT32;
        }
        break;

    case LY_TYPE_UINT64:
        if (parse_uint(var_131, __UINT64_C(18446744073709551615), var_89 ? 0 : 10, &var_64, contextnode)
                || (!var_64 && validate_length_range(0, var_64, 0, 0, 0, var_98, var_131, contextnode))) {
            goto error;
        }

        if (make_canonical(ctx, LY_TYPE_UINT64, value_, &var_64, NULL) == -1) {
            goto error;
        }

        if (var_64) {

            val->uint64 = var_64;
            *val_type = LY_TYPE_UINT64;
        }
        break;

    case LY_TYPE_UNION:
        if (var_64) {

            memset(val, 0, sizeof(lyd_val));
            *val_type = LY_TYPE_UNION;
        }

        if (var_98->info.uni.has_ptr_type) {


            if (xml) {

                ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);
                val->string = transform_xml2json(ctx, var_131, xml, 1, 1);
                ly_ilo_restore(NULL, prev_ilo, NULL, 0);
                if (!val->string) {

                    val->string = lydict_insert(ctx, var_131, 0);
                }
            }
            break;
        }

        t = NULL;
        var_123 = 0;


        ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);

        while ((t = lyp_get_next_union_type(var_98, t, &var_123))) {
            var_123 = 0;
            var_139 = lyp_parse_value(t, value_, xml, leaf, attr, NULL, var_64, var_89, 0);
            if (var_139) {

                var_98 = var_139;
                break;
            }

            if (var_64) {

                lyd_free_value(*val, *val_type, *val_flags, t, *value_, NULL, NULL, NULL);
                memset(val, 0, sizeof(lyd_val));
            }
        }


        ly_ilo_restore(NULL, prev_ilo, NULL, 0);

        if (!t) {

            if (var_64) {
                *val_type = 0;
            }
            if (leaf) {
                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_ ? *value_ : "", itemname);
            } else {
                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, "<none>", itemname, *value_);
            }
            goto error;
        }
        break;

    default:
        LOGINT(ctx);
        goto error;
    }


    if (var_64 && var_98->der && var_98->der->module) {
        c = lytype_store(var_98->der->module, var_98->der->name, value_, val);
        if (c == -1) {
            goto error;
        } else if (!c) {
            *val_flags |= LY_VALUE_USER;
        }
    }


    if (var_64) {
        lyd_free_value(old_val, old_val_type, old_val_flags, var_98, old_val_str, NULL, NULL, NULL);
        lydict_remove(ctx, old_val_str);
    }
    return var_98;

error:

    if (var_64) {
        *val = old_val;
        *val_type = old_val_type;
        *val_flags = old_val_flags;
        lydict_remove(ctx, old_val_str);
    }
    return NULL;
}


struct struct_67 *
fn_64(struct struct_67 *var_98, struct struct_67 *prev_type, int *var_123)
{
    unsigned int i;
    struct struct_67 *var_139 = NULL;

    while (!var_98->info.uni.count) {
        assert(var_98->der);
        var_98 = &var_98->der->type;
    }

    for (i = 0; i < var_98->info.uni.count; ++i) {
        if (var_98->info.uni.types[i].base == LY_TYPE_UNION) {
            var_139 = lyp_get_next_union_type(&var_98->info.uni.types[i], prev_type, var_123);
            if (var_139) {
                break;
            }
            continue;
        }

        if (!prev_type || *var_123) {
            var_139 = &var_98->info.uni.types[i];
            break;
        }

        if (&var_98->info.uni.types[i] == prev_type) {
            *var_123 = 1;
        }
    }

    return var_139;
}


int
fn_65(struct struct_131 *ctx, struct struct_137 *parent, const char *module_ns, const char *module_name,
              const char *attr_name, const char *attr_value, struct struct_66 *xml, int var_67, struct struct_68 **var_139)
{
    const struct struct_138 *mod = NULL;
    const struct struct_139 *submod = NULL;
    struct struct_67 **var_98;
    struct struct_68 *dattr;
    int pos, i, j, k;


    if (module_ns) {
        mod = (struct struct_138 *)ly_ctx_get_module_by_ns(ctx, module_ns, NULL, 0);
    } else if (module_name) {
        mod = (struct struct_138 *)ly_ctx_get_module(ctx, module_name, NULL, 0);
    } else {
        LOGINT(ctx);
        return -1;
    }
    if (!mod) {
        return 1;
    }


    pos = -1;
    for (i = 0, j = 0; i < mod->ext_size; i = i + j + 1) {
        j = lys_ext_instance_presence(&ctx->models.list[0]->extensions[0], &mod->ext[i], mod->ext_size - i);
        if (j == -1) {
            break;
        }
        if (ly_strequal(mod->ext[i + j]->arg_value, attr_name, 0)) {
            pos = i + j;
            break;
        }
    }


    if (pos == -1) {
        for (k = 0; k < mod->inc_size; ++k) {
            submod = mod->inc[k].submodule;
            for (i = 0, j = 0; i < submod->ext_size; i = i + j + 1) {
                j = lys_ext_instance_presence(&ctx->models.list[0]->extensions[0], &submod->ext[i], submod->ext_size - i);
                if (j == -1) {
                    break;
                }
                if (ly_strequal(submod->ext[i + j]->arg_value, attr_name, 0)) {
                    pos = i + j;
                    break;
                }
            }
        }
    }

    if (pos == -1) {
        return 1;
    }


    dattr = calloc(1, sizeof *dattr);
    LY_CHECK_ERR_RETURN(!dattr, LOGMEM(ctx), -1);

    dattr->parent = parent;
    dattr->next = NULL;
    dattr->annotation = submod ? (struct struct_137 *)submod->ext[pos] :
                                 (struct struct_137 *)mod->ext[pos];
    dattr->name = lydict_insert(ctx, attr_name, 0);
    dattr->value_str = lydict_insert(ctx, attr_value, 0);



    var_98 = lys_ext_complex_get_substmt(LY_STMT_TYPE, dattr->annotation, NULL);
    if (!var_98 || !lyp_parse_value(*var_98, &dattr->value_str, xml, NULL, dattr, NULL, 1, 0, var_67 & LYD_OPT_TRUSTED)) {
        lydict_remove(ctx, dattr->name);
        lydict_remove(ctx, dattr->value_str);
        free(dattr);
        return -1;
    }

    *var_139 = dattr;
    return 0;
}

int
fn_67(struct struct_131 *ctx, struct struct_68 *attr, struct struct_137 *parent, int *editbits)
{
    struct struct_68 *last = NULL;
    int var_68 = 0;

    LY_TREE_FOR(attr, attr) {
        last = NULL;
        if (!strcmp(attr->annotation->arg_value, "operation") &&
                !strcmp(attr->annotation->module->name, "ietf-netconf")) {
            if (var_68 & 0x10) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, "operation attributes", parent->schema->name);
                return -1;
            }

            var_68 |= 0x10;
            if (attr->value.enm->value >= 3) {

                var_68 |= 0x20;
            }
        } else if (attr->annotation->module == ctx->models.list[1] &&
                !strcmp(attr->annotation->arg_value, "insert")) {

            if (!(parent->schema->flags & LYS_USERORDERED)) {

                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, "insert");
                return -1;
            }
            if (var_68 & 0x01) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, "insert attributes", parent->schema->name);
                return -1;
            }

            var_68 |= 0x01;
            if (attr->value.enm->value >= 2) {

                var_68 |= 0x02;
            }
            last = attr;
        } else if (attr->annotation->module == ctx->models.list[1] &&
                !strcmp(attr->annotation->arg_value, "value")) {
            if (var_68 & 0x04) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, "value attributes", parent->schema->name);
                return -1;
            } else if (parent->schema->nodetype & LYS_LIST) {
                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, attr->name);
                return -1;
            }
            var_68 |= 0x04;
            last = attr;
        } else if (attr->annotation->module == ctx->models.list[1] &&
                !strcmp(attr->annotation->arg_value, "key")) {
            if (var_68 & 0x08) {
                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, "key attributes", parent->schema->name);
                return -1;
            } else if (parent->schema->nodetype & LYS_LEAFLIST) {
                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, attr->name);
                return -1;
            }
            var_68 |= 0x08;
            last = attr;
        }
    }


    if (last && (!(parent->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) || !(parent->schema->flags & LYS_USERORDERED))) {

        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, last->name);
        return -1;
    } else if (var_68 == 3) {

        if (parent->schema->nodetype & LYS_LIST) {
            LOGVAL(ctx, LYE_MISSATTR, LY_VLOG_LYD, parent, "key", parent->schema->name);
        } else {
            LOGVAL(ctx, LYE_MISSATTR, LY_VLOG_LYD, parent, "value", parent->schema->name);
        }
        return -1;
    } else if ((var_68 & (0x04 | 0x08)) && !(var_68 & 0x02)) {

        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, (var_68 & 0x04) ? "value" : "key");
        return -1;
    } else if ((var_68 & 0x21) == 0x21) {

        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, "insert");
        return -1;
    }

    if (editbits) {
        *editbits = var_68;
    }
    return 0;
}


static int
fn_68(const char *id, struct struct_69 *ident, uint32_t var_113)
{
    uint32_t i;

    for (i = 0; i < var_113; i++) {
        if (ly_strequal(id, ident[i].name, 1)) {

            return var_126;
        }
    }

    return EXIT_SUCCESS;
}

int
fn_70(const char *id, struct struct_138 *module)
{
    struct struct_138 *mainmod;
    int i;

    if (dup_identity_check(id, module->ident, module->ident_size)) {
        LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "identity", id);
        return var_126;
    }


    mainmod = lys_main_module(module);
    for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; ++i) {
        if (dup_identity_check(id, mainmod->inc[i].submodule->ident, mainmod->inc[i].submodule->ident_size)) {
            LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "identity", id);
            return var_126;
        }
    }

    return EXIT_SUCCESS;
}


int
fn_71(const char *var_98, struct struct_76 *tpdf, int var_113)
{
    int i;

    for (i = 0; i < var_113; i++) {
        if (!strcmp(var_98, tpdf[i].name)) {

            return var_126;
        }
    }

    return EXIT_SUCCESS;
}


static int
fn_72(const char *id, struct struct_138 *module)
{
    int i;

    for (i = 0; i < module->features_size; i++) {
        if (!strcmp(id, module->features[i].name)) {
            return var_126;
        }
    }

    return EXIT_SUCCESS;
}


static int
fn_73(const char *prefix, struct struct_138 *module)
{
    int i;

    if (module->prefix && !strcmp(module->prefix, prefix)) {
        return var_126;
    }
    for (i = 0; i < module->imp_size; i++) {
        if (!strcmp(module->imp[i].prefix, prefix)) {
            return var_126;
        }
    }

    return EXIT_SUCCESS;
}


int
fn_74(struct struct_131 *ctx, const char *id, enum enumtype_75 var_98, struct struct_138 *module,
                     struct struct_139 *parent)
{
    int i, j;
    int var_113;
    struct struct_76 *tpdf;
    struct struct_139 *node;
    struct struct_138 *mainmod;
    struct struct_139 *submod;

    assert(ctx && id);


    if (!(id[0] >= 'A' && id[0] <= 'Z') && !(id[0] >= 'a' && id[0] <= 'z') && id[0] != '_') {
        LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, "invalid start character");
        return var_126;
    }
    for (i = 1; id[i]; i++) {
        if (!(id[i] >= 'A' && id[i] <= 'Z') && !(id[i] >= 'a' && id[i] <= 'z')
                && !(id[i] >= '0' && id[i] <= '9') && id[i] != '_' && id[i] != '-' && id[i] != '.') {
            LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, "invalid character");
            return var_126;
        }
    }

    if (i > 64) {
        LOGWRN(ctx, "Identifier \"%s\" is long, you should use something shorter.", id);
    }

    switch (var_98) {
    case LY_IDENT_NAME:

        if (!parent) {
            break;
        }

        LY_TREE_FOR(parent->child, node) {
            if (ly_strequal(node->name, id, 1)) {
                LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, "name duplication");
                return var_126;
            }
        }
        break;
    case LY_IDENT_TYPE:
        assert(module);
        mainmod = lys_main_module(module);


        if (!strcmp(id, "binary") || !strcmp(id, "bits") ||
                !strcmp(id, "boolean") || !strcmp(id, "decimal64") ||
                !strcmp(id, "empty") || !strcmp(id, "enumeration") ||
                !strcmp(id, "identityref") || !strcmp(id, "instance-identifier") ||
                !strcmp(id, "int8") || !strcmp(id, "int16") ||
                !strcmp(id, "int32") || !strcmp(id, "int64") ||
                !strcmp(id, "leafref") || !strcmp(id, "string") ||
                !strcmp(id, "uint8") || !strcmp(id, "uint16") ||
                !strcmp(id, "uint32") || !strcmp(id, "uint64") || !strcmp(id, "union")) {
            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, id, "typedef");
            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Typedef name duplicates a built-in type.");
            return var_126;
        }


        for (; parent; parent = lys_parent(parent)) {
            switch (parent->nodetype) {
            case LYS_CONTAINER:
                var_113 = ((struct struct_77 *)parent)->tpdf_size;
                tpdf = ((struct struct_77 *)parent)->tpdf;
                break;
            case LYS_LIST:
                var_113 = ((struct struct_84 *)parent)->tpdf_size;
                tpdf = ((struct struct_84 *)parent)->tpdf;
                break;
            case LYS_GROUPING:
                var_113 = ((struct struct_79 *)parent)->tpdf_size;
                tpdf = ((struct struct_79 *)parent)->tpdf;
                break;
            default:
                continue;
            }

            if (dup_typedef_check(id, tpdf, var_113)) {
                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "typedef", id);
                return var_126;
            }
        }


        if (dup_typedef_check(id, module->tpdf, module->tpdf_size)) {
            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "typedef", id);
            return var_126;
        }


        for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; i++) {
            if (dup_typedef_check(id, mainmod->inc[i].submodule->tpdf, mainmod->inc[i].submodule->tpdf_size)) {
                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "typedef", id);
                return var_126;
            }
        }

        break;
    case LY_IDENT_PREFIX:
        assert(module);


        if (dup_prefix_check(id, module)) {
            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "prefix", id);
            return var_126;
        }
        break;
    case LY_IDENT_FEATURE:
        assert(module);
        mainmod = lys_main_module(module);



        if (dup_feature_check(id, module)) {
            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "feature", id);
            return var_126;
        }


        for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; i++) {
            if (dup_feature_check(id, (struct struct_138 *)mainmod->inc[i].submodule)) {
                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "feature", id);
                return var_126;
            }
        }
        break;

    case LY_IDENT_EXTENSION:
        assert(module);
        mainmod = lys_main_module(module);


        for (i = 0; i < mainmod->extensions_size; i++) {
            if (ly_strequal(id, mainmod->extensions[i].name, 1)) {
                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "extension", id);
                return var_126;
            }
        }


        for (j = 0; j < mainmod->inc_size && mainmod->inc[j].submodule; j++) {
            submod = mainmod->inc[j].submodule;
            for (i = 0; i < submod->extensions_size; i++) {
                if (ly_strequal(id, submod->extensions[i].name, 1)) {
                    LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, "extension", id);
                    return var_126;
                }
            }
        }

        break;

    default:

        break;
    }

    return EXIT_SUCCESS;
}


int
fn_79(struct struct_131 *ctx, const char *date)
{
    int i;
    struct struct_80 tm, tm_;
    char *r;

    assert(date);


    for (i = 0; i < LY_REV_SIZE - 1; i++) {
        if (i == 4 || i == 7) {
            if (date[i] != '-') {
                goto error;
            }
        } else if (!isdigit(date[i])) {
            goto error;
        }
    }


    memset(&tm, 0, sizeof tm);
    r = strptime(date, "%Y-%m-%d", &tm);
    if (!r || r != &date[LY_REV_SIZE - 1]) {
        goto error;
    }

    tm.tm_hour = 12;

    memcpy(&tm_, &tm, sizeof tm);
    mktime(&tm_);
    if (tm.tm_mday != tm_.tm_mday) {


        goto error;
    }

    return EXIT_SUCCESS;

error:
    LOGVAL(ctx, LYE_INDATE, LY_VLOG_NONE, NULL, date);
    return var_126;
}







static const struct struct_139 *
fn_81(const struct struct_139 *root)
{
    int var_85 = 0;
    const struct struct_139 *iter = NULL;

    while ((iter = lys_getnext(iter, root, NULL, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHUSES | LYS_GETNEXT_INTOUSES
            | LYS_GETNEXT_INTONPCONT | LYS_GETNEXT_NOSTATECHECK))) {
        if (iter->nodetype == LYS_USES) {
            if (!((struct struct_121 *)iter)->grp) {

                return root;
            } else {

                continue;
            }
        }
        if (iter->nodetype == LYS_CHOICE) {

            continue;
        }
        if (iter->nodetype == LYS_LIST) {
            if (((struct struct_84 *)iter)->min) {
                var_85 = 1;
            }
        } else if (iter->nodetype == LYS_LEAFLIST) {
            if (((struct struct_84 *)iter)->min) {
                var_85 = 1;
            }
        } else if (iter->flags & LYS_MAND_TRUE) {
            var_85 = 1;
        }

        if (var_85) {
            return iter;
        }
    }

    return NULL;
}


int
fn_85(struct struct_86 *aug, const struct struct_139 *target)
{
    const struct struct_139 *node;

    if (aug->when || target->nodetype == LYS_CHOICE) {



        return EXIT_SUCCESS;
    }

    if ((node = lyp_check_mandatory_((struct struct_139 *)aug))) {
        if (node != (struct struct_139 *)aug) {
            LOGVAL(target->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, "mandatory");
            LOGVAL(target->module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,
                   "Mandatory node \"%s\" appears in augment of \"%s\" without when condition.",
                   node->name, aug->target_name);
            return -1;
        }
        return var_126;
    }

    return EXIT_SUCCESS;
}






int
fn_87(struct struct_139 *node)
{
    const struct struct_139 *mand, *var_89 = ((struct struct_88 *)node)->dflt;

    if ((mand = lyp_check_mandatory_(var_89))) {
        if (mand != var_89) {
            LOGVAL(node->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, "mandatory");
            LOGVAL(node->module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,
                   "Mandatory node \"%s\" is directly under the default case \"%s\" of the \"%s\" choice.",
                   mand->name, var_89->name, node->name);
            return -1;
        }
        return var_126;
    }

    return EXIT_SUCCESS;
}

int
fn_89(uint16_t var_92, struct struct_138 *mod1, const char *name1,
                 uint16_t var_92, struct struct_138 *mod2, const char *name2,
                 const struct struct_139 *node)
{
    uint16_t flg1, flg2;

    flg1 = (var_92 & LYS_STATUS_MASK) ? (var_92 & LYS_STATUS_MASK) : LYS_STATUS_CURR;
    flg2 = (var_92 & LYS_STATUS_MASK) ? (var_92 & LYS_STATUS_MASK) : LYS_STATUS_CURR;

    if ((flg1 < flg2) && (lys_main_module(mod1) == lys_main_module(mod2))) {
        LOGVAL(mod1->ctx, LYE_INSTATUS, node ? LY_VLOG_LYS : LY_VLOG_NONE, node,
               flg1 == LYS_STATUS_CURR ? "current" : "deprecated", name1, "references",
               flg2 == LYS_STATUS_OBSLT ? "obsolete" : "deprecated", name2);
        return var_126;
    }

    return EXIT_SUCCESS;
}

void
fn_92(struct struct_138 *mod, int var_95)
{
    struct struct_99 *models = &mod->ctx->models;
    uint8_t i;

    assert(mod && !mod->type);

    if (models->parsed_submodules_count) {
        for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i);
        if (models->parsed_submodules[i] == mod) {
            if (var_95) {
                for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i) {
                    lys_sub_module_remove_devs_augs((struct struct_138 *)models->parsed_submodules[i]);
                    lys_submodule_module_data_free((struct struct_139 *)models->parsed_submodules[i]);
                    lys_submodule_free((struct struct_139 *)models->parsed_submodules[i], NULL);
                }
            }

            models->parsed_submodules_count = i;
            if (!models->parsed_submodules_count) {
                free(models->parsed_submodules);
                models->parsed_submodules = NULL;
            }
        }
    }
}

static void
fn_95(struct struct_138 *sub_mod, struct struct_139 *parsed_submod)
{
    struct struct_99 *models = &sub_mod->ctx->models;
    int16_t i;


    if (models->parsed_submodules_count) {
        for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i);
    } else {
        i = -1;
    }
    if ((i == -1) || (models->parsed_submodules[i] != lys_main_module(sub_mod))) {
        ++models->parsed_submodules_count;
        models->parsed_submodules = ly_realloc(models->parsed_submodules,
                                               models->parsed_submodules_count * sizeof *models->parsed_submodules);
        LY_CHECK_ERR_RETURN(!models->parsed_submodules, LOGMEM(sub_mod->ctx), );
        models->parsed_submodules[models->parsed_submodules_count - 1] = lys_main_module(sub_mod);
    }


    ++models->parsed_submodules_count;
    models->parsed_submodules = ly_realloc(models->parsed_submodules,
                                           models->parsed_submodules_count * sizeof *models->parsed_submodules);
    LY_CHECK_ERR_RETURN(!models->parsed_submodules, LOGMEM(sub_mod->ctx), );
    models->parsed_submodules[models->parsed_submodules_count - 1] = (struct struct_138 *)parsed_submod;
}




static int
fn_96(struct struct_138 *module, const char *var_131, int var_98)
{
    LY_ECODE var_98 = var_98 ? LYE_CIRC_IMPORTS : LYE_CIRC_INCLUDES;
    struct struct_99 *models = &module->ctx->models;
    uint8_t i;


    if (ly_strequal(module->name, var_131, 1)) {
        LOGVAL(module->ctx, var_98, LY_VLOG_NONE, NULL, var_131);
        return -1;
    }


    for (i = 0; i < models->parsing_sub_modules_count; i++) {
        if (ly_strequal(models->parsing_sub_modules[i]->name, var_131, 1)) {
            LOGVAL(module->ctx, var_98, LY_VLOG_NONE, NULL, var_131);
            return -1;
        }
    }

    return 0;
}

int
fn_98(struct struct_138 *module)
{
    struct struct_99 *models = &module->ctx->models;


    ++models->parsing_sub_modules_count;
    models->parsing_sub_modules = ly_realloc(models->parsing_sub_modules,
                                             models->parsing_sub_modules_count * sizeof *models->parsing_sub_modules);
    LY_CHECK_ERR_RETURN(!models->parsing_sub_modules, LOGMEM(module->ctx), -1);
    models->parsing_sub_modules[models->parsing_sub_modules_count - 1] = module;

    return 0;
}

void
fn_99(struct struct_131 *ctx)
{
    if (!ctx->models.parsing_sub_modules_count) {
        LOGINT(ctx);
        return;
    }


    ctx->models.parsing_sub_modules_count--;
    if (!ctx->models.parsing_sub_modules_count) {
        free(ctx->models.parsing_sub_modules);
        ctx->models.parsing_sub_modules = NULL;
    }
}






static int
fn_100(struct struct_138 *mod, const char *name, struct struct_104 *inc, struct struct_139 **sub)
{
    struct struct_138 **parsed_sub = mod->ctx->models.parsed_submodules;
    uint8_t i, var_103 = mod->ctx->models.parsed_submodules_count;

    assert(sub);

    for (i = 0; i < mod->inc_size; ++i) {
        if (ly_strequal(mod->inc[i].submodule->name, name, 1)) {

            LOGVAL(mod->ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, "include");
            LOGVAL(mod->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Submodule \"%s\" included twice in the same module \"%s\".",
                   name, mod->name);
            return -1;
        }
    }

    if (var_103) {
        assert(!parsed_sub[0]->type);
        for (i = var_103 - 1; parsed_sub[i]->type; --i) {
            if (ly_strequal(parsed_sub[i]->name, name, 1)) {

                if (inc->rev[0] && (!parsed_sub[i]->rev_size || strcmp(parsed_sub[i]->rev[0].date, inc->rev))) {



                    LOGVAL(mod->ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, "include");
                    LOGVAL(mod->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Including multiple revisions of submodule \"%s\".", name);
                    return -1;
                }


                (*sub) = (struct struct_139 *)parsed_sub[i];
                return 1;
            }
        }
    }


    return 0;
}





int
fn_103(struct struct_138 *module, const char *var_131, struct struct_104 *inc, struct struct_104 *unres)
{
    int i;


    i = lyp_check_includedup(module, var_131, inc, &inc->submodule);
    if (i == -1) {
        return -1;
    } else if (i == 1) {
        return 0;
    }



    if (lyp_check_circmod(module, var_131, 0)) {
        return -1;
    }


    inc->submodule = (struct struct_139 *)ly_ctx_load_sub_module(module->ctx, module, var_131,
                                                                    inc->rev[0] ? inc->rev : NULL, 1, unres);


    if (!inc->submodule) {
        if (ly_errno != LY_EVALID) {
            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, var_131, "include");
        }
        LOGERR(module->ctx, LY_EVALID, "Including \"%s\" module into \"%s\" failed.", var_131, module->name);
        return -1;
    }


    if (inc->rev[0] && inc->submodule->rev_size && strcmp(inc->rev, inc->submodule->rev[0].date)) {
        LOGERR(module->ctx, LY_EVALID, "\"%s\" include of submodule \"%s\" in revision \"%s\" not found.",
               module->name, var_131, inc->rev);
        unres_schema_free((struct struct_138 *)inc->submodule, &unres, 0);
        lys_sub_module_remove_devs_augs((struct struct_138 *)inc->submodule);
        lys_submodule_module_data_free((struct struct_139 *)inc->submodule);
        lys_submodule_free(inc->submodule, NULL);
        inc->submodule = NULL;
        return -1;
    }


    lyp_add_includedup(module, inc->submodule);

    return 0;
}

static int
fn_105(struct struct_138 *main_module, struct struct_139 *sub)
{
    uint8_t i, j;
    void *reallocated;
    int var_139 = 0, tmp;
    struct struct_131 *ctx = main_module->ctx;

    for (i = 0; i < sub->inc_size; i++) {

        for (j = 0; j < main_module->inc_size; j++) {
            if (main_module->inc[j].submodule == sub->inc[i].submodule) {
                break;
            }
        }

        if (j == main_module->inc_size) {

            if (main_module->version >= LYS_VERSION_1_1) {
                LOGVAL(ctx, LYE_MISSSTMT, LY_VLOG_NONE, NULL, "include");
                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,
                       "The main module \"%s\" misses include of the \"%s\" submodule used in another submodule \"%s\".",
                       main_module->name, sub->inc[i].submodule->name, sub->name);



                var_139 = 1;
            } else {

                LOGWRN(ctx, "The main module \"%s\" misses include of the \"%s\" submodule used in another submodule \"%s\".",
                       main_module->name, sub->inc[i].submodule->name, sub->name);
                LOGWRN(ctx, "To avoid further issues, adding submodule \"%s\" into the main module \"%s\".",
                       sub->inc[i].submodule->name, main_module->name);


            }
            main_module->inc_size++;
            reallocated = realloc(main_module->inc, main_module->inc_size * sizeof *main_module->inc);
            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), 1);
            main_module->inc = reallocated;
            memset(&main_module->inc[main_module->inc_size - 1], 0, sizeof *main_module->inc);


            memcpy(&main_module->inc[main_module->inc_size - 1].rev, sub->inc[i].rev, LY_REV_SIZE - 1);
            main_module->inc[main_module->inc_size - 1].submodule = sub->inc[i].submodule;
        }


        tmp = lyp_check_include_missing_recursive(main_module, sub->inc[i].submodule);
        if (!var_139 && tmp) {
            var_139 = 1;
        }
    }

    return var_139;
}

int
fn_106(struct struct_138 *main_module)
{
    int var_139 = 0;
    uint8_t i;



    for (i = 0; i < main_module->inc_size; i++) {
        if (lyp_check_include_missing_recursive(main_module, main_module->inc[i].submodule)) {
            var_139 = 1;
        }
    }

    return var_139;
}





int
fn_107(struct struct_138 *module, const char *var_131, struct struct_108 *imp)
{
    int i;
    struct struct_138 *dup = NULL;
    struct struct_131 *ctx = module->ctx;


    for (i = 0; i < module->imp_size; i++) {
        if (!module->imp[i].module) {

            continue;
        }
        if (ly_strequal(module->imp[i].module->name, var_131, 1)) {

            if (imp->rev[0] && (!module->imp[i].module->rev_size || strcmp(module->imp[i].module->rev[0].date, imp->rev))) {



                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, var_131, "import");
                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Importing multiple revisions of module \"%s\".", var_131);
                return -1;
            } else if (!imp->rev[0]) {



                dup = module->imp[i].module;
                break;
            }



            imp->module = module->imp[i].module;
            return 0;
        }
    }


    if (lyp_check_circmod(module, var_131, 1)) {
        return -1;
    }


    imp->module = (struct struct_138 *)ly_ctx_load_sub_module(module->ctx, NULL, var_131, imp->rev[0] ? imp->rev : NULL,
                                                              module->ctx->models.flags & LY_CTX_ALLIMPLEMENTED ? 1 : 0,
                                                              NULL);


    if (!imp->module) {
        LOGERR(ctx, LY_EVALID, "Importing \"%s\" module into \"%s\" failed.", var_131, module->name);
        return -1;
    }

    if (imp->rev[0] && imp->module->rev_size && strcmp(imp->rev, imp->module->rev[0].date)) {
        LOGERR(ctx, LY_EVALID, "\"%s\" import of module \"%s\" in revision \"%s\" not found.",
               module->name, var_131, imp->rev);
        return -1;
    }

    if (dup) {

        if ((dup != imp->module) ||
                (dup->rev_size != imp->module->rev_size && (!dup->rev_size || imp->module->rev_size)) ||
                (dup->rev_size && strcmp(dup->rev[0].date, imp->module->rev[0].date))) {



            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, var_131, "import");
            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Importing multiple revisions of module \"%s\".", var_131);
            return -1;
        } else {
            LOGWRN(ctx, "Module \"%s\" is imported by \"%s\" multiple times with different prefixes.", dup->name, module->name);
        }
    }

    return 0;
}




void
fn_109(struct struct_138 *module)
{
    uint8_t i, r;
    struct struct_110 rev;

    for (i = 1, r = 0; i < module->rev_size; i++) {
        if (strcmp(module->rev[i].date, module->rev[r].date) > 0) {
            r = i;
        }
    }

    if (r) {

        memcpy(&rev, &module->rev[0], sizeof rev);
        memcpy(&module->rev[0], &module->rev[r], sizeof rev);
        memcpy(&module->rev[r], &rev, sizeof rev);
    }
}

void
fn_111(struct struct_131 *ctx, struct struct_125 ***ext, uint8_t *var_113, uint8_t var_113)
{
    uint8_t i;

    lys_extension_instances_free(ctx, (*ext)[var_113]->ext, (*ext)[var_113]->ext_size, NULL);
    lydict_remove(ctx, (*ext)[var_113]->arg_value);
    free((*ext)[var_113]);


    for (i = var_113 + 1; i < (*var_113); i++) {
        (*ext)[i - 1] = (*ext)[i];
    }

    (*ext)[(*var_113) - 1] = NULL;

    (*var_113) = (*var_113) - 1;

    if (!(*var_113)) {

        free((*ext));
        ext = NULL;
    }
}

static int
fn_113(struct struct_120 *rfn, struct struct_139 *target, LYEXT_SUBSTMT var_125, struct struct_126 *extdef)
{
    struct struct_131 *ctx;
    int m, var_125;
    struct struct_125 *new;
    void *reallocated;

    ctx = target->module->ctx;

    m = var_125 = -1;
    while ((m = lys_ext_iter(rfn->ext, rfn->ext_size, m + 1, var_125)) != -1) {



        if (var_125 == LYEXT_SUBSTMT_SELF && rfn->ext[m]->def != extdef) {
            continue;
        }


        do {
            var_125 = lys_ext_iter(target->ext, target->ext_size, var_125 + 1, var_125);
        } while (var_125 != -1 && var_125 == LYEXT_SUBSTMT_SELF && target->ext[var_125]->def != extdef);


        if (var_125 == -1) {

            new = malloc(sizeof **target->ext);
            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), var_126);
            reallocated = realloc(target->ext, (target->ext_size + 1) * sizeof *target->ext);
            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx); free(new), var_126);
            target->ext = reallocated;
            target->ext_size++;


            var_125 = target->ext_size - 1;
            target->ext[var_125] = new;
            target->ext[var_125]->parent = target;
            target->ext[var_125]->parent_type = LYEXT_PAR_NODE;
            target->ext[var_125]->flags = 0;
            target->ext[var_125]->insubstmt = var_125;
            target->ext[var_125]->priv = NULL;
            target->ext[var_125]->nodetype = LYS_EXT;
            target->ext[var_125]->module = target->module;
        } else {

            lys_extension_instances_free(ctx, target->ext[var_125]->ext, target->ext[var_125]->ext_size, NULL);
            lydict_remove(ctx, target->ext[var_125]->arg_value);
        }

        target->ext[var_125]->def = rfn->ext[m]->def;

        target->ext[var_125]->arg_value = lydict_insert(ctx, rfn->ext[m]->arg_value, 0);

        target->ext[var_125]->ext_size = rfn->ext[m]->ext_size;
        lys_ext_dup(ctx, target->module, rfn->ext[m]->ext, rfn->ext[m]->ext_size, target, LYEXT_PAR_NODE,
                    &target->ext[var_125]->ext, 0, NULL);

        target->ext[var_125]->insubstmt_index = rfn->ext[m]->insubstmt_index;
    }


    while ((var_125 = lys_ext_iter(target->ext, target->ext_size, var_125 + 1, var_125)) != -1) {
        if (var_125 == LYEXT_SUBSTMT_SELF && target->ext[var_125]->def != extdef) {

            continue;
        }


        lyp_ext_instance_rm(ctx, &target->ext, &target->ext_size, var_125);
        --var_125;
    }

    return EXIT_SUCCESS;
}






int
fn_118(struct struct_138 *module)
{
    int i, k, var_121 = 0;
    struct struct_139 *root, *nextroot, *next, *node;
    struct struct_139 *target;
    struct struct_121 *uses;
    struct struct_120 *rfn;
    struct struct_126 *extset;


    LY_TREE_FOR_SAFE(module->data, nextroot, root) {


        LY_TREE_DFS_BEGIN(root, next, node) {
            if (node->nodetype == LYS_USES) {
                uses = (struct struct_121 *)node;

                for (i = 0; i < uses->refine_size; i++) {
                    if (!uses->refine[i].ext_size) {

                        continue;
                    }
                    rfn = &uses->refine[i];


                    target = NULL;
                    resolve_descendant_schema_nodeid(rfn->target_name, uses->child,
                                                     LYS_NO_RPC_NOTIF_NODE | LYS_ACTION | LYS_NOTIF,
                                                     0, (const struct struct_139 **)&target);
                    if (!target) {


                        LOGINT(module->ctx);;
                        return var_126;
                    }


                    extset = ly_set_new();
                    k = -1;
                    while ((k = lys_ext_iter(rfn->ext, rfn->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {
                        ly_set_add(extset, rfn->ext[k]->def, 0);
                    }
                    for (k = 0; (unsigned int)k < extset->number; k++) {
                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_SELF, (struct struct_126 *)extset->set.g[k])) {
                            ly_set_free(extset);
                            return var_126;
                        }
                    }
                    ly_set_free(extset);


                    if (rfn->dsc && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_DESCRIPTION, NULL)) {
                        return var_126;
                    }

                    if (rfn->ref && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_REFERENCE, NULL)) {
                        return var_126;
                    }


                    if ((rfn->flags & LYS_CONFIG_MASK) && (target->flags & LYS_CONFIG_MASK)) {
                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_CONFIG, NULL)) {
                            return var_126;
                        }
                    }

                    if (rfn->dflt_size && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_DEFAULT, NULL)) {
                        return var_126;
                    }

                    if (rfn->flags & LYS_MAND_MASK) {
                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MANDATORY, NULL)) {
                            return var_126;
                        }
                    }

                    if ((target->nodetype & LYS_CONTAINER) && rfn->mod.presence) {
                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_PRESENCE, NULL)) {
                            return var_126;
                        }
                    }

                    if (rfn->flags & LYS_RFN_MINSET) {
                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MIN, NULL)) {
                            return var_126;
                        }
                    }
                    if (rfn->flags & LYS_RFN_MAXSET) {
                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MAX, NULL)) {
                            return var_126;
                        }
                    }


                    if (target->ext_size) {



                        target->ext = realloc(target->ext, target->ext_size * sizeof *target->ext);
                    }
                }
            }
            LY_TREE_DFS_END(root, next, node)
        }

        if (!nextroot && var_121 < module->augment_size) {
            nextroot = module->augment[var_121].child;
            var_121++;
        }
    }

    return EXIT_SUCCESS;
}




int
fn_121(struct struct_137 *ext, const char *ext_name)
{
    void *p;
    int i;
    struct struct_131 *ctx = ext->module->ctx;


    for (i = 0; ext->substmt[i].stmt; i++) {
        if (ext->substmt[i].cardinality == LY_STMT_CARD_OPT || ext->substmt[i].cardinality == LY_STMT_CARD_ANY) {

            continue;
        } else if (ext->substmt[i].cardinality == LY_STMT_CARD_SOME) {
            goto array;
        }






        switch(ext->substmt[i].stmt) {
        case LY_STMT_ORDEREDBY:

            break;
        case LY_STMT_REQINSTANCE:
        case LY_STMT_DIGITS:
        case LY_STMT_MODIFIER:
            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);
            if (!*(uint8_t*)p) {
                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);
                goto error;
            }
            break;
        case LY_STMT_STATUS:
            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);
            if (!(*(uint16_t*)p & LYS_STATUS_MASK)) {
                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);
                goto error;
            }
            break;
        case LY_STMT_MANDATORY:
            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);
            if (!(*(uint16_t*)p & LYS_MAND_MASK)) {
                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);
                goto error;
            }
            break;
        case LY_STMT_CONFIG:
            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);
            if (!(*(uint16_t*)p & LYS_CONFIG_MASK)) {
                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);
                goto error;
            }
            break;
        default:
array:

            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);
            if (!(*(void**)p)) {
                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);
                goto error;
            }
            break;
        }
    }

    return EXIT_SUCCESS;

error:
    return var_126;
}

static int
fn_122(struct struct_139 *target, struct struct_125 *ext)
{
    int var_125 = -1, var_123 = 0;
    char *path;

    while ((var_125 = lys_ext_iter(target->ext, target->ext_size, var_125 + 1, ext->insubstmt)) != -1) {
        if (target->ext[var_125]->def != ext->def) {
            continue;
        }

        if (ext->def->argument) {

            if (!ly_strequal(target->ext[var_125]->arg_value, ext->arg_value, 1)) {
                continue;
            }
        }


        ++var_123;
        lyp_ext_instance_rm(target->module->ctx, &target->ext, &target->ext_size, var_125);
        --var_125;
    }

    if (!var_123) {
        path = lys_path(target, LYS_PATH_FIRST_PREFIX);
        LOGERR(target->module->ctx, LY_EVALID, "Extension deviation: extension \"%s\" to delete not found in \"%s\".",
               ext->def->name, path)
        free(path);
        return var_126;
    }
    return EXIT_SUCCESS;
}

static int
fn_123(struct struct_126 *dev, struct struct_139 *target, LYEXT_SUBSTMT var_125, struct struct_126 *extdef)
{
    struct struct_131 *ctx;
    int m, var_125;
    struct struct_125 *new;
    void *reallocated;





    ctx = target->module->ctx;
    m = var_125 = -1;

    while ((m = lys_ext_iter(dev->ext, dev->ext_size, m + 1, var_125)) != -1) {



        if (var_125 == LYEXT_SUBSTMT_SELF && dev->ext[m]->def != extdef) {
            continue;
        }

        if (var_125 == LYEXT_SUBSTMT_SELF && dev->mod == LY_DEVIATE_ADD) {

            do {
                var_125 = lys_ext_iter(target->ext, target->ext_size, var_125 + 1, var_125);
            } while (var_125 != -1 && (target->ext[var_125]->def != extdef || !(target->ext[var_125]->flags & LYEXT_OPT_INHERIT)));
        } else {

            do {
                var_125 = lys_ext_iter(target->ext, target->ext_size, var_125 + 1, var_125);

            } while (var_125 != -1 && var_125 == LYEXT_SUBSTMT_SELF && target->ext[var_125]->def != extdef);
        }

        if (var_125 == -1) {

            new = malloc(sizeof **target->ext);
            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), var_126);
            reallocated = realloc(target->ext, (target->ext_size + 1) * sizeof *target->ext);
            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx); free(new), var_126);
            target->ext = reallocated;
            target->ext_size++;

            var_125 = target->ext_size - 1;
        } else {


            lys_extension_instances_free(ctx, target->ext[var_125]->ext, target->ext[var_125]->ext_size, NULL);
            lydict_remove(ctx, target->ext[var_125]->arg_value);
            free(target->ext[var_125]);


            new = malloc(sizeof **target->ext);
            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), var_126);
        }

        target->ext[var_125] = new;
        target->ext[var_125]->def = dev->ext[m]->def;
        target->ext[var_125]->arg_value = lydict_insert(ctx, dev->ext[m]->arg_value, 0);
        target->ext[var_125]->flags = 0;
        target->ext[var_125]->parent = target;
        target->ext[var_125]->parent_type = LYEXT_PAR_NODE;
        target->ext[var_125]->insubstmt = var_125;
        target->ext[var_125]->insubstmt_index = dev->ext[m]->insubstmt_index;
        target->ext[var_125]->ext_size = dev->ext[m]->ext_size;
        lys_ext_dup(ctx, target->module, dev->ext[m]->ext, dev->ext[m]->ext_size, target, LYEXT_PAR_NODE,
                    &target->ext[var_125]->ext, 1, NULL);
        target->ext[var_125]->nodetype = LYS_EXT;
        target->ext[var_125]->module = target->module;
        target->ext[var_125]->priv = NULL;


    }





    while ((var_125 = lys_ext_iter(target->ext, target->ext_size, var_125 + 1, var_125)) != -1) {
        if (var_125 == LYEXT_SUBSTMT_SELF) {




            if (target->ext[var_125]->def != extdef ||
                    (dev->mod == LY_DEVIATE_ADD && !(target->ext[var_125]->flags & LYEXT_OPT_INHERIT))) {

                continue;
            }

        }


        lyp_ext_instance_rm(ctx, &target->ext, &target->ext_size, var_125);
        --var_125;
    }

    return EXIT_SUCCESS;
}




int
fn_125(struct struct_138 *module)
{
    int i, j, k;
    struct struct_126 *dev;
    struct struct_139 *target;
    struct struct_126 *extset;

    for (i = 0; i < module->deviation_size; i++) {
        target = NULL;
        extset = NULL;
        j = resolve_schema_nodeid(module->deviation[i].target_name, NULL, module, &extset, 0, 0);
        if (j == -1) {
            return var_126;
        } else if (!extset) {

            ly_set_free(extset);
            continue;
        }
        target = extset->set.s[0];
        ly_set_free(extset);

        for (j = 0; j < module->deviation[i].deviate_size; j++) {
            dev = &module->deviation[i].deviate[j];
            if (!dev->ext_size) {

                continue;
            }


            if (dev->mod == LY_DEVIATE_DEL) {
                k = -1;
                while ((k = lys_ext_iter(dev->ext, dev->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {
                    if (lyp_deviate_del_ext(target, dev->ext[k])) {
                        return var_126;
                    }
                }





                continue;
            } else {
                extset = ly_set_new();
                k = -1;
                while ((k = lys_ext_iter(dev->ext, dev->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {
                    ly_set_add(extset, dev->ext[k]->def, 0);
                }
                for (k = 0; (unsigned int)k < extset->number; k++) {
                    if (lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_SELF, (struct struct_126 *)extset->set.g[k])) {
                        ly_set_free(extset);
                        return var_126;
                    }
                }
                ly_set_free(extset);
            }


            if (dev->unique_size && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_UNIQUE, NULL)) {
                return var_126;
            }

            if (dev->units && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_UNITS, NULL)) {
                return var_126;
            }

            if (dev->dflt_size && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_DEFAULT, NULL)) {
                return var_126;
            }

            if ((dev->flags & LYS_CONFIG_MASK) && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_CONFIG, NULL)) {
                return var_126;
            }

            if ((dev->flags & LYS_MAND_MASK) && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MANDATORY, NULL)) {
                return var_126;
            }

            if (dev->min_set && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MIN, NULL)) {
                return var_126;
            }
            if (dev->min_set && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MAX, NULL)) {
                return var_126;
            }

        }
    }

    return EXIT_SUCCESS;
}

int
fn_126(struct struct_138 *module)
{
    struct struct_131 *ctx;
    int i, var_128 = -1, to_implement;
    const char *last_rev = NULL;

    assert(module);
    to_implement = 0;
    ctx = module->ctx;


    for (i = 0; i < module->rev_size; ++i) {
        if (!last_rev || (strcmp(last_rev, module->rev[i].date) < 0)) {
            last_rev = module->rev[i].date;
        }
    }

    for (i = 0; i < ctx->models.used; i++) {

        if (!strcmp(ctx->models.list[i]->name, module->name)) {
            if (to_implement) {
                if (i == var_128) {
                    continue;
                }
                LOGERR(ctx, LY_EINVAL, "Module \"%s@%s\" in another revision \"%s\" already implemented.",
                       module->name, last_rev ? last_rev : "<latest>", ctx->models.list[i]->rev[0].date);
                return -1;
            } else if (!ctx->models.list[i]->rev_size && module->rev_size) {
                LOGERR(ctx, LY_EINVAL, "Module \"%s\" without revision already in context.", module->name);
                return -1;
            } else if (ctx->models.list[i]->rev_size && !module->rev_size) {
                LOGERR(ctx, LY_EINVAL, "Module \"%s\" with revision \"%s\" already in context.",
                       module->name, ctx->models.list[i]->rev[0].date);
                return -1;
            } else if ((!module->rev_size && !ctx->models.list[i]->rev_size)
                    || !strcmp(ctx->models.list[i]->rev[0].date, last_rev)) {

                LOGVRB("Module \"%s@%s\" already in context.", module->name, last_rev ? last_rev : "<latest>");


                if (ctx->models.list[i]->disabled) {
                    lys_set_enabled(ctx->models.list[i]);
                }

                to_implement = module->implemented;
                var_128 = i;
                if (to_implement && !ctx->models.list[i]->implemented) {

                    i = -1;
                    continue;
                }
                return 1;

            } else if (module->implemented && ctx->models.list[i]->implemented) {
                LOGERR(ctx, LY_EINVAL, "Module \"%s@%s\" in another revision \"%s\" already implemented.",
                       module->name, last_rev ? last_rev : "<latest>", ctx->models.list[i]->rev[0].date);
                return -1;
            }



        } else if (!strcmp(ctx->models.list[i]->ns, module->ns)) {
            LOGERR(ctx, LY_EINVAL, "Two different modules (\"%s\" and \"%s\") have the same namespace \"%s\".",
                   ctx->models.list[i]->name, module->name, module->ns);
            return -1;
        }
    }

    if (to_implement) {
        if (lys_set_implemented(ctx->models.list[var_128])) {
            return -1;
        }
        return 1;
    }

    return 0;
}

int
fn_128(struct struct_138 *module)
{
    struct struct_138 **newlist = NULL;
    int i;

    assert(!lyp_ctx_check_module(module));


    int j;

    for (i = 0; i < module->augment_size; ++i) {
        assert(module->augment[i].target);
    }
    for (i = 0; i < module->inc_size; ++i) {
        for (j = 0; j < module->inc[i].submodule->augment_size; ++j) {
            assert(module->inc[i].submodule->augment[j].target);
        }
    }



    if (module->ctx->models.used == module->ctx->models.size) {
        newlist = realloc(module->ctx->models.list, (2 * module->ctx->models.size) * sizeof *newlist);
        LY_CHECK_ERR_RETURN(!newlist, LOGMEM(module->ctx), -1);
        for (i = module->ctx->models.size; i < module->ctx->models.size * 2; i++) {
            newlist[i] = NULL;
        }
        module->ctx->models.size *= 2;
        module->ctx->models.list = newlist;
    }
    module->ctx->models.list[module->ctx->models.used++] = module;
    module->ctx->models.module_set_id++;

    return 0;
}

unsigned int
fn_129(struct struct_131 *ctx, char *dst, int32_t var_131)
{
    if (var_131 < 0x80) {

        if (var_131 < 0x20 &&
                var_131 != 0x09 &&
                var_131 != 0x0a &&
                var_131 != 0x0d) {
            goto error;
        }

        dst[0] = var_131;
        return 1;
    } else if (var_131 < 0x800) {

        dst[0] = 0xc0 | (var_131 >> 6);
        dst[1] = 0x80 | (var_131 & 0x3f);
        return 2;
    } else if (var_131 < 0xfffe) {

        if (((var_131 & 0xf800) == 0xd800) ||
                (var_131 >= 0xfdd0 && var_131 <= 0xfdef)) {


            goto error;
        }

        dst[0] = 0xe0 | (var_131 >> 12);
        dst[1] = 0x80 | ((var_131 >> 6) & 0x3f);
        dst[2] = 0x80 | (var_131 & 0x3f);

        return 3;
    } else if (var_131 < 0x10fffe) {
        if ((var_131 & 0xffe) == 0xffe) {



            goto error;
        }

        dst[0] = 0xf0 | (var_131 >> 18);
        dst[1] = 0x80 | ((var_131 >> 12) & 0x3f);
        dst[2] = 0x80 | ((var_131 >> 6) & 0x3f);
        dst[3] = 0x80 | (var_131 & 0x3f);

        return 4;
    }

error:

    LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, NULL);
    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Invalid UTF-8 value 0x%08x", var_131);
    return 0;
}

unsigned int
fn_130(struct struct_131 *ctx, char *dst, const char *src)
{
    uint32_t var_131;


    if (!(src[0] & 0x80)) {

        if (src[0] < 0x20 &&
                src[0] != 0x09 &&
                src[0] != 0x0a &&
                src[0] != 0x0d) {
            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);
            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Invalid UTF-8 value 0x%02x", src[0]);
            return 0;
        }

        dst[0] = src[0];
        return 1;
    } else if (!(src[0] & 0x20)) {

        dst[0] = src[0];
        dst[1] = src[1];
        return 2;
    } else if (!(src[0] & 0x10)) {

        var_131 = ((uint32_t)(src[0] & 0xf) << 12) | ((uint32_t)(src[1] & 0x3f) << 6) | (src[2] & 0x3f);
        if (((var_131 & 0xf800) == 0xd800) ||
                (var_131 >= 0xfdd0 && var_131 <= 0xfdef) ||
                (var_131 & 0xffe) == 0xffe) {



            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);
            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Invalid UTF-8 value 0x%08x", var_131);
            return 0;
        }

        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        return 3;
    } else if (!(src[0] & 0x08)) {

        var_131 = ((uint32_t)(src[0] & 0x7) << 18) | ((uint32_t)(src[1] & 0x3f) << 12) | ((uint32_t)(src[2] & 0x3f) << 6) | (src[3] & 0x3f);
        if ((var_131 & 0xffe) == 0xffe) {



            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);
            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Invalid UTF-8 value 0x%08x", var_131);
            return 0;
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        return 4;
    } else {
        LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);
        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, "Invalid UTF-8 leading byte 0x%02x", src[0]);
        return 0;
    }
}

const struct struct_138 *
fn_131(const struct struct_138 *module, const char *prefix, int var_135, const char *name, int var_135, int var_135)
{
    const struct struct_138 *main_module;
    char *str;
    int i;

    assert(!prefix || !name);

    if (prefix && !var_135) {
        var_135 = strlen(prefix);
    }
    if (name && !var_135) {
        var_135 = strlen(name);
    }

    main_module = lys_main_module(module);


    if ((!prefix || (!module->type && !strncmp(main_module->prefix, prefix, var_135) && !main_module->prefix[var_135])
                 || (module->type && !strncmp(module->prefix, prefix, var_135) && !module->prefix[var_135]))
            && (!name || (!strncmp(main_module->name, name, var_135) && !main_module->name[var_135]))) {
        return main_module;
    }


    for (i = 0; i < module->imp_size; ++i) {
        if ((!prefix || (!strncmp(module->imp[i].prefix, prefix, var_135) && !module->imp[i].prefix[var_135]))
                && (!name || (!strncmp(module->imp[i].module->name, name, var_135) && !module->imp[i].module->name[var_135]))) {
            return module->imp[i].module;
        }
    }


    if (name) {
        str = strndup(name, var_135);
        if (!str) {
            LOGMEM(module->ctx);
            return NULL;
        }
        main_module = ly_ctx_get_module(module->ctx, str, NULL, 0);


        if (!main_module && var_135 && module->ctx->data_clb) {
            main_module = module->ctx->data_clb(module->ctx, str, NULL, 0, module->ctx->data_clb_data);
        }

        free(str);
        return main_module;
    }

    return NULL;
}

const struct struct_138 *
fn_135(const struct struct_138 *module, const char *ns)
{
    int i;
    const struct struct_138 *mod = NULL;

    assert(module && ns);

    if (module->type) {

        if (ly_strequal(((struct struct_139 *)module)->belongsto->ns, ns, 0)) {
            return ((struct struct_139 *)module)->belongsto;
        }
    } else {

        if (ly_strequal(module->ns, ns, 0)) {
            return module;
        }
    }


    for (i = 0; i < module->imp_size; ++i) {
        if (ly_strequal(module->imp[i].module->ns, ns, 0)) {
            return module->imp[i].module;
        }
    }

    return mod;
}

const char *
fn_136(const struct struct_137 *node)
{
    struct struct_139 *snode;

    snode = lys_parent(node->schema);
    while (snode && snode->nodetype & (LYS_USES | LYS_CASE | LYS_CHOICE)) {
        snode = lys_parent(snode);
    }

    if (snode && snode->nodetype == LYS_EXT && strcmp(((struct struct_137 *)snode)->def->name, "yang-data") == 0) {
        return ((struct struct_137 *)snode)->arg_value;
    } else {
        return NULL;
    }
}

const struct struct_139 *
fn_137(const struct struct_138 *module, const char *yang_data_name, int var_139)
{
    int i, j;
    const struct struct_139 *var_139 = NULL;
    const struct struct_139 *submodule;

    for(i = 0; i < module->ext_size; ++i) {
        if (!strcmp(module->ext[i]->def->name, "yang-data") && !strncmp(module->ext[i]->arg_value, yang_data_name, var_139)
            && !module->ext[i]->arg_value[var_139]) {
            var_139 = (struct struct_139 *)module->ext[i];
            break;
        }
    }

    for(j = 0; !var_139 && j < module->inc_size; ++j) {
        submodule = module->inc[j].submodule;
        for(i = 0; i < submodule->ext_size; ++i) {
            if (!strcmp(submodule->ext[i]->def->name, "yang-data") && !strncmp(submodule->ext[i]->arg_value, yang_data_name, var_139)
                && !submodule->ext[i]->arg_value[var_139]) {
                var_139 = (struct struct_139 *)submodule->ext[i];
                break;
            }
        }
    }

    return var_139;
}
